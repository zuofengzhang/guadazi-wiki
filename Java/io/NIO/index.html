<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="&lt;&lt; Java高级软件工程师知识结构  掌握InputStream、OutputStream、Reader、Writer的继承体系.  掌握字节流(FileInputStream、DataInputStream、BufferedInputStream、FileOutputSteam、DataOutputStream、BufferedOutputStream)和 字符流(Buffered">
<meta property="og:type" content="article">
<meta property="og:title" content="Java NIO(占坑)">
<meta property="og:url" content="http://example.com/Java/io/NIO/index.html">
<meta property="og:site_name" content="Guadazi">
<meta property="og:description" content="&lt;&lt; Java高级软件工程师知识结构  掌握InputStream、OutputStream、Reader、Writer的继承体系.  掌握字节流(FileInputStream、DataInputStream、BufferedInputStream、FileOutputSteam、DataOutputStream、BufferedOutputStream)和 字符流(Buffered">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/images/java/io/NIO/01.gif">
<meta property="og:image" content="http://example.com/images/java/io/NIO/02.gif">
<meta property="og:image" content="http://example.com/images/java/io/NIO/03.gif">
<meta property="og:image" content="http://example.com/images/java/io/NIO/04.gif">
<meta property="og:image" content="http://example.com/images/java/io/NIO/05.gif">
<meta property="og:image" content="http://example.com/images/java/io/NIO/06.gif">
<meta property="og:image" content="http://example.com/images/java/io/NIO/07.gif">
<meta property="og:image" content="http://example.com/images/java/io/NIO/08.gif">
<meta property="og:image" content="http://example.com/images/java/io/NIO/09.gif">
<meta property="article:published_time" content="2016-04-04T03:28:00.000Z">
<meta property="article:modified_time" content="2021-01-16T06:28:27.632Z">
<meta property="article:author" content="aaronzhang">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JDBC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/java/io/NIO/01.gif">

<link rel="canonical" href="http://example.com/Java/io/NIO/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>Java NIO(占坑) | Guadazi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Guadazi</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/io/NIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java NIO(占坑)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-04-04 11:28:00" itemprop="dateCreated datePublished" datetime="2016-04-04T11:28:00+08:00">2016-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-16 14:28:27" itemprop="dateModified" datetime="2021-01-16T14:28:27+08:00">2021-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><a href="/Java/advanced-engineer-outline/">&lt;&lt; Java高级软件工程师知识结构</a></p>
<ol>
<li>掌握InputStream、OutputStream、Reader、Writer的继承体系. </li>
<li>掌握字节流(FileInputStream、DataInputStream、BufferedInputStream、FileOutputSteam、DataOutputStream、BufferedOutputStream)和 字符流(BufferedReader、InputStreamReader、FileReader、BufferedWriter、OutputStreamWriter、PrintWriter、FileWriter), 并熟练运用. </li>
<li>掌握NIO实现原理及使用方法. </li>
</ol>
<p>Java IO包括:</p>
<ul>
<li><a href="/Java/io/IO-Model/">IO Model</a></li>
<li><a href="/Java/io/BIO/">Java BIO</a></li>
<li><a href="/Java/io/NIO/">Java NIO</a></li>
<li><a href="/Java/io/AIO/">Java AIO</a></li>
<li><a href="/Java/io/java-zip/">Java压缩</a></li>
<li><a href="/Java/io/object-serialization/">Java序列化</a></li>
<li><a href="/Java/io/java-XML-JSON/">Java XML与JSON</a></li>
</ul>
<pre><code>感谢`蔡毅`同学对NIO与AIO的深入研究</code></pre>
<p>文后的参考文献 <a target="_blank" rel="noopener" href="http://blog.csdn.net/kunluntaishan/article/details/53536386"> <strong>Java NIO浅析</strong> </a> 需要重点关注</p>
<p><a target="_blank" rel="noopener" href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">Doug Lea《scalable IO in Java》</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/fxjwind/p/3363329.html">中文解读</a></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>新的输入/输出(NIO)库是在JDK 1.4中引入的. NIO弥补了原来的I/O的不足, 它在标准java中提供了高速的、面向块的I/O.<br>   NIO与 <a href="/Java/io/BIO/">BIO</a> 最重要的区别是数据打包和传输的方式的不同, 原来的 I/O 以流 的方式处理数据, 而 NIO 以块 的方式处理数据.  <br>   面向流的I/O系统一次一个字节地处理数据. 一个输入流产生一个字节的数据, 一个输出流消费一个字节的数据. 为流式数据创建过滤器非常容易. 链接几个过滤器, 以便每个过滤器只负责单个复杂处理机制的一部分, 这样也是相对简单的. 不利的一面是, 面向流的I/O通常相当慢.  <br>   NIO与 <a href="/Java/io/BIO/">BIO</a> 有同样的作用和目的, 但是它使用块I/O的处理方式. 每一个操作都在一步中产生或者消费一个数据块. 按块处理数据比按(流式的)字节处理数据要快得多. 但是面向块的I/O缺少一些面向流的I/O所具有的优雅性和简单性. </p>
<p> </p>
<p>从一个例子开始 <br>     下面我们从一个简单的使用IO和NIO读取一个文件中的内容为例, 来进入NIO的学习之旅.<br>     使用IO来读取指定文件中的前1024字节并打印出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 使用IO读取指定文件的前1024个字节的内容.  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> file 指定文件名称.  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> java.io.IOException IO异常.  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ioRead</span><span class="params">(String file)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line"> FileInputStream in = <span class="keyword">new</span> FileInputStream(file);  </span><br><span class="line"> <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];  </span><br><span class="line"> in.read(b);  </span><br><span class="line"> System.out.println(<span class="keyword">new</span> String(b));  </span><br><span class="line">&#125;  </span><br><span class="line">​</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 使用NIO读取指定文件的前1024个字节的内容.  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> file 指定文件名称.  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> java.io.IOException IO异常.  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nioRead</span><span class="params">(String file)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line"> FileInputStream in = <span class="keyword">new</span> FileInputStream(file);  </span><br><span class="line"> FileChannel channel = in.getChannel();  </span><br><span class="line"> ​</span><br><span class="line"> ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);  </span><br><span class="line"> channel.read(buffer);  </span><br><span class="line"> <span class="keyword">byte</span>[] b = buffer.array();  </span><br><span class="line"> System.out.println(<span class="keyword">new</span> String(b));  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>从上面的例子中可以看出, NIO以 <code>通道Channel</code> 和 <code>缓冲区Buffer</code> 为基础来实现面向块的IO数据处理. 下面将讨论并学习NIO 库的核心概念以及从高级的特性到底层编程细节的几乎所有方面. </p>
<h1 id="核心概念：通道和缓冲区"><a href="#核心概念：通道和缓冲区" class="headerlink" title="核心概念：通道和缓冲区"></a>核心概念：通道和缓冲区</h1><p>通道和缓冲区是NIO中的核心对象, 几乎在每一个I/O操作中都要使用它们</p>
<ul>
<li>通道Channel 是对原I/O包中的流的模拟. 到任何目的地(或来自任何地方)的所有数据都必须通过一个Channel对象. </li>
<li>缓冲区Buffer 实质上是一个容器对象. 发送给一个通道的所有对象都必须首先放到缓冲区中；同样地, 从通道中读取的任何数据都要读到缓冲区中</li>
</ul>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>Buffer是一个容器对象, 它包含一些要写入或者刚读出的数据. 在NIO中加入Buffer对象, 体现了新库与原I/O的一个重要区别. 在面向流的I/O中, 您将数据直接写入或者将数据直接读到Stream对象中；<br>在NIO库中, 所有数据都是用缓冲区处理的. 在读取数据时, 它是直接读到缓冲区中的. 在写入数据时, 它是写入到缓冲区中的. 任何时候访问NIO中的数据, 您都是将它放到缓冲区中.  <br>缓冲区实质上是一个数组. 通常它是一个字节数组, 但是也可以使用其他种类的数组. 但是一个缓冲区不仅仅是一个数组. 缓冲区提供了对数据的结构化访问, 而且还可以跟踪系统的读/写进程.  </p>
<p>最常用的缓冲区类型是 <code>ByteBuffer</code> .  一个ByteBuffer可以在其底层字节数组上进行get/set操作(即字节的获取和设置).  <br>ByteBuffer不是NIO中唯一的缓冲区类型. 事实上, 对于每一种基本Java类型都有一种缓冲区类型：</p>
<ul>
<li><code>ByteBuffer</code></li>
<li><code>CharBuffer</code></li>
<li><code>ShortBuffer</code></li>
<li><code>IntBuffer</code></li>
<li><code>LongBuffer</code></li>
<li><code>FloatBuffer</code></li>
<li><code>DoubleBuffer</code></li>
</ul>
<p>每一个Buffer类都是Buffer接口的一个实例.  除了ByteBuffer,  每一个Buffer类都有完全一样的操作, 只是它们所处理的数据类型不一样. 因为大多数标准I/O操作都使用 ByteBuffer , 所以它具有所有共享的缓冲区操作以及一些特有的操作. </p>
<p>下面的例子使用类型化的缓冲区<code>FloatBuffer</code>的一个应用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个容量为10的新的 float 缓冲区  </span></span><br><span class="line">FloatBuffer buffer = FloatBuffer.allocate(<span class="number">10</span>);  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;  </span><br><span class="line">  <span class="keyword">float</span> f = (<span class="keyword">float</span>) Math.sin((((<span class="keyword">float</span>) i) / <span class="number">10</span>) * (<span class="number">2</span> * Math.PI));  </span><br><span class="line">  buffer.put(f);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 反转此缓冲区  </span></span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="comment">// 告知在当前位置和限制之间是否有元素  </span></span><br><span class="line"><span class="keyword">while</span> (buffer.hasRemaining()) &#123;  </span><br><span class="line">  <span class="keyword">float</span> f = buffer.get();  </span><br><span class="line">  System.out.println(f);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><p><code>Channel</code>是对原I/O包中的流的模拟, 可以通过它读取和写入数据. 通道就像流, 所有数据都通过<code>Buffer</code>对象来处理. 您永远不会将字节直接写入通道中, 相反, 是将数据写入包含一个或者多个字节的缓冲区. 同样, 您不会直接从通道中读取字节, 而是将数据从通道 读入缓冲区, 再从缓冲区获取这个字节</p>
<p>**通道与流的不同之处在于通道是双向的. ** 而流只是在一个方向上移动(一个流必须是InputStream或者OutputStream的子类),  而通道可以用于读、写或者同时用于读写. 因为它们是双向的, 所以通道可以比流更好地反映底层操作系统的真实情况. 特别是在UNIX模型中, 底层操作系统通道是双向的. </p>
<h1 id="从理论到实践：NIO中的读和写"><a href="#从理论到实践：NIO中的读和写" class="headerlink" title="从理论到实践：NIO中的读和写"></a>从理论到实践：NIO中的读和写</h1><p>读和写是I/O的基本过程. 从一个通道中读取很简单：只需创建一个缓冲区, 然后让通道将数据读到这个缓冲区中. 写入也相当简单：创建一个缓冲区, 用数据填充它, 然后让通道用这些数据来执行写入操作.  </p>
<h2 id="从文件中读取"><a href="#从文件中读取" class="headerlink" title="从文件中读取"></a>从文件中读取</h2><p>首先从FileInputStream获取一个FileChannel对象, 然后使用这个通道来读取数据.  </p>
<p>在NIO系统中, 任何时候执行一个读操作, 您都是从通道中读取, 但是您不是直接从通道读取. 因为所有数据最终都驻留在缓冲区中, 所以您是从通道读到缓冲区中</p>
<p>   因此读取文件涉及三个步骤：</p>
<p>  (1) 从 FileInputStream 获取 Channel<br>  (2) 创建 Buffer<br>  (3) 将数据从 Channel 读到 Buffer 中</p>
<p>现在, 让我们看一下这个过程. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步是获取通道. 从 FileInputStream 获取通道：</span></span><br><span class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream( <span class="string">&quot;readandshow.txt&quot;</span> );  </span><br><span class="line">FileChannel fc = fin.getChannel();  </span><br><span class="line"><span class="comment">// 下一步是创建缓冲区：</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );  </span><br><span class="line"><span class="comment">// 最后, 需要将数据从通道读到缓冲区中：</span></span><br><span class="line">fc.read( buffer );  </span><br></pre></td></tr></table></figure>
<p>不需要告诉通道要读多少数据到缓冲区中. 每一个缓冲区都有复杂的内部统计机制, 它会跟踪已经读了多少数据以及还有多少空间可以容纳更多的数据. </p>
<h2 id="写入文件："><a href="#写入文件：" class="headerlink" title="写入文件："></a>写入文件：</h2><p>在 NIO 中写入文件类似于从文件中读取. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先从 FileOutputStream 获取一个通道：</span></span><br><span class="line">FileOutputStream fout = <span class="keyword">new</span> FileOutputStream( <span class="string">&quot;writesomebytes.txt&quot;</span> );  </span><br><span class="line">FileChannel fc = fout.getChannel();  </span><br><span class="line"><span class="comment">// 下一步是创建一个缓冲区并在其中放入一些数据, 这里, 用message来表示一个持有数据的数组. </span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; message.length; ++i) &#123;  </span><br><span class="line">  buffer.put( message[i] );  </span><br><span class="line">&#125;  </span><br><span class="line">buffer.flip();  </span><br><span class="line"> <span class="comment">// 最后一步是从缓冲区写入通道中：</span></span><br><span class="line">fc.write( buffer );  </span><br></pre></td></tr></table></figure>
<h2 id="读写结合"><a href="#读写结合" class="headerlink" title="读写结合"></a>读写结合</h2><p>将一个文件的所有内容拷贝到另一个文件中. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 将一个文件的所有内容拷贝到另一个文件中. ​</span></span><br><span class="line"><span class="comment">* 执行三个基本操作： </span></span><br><span class="line"><span class="comment">* 首先创建一个 Buffer, 然后从源文件中将数据读到这个缓冲区中, </span></span><br><span class="line"><span class="comment">* 然后将缓冲区写入目标文件.  </span></span><br><span class="line"><span class="comment">* 程序不断重复 — 读、写、读、写 — 直到源文件结束.  </span></span><br><span class="line"><span class="comment">*  ​</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line">String infile = <span class="string">&quot;C:\\copy.sql&quot;</span>;  </span><br><span class="line">String outfile = <span class="string">&quot;C:\\copy.txt&quot;</span>;  </span><br><span class="line">​</span><br><span class="line"><span class="comment">// 获取源文件和目标文件的输入输出流  </span></span><br><span class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream(infile);  </span><br><span class="line">FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(outfile);  </span><br><span class="line">​</span><br><span class="line"><span class="comment">// 获取输入输出通道  </span></span><br><span class="line">FileChannel fcin = fin.getChannel();  </span><br><span class="line">FileChannel fcout = fout.getChannel();  </span><br><span class="line">​</span><br><span class="line"><span class="comment">// 创建缓冲区  </span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);  </span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">  <span class="comment">// clear方法重设缓冲区, 使它可以接受读入的数据  </span></span><br><span class="line">  buffer.clear();  </span><br><span class="line">  ​</span><br><span class="line">  <span class="comment">// 从输入通道中将数据读到缓冲区  </span></span><br><span class="line">  <span class="keyword">int</span> r = fcin.read(buffer);  </span><br><span class="line">  ​</span><br><span class="line">  <span class="comment">// read方法返回读取的字节数, 可能为零, </span></span><br><span class="line">  <span class="comment">// 如果该通道已到达流的末尾, 则返回-1  </span></span><br><span class="line">  <span class="keyword">if</span> (r == -<span class="number">1</span>) &#123;  </span><br><span class="line">    <span class="keyword">break</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  ​</span><br><span class="line">  <span class="comment">// flip方法让缓冲区可以将新读入的数据写入另一个通道  </span></span><br><span class="line">  buffer.flip();  </span><br><span class="line">  ​</span><br><span class="line">  <span class="comment">// 从输出通道中将数据写入缓冲区  </span></span><br><span class="line">  fcout.write(buffer);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h1 id="缓冲区内部实现"><a href="#缓冲区内部实现" class="headerlink" title="缓冲区内部实现"></a>缓冲区内部实现</h1><p>每一个缓冲区都有复杂的内部统计机制, 它会跟踪已经读了多少数据以及还有多少空间可以容纳更多的数据, 以便我们对缓冲区的操作. </p>
<p>本节介绍两个重要的缓冲区组件：状态变量和访问方法. 虽然NIO的内部统计机制初看起来可能很复杂, 但是您很快就会看到大部分的实际工作都已经替您完成了. 您只需像平时使用字节数组和索引变量一样进行操作即可. </p>
<h2 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h2><p>状态变量是”内部统计机制”的关键.  每一个读/写操作都会改变缓冲区的状态. 通过记录和跟踪这些变化, 缓冲区就能够管理内部地自己的资源. </p>
<p>每一种Java基本类型的缓冲区都是抽象类Buffer的子类, 从Buffer的源代码中可以发现, 它定义了三个私有属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> limit;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;  </span><br></pre></td></tr></table></figure>
<p>实际上, 这三个属性值可以指定缓冲区在任意时刻的状态和它所包含的数据.<br>我们知道, 每一个基本类型的缓冲区底层实际上就是一个该类型的数组. 如在ByteBuffer中, 有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] hb;  </span><br></pre></td></tr></table></figure>
<p>在从通道读取时, 所读取的数据将放被到底层的数组中；同理, 向通道中写入时, 将从底层数组中将数据写入通道. 下面我们来具体介绍这三个变量的作用：</p>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>position变量跟踪了向缓冲区中写入了多少数据或者从缓冲区中读取了多少数据.<br>更确切的说, 当您从通道中读取数据到缓冲区中时, 它指示了下一个数据将放到数组的哪一个元素中. 比如, 如果您从通道中读三个字节到缓冲区中, 那么缓冲区的position将会设置为3, 指向数组中第4个元素. 反之, 当您从缓冲区中获取数据进行写通道时, 它指示了下一个数据来自数组的哪一个元素. 比如, 当您从缓冲区写了5个字节到通道中, 那么缓冲区的 position 将被设置为5, 指向数组的第六个元素. </p>
<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>limit变量表明还有多少数据需要取出(在从缓冲区写入通道时), 或者还有多少空间可以放入数据(在从通道读入缓冲区时).<br>position总是小于或者等于limit. </p>
<h3 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h3><p>capacity变量表明可以储存在缓冲区中的最大数据容量. 实际上, 它指定了底层数组的大小—或者至少是指定了准许我们使用的底层数组的容量.  <br>limit总是小于或者等于capacity. </p>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>下面我们就以数据从一个输入通道拷贝到一个输出通道为例, 来详细分析每一个变量, 并说明它们是如何协同工作的：</p>
<p>初始变量： </p>
<p>我们首先观察一个新创建的缓冲区, 以ByteBuffer为例, 假设缓冲区的大小为8个字节, ByteBuffer初始状态如下：</p>
<p><img src="/images/java/io/NIO/01.gif" alt="NIO缓冲区内部实现机制"></p>
<p>回想一下 , limit决不能大于capacity, 此例中这两个值都被设置为8. 我们通过将它们指向数组的尾部之后(第8个槽位)来说明这点. </p>
<p><img src="/images/java/io/NIO/02.gif" alt="NIO缓冲区内部实现机制"></p>
<p>我们再将position设置为0. 表示如果我们读一些数据到缓冲区中, 那么下一个读取的数据就进入 slot 0. 如果我们从缓冲区写一些数据, 从缓冲区读取的下一个字节就来自slot 0. position设置如下所示：</p>
<p><img src="/images/java/io/NIO/03.gif" alt="NIO缓冲区内部实现机制"></p>
<p>由于缓冲区的最大数据容量capacity不会改变, 所以我们在下面的讨论中可以忽略它. </p>
<p>第一次读取： <br>   现在我们可以开始在新创建的缓冲区上进行读/写操作了. 首先从输入通道中读一些数据到缓冲区中. 第一次读取得到三个字节. 它们被放到数组中从position开始的位置, 这时position被设置为0. 读完之后, position就增加到了3, 如下所示, limit没有改变. </p>
<p><img src="/images/java/io/NIO/04.gif" alt="NIO缓冲区内部实现机制"></p>
<p>第二次读取： <br>   在第二次读取时, 我们从输入通道读取另外两个字节到缓冲区中. 这两个字节储存在由position所指定的位置上,  position因而增加2, limit没有改变. </p>
<p><img src="/images/java/io/NIO/05.gif" alt="NIO缓冲区内部实现机制"></p>
<p>flip： <br>   现在我们要将数据写到输出通道中. 在这之前, 我们必须调用flip()方法.  其源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	limit = position;  </span><br><span class="line">	position = <span class="number">0</span>;  </span><br><span class="line">	mark = -<span class="number">1</span>;  </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p>   这个方法做两件非常重要的事：<br>   i  将limit设置为当前position.<br>   ii 将position设置为0. </p>
<p>   上一个图显示了在flip之前缓冲区的情况. 下面是在flip之后的缓冲区：</p>
<p><img src="/images/java/io/NIO/06.gif" alt="NIO缓冲区内部实现机制"></p>
<p>   我们现在可以将数据从缓冲区写入通道了. position被设置为0, 这意味着我们得到的下一个字节是第一个字节. limit已被设置为原来的position, 这意味着它包括以前读到的所有字节, 并且一个字节也不多.<br>第一次写入： <br>   在第一次写入时, 我们从缓冲区中取四个字节并将它们 写入输出通道. 这使得position增加到4, 而limit不变, 如下所示：</p>
<p><img src="/images/java/io/NIO/07.gif" alt="NIO缓冲区内部实现机制"></p>
<p>第二次写入： <br>   我们只剩下一个字节可写了. limit在我们调用flip()时被设置为5, 并且position不能超过limit.  所以最后一次写入操作从缓冲区取出一个字节并将它写入输出通道. 这使得position增加到5, 并保持limit不变, 如下所示：</p>
<p><img src="/images/java/io/NIO/08.gif" alt="NIO缓冲区内部实现机制"></p>
<p>clear： <br>   最后一步是调用缓冲区的clear()方法. 这个方法重设缓冲区以便接收更多的字节. 其源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	position = <span class="number">0</span>;  </span><br><span class="line">	limit = capacity;  </span><br><span class="line">	mark = -<span class="number">1</span>;  </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p>clear做两种非常重要的事情：</p>
<p>i 将limit设置为与capacity相同.  <br>ii 设置position为0.  </p>
<p>下图显示了在调用clear()后缓冲区的状态,  此时缓冲区现在可以接收新的数据了. </p>
<p><img src="/images/java/io/NIO/09.gif" alt="NIO缓冲区内部实现机制"></p>
<p> </p>
<h2 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h2><p>程序需要直接处理数据. 例如, 您可能需要将用户数据保存到磁盘. 在这种情况下, 您必须将这些数据直接放入缓冲区, 然后用通道将缓冲区写入磁盘.  或者, 您可能想要从磁盘读取用户数据. 在这种情况下, 您要将数据从通道读到缓冲区中, 然后检查缓冲区中的数据.  <br>   实际上, 每一个基本类型的缓冲区都为我们提供了直接访问缓冲区中数据的方法, 我们以ByteBuffer为例, 分析如何使用其提供的get()和put()方法直接访问缓冲区中的数据. </p>
<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>   ByteBuffer类中有四个get()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="function">ByteBuffer <span class="title">get</span><span class="params">( <span class="keyword">byte</span> dst[] )</span></span>;  </span><br><span class="line"><span class="function">ByteBuffer <span class="title">get</span><span class="params">( <span class="keyword">byte</span> dst[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length )</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">byte</span> <span class="title">get</span><span class="params">( <span class="keyword">int</span> index )</span></span>;</span><br></pre></td></tr></table></figure>
<p>   第一个方法获取单个字节. 第二和第三个方法将一组字节读到一个数组中. 第四个方法从缓冲区中的特定位置获取字节. 那些返回ByteBuffer的方法只是返回调用它们的缓冲区的this值.  <br>   前三个get()方法是相对的, 而最后一个方法是绝对的. “相对”意味着get()操作服从limit和position值, 更明确地说, 字节是从当前position读取的, 而position在get之后会增加. 另一方面, 一个“绝对”方法会忽略limit和position值, 也不会影响它们. 事实上, 它完全绕过了缓冲区的统计方法.  </p>
<p>上面列出的方法对应于ByteBuffer类. 其他类有等价的get()方法, 这些方法除了不是处理字节外, 其它方面是是完全一样的, 它们处理的是与该缓冲区类相适应的类型. </p>
<h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><p>   ByteBuffer类中有五个put()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ByteBuffer <span class="title">put</span><span class="params">( <span class="keyword">byte</span> b )</span></span>;  </span><br><span class="line"><span class="function">ByteBuffer <span class="title">put</span><span class="params">( <span class="keyword">byte</span> src[] )</span></span>;  </span><br><span class="line"><span class="function">ByteBuffer <span class="title">put</span><span class="params">( <span class="keyword">byte</span> src[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length )</span></span>;  </span><br><span class="line"><span class="function">ByteBuffer <span class="title">put</span><span class="params">( ByteBuffer src )</span></span>;  </span><br><span class="line"><span class="function">ByteBuffer <span class="title">put</span><span class="params">( <span class="keyword">int</span> index, <span class="keyword">byte</span> b )</span></span>;</span><br></pre></td></tr></table></figure>
<p>   第一个方法 写入（put）单个字节. 第二和第三个方法写入来自一个数组的一组字节. 第四个方法将数据从一个给定的源ByteBuffer写入这个ByteBuffer. 第五个方法将字节写入缓冲区中特定的 位置 . 那些返回ByteBuffer的方法只是返回调用它们的缓冲区的this值.  <br>   与get()方法一样, 我们将把put()方法划分为“相对”或者“绝对”的. 前四个方法是相对的, 而第五个方法是绝对的.  <br>   上面显示的方法对应于ByteBuffer类. 其他类有等价的put()方法, 这些方法除了不是处理字节之外, 其它方面是完全一样的. 它们处理的是与该缓冲区类相适应的类型.  </p>
<h3 id="类型化的-get-和-put-方法"><a href="#类型化的-get-和-put-方法" class="headerlink" title="类型化的 get() 和 put() 方法"></a>类型化的 get() 和 put() 方法</h3><p>   除了前些小节中描述的get()和put()方法,  ByteBuffer还有用于读写不同类型的值的其他方法, 如下所示</p>
<p> -  <code>getByte()</code><br> -  <code>getChar()</code><br> -  <code>getShort()</code><br> -  <code>getInt()</code><br> -  <code>getLong()</code><br> -  <code>getFloat()</code><br> -  <code>getDouble()</code><br> -  <code>putByte()</code><br> -  <code>putChar()</code><br> -  <code>putShort()</code><br> -  <code>putInt()</code><br> -  <code>putLong()</code><br> -  <code>putFloat()</code><br> -  <code>putDouble()</code></p>
<p>   事实上, 这其中的每个方法都有两种类型：一种是相对的, 另一种是绝对的. 它们对于读取格式化的二进制数据（如图像文件的头部）很有用. </p>
<p> </p>
<h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>   下面的内部循环概括了使用缓冲区将数据从输入通道拷贝到输出通道的过程. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line"> buffer.clear();  </span><br><span class="line"> <span class="keyword">int</span> r = fcin.read( buffer );  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (r==-<span class="number">1</span>) &#123;  </span><br><span class="line"> 	<span class="keyword">break</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line"> buffer.flip();  </span><br><span class="line"> fcout.write( buffer );  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>   read()和write()调用得到了极大的简化, 因为许多工作细节都由缓冲区完成了. clear()和flip()方法用于让缓冲区在读和写之间切换. </p>
<h1 id="连网和异步IO"><a href="#连网和异步IO" class="headerlink" title="连网和异步IO"></a>连网和异步IO</h1><p>连网是学习异步I/O的很好基础, 而异步I/O对于在Java语言中执行任何输入/输出过程的人来说, 无疑都是必须具备的知识. NIO中的连网与NIO中的其他任何操作没有什么不同, 它依赖通道和缓冲区, 而您通常使用InputStream和OutputStream来获得通道. </p>
<h2 id="异步-I-O"><a href="#异步-I-O" class="headerlink" title="异步 I/O"></a>异步 I/O</h2><p>   异步I/O是一种“没有阻塞地读写数据”的方法. 通常, 在代码进行read()调用时, 代码会阻塞直至有可供读取的数据. 同样,  write()调用将会阻塞直至数据能够写入.  但异步I/O调用不会阻塞. 相反, 您可以注册对特定I/O事件的兴趣：如可读的数据的到达、新的套接字连接等等, 而在发生这样的事件时, 系统将会告诉您.  <br>   异步I/O的一个优势在于, 它允许您同时根据大量的输入和输出执行I/O. 同步程序常常要求助于轮询, 或者创建许许多多的线程以处理大量的连接. 使用异步I/O, 您可以监听任何数量的通道上的事件, 不用轮询, 也不用额外的线程.<br>   我们来看一个基于非阻塞I/O的服务器端的处理流程, 它接受网络连接并向它们echo它们可能发送的数据. 在这里假设它能同时监听多个端口, 并处理来自所有这些端口的连接. 下面是其主方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span> <span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">  <span class="comment">// 创建一个新的选择器  </span></span><br><span class="line">  Selector selector = Selector.open();  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开在每个端口上的监听, 并向给定的选择器注册此通道接受客户端连接的I/O事件.   </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ports.length; i++) &#123;  </span><br><span class="line">    <span class="comment">// 打开服务器套接字通道  </span></span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();  </span><br><span class="line">    <span class="comment">// 设置此通道为非阻塞模式  </span></span><br><span class="line">    ssc.configureBlocking(<span class="keyword">false</span>);  </span><br><span class="line">    <span class="comment">// 绑定到特定地址  </span></span><br><span class="line">    ServerSocket ss = ssc.socket();  </span><br><span class="line">    InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(ports[i]);  </span><br><span class="line">    ss.bind(address);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向给定的选择器注册此通道的接受连接事件  </span></span><br><span class="line">    ssc.register(selector, SelectionKey.OP_ACCEPT);  </span><br><span class="line">    System.out.println(<span class="string">&quot;Going to listen on &quot;</span> + ports[i]);  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">    <span class="comment">// 这个方法会阻塞, 直到至少有一个已注册的事件发生.   </span></span><br><span class="line">    <span class="comment">// 当一个或者更多的事件发生时, 此方法将返回所发生的事件的数量.   </span></span><br><span class="line">    <span class="keyword">int</span> num = selector.select();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代所有的选择键, 以处理特定的I/O事件.   </span></span><br><span class="line">    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();  </span><br><span class="line">    Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();  </span><br><span class="line"></span><br><span class="line">    SocketChannel sc;  </span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;  </span><br><span class="line">      SelectionKey key = iter.next();  </span><br><span class="line">      <span class="keyword">if</span> ((key.readyOps() </span><br><span class="line">      &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) &#123;  </span><br><span class="line">        <span class="comment">// 接受服务器套接字撒很能够传入的新的连接, 并处理接受连接事件.   </span></span><br><span class="line">        ServerSocketChannel ssc = (ServerSocketChannel) key.channel();  </span><br><span class="line">        sc = ssc.accept();  </span><br><span class="line">        <span class="comment">// 将新连接的套接字通道设置为非阻塞模式  </span></span><br><span class="line">        sc.configureBlocking(<span class="keyword">false</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接受连接后, 在此通道上从新注册读取事件, 以便接收数据.   </span></span><br><span class="line">        sc.register(selector, SelectionKey.OP_READ);  </span><br><span class="line">        <span class="comment">// 删除处理过的选择键  </span></span><br><span class="line">        iter.remove();  </span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Got connection from &quot;</span> + sc);  </span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((key.readyOps() </span><br><span class="line">      &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ) &#123;  </span><br><span class="line">          <span class="comment">// 处理读取事件, 读取套接字通道中发来的数据.   </span></span><br><span class="line">          sc = (SocketChannel) key.channel();  </span><br><span class="line"></span><br><span class="line">          <span class="comment">// 读取数据  </span></span><br><span class="line">          <span class="keyword">int</span> bytesEchoed = <span class="number">0</span>;  </span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">            echoBuffer.clear();  </span><br><span class="line">            <span class="keyword">int</span> r = sc.read(echoBuffer);  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r == -<span class="number">1</span>) &#123;  </span><br><span class="line">              <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            echoBuffer.flip();  </span><br><span class="line">            sc.write(echoBuffer);  </span><br><span class="line"></span><br><span class="line">            bytesEchoed += r;  </span><br><span class="line">          &#125;  </span><br><span class="line">          System.out.println(<span class="string">&quot;Echoed &quot;</span> + bytesEchoed + <span class="string">&quot; from &quot;</span> + sc);  </span><br><span class="line">          <span class="comment">// 删除处理过的选择键  </span></span><br><span class="line">          iter.remove();  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3)    Selectors</p>
<p>Selector是异步<code>I/O</code>中的核心对象. Selector就是注册对各种<code>I/O</code>事件的兴趣的地方, 而且当那些事件发生时, 就是这个对象告诉您所发生的事件. 所以, 我们需要做的第一件事就是创建一个Selector：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();  </span><br></pre></td></tr></table></figure>
<p>然后, 我们将对不同的通道对象调用<code>register()</code>方法, 以便注册我们对这些对象中发生的I/O事件的兴趣. <code>register()</code>的第一个参数就是这个Selector对象.  </p>
<p>4)    打开一个<code>ServerSocketChannel</code></p>
<p>在服务端为了接收连接, 我们需要一个<code>ServerSocketChannel</code>.  事实上, 我们要监听的每一个端口都需要有一个<code>ServerSocketChannel</code>. 对于每一个端口, 我们打开一个<code>ServerSocketChannel</code>,  如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();  </span><br><span class="line">ssc.configureBlocking( <span class="keyword">false</span> );  </span><br><span class="line">ServerSocket ss = ssc.socket();  </span><br><span class="line">InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress( ports[i] );  </span><br><span class="line">ss.bind( address );  </span><br></pre></td></tr></table></figure>
<p>第一行创建一个新的<code>ServerSocketChannel</code>, 最后三行将它绑定到给定的端口. 第二行将<code>ServerSocketChannel</code>设置为非阻塞的. 我们必须对每一个要使用的套接字通道调用这个方法, 否则异步<code>I/O</code>就不能工作.</p>
<p>5)    选择键</p>
<p>下一步是将新打开的<code>ServerSocketChannels</code>注册到<code>Selector</code>上. 为此我们使用<code>ServerSocketChannel.register()</code>方法, 如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = ssc.register( selector, SelectionKey.OP_ACCEPT );  </span><br></pre></td></tr></table></figure>
<p><code>register()</code>方法的第一个参数总是这个<code>Selector</code>. 第二个参数是<code>OP_ACCEPT</code>, 这里它指定我们想要监听<code>accept</code>事件, 也就是在新的连接建立时所发生的事件. 这是适用于<code>ServerSocketChannel</code>的唯一事件类型.  </p>
<p>请注意对<code>register()</code>的调用的返回值. <code>SelectionKey</code>代表这个通道在此<code>Selector</code>上的这个注册. 当某个<code>Selector</code>通知您某个传入事件时, 它是通过提供对应于该事件的<code>SelectionKey</code>来进行的. <code>SelectionKey</code>还可以用于取消通道的注册.<br>  <br>6)    内部循环</p>
<p>现在已经注册了我们对一些 <code>I/O</code> 事件的兴趣, 下面将进入主循环. 使用 <code>Selectors</code> 的几乎每个程序都像下面这样使用内部循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = selector.select();  </span><br><span class="line"></span><br><span class="line">Set selectedKeys = selector.selectedKeys();  </span><br><span class="line">Iterator it = selectedKeys.iterator();  </span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;  </span><br><span class="line">SelectionKey key = (SelectionKey)it.next();  </span><br><span class="line"><span class="comment">// ... 处理I/O事件...  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<ul>
<li>调用<code>Selector</code>的<code>select()</code>方法. 这个方法会阻塞, 直到至少有一个已注册的事件发生. 当一个或者更多的事件发生时, <code>select()</code>方法将返回所发生的事件的数量.  </li>
<li>调用<code>Selector</code>的<code>selectedKeys()</code>方法, 它返回发生了事件的<code>SelectionKey</code>对象的一个集合.  </li>
<li>通过迭代<code>SelectionKeys</code>并依次处理每个<code>SelectionKey</code>来处理事件. 对于每一个<code>SelectionKey</code>, 您必须确定发生的是什么<code>I/O</code>事件, 以及这个事件影响哪些<code>I/O</code>对象.</li>
</ul>
<p>7)    监听新连接</p>
<p>程序执行到这里, 我们仅注册了<code>ServerSocketChannel</code>,  并且仅注册它们“接收”事件. 为确认这一点, 我们对<code>SelectionKey</code>调用<code>readyOps()</code>方法, 并检查发生了什么类型的事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((key.readyOps() &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) &#123;  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>可以肯定地说, <code>readOps()</code>方法告诉我们该事件是新的连接. </p>
<p>8)    接受新的连接</p>
<p>因为我们知道这个服务器套接字上有一个传入连接在等待, 所以可以安全地接受它；也就是说, 不用担心<code>accept()</code>操作会阻塞：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = (ServerSocketChannel)key.channel();  </span><br><span class="line">SocketChannel sc = ssc.accept();  </span><br></pre></td></tr></table></figure>
<p>下一步是将新连接的SocketChannel配置为非阻塞的. 而且由于接受这个连接的目的是为了读取来自套接字的数据, 所以我们还必须将SocketChannel注册到Selector上, 如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc.configureBlocking( <span class="keyword">false</span> );  </span><br><span class="line">SelectionKey newKey = sc.register( selector, SelectionKey.OP_READ );  </span><br></pre></td></tr></table></figure>
<p>注意我们使用register()的OP_READ参数, 将SocketChannel注册用于“读取”而不是“接受”新连接.</p>
<p>9)    删除处理过的SelectionKey</p>
<p>在处理SelectionKey之后, 我们几乎可以返回主循环了. 但是我们必须首先将处理过的SelectionKey从选定的键集合中删除. 如果我们没有删除处理过的键, 那么它仍然会在主集合中以一个激活的键出现, 这会导致我们尝试再次处理它. 我们调用迭代器的remove()方法来删除处理过的SelectionKey：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it.remove();  </span><br></pre></td></tr></table></figure>
<p>现在我们可以返回主循环并接受从一个套接字中传入的数据(或者一个传入的I/O事件)了.  </p>
<p>10) 传入的I/O</p>
<p>当来自一个套接字的数据到达时, 它会触发一个I/O事件. 这会导致在主循环中调用Selector.select(), 并返回一个或者多个I/O事件. 这一次,  SelectionKey将被标记为OP_READ事件, 如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((key.readyOps() &amp; SelectionKey.OP_READ)  </span><br><span class="line">== SelectionKey.OP_READ) &#123;  </span><br><span class="line"><span class="comment">// Read the data  </span></span><br><span class="line">SocketChannel sc = (SocketChannel)key.channel();  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>与以前一样, 我们取得发生I/O事件的通道并处理它. 在本例中, 由于这是一个echo server, 我们只希望从套接字中读取数据并马上将它发送回去. 关于这个过程的细节, 请参见附件中的源代码 (MultiPortEcho.java).  </p>
<p>11)    回到主循环</p>
<p>每次返回主循环, 我们都要调用select的Selector()方法, 并取得一组SelectionKey. 每个键代表一个I/O事件. 我们处理事件, 从选定的键集中删除SelectionKey, 然后返回主循环的顶部.</p>
<p>说明： 这个程序有点过于简单, 因为它的目的只是展示异步I/O所涉及的技术. 在现实的应用程序中, 您需要通过将通道从Selector中删除来处理关闭的通道. 而且您可能要使用多个线程. 这个程序可以仅使用一个线程, 因为它只是一个演示, 但是在现实场景中, 创建一个线程池来负责I/O事件处理中的耗时部分会更有意义. </p>
<h1 id="缓冲区更多内容"><a href="#缓冲区更多内容" class="headerlink" title="缓冲区更多内容"></a>缓冲区更多内容</h1><p>比如缓冲区分配、包装和分片. 我们还会讨论NIO带给Java平台的一些新功能. 我们将学如何创建不同类型的缓冲区以达到不同的目的, 如可保护数据不被修改的“只读缓冲区”, 和直接映射到底层操作系统缓冲区的“直接缓冲区”, 以及如何在 NIO 中创建内存映射文件. </p>
<p>   1) 缓冲区分配和包装</p>
<p>在能够读和写之前, 必须有一个缓冲区. 要创建缓冲区, 您必须“分配”它. 我们使用静态方法allocate()来分配缓冲区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );  </span><br></pre></td></tr></table></figure>
<p>   allocate()方法分配一个具有指定大小的底层数组, 并将它包装到一个缓冲区对象中, 在本例中是一个ByteBuffer.<br>   您还可以将一个现有的数组转换为缓冲区, 如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> array[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];  </span><br><span class="line">ByteBuffer buffer = ByteBuffer.wrap( array );  </span><br></pre></td></tr></table></figure>
<p>   本例使用了wrap()方法将一个数组包装为缓冲区. 必须非常小心地进行这类操作. 一旦完成包装, 底层数据就可以通过缓冲区或者直接访问.<br> <br>2) 缓冲区分片 </p>
<p>   slice()方法根据现有的缓冲区创建一个子缓冲区. 也就是说, 它创建一个新的缓冲区, 新缓冲区与原来的缓冲区的一部分共享数据.<br>  <br>   使用例子可以最好地说明这点. 让我们首先创建一个长度为10的ByteBuffer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">10</span> );  </span><br></pre></td></tr></table></figure>
<p>   然后使用数据来填充这个缓冲区, 在第n个槽中放入数字n：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;buffer.capacity(); ++i) &#123;  </span><br><span class="line"> buffer.put( (<span class="keyword">byte</span>)i );  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>   现在我们对这个缓冲区“分片”, 以创建一个包含槽3到槽6的子缓冲区. 在某种意义上, 子缓冲区就像原来的缓冲区中的一个窗口 . </p>
<p>   窗口的起始和结束位置通过设置position和limit值来指定, 然后调用Buffer的slice()方法进行分片：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.position( <span class="number">3</span> );  </span><br><span class="line">buffer.limit( <span class="number">7</span> );  </span><br><span class="line">ByteBuffer slice = buffer.slice();  </span><br></pre></td></tr></table></figure>
<p>   该“片段”是缓冲区的子缓冲区. 不过, “片段”和“缓冲区”共享同一个底层数据数组, 我们在下一节将会看到这一点. </p>
<ol start="3">
<li>缓冲区片份和数据共享 </li>
</ol>
<p>   我们已经创建了原缓冲区的子缓冲区, 并且已经知道缓冲区和子缓冲区共享同一个底层数据数组. 让我们看看这意味着什么.  </p>
<p>   我们遍历子缓冲区, 将每一个元素乘以11来改变它. 例如, 5会变成55. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;slice.capacity(); ++i) &#123;  </span><br><span class="line"> <span class="keyword">byte</span> b = slice.get( i );  </span><br><span class="line"> b *= <span class="number">11</span>;  </span><br><span class="line"> slice.put( i, b );  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>   最后, 再看一下原缓冲区中的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buffer.position( <span class="number">0</span> );  </span><br><span class="line">buffer.limit( buffer.capacity() );  </span><br><span class="line"><span class="keyword">while</span> ( buffer.remaining() &gt; <span class="number">0</span> ) &#123;  </span><br><span class="line"> System.out.println( buffer.get() );  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>   结果表明只有在子缓冲区窗口中的元素被改变了： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">33</span><br><span class="line">44</span><br><span class="line">55</span><br><span class="line">66</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<p>   缓冲区片对于促进抽象非常有帮助. 可以编写自己的函数处理整个缓冲区, 而且如果想要将这个过程应用于子缓冲区上, 您只需取主缓冲区的一个片, 并将它传递给您的函数. 这比编写自己的函数来取额外的参数以指定要对缓冲区的哪一部分进行操作更容易.  </p>
<ol start="4">
<li>只读缓冲区</li>
</ol>
<p>只读缓冲区的含义已经很直白了：您可以读取它们, 但是不能向它们写入. 可以通过调用缓冲区的<code>asReadOnlyBuffer()</code>方法, 来将任何常规缓冲区转换为只读缓冲区, 这个方法返回一个与原缓冲区完全相同的缓冲区(并与其共享数据), 只不过它是只读的.  </p>
<p>   只读缓冲区对于保护数据很有用. 在将缓冲区传递给某个对象的方法时, 您无法知道这个方法是否会修改缓冲区中的数据. 创建一个只读的缓冲区可以保证该缓冲区不会被修改. 不能将只读的缓冲区转换为可写的缓冲区.  </p>
<ol start="5">
<li>直接和间接缓冲区 </li>
</ol>
<p>   另一种有用的ByteBuffer是直接缓冲区. “直接缓冲区”是为加快I/O速度, 而以一种特殊的方式分配其内存的缓冲区. 实际上, 直接缓冲区的准确定义是与实现相关的. </p>
<blockquote>
<p>Sun的文档是这样描述直接缓冲区的： 给定一个直接字节缓冲区, Java虚拟机将尽最大努力直接对它执行本机I/O操作. 也就是说, 它会在每一次调用底层操作系统的本机I/O操作之前(或之后), 尝试避免将缓冲区的内容拷贝到一个中间缓冲区中(或者从一个中间缓冲区中拷贝数据).  </p>
</blockquote>
<p>附件中, 您可以在例子程序FastCopyFile.java中看到直接缓冲区的实际应用, 这个程序是CopyFile.java的另一个版本, 它使用了直接缓冲区以提高速度. 还可以用内存映射文件创建直接缓冲区.  </p>
<ol start="6">
<li>内存映射文件I/O</li>
</ol>
<p>   内存映射文件I/O是一种读和写文件数据的方法, 它可以比常规的基于流或者基于通道的I/O快得多.  </p>
<p>内存映射文件I/O是通过使文件中的数据神奇般地出现为内存数组的内容来完成的. 这其初听起来似乎不过就是将整个文件读到内存中, 但是事实上并不是这样. 一般来说, 只有文件中实际读取或者写入的部分才会送入（或者映射）到内存中.  </p>
<p><strong>内存映射并不真的神奇或者多么不寻常. 现代操作系统一般根据需要将文件的部分映射为内存的部分, 从而实现文件系统. Java内存映射机制不过是在底层操作系统中可以采用这种机制时, 提供了对该机制的访问</strong></p>
<p>尽管创建内存映射文件相当简单, 但是向它写入可能是危险的. 仅只是改变数组的单个元素这样的简单操作, 就可能会直接修改磁盘上的文件. 修改数据与将 数据保存到磁盘是没有分开的. </p>
<ol start="7">
<li>将文件映射到内存</li>
</ol>
<p>了解内存映射的最好方法是使用例子. 在下面的例子中, 我们要将一个FileChannel (它的全部或者部分)映射到内存中. 为此我们将使用<code>FileChannel.map()</code>方法. 下面代码行将文件的前1024个字节映射到内存中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MappedByteBuffer mbb = fc.map( FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">1024</span> );  </span><br></pre></td></tr></table></figure>
<p>map()方法返回一个<code>MappedByteBuffer</code>, 它是ByteBuffer的子类. 因此, 您可以像使用其他任何ByteBuffer 一样使用新映射的缓冲区, 操作系统会在需要时负责执行行映射.</p>
<ol>
<li>分散和聚集 </li>
</ol>
<ol>
<li>概述：</li>
</ol>
<p>分散/聚集I/O是使用多个而不是单个缓冲区来保存数据的读写方法.  <br>一个分散的读取就像一个常规通道读取, 只不过它是将数据读到一个缓冲区数组中而不是读到单个缓冲区中. 同样地, 一个聚集写入是向缓冲区数组而不是向单个缓冲区写入数据. 分散/聚集I/O对于将数据流划分为单独的部分很有用, 这有助于实现复杂的数据格式. </p>
<ol start="2">
<li>分散/聚集 I/O：</li>
</ol>
<p>通道可以有选择地实现两个新的接口：ScatteringByteChannel和GatheringByteChannel. 一个 ScatteringByteChannel是一个具有两个附加读方法的通道：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">read</span><span class="params">( ByteBuffer[] dsts )</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">read</span><span class="params">( ByteBuffer[] dsts, <span class="keyword">int</span> offset, <span class="keyword">int</span> length )</span></span>;</span><br></pre></td></tr></table></figure>
<p>这些long read()方法很像标准的read方法, 只不过它们不是取单个缓冲区而是取一个缓冲区数组.  </p>
<p>在“分散读取”中, 通道依次填充每个缓冲区. 填满一个缓冲区后, 它就开始填充下一个. 在某种意义上, 缓冲区数组就像一个大缓冲区.  </p>
<ol start="3">
<li>分散/聚集的应用： </li>
</ol>
<p>分散/聚集I/O对于将数据划分为几个部分很有用. 例如, 您可能在编写一个使用消息对象的网络应用程序, 每一个消息被划分为固定长度的头部和固定长度的正文. 您可以创建一个刚好可以容纳头部的缓冲区和另一个刚好可以容难正文的缓冲区. 当您将它们放入一个数组中并使用分散读取来向它们读入消息时, 头部和正文将整齐地划分到这 两个缓冲区中.  </p>
<p>我们从缓冲区所得到的方便性对于缓冲区数组同样有效. 因为每一个缓冲区都跟踪自己还可以接受多少数据, 所以分散读取会自动找到有空间接受数据的第一个缓冲区. 在这个缓冲区填满后, 它就会移动到下一个缓冲区.  </p>
<ol start="4">
<li>聚集写入： </li>
</ol>
<p>聚集写入类似于分散读取, 只不过是用来写入. 它也有接受缓冲区数组的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">write</span><span class="params">( ByteBuffer[] srcs )</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">write</span><span class="params">( ByteBuffer[] srcs, <span class="keyword">int</span> offset, <span class="keyword">int</span> length )</span></span>;</span><br></pre></td></tr></table></figure>
<p>聚集写对于把一组单独的缓冲区中组成单个数据流很有用. 为了与上面的消息例子保持一致, 您可以使用聚集写入来自动将网络消息的各个部分组装为单个数据流, 以便跨越网络传输消息.  <br>从附件的例子程序 UseScatterGather.java 中可以看到分散读取和聚集写入的实际应用. </p>
<h1 id="文件锁定"><a href="#文件锁定" class="headerlink" title="文件锁定"></a>文件锁定</h1><ol>
<li>概述： </li>
</ol>
<p>文件锁定初看起来可能让人迷惑. 它似乎指的是防止程序或者用户访问特定文件. 事实上, <strong>文件锁就像常规的Java对象锁, 它们是“劝告式”的（advisory）锁</strong>. <strong>它们不阻止任何形式的数据访问, 相反, 它们通过锁的共享和获取来允许系统的不同部分相互协调</strong>. 您可以锁定整个文件或者文件的一部分. 如果您获取一个排它锁, 那么其他人就不能获得同一个文件或者文件的一部分上的锁. 如果您获得一个共享锁, 那么其他人可以获得同一个文件或者文件一部分上的共享锁, 但是不能获得排它锁. 文件锁定并不总是出于保护数据的目的. 例如, 您可能临时锁定一个文件以保证特定 的写操作成为原子的, 而不会有其他程序的干扰.  大多数操作系统提供了文件系统锁, 但是它们并不都是采用同样的方式. 有些实现提供了共享锁, 而另一些仅提供了排它锁. 事实上, 有些实现使得文件的锁定部分不可访问, 尽管大多数实现不是这样的.  在这里, 我们将学习如何在 NIO 中执行简单的文件锁过程, 还将探讨一些保证被锁定的文件尽可能可移植的方法.  </p>
<ol start="2">
<li>锁定文件： </li>
</ol>
<p>要获取文件的一部分上的锁, 您要调用一个打开的FileChannel上的lock()方法. 注意, 如果要获取一个排它锁, 您必须以写方式打开文件. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile( <span class="string">&quot;usefilelocks.txt&quot;</span>, <span class="string">&quot;rw&quot;</span> );  </span><br><span class="line">FileChannel fc = raf.getChannel();  </span><br><span class="line">FileLock lock = fc.lock( start, end, <span class="keyword">false</span> );  </span><br></pre></td></tr></table></figure>
<p>   在拥有锁之后, 您可以执行需要的任何敏感操作, 然后再释放锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.release();  </span><br></pre></td></tr></table></figure>
<p>   在释放锁后, 尝试获得锁的其他任何程序都有机会获得它.  <br>   本附件的例子程序UseFileLocks.java必须与它自己并行运行. 这个程序获取一个文件上的锁, 持有三秒钟, 然后释放它. 如果同时运行这个程序的多个实例, 您会看到每个实例依次获得锁.  </p>
<ol start="3">
<li>文件锁定和可移植性：</li>
</ol>
<p>文件锁定可能是一个复杂的操作, 特别是考虑到 不同的操作系统是以不同的方式实现锁这一事实. 下面的指导原则将帮助您尽可能保持代码的可移植性： </p>
<p>i 只使用排它锁.  </p>
<p>ii 将所有的锁视为劝告式的（advisory）.  </p>
<h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><ol>
<li>概述： </li>
</ol>
<p>根据Sun的文档, 一个Charset是“十六位Unicode字符序列与字节序列之间的一个命名的映射”. 实际上, 一个Charset允许您以尽可能最具可移植性的方式读写字符序列.  </p>
<p>Java语言被定义为基于Unicode. 然而在实际上, 许多人编写代码时都假设一个字符在磁盘上或者在网络流中用一个字节表示. 这种假设在许多情况下成立, 但是并不是在所有情况下都成立, 而且随着计算机变得对Unicode越来越友好, 这个假设就日益变得不能成立了.  </p>
<p>在这里, 我们将看一下如何使用Charsets以适合现代文本格式的方式处理文本数据. 这里将使用的示例程序相当简单, 不过, 它触及了使用Charset的所有关键方面：为给定的字符编码创建Charset, 以及使用该Charset解码和编码文本数据.  </p>
<ol start="2">
<li>编码/解码： </li>
</ol>
<p>要读和写文本, 我们要分别使用CharsetDecoder和CharsetEncoder. 将它们称为“编码器”和“解码器” 是有道理的. 一个字符不再表示一个特定的位模式, 而是表示字符系统中的一个实体. 因此, 由某个实际的位模式表示的字符必须以某种特定的编码来表示.  </p>
<p>CharsetDecoder用于将逐位表示的一串字符转换为具体的char值. 同样, 一个CharsetEncoder用于将字符转换回位.  </p>
<ol start="3">
<li>处理文本的正确方式： </li>
</ol>
<p>现在我们将分析这个例子程序UseCharsets.java. 这个程序非常简单：它从一个文件中读取一些文本, 并将该文本写入另一个文件. 但是它把该数据当作文本数据, 并使用CharBuffer来将该数句读入一个CharsetDecoder中. 同样, 它使用CharsetEncoder来写回该数据.  </p>
<p>我们将假设字符以ISO-8859-1(Latin1)字符集（这是ASCII的标准扩展）的形式储存在磁盘上. 尽管我们必须为使用Unicode做好准备, 但是也必须认识到不同的文件是以不同的格式储存的, 而ASCII无疑是非常普遍的一种格式. 事实上, 每种Java实现都要求对以下字符编码提供完全的支持： </p>
<p>   US-ASCII <br>   ISO-8859-1 <br>   UTF-8 <br>   UTF-16BE <br>   UTF-16LE <br>   UTF-16 </p>
<ol start="4">
<li>示例程序： </li>
</ol>
<p>   在打开相应的文件、将输入数据读入名为inputData的ByteBuffer之后, 我们的程序必须创建ISO-8859-1字符集的一个实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Charset latin1 = Charset.forName( <span class="string">&quot;ISO-8859-1&quot;</span> );  </span><br></pre></td></tr></table></figure>
<p>   然后, 创建一个解码器（用于读取）和一个编码器 （用于写入）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CharsetDecoder decoder = latin1.newDecoder();  </span><br><span class="line">CharsetEncoder encoder = latin1.newEncoder();</span><br></pre></td></tr></table></figure>
<p>   为了将字节数据解码为一组字符, 我们把ByteBuffer传递给CharsetDecoder,  结果得到一个CharBuffer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharBuffer cb = decoder.decode( inputData );  </span><br></pre></td></tr></table></figure>
<p>   如果想要处理字符, 我们可以在程序的此处进行. 但是我们只想无改变地将它写回, 所以没有什么要做的.  </p>
<p>   要写回数据, 我们必须使用CharsetEncoder将它转换回字节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer outputData = encoder.encode( cb );  </span><br></pre></td></tr></table></figure>
<p>   在转换完成之后, 我们就可以将数据写到文件中了. </p>
<h2 id="Java-NIO-bug"><a href="#Java-NIO-bug" class="headerlink" title="Java NIO bug"></a>Java NIO bug</h2><p>JDK 原生 NIO 程序的问题</p>
<p>JDK 原生也有一套网络应用程序 API，但是存在一系列问题，主要如下：</p>
<p>NIO 的类库和 API 繁杂，使用麻烦。你需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等。</p>
<p>需要具备其他的额外技能做铺垫。例如熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的 NIO 程序。</p>
<p>可靠性能力补齐，开发工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等。</p>
<p>NIO 编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大。</p>
<p>JDK NIO 的 Bug。例如臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。</p>
<p>官方声称在 JDK 1.6 版本的 update 18 修复了该问题，但是直到 JDK 1.7 版本该问题仍旧存在，只不过该 Bug 发生概率降低了一些而已，它并没有被根本解决。</p>
<hr>
<p>[参考文献]</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html">NIO 入门</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/kunluntaishan/article/details/53536386"> <strong>Java NIO浅析</strong> </a></li>
<li><a target="_blank" rel="noopener" href="http://zhangshixi.iteye.com/blog/679959">NIO学习系列：核心概念及基本读写</a></li>
<li><a target="_blank" rel="noopener" href="http://zhangshixi.iteye.com/blog/683767">NIO学习系列：连网和异步IO</a></li>
<li><a target="_blank" rel="noopener" href="http://zhangshixi.iteye.com/blog/684544">NIO学习系列：缓冲区更多特性及分散/聚集IO</a></li>
<li><a target="_blank" rel="noopener" href="http://zhangshixi.iteye.com/blog/685022">NIO学习系列：文件锁定和字符集</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/JDBC/" rel="tag"># JDBC</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/database/MySQL/struct_1/" rel="prev" title="MySQL架构1 主从复制">
      <i class="fa fa-chevron-left"></i> MySQL架构1 主从复制
    </a></div>
      <div class="post-nav-item">
    <a href="/database/concept/" rel="next" title="数据库设计">
      数据库设计 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9A%E9%80%9A%E9%81%93%E5%92%8C%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">2.</span> <span class="nav-text">核心概念：通道和缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">2.1.</span> <span class="nav-text">缓冲区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%9A%E9%81%93"><span class="nav-number">2.2.</span> <span class="nav-text">通道</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E5%AE%9E%E8%B7%B5%EF%BC%9ANIO%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%92%8C%E5%86%99"><span class="nav-number">3.</span> <span class="nav-text">从理论到实践：NIO中的读和写</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96"><span class="nav-number">3.1.</span> <span class="nav-text">从文件中读取</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%EF%BC%9A"><span class="nav-number">3.2.</span> <span class="nav-text">写入文件：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E7%BB%93%E5%90%88"><span class="nav-number">3.3.</span> <span class="nav-text">读写结合</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.</span> <span class="nav-text">缓冲区内部实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-number">4.1.</span> <span class="nav-text">状态变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#position"><span class="nav-number">4.1.1.</span> <span class="nav-text">position</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#limit"><span class="nav-number">4.1.2.</span> <span class="nav-text">limit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#capacity"><span class="nav-number">4.1.3.</span> <span class="nav-text">capacity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="nav-number">4.1.4.</span> <span class="nav-text">举例说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">访问方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#get"><span class="nav-number">4.2.1.</span> <span class="nav-text">get()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#put"><span class="nav-number">4.2.2.</span> <span class="nav-text">put()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%8C%96%E7%9A%84-get-%E5%92%8C-put-%E6%96%B9%E6%B3%95"><span class="nav-number">4.2.3.</span> <span class="nav-text">类型化的 get() 和 put() 方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="nav-number">4.3.</span> <span class="nav-text">如何使用？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%9E%E7%BD%91%E5%92%8C%E5%BC%82%E6%AD%A5IO"><span class="nav-number">5.</span> <span class="nav-text">连网和异步IO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5-I-O"><span class="nav-number">5.1.</span> <span class="nav-text">异步 I&#x2F;O</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%9B%B4%E5%A4%9A%E5%86%85%E5%AE%B9"><span class="nav-number">6.</span> <span class="nav-text">缓冲区更多内容</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E9%94%81%E5%AE%9A"><span class="nav-number">7.</span> <span class="nav-text">文件锁定</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="nav-number">8.</span> <span class="nav-text">字符集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-NIO-bug"><span class="nav-number">8.1.</span> <span class="nav-text">Java NIO bug</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">aaronzhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">226</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">107</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aaronzhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
