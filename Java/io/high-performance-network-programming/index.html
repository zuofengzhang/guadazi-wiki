<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="C10K问题C10K问题: 一万个客户端同时连接 常识一：文件句柄限制在linux下每一个tcp连接都要占一个文件描述符，一旦文件描述符使用完了，新的连接到来返回给我们的错误是“Socket&#x2F;File:Can’t open so many files”。 操作系统可以打开的最大文件数的限制。 1 进程限制执行 ulimit -n 输出 1024，说明对于一个进程而言最多只能打开1024个文件，所以">
<meta property="og:type" content="article">
<meta property="og:title" content="高性能网络编程IO模型与线程模型">
<meta property="og:url" content="http://example.com/Java/io/high-performance-network-programming/index.html">
<meta property="og:site_name" content="Guadazi">
<meta property="og:description" content="C10K问题C10K问题: 一万个客户端同时连接 常识一：文件句柄限制在linux下每一个tcp连接都要占一个文件描述符，一旦文件描述符使用完了，新的连接到来返回给我们的错误是“Socket&#x2F;File:Can’t open so many files”。 操作系统可以打开的最大文件数的限制。 1 进程限制执行 ulimit -n 输出 1024，说明对于一个进程而言最多只能打开1024个文件，所以">
<meta property="og:locale">
<meta property="og:image" content="http://www.52im.net/data/attachment/forum/201809/05/211858pgsyanbk1yffennv.jpeg">
<meta property="og:image" content="http://www.52im.net/data/attachment/forum/201809/05/212717yp8iwt5z8j1niw8a.jpeg">
<meta property="og:image" content="http://www.52im.net/data/attachment/forum/201809/05/212910wn44nrr6zp5siiuo.jpeg">
<meta property="og:image" content="http://www.52im.net/data/attachment/forum/201809/05/213041mtejdsoeojfjy7dd.jpeg">
<meta property="og:image" content="http://www.52im.net/data/attachment/forum/201809/05/213143a7n3mnxb38ybgxy3.jpeg">
<meta property="og:image" content="http://www.52im.net/data/attachment/forum/201809/05/213218wbeovsvt6g7s4zsj.jpeg">
<meta property="og:image" content="http://www.52im.net/data/attachment/forum/201809/05/213459mmmhohhgwom24uoj.jpeg">
<meta property="og:image" content="http://www.52im.net/data/attachment/forum/201809/06/195333v2cj2o6y92d2zp5z.jpeg">
<meta property="og:image" content="http://www.52im.net/data/attachment/forum/201809/06/195839s5hi3te5pxueq5ze.jpeg">
<meta property="og:image" content="http://www.52im.net/data/attachment/forum/201809/06/200048bgll2l41w72174ot.jpeg">
<meta property="og:image" content="http://www.52im.net/data/attachment/forum/201809/06/200650wun9j9ghkgk7ngna.jpeg">
<meta property="og:image" content="http://www.52im.net/data/attachment/forum/201809/06/200759gg777fr7v7wzcr7r.jpeg">
<meta property="og:image" content="http://www.52im.net/data/attachment/forum/201809/06/201251i0om3mro9wtcxrty.jpeg">
<meta property="article:published_time" content="2019-03-19T09:28:00.000Z">
<meta property="article:modified_time" content="2021-04-04T00:36:18.009Z">
<meta property="article:author" content="aaronzhang">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="IO">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.52im.net/data/attachment/forum/201809/05/211858pgsyanbk1yffennv.jpeg">

<link rel="canonical" href="http://example.com/Java/io/high-performance-network-programming/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>高性能网络编程IO模型与线程模型 | Guadazi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Guadazi</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/io/high-performance-network-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          高性能网络编程IO模型与线程模型
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-19 17:28:00" itemprop="dateCreated datePublished" datetime="2019-03-19T17:28:00+08:00">2019-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-04 08:36:18" itemprop="dateModified" datetime="2021-04-04T08:36:18+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="C10K问题"><a href="#C10K问题" class="headerlink" title="C10K问题"></a>C10K问题</h2><p><a target="_blank" rel="noopener" href="http://www.kegel.com/c10k.html">C10K问题</a>: 一万个客户端同时连接</p>
<h3 id="常识一：文件句柄限制"><a href="#常识一：文件句柄限制" class="headerlink" title="常识一：文件句柄限制"></a>常识一：文件句柄限制</h3><p>在linux下每一个tcp连接都要占一个文件描述符，一旦文件描述符使用完了，新的连接到来返回给我们的错误是“Socket/File:Can’t open so many files”。</p>
<p>操作系统可以打开的最大文件数的限制。</p>
<h4 id="1-进程限制"><a href="#1-进程限制" class="headerlink" title="1 进程限制"></a>1 进程限制</h4><p>执行 <code>ulimit -n</code> 输出 <code>1024</code>，说明对于一个进程而言最多只能打开1024个文件，所以采用此配置最多可以并发上千个TCP连接。<br>临时修改：ulimit -n 1000000，但是这种临时修改只对当前登录用户目前的使用环境有效，系统重启或用户退出后就会失效。</p>
<p>重启后失效的修改: （CentOS 6.5下测试，重启后未发现失效），编辑 <code>/etc/security/limits.conf</code> 文件， 修改后内容为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soft nofile 1000000</span><br><span class="line">hard nofile 1000000</span><br></pre></td></tr></table></figure>
<p>永久修改：编辑/etc/rc.local，在其后添加如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -SHn 1000000</span><br></pre></td></tr></table></figure>
<h4 id="2-全局限制"><a href="#2-全局限制" class="headerlink" title="2 全局限制"></a>2 全局限制</h4><p>执行<code>cat /proc/sys/fs/file-nr</code>输出<code>9344 0 592026</code>，分别为：</p>
<ol>
<li>已经分配的文件句柄数，</li>
<li>已经分配但没有使用的文件句柄数，</li>
<li>最大文件句柄数。</li>
</ol>
<p>但在kernel 2.6版本中第二项的值总为0，这并不是一个错误，它实际上意味着已经分配的文件描述符无一浪费的都已经被使用了。我们可以把这个数值改大些，用 root 权限修改 <code>/etc/sysctl.conf</code> 文件:</p>
<ul>
<li>fs.file-max = 1000000</li>
<li>net.ipv4.ip_conntrack_max = 1000000</li>
<li>net.ipv4.netfilter.ip_conntrack_max = 1000000</li>
</ul>
<h3 id="常识二：端口号范围限制？"><a href="#常识二：端口号范围限制？" class="headerlink" title="常识二：端口号范围限制？"></a>常识二：端口号范围限制？</h3><p>操作系统上端口号1024以下是系统保留的，从1024-65535是用户使用的。每个TCP连接都要占一个端口号, 但可以创建的最大并发连接不只60000个</p>
<h4 id="如何标识一个TCP连接："><a href="#如何标识一个TCP连接：" class="headerlink" title="如何标识一个TCP连接："></a>如何标识一个TCP连接：</h4><p>系统用一个4四元组来唯一标识一个TCP连接：<code>&#123;local ip, local port,remote ip,remote port&#125;</code>。</p>
<blockquote>
<p>《UNIX网络编程：卷一》第四章中对accept的讲解，第二个参数cliaddr代表了客户端的ip地址和端口号。而服务端实际只使用了bind时这一个端口，说明端口号65535并不是并发量的限制。</p>
</blockquote>
<h4 id="server最大tcp连接数："><a href="#server最大tcp连接数：" class="headerlink" title="server最大tcp连接数："></a>server最大tcp连接数：</h4><p>server通常固定在某个本地端口上监听，等待client的连接请求。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，即使server端有多个ip，本地监听端口也是独占的，因此server端tcp连接4元组中只有remote ip（也就是client ip）和remote port（客户端port）是可变的，因此最大tcp连接为<code>客户端ip数×客户端port数</code>，对IPV4，不考虑ip地址分类等因素，最大tcp连接数约为<code>2的32次方（ip数）×2的16次方（port数）</code>，也就是server端单机最大tcp连接数约为<code>2的48次方</code>。</p>
<h2 id="I-O-Model"><a href="#I-O-Model" class="headerlink" title="I/O Model"></a>I/O Model</h2><p>最初的服务器都是<strong>基于进程/线程模型</strong>的，一个TCP连接，就需要分配1个进程（或者线程）。而进程又是操作系统最昂贵的资源，一台机器无法创建很多进程。<br>如果是C10K就要创建1万个进程，那么单机而言操作系统是无法承受的（往往出现效率低下甚至完全瘫痪）。<br>如果是采用分布式系统，维持1亿用户在线需要10万台服务器，成本巨大，也只有Facebook、Google、雅虎等巨头才有财力购买如此多的服务器。</p>
<p>传统的同步阻塞I/O模型都是一样的，处理的方式都是requests per second，并发10K和100的区别关键在于CPU。<br>创建的进程线程多了，<strong>数据拷贝频繁（缓存I/O、内核将数据拷贝到用户进程空间、阻塞）， 进程/线程上下文切换消耗大</strong>， 导致操作系统崩溃，这就是C10K问题的本质！</p>
<h3 id="互联网服务端处理网络请求的原理"><a href="#互联网服务端处理网络请求的原理" class="headerlink" title="互联网服务端处理网络请求的原理"></a>互联网服务端处理网络请求的原理</h3><p>典型互联网服务端处理网络请求的典型过程：</p>
<p>  <img src="http://www.52im.net/data/attachment/forum/201809/05/211858pgsyanbk1yffennv.jpeg" alt="高性能网络编程(五)：一文读懂高性能网络编程中的I/O模型_1.jpeg">    </p>
<p>由上图可以看到，主要处理步骤包括： </p>
<p> 1）获取请求数据，客户端与服务器建立连接发出请求，服务器接受请求（1-3）；<br> 2）构建响应，当服务器接收完请求，并在用户空间处理客户端的请求，直到构建响应完成（4）；<br> 3）返回数据，服务器将已构建好的响应再通过内核空间的网络 I/O 发还给客户端（5-7）。</p>
<p>设计服务端并发模型时，主要有如下两个关键点： </p>
<p> 1）服务器如何管理连接，获取输入数据；<br> 2）服务器如何处理请求。</p>
<h3 id="“I-O-模型”的基本认识"><a href="#“I-O-模型”的基本认识" class="headerlink" title="“I/O 模型”的基本认识"></a>“I/O 模型”的基本认识</h3><h4 id="阻塞调用与非阻塞调用："><a href="#阻塞调用与非阻塞调用：" class="headerlink" title="阻塞调用与非阻塞调用："></a>阻塞调用与非阻塞调用：</h4><ul>
<li>阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回；</li>
<li>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</li>
</ul>
<p>两者的最大区别在于被调用方在收到请求到返回结果之前的这段时间内，调用方是否一直在等待。<strong>阻塞</strong>是指调用方一直在等待而且别的事情什么都不做；<strong>非阻塞</strong>是指调用方先去忙别的事情。</p>
<h4 id="同步处理与异步处理："><a href="#同步处理与异步处理：" class="headerlink" title="同步处理与异步处理："></a>同步处理与异步处理：</h4><p>同步处理是指被调用方得到最终结果之后才返回给调用方；异步处理是指被调用方先返回应答，然后再计算调用结果，计算完最终结果后再通知并返回给调用方。</p>
<p>阻塞、非阻塞和同步、异步的区别（阻塞、非阻塞和同步、异步其实针对的对象是不一样的）：</p>
<ul>
<li>1）阻塞、非阻塞的讨论对象是调用者；</li>
<li>2）同步、异步的讨论对象是被调用者。</li>
</ul>
<h4 id="recvfrom-函数："><a href="#recvfrom-函数：" class="headerlink" title="recvfrom 函数："></a>recvfrom 函数：</h4><p>// FIXME 究竟什么是Socket，操作系统套接字代表的是什么</p>
<p>recvfrom 函数(经 <code>Socket</code> 接收数据)，这里把它视为系统调用。</p>
<p>一个输入操作通常包括两个不同的阶段：</p>
<ul>
<li>1）等待数据准备好；</li>
<li>2）从内核向进程复制数据。</li>
</ul>
<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>
<p>实际应用程序在系统调用完成上面的 2 步操作时，调用方式的阻塞、非阻塞，操作系统在处理应用程序请求时，处理方式的同步、异步处理的不同，可以分为 5 种 I/O 模型（下面的章节将逐个展开介绍）。（参考《UNIX网络编程卷1》）</p>
<h3 id="阻塞式-I-O-blocking-I-O）"><a href="#阻塞式-I-O-blocking-I-O）" class="headerlink" title="阻塞式 I/O(blocking I/O）"></a>阻塞式 I/O(blocking I/O）</h3><p>  <img src="http://www.52im.net/data/attachment/forum/201809/05/212717yp8iwt5z8j1niw8a.jpeg" alt="高性能网络编程(五)：一文读懂高性能网络编程中的I/O模型_2.jpeg">    </p>
<p> 在阻塞式 I/O 模型中，应用程序在从调用 recvfrom 开始到它返回有数据报准备好这段时间是阻塞的，recvfrom 返回成功后，应用进程开始处理数据报。</p>
<p><strong>比喻：</strong> 一个人在钓鱼，当没鱼上钩时，就坐在岸边一直等。</p>
<p><strong>优点：</strong> 程序简单，在阻塞等待数据期间进程/线程挂起，基本不会占用 CPU 资源。</p>
<p><strong>缺点：</strong> 每个连接需要独立的进程/线程单独处理，当并发请求量大时为了维护程序，内存、线程切换开销较大，这种模型在实际生产中很少使用。</p>
<h3 id="非阻塞式-I-O-non-blocking-I-O）"><a href="#非阻塞式-I-O-non-blocking-I-O）" class="headerlink" title="非阻塞式 I/O (non-blocking I/O）"></a>非阻塞式 I/O (non-blocking I/O）</h3><p>  <img src="http://www.52im.net/data/attachment/forum/201809/05/212910wn44nrr6zp5siiuo.jpeg" alt="高性能网络编程(五)：一文读懂高性能网络编程中的I/O模型_3.jpeg"></p>
<p> 应用程序把一个套接口设置为非阻塞，就是告诉内核，当所请求的 I/O 操作无法完成时，不要将进程睡眠。<br> 而是返回一个错误，应用程序基于 I/O 操作函数将不断的轮询数据是否已经准备好，如果没有准备好，继续轮询，直到数据准备好为止。</p>
<p><strong>比喻：</strong> 边钓鱼边玩手机，隔会再看看有没有鱼上钩，有的话就迅速拉杆。</p>
<p><strong>优点：</strong> 不会阻塞在内核的等待数据过程，每次发起的 I/O 请求可以立即返回，不用阻塞等待，实时性较好。</p>
<p><strong>缺点：</strong> 轮询将会不断地询问内核，这将占用大量的 CPU 时间，系统资源利用率较低，所以一般 Web 服务器不使用这种 I/O 模型。</p>
<h3 id="I-O-多路复用-I-O-multiplexing）"><a href="#I-O-多路复用-I-O-multiplexing）" class="headerlink" title="I/O 多路复用(I/O multiplexing）"></a>I/O 多路复用(I/O multiplexing）</h3><p><img src="http://www.52im.net/data/attachment/forum/201809/05/213041mtejdsoeojfjy7dd.jpeg" alt="高性能网络编程(五)：一文读懂高性能网络编程中的I/O模型_4.jpeg"></p>
<p> 在 I/O 复用模型中，会用到 Select 或 Poll 函数或 Epoll 函数(Linux 2.6 以后的内核开始支持)，这两个函数也会使进程阻塞，但是和阻塞 I/O 有所不同。</p>
<p> 这两个函数可以同时阻塞多个 I/O 操作，而且可以同时对多个读操作，多个写操作的 I/O 函数进行检测，直到有数据可读或可写时，才真正调用 I/O 操作函数。</p>
<p><strong>比喻：</strong> 放了一堆鱼竿，在岸边一直守着这堆鱼竿，没鱼上钩就玩手机。</p>
<p><strong>优点：</strong> 可以基于一个阻塞对象，同时在多个描述符上等待就绪，而不是使用多个线程(每个文件描述符一个线程)，这样可以大大节省系统资源。</p>
<p><strong>缺点：</strong> 当连接数较少时效率相比多线程+阻塞 I/O 模型效率较低，可能延迟更大，因为单个连接处理需要 2 次系统调用，占用时间会有增加。</p>
<p>众所周之，Nginx这样的高性能互联网反向代理服务器大获成功的关键就是得益于<code>Epoll</code>。</p>
<h3 id="信号驱动式-I-O-（signal-driven-I-O"><a href="#信号驱动式-I-O-（signal-driven-I-O" class="headerlink" title="信号驱动式 I/O （signal-driven I/O)"></a>信号驱动式 I/O （signal-driven I/O)</h3><p>  <img src="http://www.52im.net/data/attachment/forum/201809/05/213143a7n3mnxb38ybgxy3.jpeg" alt="高性能网络编程(五)：一文读懂高性能网络编程中的I/O模型_5.jpeg"></p>
<p> 在信号驱动式 I/O 模型中，应用程序使用套接口进行信号驱动 I/O，并安装一个信号处理函数，进程继续运行并不阻塞。<br> 当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I/O 操作函数处理数据。</p>
<p><strong>比喻：</strong> 鱼竿上系了个铃铛，当铃铛响，就知道鱼上钩，然后可以专心玩手机。</p>
<p><strong>优点：</strong> 线程并没有在等待数据时被阻塞，可以提高资源的利用率。</p>
<p><strong>缺点：</strong> 信号 I/O 在大量 IO 操作时可能会因为信号队列溢出导致没法通知。</p>
<p> 信号驱动 I/O 尽管对于处理 UDP 套接字来说有用，即这种信号通知意味着到达一个数据报，或者返回一个异步错误。</p>
<p> 但是，对于 TCP 而言，信号驱动的 I/O 方式近乎无用，因为导致这种通知的条件为数众多，每一个来进行判别会消耗很大资源，与前几种方式相比优势尽失。</p>
<h3 id="异步-I-O（即AIO，全称asynchronous-I-O）"><a href="#异步-I-O（即AIO，全称asynchronous-I-O）" class="headerlink" title="异步 I/O（即AIO，全称asynchronous I/O）"></a>异步 I/O（即AIO，全称asynchronous I/O）</h3><p><img src="http://www.52im.net/data/attachment/forum/201809/05/213218wbeovsvt6g7s4zsj.jpeg" alt="高性能网络编程(五)：一文读懂高性能网络编程中的I/O模型_6.jpeg"></p>
<p> 由 POSIX 规范定义，应用程序告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到应用程序的缓冲区）完成后通知应用程序。</p>
<p> 这种模型与信号驱动模型的主要区别在于：信号驱动 I/O 是由内核通知应用程序何时启动一个 I/O 操作，而异步 I/O 模型是由内核通知应用程序 I/O 操作何时完成。</p>
<p><strong>优点：</strong> 异步 I/O 能够充分利用 DMA 特性，让 I/O 操作与计算重叠。</p>
<p><strong>缺点：</strong> 要实现真正的异步 I/O，操作系统需要做大量的工作。目前 Windows 下通过 IOCP 实现了真正的异步 I/O。</p>
<p> 而在 Linux 系统下，Linux 2.6才引入，目前 AIO 并不完善，因此在 Linux 下实现高并发网络编程时都是以 IO 复用模型模式为主。</p>
<p> 关于AOI的介绍，请见：《Java新一代网络编程模型AIO原理及Linux系统AIO介绍》。</p>
<h3 id="5-种-I-O-模型总结"><a href="#5-种-I-O-模型总结" class="headerlink" title="5 种 I/O 模型总结"></a>5 种 I/O 模型总结</h3><p>  <img src="http://www.52im.net/data/attachment/forum/201809/05/213459mmmhohhgwom24uoj.jpeg" alt="高性能网络编程(五)：一文读懂高性能网络编程中的I/O模型_7.jpeg">    </p>
<p> 从上图中我们可以看出，越往后，阻塞越少，理论上效率也是最优。</p>
<p> 这五种 I/O 模型中，前四种属于同步 I/O，因为其中真正的 I/O 操作(recvfrom)将阻塞进程/线程，只有异步 I/O 模型才与 POSIX 定义的异步 I/O 相匹配。</p>
<h2 id="高性能网络编程中的线程模型"><a href="#高性能网络编程中的线程模型" class="headerlink" title="高性能网络编程中的线程模型"></a>高性能网络编程中的线程模型</h2><h3 id="传统阻塞-I-O-服务模型"><a href="#传统阻塞-I-O-服务模型" class="headerlink" title="传统阻塞 I/O 服务模型"></a>传统阻塞 I/O 服务模型</h3><p><img src="http://www.52im.net/data/attachment/forum/201809/06/195333v2cj2o6y92d2zp5z.jpeg" alt="高性能网络编程(六)：一文读懂高性能网络编程中的线程模型_1.jpeg">    </p>
<p><strong>特点：</strong></p>
<p>1）采用阻塞式 I/O 模型获取输入数据；<br>2）每个连接都需要独立的线程完成数据输入，业务处理，数据返回的完整操作。</p>
<p><strong>存在问题：</strong></p>
<p>1）当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大；<br>2）连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费。</p>
<h3 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>针对传统阻塞 I/O 服务模型的 2 个缺点，比较常见的有如下解决方案： </p>
<p> 1）基于 I/O 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理；<br> 2）基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。</p>
<p>I/O 复用结合线程池，这就是 Reactor 模式基本设计思想，如下图：</p>
<p><img src="http://www.52im.net/data/attachment/forum/201809/06/195839s5hi3te5pxueq5ze.jpeg" alt="高性能网络编程(六)：一文读懂高性能网络编程中的线程模型_2.jpeg"></p>
<p>Reactor 模式，是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。 </p>
<p>服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor 模式也叫 Dispatcher 模式。即 I/O 多了复用统一监听事件，收到事件后分发(Dispatch 给某进程)，是编写高性能网络服务器的必备技术之一。</p>
<p>Reactor 模式中有 2 个关键组成：</p>
<p>1）Reactor：Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO 事件做出反应。 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；<br>2）Handlers：处理程序执行 I/O 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor 通过调度适当的处理程序来响应 I/O 事件，处理程序执行非阻塞操作。</p>
<p>根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现：</p>
<p>1）单 Reactor 单线程；<br>2）单 Reactor 多线程；<br>3）主从 Reactor 多线程。</p>
<p>下面详细介绍这 3 种实现方式。</p>
<h4 id="单-Reactor-单线程"><a href="#单-Reactor-单线程" class="headerlink" title="单 Reactor 单线程"></a>单 Reactor 单线程</h4><p><img src="http://www.52im.net/data/attachment/forum/201809/06/200048bgll2l41w72174ot.jpeg" alt="高性能网络编程(六)：一文读懂高性能网络编程中的线程模型_3.jpeg">    </p>
<p>其中，Select 是前面 I/O 复用模型介绍的标准网络编程 API，可以实现应用程序通过一个阻塞对象监听多路连接请求，其他方案示意图类似。</p>
<p>方案说明：</p>
<p>1）Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发；<br>2）如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理；<br>3）如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应；<br>4）Handler 会完成 Read→业务处理→Send 的完整业务流程。</p>
<p><strong>优点：</strong></p>
<p>模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成。</p>
<p>缺点：</p>
<p>性能问题，只有一个线程，无法完全发挥多核 CPU 的性能。Handler 在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈。</p>
<p> 可靠性问题，线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。</p>
<p><strong>使用场景：</strong></p>
<p>客户端的数量有限，业务处理非常快速，比如 Redis，业务处理的时间复杂度 O(1)。</p>
<h4 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor 多线程"></a>单 Reactor 多线程</h4><p>  <img src="http://www.52im.net/data/attachment/forum/201809/06/200650wun9j9ghkgk7ngna.jpeg" alt="高性能网络编程(六)：一文读懂高性能网络编程中的线程模型_4.jpeg">    </p>
<p>方案说明：</p>
<ul>
<li>1）Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发；</li>
<li>2）如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后续的各种事件；</li>
<li>3）如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应；</li>
<li>4）Handler 只负责响应事件，不做具体业务处理，通过 Read 读取数据后，会分发给后面的 Worker 线程池进行业务处理；</li>
<li>5）Worker 线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给 Handler 进行处理；</li>
<li>6）Handler 收到响应结果后通过 Send 将响应结果返回给 Client。</li>
</ul>
<p>优点：</p>
<p>可以充分利用多核 CPU 的处理能力。</p>
<p>缺点：</p>
<p>多线程数据共享和访问比较复杂；Reactor 承担所有事件的监听和响应，在单线程中运行，高并发场景下容易成为性能瓶颈。</p>
<h4 id="主从-Reactor-多线程"><a href="#主从-Reactor-多线程" class="headerlink" title="主从 Reactor 多线程"></a>主从 Reactor 多线程</h4><p>  <img src="http://www.52im.net/data/attachment/forum/201809/06/200759gg777fr7v7wzcr7r.jpeg" alt="高性能网络编程(六)：一文读懂高性能网络编程中的线程模型_5.jpeg">    </p>
<p> 针对单 Reactor 多线程模型中，Reactor 在单线程中运行，高并发场景下容易成为性能瓶颈，可以让 Reactor 在多线程中运行。</p>
<p>方案说明：</p>
<ul>
<li>1）Reactor 主线程 MainReactor 对象通过 Select 监控建立连接事件，收到事件后通过 Acceptor 接收，处理建立连接事件；</li>
<li>2）Acceptor 处理建立连接事件后，MainReactor 将连接分配 Reactor 子线程给 SubReactor 进行处理；</li>
<li>3）SubReactor 将连接加入连接队列进行监听，并创建一个 Handler 用于处理各种连接事件；</li>
<li>4）当有新的事件发生时，SubReactor 会调用连接对应的 Handler 进行响应；</li>
<li>5）Handler 通过 Read 读取数据后，会分发给后面的 Worker 线程池进行业务处理；</li>
<li>6）Worker 线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给 Handler 进行处理；</li>
<li>7）Handler 收到响应结果后通过 Send 将响应结果返回给 Client。</li>
</ul>
<p>优点：</p>
<p>父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</p>
<p> 父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据。</p>
<p> 这种模型在许多项目中广泛使用，包括 Nginx 主从 Reactor 多进程模型，Memcached 主从多线程，Netty 主从多线程模型的支持。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>3 种模式可以用个比喻来理解：</p>
<p>（餐厅常常雇佣接待员负责迎接顾客，当顾客入坐后，侍应生专门为这张桌子服务）</p>
<ul>
<li>1）单 Reactor 单线程，接待员和侍应生是同一个人，全程为顾客服务；</li>
<li>2）单 Reactor 多线程，1 个接待员，多个侍应生，接待员只负责接待；</li>
<li>3）主从 Reactor 多线程，多个接待员，多个侍应生。</li>
</ul>
<p>Reactor 模式具有如下的优点：</p>
<ul>
<li>1）响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的；</li>
<li>2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；</li>
<li>3）可扩展性，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源；</li>
<li>4）可复用性，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性。</li>
</ul>
<h3 id="Proactor-模型"><a href="#Proactor-模型" class="headerlink" title="Proactor 模型"></a>Proactor 模型</h3><p> 在 Reactor 模式中，Reactor 等待某个事件或者可应用或者操作的状态发生（比如文件描述符可读写，或者是 Socket 可读写）。 然后把这个事件传给事先注册的 Handler（事件处理函数或者回调函数），由后者来做实际的读写操作。其中的读写操作都需要应用程序同步操作，所以 Reactor 是非阻塞同步网络模型。</p>
<p> 如果把 I/O 操作改为异步，即交给操作系统来完成就能进一步提升性能，这就是异步网络模型 Proactor。</p>
<p>  <img src="http://www.52im.net/data/attachment/forum/201809/06/201251i0om3mro9wtcxrty.jpeg" alt="高性能网络编程(六)：一文读懂高性能网络编程中的线程模型_1.jpeg">    </p>
<p>Proactor 是和异步 I/O 相关的，详细方案如下：</p>
<p>1）Proactor Initiator 创建 Proactor 和 Handler 对象，并将 Proactor 和 Handler 都通过 AsyOptProcessor（Asynchronous Operation Processor）注册到内核；<br>2）AsyOptProcessor 处理注册请求，并处理 I/O 操作；<br>3）AsyOptProcessor 完成 I/O 操作后通知 Proactor；<br>4）Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理；<br>5）Handler 完成业务处理。</p>
<p>可以看出 Proactor 和 Reactor 的区别：</p>
<p>1）Reactor 是在事件发生时就通知事先注册的事件（读写在应用程序线程中处理完成）；<br>2）Proactor 是在事件发生时基于异步 I/O 完成读写操作（由内核完成），待 I/O 操作完成后才回调应用程序的处理器来进行业务处理。</p>
<p>理论上 Proactor 比 Reactor 效率更高，异步 I/O 更加充分发挥 DMA(Direct Memory Access，直接内存存取)的优势。</p>
<p>但是Proactor有如下缺点：</p>
<p>1）编程复杂性，由于异步操作流程的事件的初始化和事件完成在时间和空间上都是相互分离的，因此开发异步应用程序更加复杂。应用程序还可能因为反向的流控而变得更加难以 Debug；<br>2）内存使用，缓冲区在读或写操作的时间段内必须保持住，可能造成持续的不确定性，并且每个并发操作都要求有独立的缓存，相比 Reactor 模式，在 Socket 已经准备好读或写前，是不要求开辟缓存的；<br>3）操作系统支持，Windows 下通过 IOCP 实现了真正的异步 I/O，而在 Linux 系统下，Linux 2.6 才引入，目前异步 I/O 还不完善。</p>
<p>因此在 Linux 下实现高并发网络编程都是以 Reactor 模型为主。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/IO/" rel="tag"># IO</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Java/metric/03_G1_GC/" rel="prev" title="Java G1 GC">
      <i class="fa fa-chevron-left"></i> Java G1 GC
    </a></div>
      <div class="post-nav-item">
    <a href="/Java/multithread/lockless-disruptor/" rel="next" title="无锁队列与Disruptor">
      无锁队列与Disruptor <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#C10K%E9%97%AE%E9%A2%98"><span class="nav-number">1.</span> <span class="nav-text">C10K问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%AF%86%E4%B8%80%EF%BC%9A%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E9%99%90%E5%88%B6"><span class="nav-number">1.1.</span> <span class="nav-text">常识一：文件句柄限制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%BF%9B%E7%A8%8B%E9%99%90%E5%88%B6"><span class="nav-number">1.1.1.</span> <span class="nav-text">1 进程限制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%85%A8%E5%B1%80%E9%99%90%E5%88%B6"><span class="nav-number">1.1.2.</span> <span class="nav-text">2 全局限制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%AF%86%E4%BA%8C%EF%BC%9A%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%8C%83%E5%9B%B4%E9%99%90%E5%88%B6%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">常识二：端口号范围限制？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%A0%87%E8%AF%86%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%EF%BC%9A"><span class="nav-number">1.2.1.</span> <span class="nav-text">如何标识一个TCP连接：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#server%E6%9C%80%E5%A4%A7tcp%E8%BF%9E%E6%8E%A5%E6%95%B0%EF%BC%9A"><span class="nav-number">1.2.2.</span> <span class="nav-text">server最大tcp连接数：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O-Model"><span class="nav-number">2.</span> <span class="nav-text">I&#x2F;O Model</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E8%81%94%E7%BD%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.</span> <span class="nav-text">互联网服务端处理网络请求的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%80%9CI-O-%E6%A8%A1%E5%9E%8B%E2%80%9D%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86"><span class="nav-number">2.2.</span> <span class="nav-text">“I&#x2F;O 模型”的基本认识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E8%B0%83%E7%94%A8%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B0%83%E7%94%A8%EF%BC%9A"><span class="nav-number">2.2.1.</span> <span class="nav-text">阻塞调用与非阻塞调用：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%A4%84%E7%90%86%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%9A"><span class="nav-number">2.2.2.</span> <span class="nav-text">同步处理与异步处理：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#recvfrom-%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="nav-number">2.2.3.</span> <span class="nav-text">recvfrom 函数：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%E5%BC%8F-I-O-blocking-I-O%EF%BC%89"><span class="nav-number">2.3.</span> <span class="nav-text">阻塞式 I&#x2F;O(blocking I&#x2F;O）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F-I-O-non-blocking-I-O%EF%BC%89"><span class="nav-number">2.4.</span> <span class="nav-text">非阻塞式 I&#x2F;O (non-blocking I&#x2F;O）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-I-O-multiplexing%EF%BC%89"><span class="nav-number">2.5.</span> <span class="nav-text">I&#x2F;O 多路复用(I&#x2F;O multiplexing）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8%E5%BC%8F-I-O-%EF%BC%88signal-driven-I-O"><span class="nav-number">2.6.</span> <span class="nav-text">信号驱动式 I&#x2F;O （signal-driven I&#x2F;O)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5-I-O%EF%BC%88%E5%8D%B3AIO%EF%BC%8C%E5%85%A8%E7%A7%B0asynchronous-I-O%EF%BC%89"><span class="nav-number">2.7.</span> <span class="nav-text">异步 I&#x2F;O（即AIO，全称asynchronous I&#x2F;O）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%A7%8D-I-O-%E6%A8%A1%E5%9E%8B%E6%80%BB%E7%BB%93"><span class="nav-number">2.8.</span> <span class="nav-text">5 种 I&#x2F;O 模型总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">高性能网络编程中的线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E9%98%BB%E5%A1%9E-I-O-%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.1.</span> <span class="nav-text">传统阻塞 I&#x2F;O 服务模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reactor-%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">Reactor 模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.2.1.</span> <span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95-Reactor-%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.2.2.</span> <span class="nav-text">单 Reactor 单线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95-Reactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.2.3.</span> <span class="nav-text">单 Reactor 多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E-Reactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.2.4.</span> <span class="nav-text">主从 Reactor 多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">3.2.5.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proactor-%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.3.</span> <span class="nav-text">Proactor 模型</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">aaronzhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">268</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">121</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aaronzhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
