<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="理解Java多线程, 需要深入理解&#96;线程状态和锁&#96; [TOC] 线程由于每个时钟周期内, CPU 实际上只能执行一条指令. CPU每一个时刻只能做一件事, 多线程是通过任务调度给CPU分配任务实现的, 多线程的目的是为了最大限度的利用CPU资源. 操作系统负责管理进程和线程, 轮流(没有固定的顺序)分配每个进程很短的时间(不一定是均分), 然后在每个线程内部, 程序代码自己处理该进程内部线程的时间">
<meta property="og:type" content="article">
<meta property="og:title" content="线程生命周期">
<meta property="og:url" content="http://example.com/Java/multithread/01.thread-lifecycle/index.html">
<meta property="og:site_name" content="Guadazi">
<meta property="og:description" content="理解Java多线程, 需要深入理解&#96;线程状态和锁&#96; [TOC] 线程由于每个时钟周期内, CPU 实际上只能执行一条指令. CPU每一个时刻只能做一件事, 多线程是通过任务调度给CPU分配任务实现的, 多线程的目的是为了最大限度的利用CPU资源. 操作系统负责管理进程和线程, 轮流(没有固定的顺序)分配每个进程很短的时间(不一定是均分), 然后在每个线程内部, 程序代码自己处理该进程内部线程的时间">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/images/java/multithread/01.base/Java-Thread-statue-01.png">
<meta property="article:published_time" content="2015-08-11T16:00:00.000Z">
<meta property="article:modified_time" content="2021-04-12T09:33:23.842Z">
<meta property="article:author" content="aaronzhang">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Thread">
<meta property="article:tag" content="Multi-thread">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/java/multithread/01.base/Java-Thread-statue-01.png">

<link rel="canonical" href="http://example.com/Java/multithread/01.thread-lifecycle/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>线程生命周期 | Guadazi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Guadazi</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/multithread/01.thread-lifecycle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          线程生命周期
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-08-12 00:00:00" itemprop="dateCreated datePublished" datetime="2015-08-12T00:00:00+08:00">2015-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-12 17:33:23" itemprop="dateModified" datetime="2021-04-12T17:33:23+08:00">2021-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <pre><code>理解Java多线程, 需要深入理解`线程状态和锁`</code></pre>
<p>[TOC]</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>由于每个时钟周期内, CPU 实际上只能执行一条指令. CPU每一个时刻只能做一件事, 多线程是通过任务调度给CPU分配任务实现的, 多线程的目的是为了最大限度的利用CPU资源.</p>
<p>操作系统负责管理进程和线程, 轮流(没有固定的顺序)分配每个进程很短的时间(不一定是均分), 然后在每个线程内部, 程序代码自己处理该进程内部线程的时间分配, 多个线程之间相互的切换去执行, 这个切换时间也是非常短的.</p>
<h2 id="程序、进程、线程之间的关系"><a href="#程序、进程、线程之间的关系" class="headerlink" title="程序、进程、线程之间的关系"></a>程序、进程、线程之间的关系</h2><ul>
<li>程序是一段静态的代码，是应用软件执行的蓝本。</li>
<li>进程是程序一次动态执行的过程，它对应了从代码加载、执行完毕的一个完整过程，这也是进程开始到消亡的过程。</li>
<li>线程是进程中独立、可调度的执行单元，是执行中最小单位。</li>
<li>一个程序一般是一个进程，但一个程序中也可以有多个进程。</li>
<li>一个进程中可以有多个线程，但只有一个主线程。</li>
<li>Java应用程序中默认的主线程是main方法，如果main方法中创建了其他线程，JVM就会执行其他的线程。</li>
</ul>
<h2 id="Java-进程"><a href="#Java-进程" class="headerlink" title="Java 进程"></a>Java 进程</h2><p>Java编写的程序是运行在JVM中的, 启动一个Java应用程序,  就会启动一个JVM进程. 在同一个JVM进程中, 有且只有一个进程, 就是它自己. 因此, 所有的程序代码的运行都是以线程运行的. 同一个进程中的所有线程共享一块内存块,  <strong>因此线程间通信很容易且速度很快</strong>.</p>
<ul>
<li>Java 中的线程是一个对象, 与其他 Java 中的对象一样, 具有变量和方法, 生死于堆上.</li>
</ul>
<p>调用栈</p>
<ul>
<li>Java 中的每个线程都有一个调用栈, 即使不创建任何新的线程,  线程也在后台运行着.</li>
<li>一旦创建一个新的线程,  就产生一个新的调用栈.</li>
</ul>
<h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><p>在JVM上运行一个应用程序时,  JVM首先寻找程序入口的<code>main()</code>方法,  然后运行<code>main()</code>方法, 此时就产生了一个Java线程, 这个线程就是主线程. 当main方法结束后,  主线程运行完成,  如果不存在额外的线程运行,  JVM进程随即退出.</p>
<p>调度的方式有两种：分时调度和抢占式调度, Java中采用的是<em>抢占式调度</em></p>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static int MAX_PRIORITY</span><br><span class="line">          线程可以具有的最高优先级.</span><br><span class="line">static int MIN_PRIORITY</span><br><span class="line">          线程可以具有的最低优先级.</span><br><span class="line">static int NORM_PRIORITY</span><br><span class="line">          分配给线程的默认优先级.</span><br></pre></td></tr></table></figure>
<p>当线程池中线程都具有相同的优先级, 调度程序的JVM实现自由选择它喜欢的线程. 这时候调度程序的操作有两种可能：<br>一是选择一个线程运行, 直到它阻塞或者运行完成为止.<br>二是时间分片, 为池内的每个线程提供均等的运行机会.</p>
<p>1~10之间的值是没有保证的. 一些JVM可能不能识别10个不同的值, 而将这些优先级进行每两个或多个合并, 变成少于10个的优先级, 则两个或多个优先级的线程可能被映射为一个优先级.</p>
<p>与线程休眠类似, 线程的优先级仍然无法保障线程的执行次序. 只不过, 优先级高的线程获取CPU资源的概率较大, 优先级低的并非没机会执行.</p>
<h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p>创建–运行–中断–死亡</p>
<ul>
<li>创建：线程构造</li>
<li>运行：调用start()方法，进入run()方法</li>
<li>中断：sleep()、wait()</li>
<li>死亡：执行完run()方法或强制run()方法结束，线程死亡</li>
</ul>
<h1 id="线程的状态与转换"><a href="#线程的状态与转换" class="headerlink" title="线程的状态与转换"></a>线程的状态与转换</h1><p><img src="/images/java/multithread/01.base/Java-Thread-statue-01.png" alt="线程生命周期与状态转换"></p>
<h2 id="new与新建状态"><a href="#new与新建状态" class="headerlink" title="new与新建状态"></a>new与新建状态</h2><p>新建线程有两个方法: 继承Thread类 和 实现Runnable接口.</p>
<p>Runnable 接口的定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现<code>Runnable</code>接口就需要实现run方法. <code>run</code>方法的内容就是线程要执行的任务.<br>Thread类, 是实现了Runable接口的类, 因此在Thread类中也存在run方法.</p>
<p>新建线程有若干种重载方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于 Thread 实现了 Runnable 接口,</span></span><br><span class="line"><span class="comment">//这种形式也可以以 Thread 对象为参数</span></span><br></pre></td></tr></table></figure>
<h2 id="start-启动与就绪状态-即可运行状态"><a href="#start-启动与就绪状态-即可运行状态" class="headerlink" title="start 启动与就绪状态(即可运行状态)"></a>start 启动与就绪状态(即可运行状态)</h2><p>调用<code>Thread.start()</code>方法, 该线程进入Runable(可运行)状态, 等待分配 CPU 资源, 当抢占到CPU资源时,<br>该线程启动,开始执行run方法.</p>
<p><code>Thread.start()</code>是唯一可以新建线程的方法. 执行 Thread.run() 和 Runable.run() 只会执行run方法, 不会启动新的线程.</p>
<p>一旦线程启动, 它就永远不能再重新启动. 只有一个新的线程可以被启动, 并且只能一次. 一个可运行的线程或死线程可以被重新启动.</p>
<p>线程的调度是JVM的一部分, 在一个CPU的机器上, 实际上一次只能运行一个线程. 一次只有一个<strong>线程栈</strong>执行. JVM线程调度程序决定实际运行哪个处于可运行状态的线程. 众多可运行线程中的某一个会被选中作为当前线程. 可运行线程被选择运行的顺序是没有保障的. 尽管通常采用队列形式, 但这是没有保障的. 队列形式是指当一个线程完成“一轮”时, 它移到可运行队列的尾部等待, 直到它最终排队到该队列的前端为止, 它才能被再次选中. 事实上, 我们把它称为<em>可运行池</em>而不是一个可运行队列, 目的是帮助认识线程并<em>不都是</em>以某种有保障的顺序排列成一个队列的事实.</p>
<h2 id="Running-运行"><a href="#Running-运行" class="headerlink" title="Running 运行"></a>Running 运行</h2><p>运行状态, 执行<code>run()</code>方法的内容.</p>
<p>当 Java 虚拟机继续执行线程, 直到下面任一情况出现为止:</p>
<ul>
<li>调用 Runtime的 exit 方法 <code>System.exit()</code></li>
<li>非守护线程全部停止运行, 无论是从 <code>run</code> 方法返回还是通过抛出一个传播到 <code>run</code> 方法之外的异常.</li>
</ul>
<p>几种特殊情况可能使线程离开运行状态：</p>
<ol>
<li>线程的<code>run()</code>方法完成.</li>
<li>在对象上调用<code>wait()</code>方法（不是在线程上调用）.</li>
<li>线程不能在对象上获得锁定, 它正试图运行该对象的方法代码.</li>
<li>线程调度程序可以决定将当前运行状态移动到可运行状态, 以便让另一个线程获得运行机会, 而不需要任何理由.</li>
</ol>
<h2 id="sleep-休眠"><a href="#sleep-休眠" class="headerlink" title="sleep() 休眠"></a>sleep() 休眠</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  Thread.sleep();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原始定义</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
<p>调用 Thread 的静态方法可以进入休眠, sleep()作用：</p>
<ul>
<li>执行带锁的代码时, 不会释放锁</li>
<li>进入Blocked状态</li>
<li>线程在mills时间内不会醒来</li>
<li>mills时间到了, 线程变为<code>Runnable</code>状态</li>
<li>再次进入运行状态, 继续执行 sleep() 后面的代码</li>
</ul>
<p><code>Thread.sleep(long millis)</code>和<code>Thread.sleep(long millis, int nanos)</code>静态方法强制当前正在执行的线程休眠（暂停执行）, 以“减慢线程”.<br>当线程睡眠时, 它入睡在某个地方, 在苏醒之前不会返回到可运行状态. 当睡眠时间到期, 则返回到可运行状态.<br>线程睡眠的原因：线程执行太快, 或者需要强制进入下一轮, 因为Java规范不保证合理的轮换.</p>
<p>当休眠一定时间后, 线程会苏醒, 进入准备状态等待执行.</p>
<h2 id="Blocked-阻塞状态"><a href="#Blocked-阻塞状态" class="headerlink" title="Blocked 阻塞状态"></a>Blocked 阻塞状态</h2><p>阻塞状态是线程因为某种原因放弃CPU使用权, 暂时停止运行. 直到线程进入就绪状态, 才有机会转到运行状态. 阻塞的情况分三种：</p>
<ul>
<li>等待阻塞：运行的线程执行<code>wait()</code>方法, JVM会把该线程放入等待池中.</li>
<li>同步阻塞：运行的线程在获取对象的同步锁时, 若该同步锁被别的线程占用, 则JVM会把该线程放入锁池中.</li>
<li>其他阻塞：运行的线程执行<code>sleep()</code>或<code>join()</code>方法, 或者发出了<code>I/O</code>请求时, JVM会把该线程置为阻塞状态.<pre><code> 当`sleep()`状态超时、`join()`等待线程终止或者超时、或者`I/O`处理完毕时, 线程重新转入就绪状态.</code></pre>
</li>
</ul>
<h2 id="Synchronized锁与同步"><a href="#Synchronized锁与同步" class="headerlink" title="Synchronized锁与同步"></a>Synchronized锁与同步</h2><p><a href="/Java/multithread/01.1.monitor-synchronized/">monitor与synchronized</a></p>
<p>在 Java 中每个对象都有一个锁,(问题来了: Java对象锁信息保存在哪里?) 并且对象的锁同时只能被一个线程使用, 因此当某个线程得到对象的锁时, 其他线程也就没办法获得锁.<br>利用对象的锁, 可以实现只允许一个线程访问, 即同步.</p>
<p>当线程运行到 <code>synchronized</code> 时, 首先检测是否可以获得对象的锁, 如果可以获得,则马上获取锁. 如果不能获取锁, 线程阻塞, 开始等待其他线程释放锁.</p>
<p>当同步锁被释放时, 线程重新进入 Runnable 可运行状态.</p>
<p>需要同步时,一定要搞清楚<code>加锁的对象是什么</code></p>
<p>关于锁和同步, 有一下几个要点：</p>
<ul>
<li>只能同步方法, 而不能同步变量和类；</li>
<li>每个对象只有一个锁；当提到同步时, 应该清楚在什么上同步？也就是说, 在哪个对象上同步？</li>
<li>不必同步类中所有的方法, 类可以同时拥有同步和非同步方法.</li>
<li>线程睡眠(执行<code>sleep</code>)时, 它所持的任何锁都不会释放.</li>
<li>线程可以获得多个锁. 比如, 在一个对象的同步方法里面调用另外一个对象的同步方法, 则获取了两个对象的同步锁.</li>
</ul>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>在方法名称前面增加 <code>synchronized</code> 关键字, 此时相当于以类的对象(即<code>this</code>)作为对象锁.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object1)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 <code>object1</code>作为对象锁</p>
<h3 id="同步静态方法"><a href="#同步静态方法" class="headerlink" title="同步静态方法"></a>同步静态方法</h3><ol>
<li><p>静态方法同步是以方法所在的class对象作为锁的.<br> 要同步静态方法, 需要一个用于整个类对象的锁, 这个对象是就是这个类（XXX.class).<br> 例如：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    Xxx.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Xxx.class)&#123;</span><br><span class="line">            Xxx.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 实质上, 线程进入该对象的的一种池中, 必须在那里等待, 直到其锁被释放</p>
</li>
<li><p>调用同一个类中的静态同步方法的线程将彼此阻塞, 它们都是锁定在相同的Class对象上.</p>
</li>
<li><p>静态同步方法和非静态同步方法将永远不会彼此阻塞, 因为静态方法锁定在Class对象上, 非静态方法锁定在该类的对象上.<br>对于非静态字段中可更改的数据, 通常使用非静态方法访问.<br>对于静态字段中可更改的数据, 通常使用静态方法访问.</p>
</li>
</ol>
<p><strong>减少锁定时间</strong></p>
<p>线程同步的目的是为了保护多个线程访问一个资源时对资源的破坏. 线程同步方法是通过锁来实现, 每个对象都有且仅有一个锁, 这个锁与一个特定的对象关联, 线程一旦获取了对象锁, 其他访问该对象的线程就无法再访问该对象的其他同步方法.</p>
<p><strong>synchronized中慎用sleep和yield</strong></p>
<p>在使用<code>synchronized</code>关键字时候, 应该尽可能避免在<code>synchronized</code>方法或<code>synchronized块</code>中使用<code>sleep</code>或者<code>yield</code>方法:<br>因为<code>synchronized</code>程序块占有着对象锁, 你休息那么其他的线程只能一边等着你醒来执行完了才能执行. 不但严重影响效率, 也不合逻辑. 同样, 在同步程序块内调用<code>yield</code>方法让出CPU资源也没有意义, 因为你占用着锁, 其他互斥线程还是无法访问同步程序块. 当然与同步程序块无关的线程可以获得更多的执行时间.</p>
<h2 id="wait-等待-与-notify-notifyAll-通知"><a href="#wait-等待-与-notify-notifyAll-通知" class="headerlink" title="wait 等待 与 notify/notifyAll 通知"></a><code>wait</code> 等待 与 <code>notify</code>/<code>notifyAll</code> 通知</h2><p><code>wait</code> 让本线程等待, <code>notify</code> 通知某个线程不再等待</p>
<p><code>wait()</code>作用主要有:</p>
<ul>
<li>释放锁</li>
<li>不继续执行 wait 后面的代码</li>
<li>本线程进入等待阻塞</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1038007/why-should-wait-always-be-called-inside-a-loop">wait必须与while一起使用:(避免假唤醒)</a></p>
<blockquote>
<p>A thread can also wake up without being notified, interrupted, or timing out, a so-called spurious wakeup. While this will rarely occur in practice, applications must guard against it by testing for the condition that should have caused the thread to be awakened, and continuing to wait if the condition is not satisfied. In other words, waits should always occur in loops, like this one:<br>线程也可以在没有被通知，中断或超时的情况下唤醒，即所谓的虚假唤醒。 虽然这在实践中很少发生，但应用程序必须通过测试应该导致线程被唤醒的条件来防范它，并且如果条件不满足则继续等待。 换句话说，等待应该总是出现在循环中</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!condition) &#123;</span><br><span class="line">     obj.wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>notify</code>()与 <code>notifyAll</code>()<br>针对同一个对象锁上的线程, 主要的作用是:</p>
<ul>
<li>不再等待, 从等待 Blocked 中转出</li>
<li>进入 Runnable 状态, 等待获取 CPU 资源. ??</li>
</ul>
<p><strong>线程唤醒 notify</strong></p>
<p>Object类中的<code>notify()</code>方法, 唤醒在此对象监视器上等待的单个线程. 如果所有线程都在此对象上等待, 则会选择唤醒其中一个线程. 选择是任意性的, 并在对实现做出决定时发生. 线程通过调用其中一个 <code>wait</code> 方法, 在对象的监视器上等待.  直到当前的线程放弃此对象上的锁定, 才能继续执行被唤醒的线程. 被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如, 唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势. 类似的方法还有一个<code>notifyAll()</code>, 唤醒在此对象监视器上等待的所有线程.</p>
<p><code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>都是Object的实例方法. 与每个对象具有锁一样, 每个对象可以有一个<code>线程列表</code>, 他们等待来自该信号（通知）. 线程通过执行对象上的wait()方法获得这个等待列表.</p>
<p>这3个方法<strong>必须处于synchronized代码块或者synchronized方法中</strong>，否则就会抛出IllegalMonitorStateException异常，这是因为这几个方法必须拿到当前对象的监视器monitor对象，也就是说notify/notifyAll和wait方法依赖于monitor对象，</p>
<p><strong>千万注意</strong></p>
<p>当在对象上调用<code>wait()</code>方法时, 执行该代码的线程立即<code>放弃</code>它在对象上的锁. 然而调用<code>notify()</code>时, 并不意味着这时线程会放弃其锁. 如果线程仍然在完成同步代码, 则线程在移出之前不会放弃锁. 因此, 只要调用notify()并不意味着这时该锁变得可用.</p>
<p><code>notifyAll()</code> 方法, 起到的是一个通知作用,<strong>不释放锁, 也不获取锁.</strong> 只是告诉该对象上等待的线程“可以竞争执行了, 都醒来去执行吧”</p>
<h2 id="yield-让步"><a href="#yield-让步" class="headerlink" title="yield() 让步"></a>yield() 让步</h2><ul>
<li>当前线程让出, 进入<code>Runnable可执行状态</code></li>
<li>但是<strong>继续占着锁</strong></li>
<li>同级别或较高级别的开始竞争 CPU 资源</li>
</ul>
<p>Thread.yield()方法作用是：暂停当前正在执行的线程对象, 并执行其他线程.<br>yield()应该做的是让当前运行线程回到可运行状态, 以允许具有相同优先级的其他线程获得运行机会.</p>
<p>yield()从未导致线程转到等待/睡眠/阻塞状态. 在大多数情况下, yield()将导致线程从运行状态转到可运行状态, 但有可能没有效果.</p>
<p>// TODO 使用场景</p>
<h2 id="join-合并"><a href="#join-合并" class="headerlink" title="join() 合并"></a>join() 合并</h2><p>假设在 A 线程中,执行<code>B.join()</code> , B 线程放到 A 线程前面执行. A 线程转入阻塞状态首先执行 B 线程,<br>直到执行完 B 线程后, A 线程转入可运行状态就绪, 获取到 CPU 资源后再继续执行 join 后面的代码</p>
<p>还有 join() 的重载形式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B.join(<span class="number">1000</span>);  </span><br></pre></td></tr></table></figure>
<p>首先执行 B 1000毫秒, 1000毫秒后, 即使是没有执行完, 也会停止执行 B 线程, 开始执行join 语句后面的代码</p>
<p>请看join的原始定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Waits at most &#123;<span class="doctag">@code</span> millis&#125; milliseconds for this thread to</span></span><br><span class="line"><span class="comment">* die. A timeout of &#123;<span class="doctag">@code</span> 0&#125; means to wait forever.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt; This implementation uses a loop of &#123;<span class="doctag">@code</span> this.wait&#125; calls</span></span><br><span class="line"><span class="comment">* conditioned on &#123;<span class="doctag">@code</span> this.isAlive&#125;. As a thread terminates the</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> this.notifyAll&#125; method is invoked. It is recommended that</span></span><br><span class="line"><span class="comment">* applications not use &#123;<span class="doctag">@code</span> wait&#125;, &#123;<span class="doctag">@code</span> notify&#125;, or</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> notifyAll&#125; on &#123;<span class="doctag">@code</span> Thread&#125; instances.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment">*         the time to wait in milliseconds</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">*          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment">*          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment">*          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment">*          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实Join 方法实现是通过wait实现的.<br>当main 线程调用t.join 时候, main 线程会获得线程对象t 的锁 （wait 意味着拿到该对象的锁), 调用该对象的wait( 等待时间) ,直到该对象唤醒main 线程, 比如退出后.</p>
<h2 id="stop-停止"><a href="#stop-停止" class="headerlink" title="stop 停止"></a>stop 停止</h2><p>避免使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。</p>
<h2 id="suspend-暂停"><a href="#suspend-暂停" class="headerlink" title="suspend 暂停"></a>suspend 暂停</h2><p>suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。</p>
<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        返回对当前正在执行的线程对象的引用.</span></span><br><span class="line"><span class="function">ClassLoader <span class="title">getContextClassLoader</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        返回该线程的上下文 ClassLoader.</span></span><br><span class="line"><span class="function">Thread.State <span class="title">getState</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        返回该线程的状态.</span></span><br><span class="line"><span class="function">ThreadGroup <span class="title">getThreadGroup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        返回该线程所属的线程组.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">holdsLock</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">        当且仅当当前线程在指定的对象上保持监视器锁时, 才返回 <span class="keyword">true</span>.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultUncaughtExceptionHandler</span><span class="params">(Thread.UncaughtExceptionHandler eh)</span></span></span><br><span class="line"><span class="function">          设置当线程”由于未捕获到异常而突然终止, 并且没有为该线程定义其他处理程序时”所调用的默认处理程序.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        已过时.</span></span><br><span class="line"><span class="function">        stop 的许多使用都应由只修改某些变量以指示目标线程应该停止运行的代码来取代.</span></span><br><span class="line"><span class="function">        目标线程应定期检查该变量, 并且如果该变量指示它要停止运行,  则从其运行方法依次返回.</span></span><br><span class="line"><span class="function">        如果目标线程等待很长时间（例如基于一个条件变量）,  则应使用 interrupt 方法来中断该等待.</span></span><br></pre></td></tr></table></figure>
<h3 id="线程中断与synchronized"><a href="#线程中断与synchronized" class="headerlink" title="线程中断与synchronized"></a>线程中断与synchronized</h3><p>线程中断</p>
<p>正如中断二字所表达的意义，在线程运行(run方法)中间打断它，在Java中，提供了以下3个有关线程中断的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中断线程（实例方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Thread.interrupt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断线程是否被中断（实例方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> Thread.isInterrupted();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否被中断并清除当前中断状态（静态方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> Thread.interrupted();</span><br></pre></td></tr></table></figure>
<p>当一个线程处于被阻塞状态或者试图执行一个阻塞操作时，使用Thread.interrupt()方式中断该线程，注意此时将会抛出一个InterruptedException的异常，同时中断状态将会被复位(由中断状态改为非中断状态)，如下代码将演示该过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptSleepThread3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//while在try中，通过异常中断就可以退出run循环</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="comment">//当前线程处于阻塞状态，异常必须捕捉处理，无法往外抛出</span></span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Interruted When Sleep&quot;</span>);</span><br><span class="line">                    <span class="keyword">boolean</span> interrupt = <span class="keyword">this</span>.isInterrupted();</span><br><span class="line">                    <span class="comment">//中断状态被复位</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;interrupt:&quot;</span>+interrupt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//中断处于阻塞状态的线程</span></span><br><span class="line">        t1.interrupt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出结果:</span></span><br><span class="line"><span class="comment">           Interruted When Sleep</span></span><br><span class="line"><span class="comment">           interrupt:false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码所示，我们创建一个线程，并在线程中调用了sleep方法从而使线程进入阻塞状态，启动线程后，调用线程实例对象的interrupt方法中断阻塞异常，并抛出InterruptedException异常，此时中断状态也将被复位。除了阻塞中断的情景，我们还可能会遇到处于运行期且非阻塞的状态的线程，这种情况下，直接调用Thread.interrupt()中断线程是不会得到任响应的，如下代码，将无法中断非阻塞状态下的线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruputThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;未被中断&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出结果(无限执行):</span></span><br><span class="line"><span class="comment">             未被中断</span></span><br><span class="line"><span class="comment">             未被中断</span></span><br><span class="line"><span class="comment">             未被中断</span></span><br><span class="line"><span class="comment">             ......</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然我们调用了interrupt方法，但线程t1并未被中断，因为<strong>处于非阻塞状态的线程需要我们手动进行中断检测并结束程序</strong>，改进后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruputThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="comment">//判断当前线程是否被中断</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.isInterrupted())&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程中断&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;已跳出循环,线程中断!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出结果:</span></span><br><span class="line"><span class="comment">            线程中断</span></span><br><span class="line"><span class="comment">            已跳出循环,线程中断!</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一种是当线程处于阻塞状态或者试图执行一个阻塞操作时，我们可以使用实例方法interrupt()进行线程中断，执行中断操作后将会抛出interruptException异常(该异常必须捕捉无法向外抛出)并将中断状态复位，</li>
<li>另外一种是当线程处于运行状态时，我们也可调用实例方法interrupt()进行线程中断，但同时必须手动判断中断状态，并编写中断线程的代码(其实就是结束run方法体的代码)。有时我们在编码时可能需要兼顾以上两种情况，那么就可以如下编写：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//判断当前线程是否已中断,注意interrupted方法是静态的,执行后会对中断状态进行复位</span></span><br><span class="line">    <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上线程的中断操作对于正在等待获取的锁对象的synchronized方法或者代码块并不起作用，也就是对于synchronized来说，<strong>如果一个线程在等待锁，那么结果只有两种，要么它获得这把锁继续执行，要么它就保存等待，即使调用中断线程的方法，也不会生效</strong>。演示代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Created by zejian on 2017/6/2.</span></span><br><span class="line"><span class="comment">* Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedBlocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Trying to call f()&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123; <span class="comment">// Never releases lock</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在构造器中创建新线程并启动获取对象锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SynchronizedBlocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//该线程已持有当前实例锁</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                f(); <span class="comment">// Lock acquired by this thread</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//中断判断</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;中断线程!!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronizedBlocked sync = <span class="keyword">new</span> SynchronizedBlocked();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(sync);</span><br><span class="line">        <span class="comment">//启动后调用f()方法,无法获取当前实例锁处于等待状态</span></span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//中断线程,无法生效</span></span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在<code>SynchronizedBlocked</code>构造函数中创建一个新线程并启动获取调用f()获取到当前实例锁，由于<code>SynchronizedBlocked</code>自身也是线程，启动后在其run方法中也调用了f()，但由于对象锁被其他线程占用，导致t线程只能等到锁，此时我们调用了<code>t.interrupt();</code>但并不能中断线程。</p>
<h1 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h1><p>线程A当前持有互斥所锁 lock1 ，线程B当前持有互斥锁 lock2 。 接下来，当线程A仍然持有lock1时，它试图获取lock2，因为线程B正持有lock2，因此线程A会阻塞等待线程B对lock2的释放。如果此时线程B在持有lock2的时候，也在试图获取lock1，因为线程A正持有lock1，因此线程B会阻塞等待A对lock1的释放。二者都在等待对方所持有锁的释放，而二者却又都没释放自己所持有的锁，这时二者便会一直阻塞下去。这种情形称为死锁。</p>
<p>规避死锁：</p>
<ol>
<li>只在必要的最短时间内持有锁，考虑使用同步语句块代替整个同步方法；</li>
<li>尽量编写不在同一时刻需要持有多个锁的代码，如果不可避免，则确保线程持有第二个锁的时间尽量短暂；</li>
<li>创建和使用一个大锁来代替若干小锁，并把这个锁用于互斥，而不是用作单个对象的对象级别锁；</li>
</ol>
<h1 id="同步方案"><a href="#同步方案" class="headerlink" title="同步方案"></a>同步方案</h1><p>在需要同步的时候，第一选择应该是synchronized关键字，这是最安全的方式，尝试其他任何方式都是有风险的。尤其在jdK1.5之后，对synchronized同步机制做了很多优化，如：自适应的自旋锁、锁粗化、锁消除、轻量级锁等，使得它的性能明显有了很大的提升。</p>
<p>[volatile][a-volatile] 也是确保可见性的方法之一，但是不能实现原子性</p>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>如果同一个方法内同时有两个或更多线程，则每个线程有自己的局部变量拷贝， 采用 <code>synchronized</code> 修饰符实现的同步机制叫做互斥锁机制，它所获得的锁叫做互斥锁。 每个对象都有一个monitor(锁标记)，当线程拥有这个锁标记时才能访问这个资源，没有锁标记便进入锁池。 任何一个对象系统都会为其创建一个互斥锁，这个锁是为了分配给线程的，防止打断原子操作。每个对象的锁只能分配给一个线程，因此叫做互斥锁。</p>
<p>互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。synchronized 关键字经过编译后，会在同步块的前后分别形成 <code>monitorenter</code> 和 <code>monitorexit</code> <code>这两个字节码指令。根据虚拟机规范的要求，在执行monitorenter</code> 指令时，首先要尝试获取对象的锁，如果获得了锁，把锁的计数器加1，相应地，在执行 <code>monitorexit</code> 指令时会将锁计数器减1，当计数器为0时，锁便被释放了。由于synchronized同步块对同一个线程是可重入的，因此一个线程可以多次获得同一个对象的互斥锁，同样，要释放相应次数的该互斥锁，才能最终释放掉该锁。</p>
<p>当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法? 分几种情况：</p>
<ol>
<li>其他方法前是否加了synchronized关键字，如果没加，则能。</li>
<li>如果这个方法内部调用了wait，则可以进入其他synchronized方法。</li>
<li>如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。</li>
<li>如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。</li>
</ol>
<h1 id="线程安全类"><a href="#线程安全类" class="headerlink" title="线程安全类"></a>线程安全类</h1><p>请查看 <a href="/Java/collection-map/">Java集合</a></p>
<h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>线程总体分两类：用户线程和守候线程.</p>
<p>当所有用户线程执行完毕的时候, JVM自动关闭. 但是守候线程却不独立于JVM, 守候线程一般是由操作系统或者用户自己创建的.</p>
<p>举例来说, JVM的垃圾回收、内存管理等线程都是守护线程.<br>还有就是在做数据库应用时候, 使用的数据库连接池, 连接池本身也包含着很多后台线程, 监控连接个数、超时时间、状态等等.</p>
<h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><p>有一个后台运行的线程,  按照指定的时间执行定时任务. <code>Timer.schedual()</code>方法向后台线程添加定时任务,<br>后台线程按照的既定的时间执行定时任务.</p>
<p>调用<code>Timer.cancel()</code>取消所有已安排的定时任务,  正在的执行的任务不会被取消.</p>
<p>调用构造方法, 后台线程就已经启动.</p>
<hr>
<p>[参考文献]：</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/Thread/" rel="tag"># Thread</a>
              <a href="/tags/Multi-thread/" rel="tag"># Multi-thread</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Java/multithread/32.multithreadWaitedSample02/" rel="prev" title="Java多线程等待的N种打开方式(2)">
      <i class="fa fa-chevron-left"></i> Java多线程等待的N种打开方式(2)
    </a></div>
      <div class="post-nav-item">
    <a href="/bigdata/hive/base/" rel="next" title="Hive base">
      Hive base <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.1.</span> <span class="nav-text">程序、进程、线程之间的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">Java 进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.3.</span> <span class="nav-text">主线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.4.</span> <span class="nav-text">线程优先级</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.</span> <span class="nav-text">线程的生命周期</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.</span> <span class="nav-text">线程的状态与转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#new%E4%B8%8E%E6%96%B0%E5%BB%BA%E7%8A%B6%E6%80%81"><span class="nav-number">3.1.</span> <span class="nav-text">new与新建状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#start-%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81-%E5%8D%B3%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81"><span class="nav-number">3.2.</span> <span class="nav-text">start 启动与就绪状态(即可运行状态)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Running-%E8%BF%90%E8%A1%8C"><span class="nav-number">3.3.</span> <span class="nav-text">Running 运行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep-%E4%BC%91%E7%9C%A0"><span class="nav-number">3.4.</span> <span class="nav-text">sleep() 休眠</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Blocked-%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81"><span class="nav-number">3.5.</span> <span class="nav-text">Blocked 阻塞状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronized%E9%94%81%E4%B8%8E%E5%90%8C%E6%AD%A5"><span class="nav-number">3.6.</span> <span class="nav-text">Synchronized锁与同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-number">3.6.1.</span> <span class="nav-text">同步方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">3.6.2.</span> <span class="nav-text">同步代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-number">3.6.3.</span> <span class="nav-text">同步静态方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait-%E7%AD%89%E5%BE%85-%E4%B8%8E-notify-notifyAll-%E9%80%9A%E7%9F%A5"><span class="nav-number">3.7.</span> <span class="nav-text">wait 等待 与 notify&#x2F;notifyAll 通知</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#yield-%E8%AE%A9%E6%AD%A5"><span class="nav-number">3.8.</span> <span class="nav-text">yield() 让步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#join-%E5%90%88%E5%B9%B6"><span class="nav-number">3.9.</span> <span class="nav-text">join() 合并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stop-%E5%81%9C%E6%AD%A2"><span class="nav-number">3.10.</span> <span class="nav-text">stop 停止</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#suspend-%E6%9A%82%E5%81%9C"><span class="nav-number">3.11.</span> <span class="nav-text">suspend 暂停</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread"><span class="nav-number">3.12.</span> <span class="nav-text">Thread</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E4%B8%8Esynchronized"><span class="nav-number">3.12.1.</span> <span class="nav-text">线程中断与synchronized</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="nav-number">4.</span> <span class="nav-text">线程死锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88"><span class="nav-number">5.</span> <span class="nav-text">同步方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">5.1.</span> <span class="nav-text">互斥锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB"><span class="nav-number">6.</span> <span class="nav-text">线程安全类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text">守护线程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Timer"><span class="nav-number">8.</span> <span class="nav-text">Timer</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">aaronzhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">235</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">126</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aaronzhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
