<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="CMS GC垃圾回收器组合   Young 年轻代 Tenured 老生代 JVM options 备注    Serial Serial -XX:+UseSerialGC 单线程回收，全程STW   Parallel Scavenge Serial -XX:+UseParallelGC -XX:-UseParallelOldGC 年轻代并行，老年代串行，全程STW   Parallel Scav">
<meta property="og:type" content="article">
<meta property="og:title" content="CMS GC">
<meta property="og:url" content="http://example.com/Java/metric/02_CMS_GC/index.html">
<meta property="og:site_name" content="Guadazi">
<meta property="og:description" content="CMS GC垃圾回收器组合   Young 年轻代 Tenured 老生代 JVM options 备注    Serial Serial -XX:+UseSerialGC 单线程回收，全程STW   Parallel Scavenge Serial -XX:+UseParallelGC -XX:-UseParallelOldGC 年轻代并行，老年代串行，全程STW   Parallel Scav">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/Java/metric/02_CMS_GC/_v_images/20200716125314502_95470953.png">
<meta property="og:image" content="http://example.com/Java/metric/02_CMS_GC/_v_images/20200208214054081_1122407096.png">
<meta property="og:image" content="http://example.com/Java/metric/02_CMS_GC/_v_images/20200208214053938_762753439.png">
<meta property="og:image" content="http://example.com/Java/metric/02_CMS_GC/_v_images/20200208214053815_1244593749.png">
<meta property="og:image" content="http://example.com/Java/metric/02_CMS_GC/_v_images/20200208214053691_1851185723.png">
<meta property="og:image" content="http://example.com/Java/metric/02_CMS_GC/_v_images/20200208214053551_1708409185.png">
<meta property="og:image" content="http://example.com/Java/metric/02_CMS_GC/_v_images/20200209233712414_1450669107.png">
<meta property="article:published_time" content="2019-08-10T06:58:00.000Z">
<meta property="article:modified_time" content="2021-02-08T09:49:15.772Z">
<meta property="article:author" content="aaronzhang">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Metric">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/Java/metric/02_CMS_GC/_v_images/20200716125314502_95470953.png">

<link rel="canonical" href="http://example.com/Java/metric/02_CMS_GC/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>CMS GC | Guadazi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Guadazi</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/metric/02_CMS_GC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CMS GC
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-08-10 14:58:00" itemprop="dateCreated datePublished" datetime="2019-08-10T14:58:00+08:00">2019-08-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-08 17:49:15" itemprop="dateModified" datetime="2021-02-08T17:49:15+08:00">2021-02-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="CMS-GC"><a href="#CMS-GC" class="headerlink" title="CMS GC"></a>CMS GC</h1><h2 id="垃圾回收器组合"><a href="#垃圾回收器组合" class="headerlink" title="垃圾回收器组合"></a>垃圾回收器组合</h2><table>
<thead>
<tr>
<th>Young 年轻代</th>
<th>Tenured 老生代</th>
<th>JVM options</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>Serial</td>
<td>-XX:+UseSerialGC</td>
<td>单线程回收，全程STW</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>Serial</td>
<td>-XX:+UseParallelGC -XX:-UseParallelOldGC</td>
<td>年轻代并行，老年代串行，全程STW</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>Parallel Old</td>
<td>-XX:+UseParallelGC -XX:+UseParallelOldGC</td>
<td>多线程回收，全程STW</td>
</tr>
<tr>
<td>Parallel New或Serial</td>
<td>CMS</td>
<td>-XX:+UseParNewGC -XX:+UseConcMarkSweepGC</td>
<td>年轻代并行或串行，老年代并发，只有某个阶段会STW</td>
</tr>
<tr>
<td>G1</td>
<td>G1</td>
<td>-XX:+UseG1GC</td>
<td>并发回收， 某个阶段会STW</td>
</tr>
</tbody></table>
<p>垃圾回收器从线程运行情况分类有三种：</p>
<ul>
<li><code>串行回收</code>： Serial回收器，单线程回收，全程STW；</li>
<li><code>并行回收</code>： 名称以Parallel开头的回收器，多线程回收，全程STW;</li>
<li><code>并发回收</code>： CMS与G1，多线程分阶段回收，只有某阶段会STW；</li>
</ul>
<p><img src="_v_images/20200716125314502_95470953.png"></p>
<h2 id="Minor-GC、Major-GC与Full-GC"><a href="#Minor-GC、Major-GC与Full-GC" class="headerlink" title="Minor GC、Major GC与Full GC"></a>Minor GC、Major GC与Full GC</h2><p>分代回收中:</p>
<p>Minor GC清理年轻代(Young GC)，除了G1 GC外，都会STW<br>Major GC清理老年代(Tenured GC)<br>Full GC清理整个堆</p>
<p>Minor GC触发条件:</p>
<p>Major GC触发条件:</p>
<p>Full GC触发条件:</p>
<ul>
<li>调用<code>System.gc</code>时，系统建议执行Full GC，不是必然执行</li>
<li>老年代空间不足</li>
<li>方法区空间不足</li>
<li>通过Minor GC后，进入老年代的平均大小 &gt; 老年代的可用内存</li>
<li>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。即老年代无法存放新年代过度到老年代的对象的时候，会触发Full GC</li>
<li>手动触发Full GC: jmap -histo:live <pid> 或者 jmap -dump:live,file=dump_001.bin PID,然后删掉dump_001.bin文件</li>
</ul>
<h2 id="CMS垃圾收集器-Concurrent-Mark-Sweep-CMS-Collector"><a href="#CMS垃圾收集器-Concurrent-Mark-Sweep-CMS-Collector" class="headerlink" title="CMS垃圾收集器 Concurrent Mark Sweep(CMS) Collector"></a>CMS垃圾收集器 Concurrent Mark Sweep(CMS) Collector</h2><p>并发，低停顿<br>特别是拥有大量长期数据（大老年代），多核心，低停顿</p>
<p>启用<code>-XX:+UseConcMarkSweepGC</code></p>
<p>CMS收集器是分代的。 因此，minor GC和major GC都会发生。 CMS收集器尝试通过使用单独的垃圾收集器线程在执行应用程序线程的同时跟踪可访问对象，来减少由于major GC而导致的暂停时间。 在每个major收集周期中，CMS收集器会在收集开始时暂停所有应用程序线程一小段时间，然后收集中间再暂停一次。 第二次停顿往往是两个停顿中较长的一个。 在两个暂停期间都使用多个线程来执行收集工作。 收集的其余部分（包括大部分活动对象的跟踪和无法访问对象的清除）是通过与应用程序同时运行的一个或多个垃圾收集器线程来完成的。minor GC可以与正在进行的主要周期交错，并在一个 类似于并行收集器的方式（特别是在次要收集期间停止了应用程序线程）。</p>
<p><strong>并发模式失效Concurrent Mode Failure</strong></p>
<ol>
<li>如果CMS收集器在老年代填满之前无法完成回收无法访问的对象，</li>
<li>如果老年代的可用空闲空间块(出现了碎片)无法满足分配，则暂停应用程序，并使所有应用程序线程已停止。 无法同时完成收集的情况称为并发模式失败，代表需要调整CMS收集器参数。</li>
<li>如果并发收集被显式垃圾收集（<code>System.gc()</code>）中断</li>
<li>为提供诊断工具信息所需的垃圾收集中断了，则将报告并发模式中断。</li>
</ol>
<blockquote>
<p>if the CMS collector is unable to finish reclaiming the unreachable objects before the tenured generation fills up, or if an allocation cannot be satisfied with the available free space blocks in the tenured generation, then the application is paused and the collection is completed with all the application threads stopped. The inability to complete a collection concurrently is referred to as concurrent mode failure and indicates the need to adjust the CMS collector parameters. If a concurrent collection is interrupted by an explicit garbage collection (System.gc()) or for a garbage collection needed to provide information for diagnostic tools, then a concurrent mode interruption is reported.</p>
</blockquote>
<p><strong>Excessive GC Time and OutOfMemoryError</strong></p>
<p>太多的时间花在gc上: 如果总时间的98%花在GC上，并且回收不到2%的堆空间，将抛出<code>OutOfMemoryError</code></p>
<p>禁用命令行: <code>-XX:-UseGCOverheadLimit</code></p>
<p><strong>浮动垃圾Floating Garbage</strong></p>
<p>边收集边运行，出现浮动垃圾</p>
<h2 id="CMS垃圾回收特点"><a href="#CMS垃圾回收特点" class="headerlink" title="CMS垃圾回收特点"></a>CMS垃圾回收特点</h2><p>CMS只会回收老年代和永久代（1.8开始为元数据区，需要设置CMSClassUnloadingEnabled），不会收集年轻代；</p>
<p>CMS是一种预处理垃圾回收器，它不能等到老年代内存用尽时回收，需要在内存用尽前，完成回收操作，否则会导致并发回收失败(并发回收降级)；<br>所以CMS垃圾回收器开始执行回收操作，有一个触发阈值(<code>参数名称</code>)，默认是老年代或永久代达到92%；</p>
<h2 id="CMS垃圾收集器步骤"><a href="#CMS垃圾收集器步骤" class="headerlink" title="CMS垃圾收集器步骤"></a>CMS垃圾收集器步骤</h2><p>CMS 处理过程有七个步骤：</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>是否STW</th>
<th>详情</th>
</tr>
</thead>
<tbody><tr>
<td>初始标记(CMS-initial-mark)</td>
<td>会导致STW</td>
<td>标记GCRoot和被年轻代引用的老年代对象</td>
</tr>
<tr>
<td>并发标记(CMS-concurrent-mark)</td>
<td>与用户线程同时运行；</td>
<td>扫描整个老年代，将引用关系变化的对象置为dirty</td>
</tr>
<tr>
<td>预清理（CMS-concurrent-preclean）</td>
<td>与用户线程同时运行；</td>
<td></td>
</tr>
<tr>
<td>可被终止的预清理（CMS-concurrent-abortable-preclean）</td>
<td>与用户线程同时运行；</td>
<td></td>
</tr>
<tr>
<td>重新标记(CMS-remark)</td>
<td>会导致STW</td>
<td></td>
</tr>
<tr>
<td>并发清除(CMS-concurrent-sweep)</td>
<td>与用户线程同时运行；</td>
<td></td>
</tr>
<tr>
<td>并发重置状态等待下次CMS的触发(CMS-concurrent-reset)</td>
<td>与用户线程同时运行；</td>
<td></td>
</tr>
</tbody></table>
<p>CMS运行流程图如下所示：</p>
<p><img src="_v_images/20200208214054081_1122407096.png"></p>
<h3 id="Phase-1-Initial-Mark（初始化标记）"><a href="#Phase-1-Initial-Mark（初始化标记）" class="headerlink" title="Phase 1: Initial Mark（初始化标记）"></a>Phase 1: Initial Mark（初始化标记）</h3><p>这是CMS中两次stop-the-world事件中的一次。这一步的作用是标记存活的对象，有两部分：</p>
<ol>
<li>从GC Roots遍历可直达的老年代对象，下图中1；</li>
<li>遍历被新生代存活对象所引用的老年代对象，如下图节点2、3；</li>
</ol>
<ul>
<li>支持单线程或并发标记</li>
<li>发生STW</li>
</ul>
<p><img src="_v_images/20200208214053938_762753439.png"></p>
<p>在Java语言里，可作为GC Roots对象的包括如下几种：</p>
<ol>
<li>虚拟机栈(栈桢中的本地变量表)中的引用的对象 ；</li>
<li>方法区中的类静态属性引用的对象 ；</li>
<li>方法区中的常量引用的对象 ；</li>
<li>本地方法栈中JNI的引用的对象；</li>
</ol>
<blockquote>
<p>ps：为了加快此阶段处理速度，减少停顿时间:</p>
<ul>
<li>开启并行化初始标记: <code>-XX:+CMSParallelInitialMarkEnabled</code></li>
<li>同时调大并行标记的线程数，线程数不要超过cpu的核数: <code>-XX:ConcGCThreads=4</code></li>
</ul>
</blockquote>
<h3 id="Phase-2-Concurrent-Mark（并发标记）"><a href="#Phase-2-Concurrent-Mark（并发标记）" class="headerlink" title="Phase 2: Concurrent Mark（并发标记）"></a>Phase 2: Concurrent Mark（并发标记）</h3><p>通过遍历第一个阶段（Initial Mark）标记出来的存活对象，继续递归遍历老年代，并标记可直接或间接到达的所有老年代存活对象。</p>
<p>由于应用线程和GC线程是并发执行的，因此可能产生新的对象或对象关系发生变化，例如：</p>
<ul>
<li>新生代的对象晋升到老年代；</li>
<li>直接在老年代分配对象；</li>
<li>老年代对象的引用关系发生变更；</li>
<li>等等。</li>
</ul>
<p>对于这些对象，需要重新标记以防止被遗漏。为了提高重新标记的效率，本阶段只会把发生变化的对象所在的Card标识为Dirty，这样后续就只需要扫描这些Dirty Card的对象，从而避免扫描整个老年代。</p>
<p>并发标记阶段只负责将引用发生改变的Card标记为Dirty状态，不负责处理；</p>
<p>如下图所示，也就是节点1、2、3，最终找到了节点4和5。并不是老年代的所有存活对象都会被标记，因为标记的同时应用程序会改变一些对象的引用等。</p>
<p><img src="_v_images/20200208214053815_1244593749.png"></p>
<p>这个阶段因为是并发的, 容易导致concurrent mode failure</p>
<h3 id="Phase-3-Concurrent-Preclean（并发预清理）"><a href="#Phase-3-Concurrent-Preclean（并发预清理）" class="headerlink" title="Phase 3: Concurrent Preclean（并发预清理）"></a>Phase 3: Concurrent Preclean（并发预清理）</h3><p>在并发预清洗阶段，将会重新扫描前一个阶段标记的Dirty对象，并标记被Dirty对象直接或间接引用的对象，然后清除Card标识。</p>
<p>前一个阶段已经说明，不能标记出老年代全部的存活对象，是因为标记的同时应用程序会改变一些对象引用，这个阶段就是用来处理前一个阶段因为引用关系改变导致没有标记到的存活对象的，它会扫描所有标记为Direty的Card</p>
<p>如下图所示，在并发清理阶段，节点3的引用指向了6；则会把节点3的card标记为Dirty；</p>
<p><img src="_v_images/20200208214053691_1851185723.png"></p>
<p>最后将6标记为存活,如下图所示：</p>
<p><img src="_v_images/20200208214053551_1708409185.png"></p>
<h3 id="Phase-4-Concurrent-Abortable-Preclean（可中止的并发预清理）"><a href="#Phase-4-Concurrent-Abortable-Preclean（可中止的并发预清理）" class="headerlink" title="Phase 4: Concurrent Abortable Preclean（可中止的并发预清理）"></a>Phase 4: Concurrent Abortable Preclean（可中止的并发预清理）</h3><p>本阶段尽可能承担更多的并发预处理工作，从而减轻在Final Remark阶段的stop-the-world。</p>
<p>这个阶段尝试着去承担下一个阶段Final Remark阶段足够多的工作。这个阶段持续的时间依赖好多的因素，由于这个阶段是重复的做相同的事情直到发生abort的条件（比如：重复的次数、多少量的工作、持续的时间等等）之一才会停止。</p>
<p>ps:此阶段最大持续时间为5秒，之所以可以持续5秒，另外一个原因也是为了期待这5秒内能够发生一次ygc，清理年轻代的引用，是的下个阶段的重新标记阶段，扫描年轻代指向老年代的引用的时间减少；</p>
<p>在该阶段，主要循环的做两件事：</p>
<ul>
<li>处理 From 和 To 区的对象，标记可达的老年代对象；</li>
<li>和上一个阶段一样，扫描处理Dirty Card中的对象。</li>
</ul>
<p>具体执行多久，取决于许多因素，满足其中一个条件将会中止运行：</p>
<ul>
<li>执行循环次数达到了阈值；</li>
<li>执行时间达到了阈值；</li>
<li>新生代Eden区的内存使用率达到了阈值。</li>
</ul>
<h3 id="Phase-5-Final-Remark（重新标记）"><a href="#Phase-5-Final-Remark（重新标记）" class="headerlink" title="Phase 5: Final Remark（重新标记）"></a>Phase 5: Final Remark（重新标记）</h3><p>预清理阶段也是并发执行的，并不一定是所有存活对象都会被标记，因为在并发标记的过程中对象及其引用关系还在不断变化中。</p>
<p>因此，需要有一个stop-the-world的阶段来完成最后的标记工作，这就是重新标记阶段（CMS标记阶段的最后一个阶段）。主要目的是重新扫描之前并发处理阶段的所有残留更新对象。</p>
<p>主要工作：</p>
<p>遍历新生代对象，重新标记；（新生代会被分块，多线程扫描）<br>根据GC Roots，重新标记；<br>遍历老年代的Dirty Card，重新标记。这里的Dirty Card，大部分已经在Preclean阶段被处理过了。</p>
<p>这个阶段会导致第二次stop the world，该阶段的任务是完成标记整个年老代的所有的存活对象。</p>
<p>这个阶段，重新标记的内存范围是整个堆，包含young_gen和old_gen。为什么要扫描新生代呢，因为对于老年代中的对象，如果被新生代中的对象引用，那么就会被视为存活对象，即使新生代的对象已经不可达了，也会使用这些不可达的对象当做CMS的“gc root”，来扫描老年代； 因此对于老年代来说，引用了老年代中对象的新生代的对象，也会被老年代视作“GC ROOTS”:<br>当此阶段耗时较长的时候，可以加入参数<code>-XX:+CMSScavengeBeforeRemark</code>，在重新标记之前，先执行一次ygc，回收掉年轻代的对象无用的对象，并将对象放入survivor区或晋升到老年代，这样再进行年轻代扫描时，只需要扫描幸存区的对象即可，一般survivor区非常小，这大大减少了扫描时间</p>
<p>由于之前的预处理阶段是与用户线程并发执行的，这时候可能年轻代的对象对老年代的引用已经发生了很多改变，这个时候，remark阶段要花很多时间处理这些改变，会导致很长stop the word，所以通常CMS尽量运行Final Remark阶段在年轻代是足够干净的时候。</p>
<p>另外，还可以开启并行收集：<code>-XX:+CMSParallelRemarkEnabled</code></p>
<h3 id="Phase-6-Concurrent-Sweep（并发清理"><a href="#Phase-6-Concurrent-Sweep（并发清理" class="headerlink" title="Phase 6: Concurrent Sweep（并发清理"></a>Phase 6: Concurrent Sweep（并发清理</h3><p>并发清理阶段，主要工作是清理所有未被标记的死亡对象，回收被占用的空间。</p>
<p><img src="_v_images/20200209233712414_1450669107.png"></p>
<p>通过以上5个阶段的标记，老年代所有存活的对象已经被标记并且现在要通过Garbage Collector采用清扫的方式回收那些不能用的对象了。</p>
<p>这个阶段主要是清除那些没有标记的对象并且回收空间；</p>
<p>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p>
<h3 id="步骤7-并发重置"><a href="#步骤7-并发重置" class="headerlink" title="步骤7: 并发重置"></a>步骤7: 并发重置</h3><p>并发重置阶段，将清理并恢复在CMS GC过程中的各种状态，重新初始化CMS相关数据结构，为下一个垃圾收集周期做好准备。</p>
<p>这个阶段并发执行，重新设置CMS算法内部的数据结构，准备下一个CMS生命周期的使用。</p>
<h2 id="CMS日志分析"><a href="#CMS日志分析" class="headerlink" title="CMS日志分析"></a>CMS日志分析</h2><p>下面就是该参数设置打印出来的gc信息，一些非关键的信息已经去掉，如时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步 初始标记 这一步会停顿*</span></span><br><span class="line">[GC (CMS Initial Mark) [<span class="number">1</span> CMS-initial-mark: 299570K(307200K)] 323315K(491520K), <span class="number">0.0026208</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line">vmop [threads: total initially_running wait_to_block] [time: spin block sync cleanup vmop] page_trap_count</span><br><span class="line"><span class="number">0.345</span>: CMS_Initial_Mark [ <span class="number">10</span> <span class="number">0</span> <span class="number">1</span> ] [ <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> ] <span class="number">0</span></span><br><span class="line">Total time <span class="keyword">for</span> which application threads were stopped: <span class="number">0.0028494</span> seconds</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二步 并发标记</span></span><br><span class="line">[CMS-concurrent-mark-start]</span><br><span class="line">[CMS-concurrent-mark: <span class="number">0.012</span>/<span class="number">0.012</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs]</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三步 并发预清理</span></span><br><span class="line">[CMS-concurrent-preclean-start]</span><br><span class="line">[CMS-concurrent-preclean: <span class="number">0.001</span>/<span class="number">0.001</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line"></span><br><span class="line"><span class="comment">//第四步 可被终止的并发预清理</span></span><br><span class="line">[CMS-concurrent-abortable-preclean-start]</span><br><span class="line">[CMS-concurrent-abortable-preclean: <span class="number">0.000</span>/<span class="number">0.000</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line"></span><br><span class="line"><span class="comment">//第五步 最终重新标记</span></span><br><span class="line">[GC (CMS Final Remark) [YG occupancy: 72704 K (184320 K)][Rescan (parallel) , 0.0009069 secs][weak refs processing, 0.0000083 secs][class unloading, 0.0002626 secs][scrub symbol table, 0.0003789 secs][scrub string table, 0.0001326 secs][1 CMS-remark: 299570K(307200K)] 372275K(491520K), 0.0017842 secs] [Times: user=0.05 sys=0.00, real=0.00 secs]</span><br><span class="line">vmop [threads: total initially_running wait_to_block] [time: spin block sync cleanup vmop] page_trap_count</span><br><span class="line"><span class="number">0.360</span>: CMS_Final_Remark [ <span class="number">10</span> <span class="number">0</span> <span class="number">1</span> ] [ <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> ] <span class="number">0</span></span><br><span class="line">Total time <span class="keyword">for</span> which application threads were stopped: <span class="number">0.0018800</span> seconds</span><br><span class="line"></span><br><span class="line"><span class="comment">//第六步 并发清理</span></span><br><span class="line">[CMS-concurrent-sweep-start]</span><br><span class="line">[CMS-concurrent-sweep: <span class="number">0.007</span>/<span class="number">0.007</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs]</span><br><span class="line"></span><br><span class="line"><span class="comment">//第七步 并发重置</span></span><br><span class="line">[CMS-concurrent-reset-start]</span><br><span class="line">[CMS-concurrent-reset: <span class="number">0.002</span>/<span class="number">0.002</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br></pre></td></tr></table></figure>
<p>输出GC详情，需要添加 <code>-verbose:gc</code> 和 <code>-XX:+PrintGCDetails</code> 参数</p>
<p><code>CMS-initial-mark</code>标示着并发收集周期的开始<br><code>CMS-concurrent-mark</code>标示着并发标记阶段的结束<br><code>CMS-concurrent-sweep</code>标志着并发清理阶段的结束<br><code>CMS-concurrent-preclean</code>标志着预清理阶段，预清理代表着在准备CMS-remark阶段可以并发处理的工作<br><code>CMS-concurrent-reset</code>是最后阶段，为下一次并发收集做准备</p>
<blockquote>
<p>CMS-initial-mark indicates the start of the concurrent collection cycle,<br>CMS-concurrent-mark indicates the end of the concurrent marking phase,<br>and CMS-concurrent-sweep marks the end of the concurrent sweeping phase.<br>Not discussed previously is the precleaning phase indicated by CMS-concurrent-preclean.<br>Precleaning represents work that can be done concurrently in preparation for the remark phase CMS-remark.<br>The final phase is indicated by CMS-concurrent-reset and is in preparation for the next concurrent collection.</p>
</blockquote>
<h2 id="调优参数与启用参数"><a href="#调优参数与启用参数" class="headerlink" title="调优参数与启用参数"></a>调优参数与启用参数</h2><p>下面抓取一下gc信息，来进行详细分析，首先将jvm中加入以下运行参数：</p>
<ul>
<li>-XX:+PrintCommandLineFlags [0]</li>
<li>-XX:+UseConcMarkSweepGC [1]</li>
<li>-XX:+UseCMSInitiatingOccupancyOnly [2]</li>
<li>-XX:CMSInitiatingOccupancyFraction=80 [3]</li>
<li>-XX:+CMSClassUnloadingEnabled [4]</li>
<li>-XX:+UseParNewGC [5]</li>
<li>-XX:+CMSParallelRemarkEnabled [6]</li>
<li>-XX:+CMSScavengeBeforeRemark [7]</li>
<li>-XX:+UseCMSCompactAtFullCollection [8]</li>
<li>-XX:CMSFullGCsBeforeCompaction=0 [9]</li>
<li>-XX:+CMSConcurrentMTEnabled [10]</li>
<li>-XX:ConcGCThreads=4 [11]</li>
<li>-XX:+ExplicitGCInvokesConcurrent [12]</li>
<li>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses [13]</li>
<li>-XX:+CMSParallelInitialMarkEnabled [14]</li>
<li>-XX:+PrintGCDetails [15]</li>
<li>-XX:+PrintGCCause [16]</li>
<li>-XX:+PrintGCTimeStamps [17]</li>
<li>-XX:+PrintGCDateStamps [18]</li>
<li>-Xloggc:../logs/gc.log [19]</li>
<li>-XX:+HeapDumpOnOutOfMemoryError [20]</li>
<li>-XX:HeapDumpPath=../dump [21]</li>
</ul>
<p>先来介绍下下面几个参数的作用：</p>
<p>[0] 打印出启动参数行</p>
<p>[1] 参数指定使用CMS垃圾回收器；</p>
<p>[2]、[3] 参数指定CMS垃圾回收器在老年代达到80%的时候开始工作，如果不指定那么默认的值为92%；</p>
<p>[4] 开启永久代（jdk1.8以下版本）或元数据区（jdk1.8及其以上版本）收集，如果没有设置这个标志，一旦永久代或元数据区间也会尝试进行垃圾回收，但是收集不会是并行的，而再一次进行Full GC；</p>
<p>[5] 使用CMS时默认这个参数就是打开的，不需要配置，CMS只回收老年代，年轻代只能配合Parallel New或Serial回收器；</p>
<p>[6] 减少Remark阶段暂停的时间，启用并行Remark，如果Remark阶段暂停时间长，可以启用这个参数</p>
<p>[7] 如果Remark阶段暂停时间太长，可以启用这个参数，在Remark执行之前，先做一次ygc。因为这个阶段，年轻代也是CMS的gcroot，CMS会扫描年轻代指向老年代对象的引用，如果年轻代有大量引用需要被扫描，会让Remark阶段耗时增加；</p>
<p>[8]、[9]两个参数是针对CMS垃圾回收器碎片做优化的，CMS是不会移动内存的， 运行时间长了，会产生很多内存碎片， 导致没有一段连续区域可以存放大对象，出现”promotion failed”、”concurrent mode failure”, 导致fullgc，启用UseCMSCompactAtFullCollection 在FULL GC的时候， 对年老代的内存进行压缩。-XX:CMSFullGCsBeforeCompaction=0 则是代表多少次FGC后对老年代做压缩操作，默认值为0，代表每次都压缩, 把对象移动到内存的最左边，可能会影响性能,但是可以消除碎片；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">106.641</span>: [GC <span class="number">106.641</span>: [ParNew (promotion failed): 14784K-&gt;14784K(14784K), <span class="number">0.0370328</span> secs]<span class="number">106.678</span>: [CMS106<span class="number">.715</span>: [CMS-concurrent-mark: <span class="number">0.065</span>/<span class="number">0.103</span> secs] [Times: user=<span class="number">0.17</span> sys=<span class="number">0.00</span>, real=<span class="number">0.11</span> secs]</span><br><span class="line"></span><br><span class="line">(concurrent mode failure): 41568K-&gt;27787K(49152K), <span class="number">0.2128504</span> secs] 52402K-&gt;27787K(63936K), [CMS Perm : 2086K-&gt;2086K(12288K)], <span class="number">0.2499776</span> secs] [Times: user=<span class="number">0.28</span> sys=<span class="number">0.00</span>, real=<span class="number">0.25</span> secs]</span><br></pre></td></tr></table></figure>
<p>[11] 定义并发CMS过程运行时的线程数。比如value=4意味着CMS周期的所有阶段都以4个线程来执行。尽管更多的线程会加快并发CMS过程，但其也会带来额外的同步开销。因此，对于特定的应用程序，应该通过测试来判断增加CMS线程数是否真的能够带来性能的提升。如果未设置这个参数，JVM会根据并行收集器中的-XX:ParallelGCThreads参数的值来计算出默认的并行CMS线程数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ParallelGCThreads = (ncpus &lt;=<span class="number">8</span> ? ncpus : <span class="number">8</span>+(ncpus-<span class="number">8</span>)*<span class="number">5</span>/<span class="number">8</span>) ，ncpus为cpu个数，</span><br><span class="line">ConcGCThreads =(ParallelGCThreads + <span class="number">3</span>)/<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>这个参数一般不要自己设置，使用默认就好，除非发现默认的参数有调整的必要；<br>[12]、[13]开启foreground CMS GC，CMS gc 有两种模式，background和foreground，正常的CMS gc使用background模式，就是我们平时说的CMS gc；当并发收集失败或者调用了System.gc()的时候，就会导致一次full gc，这个fullgc是不是CMS回收，而是Serial单线程回收器，加入了参数[12]后，执行full gc的时候，就变成了CMS foreground gc，它是并行full gc，只会执行CMS中stop the world阶段的操作，效率比单线程Serial full GC要高；需要注意的是它只会回收old，因为CMS收集器是老年代收集器；而正常的Serial收集是包含整个堆的，加入了参数[13],代表永久代也会被CMS收集；</p>
<p>[14] 开启初始标记过程中的并行化，进一步提升初始化标记效率;</p>
<p>[15]、[16]、[17]、[18] 、[19]是打印gc日志，其中[16]在jdk1.8之后无需设置</p>
<p>[20]、[21]则是内存溢出时dump堆</p>
<h2 id="CMS需要注意的问题"><a href="#CMS需要注意的问题" class="headerlink" title="CMS需要注意的问题"></a>CMS需要注意的问题</h2><h3 id="CMS不是full-GC"><a href="#CMS不是full-GC" class="headerlink" title="CMS不是full GC"></a>CMS不是full GC</h3><p>有一点需要注意的是：CMS并发GC不是“full GC”。HotSpot VM里对concurrent collection和full collection有明确的区分。所有带有“FullCollection”字样的VM参数都是跟真正的full GC相关，而跟CMS并发GC无关的，CMS收集算法只是清理老年代。</p>
<h3 id="减少remark阶段停顿"><a href="#减少remark阶段停顿" class="headerlink" title="减少remark阶段停顿"></a>减少remark阶段停顿</h3><p>一般CMS的GC耗时 80%都在remark阶段，如果发现remark阶段停顿时间很长，可以尝试添加该参数：</p>
<p>-XX:+CMSScavengeBeforeRemark</p>
<p>在执行remark操作之前先做一次ygc，目的在于减少ygen对oldgen的无效引用，降低remark时的开销，如果添加该参数后 ”ygc停顿时间+remark时间&lt;添加该参数之前的remark时间“,说明该参数是有效的；</p>
<h3 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h3><p>CMS是基于标记-清除算法的，只会将标记为为存活的对象删除，并不会移动对象整理内存空间，会造成内存碎片，这时候我们需要用到这个参数;</p>
<p>-XX:CMSFullGCsBeforeCompaction=n</p>
<p>这个参数大部分人的使用方式都是错误的，往往会导致设置后问题更大。</p>
<p>CMSFullGCsBeforeCompaction这个参数在HotSpot VM里是这样声明的：</p>
<p>product(bool, UseCMSCompactAtFullCollection, true, \</p>
<p>“Use mark sweep compact at full collections”) \</p>
<p>\</p>
<p>product(uintx, CMSFullGCsBeforeCompaction, 0, \</p>
<p>“Number of CMS full collection done before compaction if &gt; 0”) \</p>
<p>然后这样使用的：</p>
<p>*should_compact =</p>
<p>UseCMSCompactAtFullCollection &amp;&amp;</p>
<p>((_full_gcs_since_conc_gc &gt;= CMSFullGCsBeforeCompaction) ||</p>
<p>GCCause::is_user_requested_gc(gch-&gt;gc_cause()) ||</p>
<p>gch-&gt;incremental_collection_will_fail(true <em>/\</em> consult_young <em>/</em>));</p>
<p>CMS GC要决定是否在full GC时做压缩，会依赖几个条件。其中，</p>
<ol>
<li><p>UseCMSCompactAtFullCollection 与 CMSFullGCsBeforeCompaction 是搭配使用的；前者目前默认就是true了，也就是关键在后者上。</p>
</li>
<li><p>用户调用了System.gc()，而且DisableExplicitGC没有开启。</p>
</li>
<li><p>young gen报告接下来如果做增量收集会失败；简单来说也就是young gen预计old gen没有足够空间来容纳下次young GC晋升的对象。</p>
</li>
</ol>
<p>上述三种条件的任意一种成立都会让CMS决定这次做full GC时要做压缩。</p>
<p>CMSFullGCsBeforeCompaction 说的是，在上一次CMS并发GC执行过后，到底还要再执行多少次full GC才会做压缩。默认是0，也就是在默认配置下每次CMS GC顶不住了而要转入full GC的时候都会做压缩。 如果把CMSFullGCsBeforeCompaction配置为10，就会让上面说的第一个条件变成每隔10次真正的full GC才做一次压缩（而不是每10次CMS并发GC就做一次压缩，目前VM里没有这样的参数）。这会使full GC更少做压缩，也就更容易使CMS的old gen受碎片化问题的困扰。 本来这个参数就是用来配置降低full GC压缩的频率，以期减少某些full GC的暂停时间。CMS回退到full GC时用的算法是mark-sweep-compact，但compaction是可选的，不做的话碎片化会严重些但这次full GC的暂停时间会短些；这是个取舍。</p>
<h3 id="concurrent-mode-failure"><a href="#concurrent-mode-failure" class="headerlink" title="concurrent mode failure"></a>concurrent mode failure</h3><p>这个异常发生在CMS正在回收的时候。执行CMS GC的过程中，同时业务线程也在运行，当年轻代空间满了，执行ygc时，需要将存活的对象放入到老年代，而此时老年代空间不足，这时CMS还没有机会回收老年带产生的，或者在做Minor GC的时候，新生代救助空间放不下，需要放入老年代，而老年代也放不下而产生的。</p>
<p>设置CMS触发时机有两个参数：</p>
<p>-XX:+UseCMSInitiatingOccupancyOnly</p>
<p>-XX:CMSInitiatingOccupancyFraction=70</p>
<p>-XX:CMSInitiatingOccupancyFraction=70 是指设定CMS在对内存占用率达到70%的时候开始GC。</p>
<p>-XX:+UseCMSInitiatingOccupancyOnly如果不指定, 只是用设定的回收阈值CMSInitiatingOccupancyFraction,则JVM仅在第一次使用设定值,后续则自动调整会导致上面的那个参数不起作用。</p>
<p>为什么要有这两个参数？</p>
<p>由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。</p>
<p>CMS前五个阶段都是标记存活对象的，除了”初始标记”和”重新标记”阶段会stop the word ，其它三个阶段都是与用户线程一起跑的，就会出现这样的情况gc线程正在标记存活对象，用户线程同时向老年代提升新的对象，清理工作还没有开始，old gen已经没有空间容纳更多对象了，这时候就会导致concurrent mode failure， 然后就会使用串行收集器回收老年代的垃圾，导致停顿的时间非常长。</p>
<p>CMSInitiatingOccupancyFraction参数要设置一个合理的值，设置大了，会增加concurrent mode failure发生的频率，设置的小了，又会增加CMS频率，所以要根据应用的运行情况来选取一个合理的值。</p>
<p>如果发现这两个参数设置大了会导致fullgc，设置小了会导致频繁的CMSgc，说明你的老年代空间过小，应该增加老年代空间的大小了；</p>
<h3 id="promotion-failed"><a href="#promotion-failed" class="headerlink" title="promotion failed"></a>promotion failed</h3><p>这个异常发生在年轻代回收的时候；</p>
<p>在进行Minor GC时，Survivor Space放不下，对象只能放入老年代，而此时老年代也放不下造成的，多数是由于老年带有足够的空闲空间，但是由于碎片较多，新生代要转移到老年带的对象比较大,找不到一段连续区域存放这个对象导致的，以下是一段promotion failed的日志：</p>
<p>106.641: [GC 106.641: [ParNew (promotion failed): 14784K-&gt;14784K(14784K), 0.0370328 secs]106.678: [CMS106.715: [CMS-concurrent-mark: 0.065/0.103 secs] [Times: user=0.17 sys=0.00, real=0.11 secs]</p>
<p>(concurrent mode failure): 41568K-&gt;27787K(49152K), 0.2128504 secs] 52402K-&gt;27787K(63936K), [CMS Perm : 2086K-&gt;2086K(12288K)], 0.2499776 secs] [Times: user=0.28 sys=0.00, real=0.25 secs]</p>
<p><strong><em>过早提升与提升失败</em></strong></p>
<p>在 Minor GC 过程中，Survivor Unused 可能不足以容纳 Eden 和另一个 Survivor 中的存活对象， 那么多余的将被移到老年代， 称为过早提升（Premature Promotion）,这会导致老年代中短期存活对象的增长， 可能会引发严重的性能问题。 再进一步， 如果老年代满了， Minor GC 后会进行 Full GC， 这将导致遍历整个堆， 称为提升失败（Promotion Failure）。</p>
<p><strong><em>早提升的原因</em></strong></p>
<ol>
<li><p>Survivor空间太小，容纳不下全部的运行时短生命周期的对象，如果是这个原因，可以尝试将Survivor调大，否则端生命周期的对象提升过快，导致老年代很快就被占满，从而引起频繁的full gc；</p>
</li>
<li><p>对象太大，Survivor和Eden没有足够大的空间来存放这些大象；</p>
</li>
</ol>
<p><strong><em>提升失败原因</em></strong></p>
<p>当提升的时候，发现老年代也没有足够的连续空间来容纳该对象。</p>
<p>为什么是没有足够的连续空间而不是空闲空间呢？</p>
<p>老年代容纳不下提升的对象有两种情况：</p>
<ol>
<li><p>老年代空闲空间不够用了；</p>
</li>
<li><p>老年代虽然空闲空间很多，但是碎片太多，没有连续的空闲空间存放该对象；</p>
</li>
</ol>
<p><strong><em>解决方法</em></strong></p>
<ol>
<li><p>如果是因为内存碎片导致的大对象提升失败，CMS需要进行空间整理压缩；</p>
</li>
<li><p>如果是因为提升过快导致的，说明Survivor 空闲空间不足，那么可以尝试调大 Survivor；</p>
</li>
<li><p>如果是因为老年代空间不够导致的，尝试将CMS触发的阈值调低；</p>
</li>
</ol>
<h2 id="其它导致回收停顿时间变长原因"><a href="#其它导致回收停顿时间变长原因" class="headerlink" title="其它导致回收停顿时间变长原因"></a>其它导致回收停顿时间变长原因</h2><p>linux使用了swap，内存换入换出（vmstat），尤其是开启了大内存页的时候，因为swap只支持4k的内存页，大内存页的大小为2M，大内存页在swap的交换的时候需要先将swap中4k内存页合并成一个大内存页再放入内存或将大内存页切分为4k的内存页放入swap，合并和切分的操作会导致操作系统占用cup飙高，用户cpu占用反而很低；</p>
<p>除了swap交换外，网络io（netstat）、磁盘I/O （iostat）在 GC 过程中发生会使 GC 时间变长。</p>
<p>如果是以上原因，就要去查看gc日志中的Times耗时：</p>
<p>[Times: user=0.00 sys=0.00, real=0.00 secs]</p>
<p>user是用户线程占用的时间，sys是系统线程占用的时间，如果是io导致的问题，会有两种情况</p>
<ol>
<li>user与sys时间都非常小，但是real却很长，如下：</li>
</ol>
<p>[ Times: user=0.51 sys=0.10, real=5.00 secs ]</p>
<p>user+sys的时间远远小于real的值，这种情况说明停顿的时间并不是消耗在cup执行上了，不是cup肯定就是io导致的了，所以这时候要去检查系统的io情况。</p>
<p>sys时间很长，user时间很短，real几乎等于sys的时间，如下：</p>
<p>[ Times: user=0.11 sys=31.10, real=33.12 secs ]</p>
<p>这时候其中一种原因是开启了大内存页，还开启了swap，大内存进行swap交换时会有这种现象；</p>
<h2 id="增加线程数"><a href="#增加线程数" class="headerlink" title="增加线程数"></a>增加线程数</h2><p>CMS默认启动的回收线程数目是 (ParallelGCThreads + 3)/4) ，这里的ParallelGCThreads是年轻代的并行收集线程数，感觉有点怪怪的；</p>
<p>年轻代的并行收集线程数默认是(ncpus &lt;= 8) ? ncpus : 3 + ((ncpus * 5) / 8)，可以通过-XX:ParallelGCThreads= N 来调整；</p>
<p>如果要直接设定CMS回收线程数，可以通过-XX:ParallelCMSThreads=n，注意这个n不能超过cpu线程数，需要注意的是增加gc线程数，就会和应用争抢资源；</p>
<p>参考</p>
<p><a target="_blank" rel="noopener" href="https://plumbr.eu/handbook/garbage-collection-algorithms-implementations#concurrent-mark-and-sweep">https://plumbr.eu/handbook/garbage-collection-algorithms-implementations#concurrent-mark-and-sweep</a></p>
<p><a target="_blank" rel="noopener" href="http://www.infoq.com/cn/presentations/a-long-period-of-atypical-jvm-gc-caused-by-os/">http://www.infoq.com/cn/presentations/a-long-period-of-atypical-jvm-gc-caused-by-os/</a></p>
<p>GC Cause</p>
<p>Heap Inspection Initiated GC</p>
<p>因为执行了jmap -histo:live 触发的gc</p>
<p>![](_v_images/20200621105321510_162455977.png =546x)</p>
<p>![](_v_images/20200621105825309_1900989220.png =541x)</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/">Java 8 document</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html">Java 8 CMS collector</a></li>
<li><a target="_blank" rel="noopener" href="https://www.iteye.com/blog/zhanjia-2435266">Java之CMS GC的7个阶段</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/Metric/" rel="tag"># Metric</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Java/metric/01_tuner/" rel="prev" title="Java性能调优">
      <i class="fa fa-chevron-left"></i> Java性能调优
    </a></div>
      <div class="post-nav-item">
    <a href="/database/MySQL/01.MySQL/" rel="next" title="MacOS中MySQL密码丢失处理">
      MacOS中MySQL密码丢失处理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CMS-GC"><span class="nav-number">1.</span> <span class="nav-text">CMS GC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%BB%84%E5%90%88"><span class="nav-number">1.1.</span> <span class="nav-text">垃圾回收器组合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Minor-GC%E3%80%81Major-GC%E4%B8%8EFull-GC"><span class="nav-number">1.2.</span> <span class="nav-text">Minor GC、Major GC与Full GC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8-Concurrent-Mark-Sweep-CMS-Collector"><span class="nav-number">1.3.</span> <span class="nav-text">CMS垃圾收集器 Concurrent Mark Sweep(CMS) Collector</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%89%B9%E7%82%B9"><span class="nav-number">1.4.</span> <span class="nav-text">CMS垃圾回收特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.5.</span> <span class="nav-text">CMS垃圾收集器步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Phase-1-Initial-Mark%EF%BC%88%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%87%E8%AE%B0%EF%BC%89"><span class="nav-number">1.5.1.</span> <span class="nav-text">Phase 1: Initial Mark（初始化标记）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Phase-2-Concurrent-Mark%EF%BC%88%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%EF%BC%89"><span class="nav-number">1.5.2.</span> <span class="nav-text">Phase 2: Concurrent Mark（并发标记）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Phase-3-Concurrent-Preclean%EF%BC%88%E5%B9%B6%E5%8F%91%E9%A2%84%E6%B8%85%E7%90%86%EF%BC%89"><span class="nav-number">1.5.3.</span> <span class="nav-text">Phase 3: Concurrent Preclean（并发预清理）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Phase-4-Concurrent-Abortable-Preclean%EF%BC%88%E5%8F%AF%E4%B8%AD%E6%AD%A2%E7%9A%84%E5%B9%B6%E5%8F%91%E9%A2%84%E6%B8%85%E7%90%86%EF%BC%89"><span class="nav-number">1.5.4.</span> <span class="nav-text">Phase 4: Concurrent Abortable Preclean（可中止的并发预清理）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Phase-5-Final-Remark%EF%BC%88%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0%EF%BC%89"><span class="nav-number">1.5.5.</span> <span class="nav-text">Phase 5: Final Remark（重新标记）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Phase-6-Concurrent-Sweep%EF%BC%88%E5%B9%B6%E5%8F%91%E6%B8%85%E7%90%86"><span class="nav-number">1.5.6.</span> <span class="nav-text">Phase 6: Concurrent Sweep（并发清理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A47-%E5%B9%B6%E5%8F%91%E9%87%8D%E7%BD%AE"><span class="nav-number">1.5.7.</span> <span class="nav-text">步骤7: 并发重置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CMS%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="nav-number">1.6.</span> <span class="nav-text">CMS日志分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0%E4%B8%8E%E5%90%AF%E7%94%A8%E5%8F%82%E6%95%B0"><span class="nav-number">1.7.</span> <span class="nav-text">调优参数与启用参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CMS%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">1.8.</span> <span class="nav-text">CMS需要注意的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CMS%E4%B8%8D%E6%98%AFfull-GC"><span class="nav-number">1.8.1.</span> <span class="nav-text">CMS不是full GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%8F%E5%B0%91remark%E9%98%B6%E6%AE%B5%E5%81%9C%E9%A1%BF"><span class="nav-number">1.8.2.</span> <span class="nav-text">减少remark阶段停顿</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="nav-number">1.8.3.</span> <span class="nav-text">内存碎片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#concurrent-mode-failure"><span class="nav-number">1.8.4.</span> <span class="nav-text">concurrent mode failure</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#promotion-failed"><span class="nav-number">1.8.5.</span> <span class="nav-text">promotion failed</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E5%AF%BC%E8%87%B4%E5%9B%9E%E6%94%B6%E5%81%9C%E9%A1%BF%E6%97%B6%E9%97%B4%E5%8F%98%E9%95%BF%E5%8E%9F%E5%9B%A0"><span class="nav-number">1.9.</span> <span class="nav-text">其它导致回收停顿时间变长原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E7%BA%BF%E7%A8%8B%E6%95%B0"><span class="nav-number">1.10.</span> <span class="nav-text">增加线程数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="nav-number">1.11.</span> <span class="nav-text">参考文献</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">aaronzhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">230</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">110</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aaronzhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
