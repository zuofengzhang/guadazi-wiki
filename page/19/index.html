<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Guadazi">
<meta property="og:url" content="http://example.com/page/19/index.html">
<meta property="og:site_name" content="Guadazi">
<meta property="og:locale">
<meta property="article:author" content="aaronzhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/19/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Guadazi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Guadazi</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/skill/pinyin4j/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/skill/pinyin4j/" class="post-title-link" itemprop="url">pinyin4j</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-07-13 08:58:00" itemprop="dateCreated datePublished" datetime="2016-07-13T08:58:00+08:00">2016-07-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-09 09:38:26" itemprop="dateModified" datetime="2021-02-09T09:38:26+08:00">2021-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">cn2Spell</span><span class="params">(String chinese)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (chinese == <span class="keyword">null</span> || chinese.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        StringBuffer pybf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">char</span>[] arr = chinese.toCharArray();</span><br><span class="line">        HanyuPinyinOutputFormat defaultFormat = <span class="keyword">new</span> HanyuPinyinOutputFormat();</span><br><span class="line">        defaultFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE);</span><br><span class="line">        defaultFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; <span class="number">128</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String[] str = PinyinHelper.toHanyuPinyinStringArray(</span><br><span class="line">                            arr[i], defaultFormat);</span><br><span class="line">                    <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pybf.append(PinyinHelper.toHanyuPinyinStringArray(</span><br><span class="line">                            arr[i], defaultFormat)[<span class="number">0</span>]);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BadHanyuPinyinOutputFormatCombination e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pybf.append(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pybf.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/network/push/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/network/push/" class="post-title-link" itemprop="url">消息推送</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-07-12 16:02:00" itemprop="dateCreated datePublished" datetime="2016-07-12T16:02:00+08:00">2016-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-09 09:38:26" itemprop="dateModified" datetime="2021-02-09T09:38:26+08:00">2021-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index"><span itemprop="name">Network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="推送服务"><a href="#推送服务" class="headerlink" title="推送服务"></a>推送服务</h1><p>维护任何一个长连接都需要心跳机制，客户端发送一个心跳给服务器，服务器给客户端一个心跳应答，这样就形成客户端服务器的一次完整的握手，这个握手是让双方都知道他们之间的连接是没有断开，客户端是在线的。如果超过一个时间的阈值，客户端没有收到服务器的应答，或者服务器没有收到客户端的心跳，那么对客户端来说则断开与服务器的连接重新建立一个连接，对服务器来说只要断开这个连接即可。那么在智能手机上的长连接心跳和在Internet上的长连接心跳有什么不同的目的呢？原因就在于智能手机使用的是移动无线网络，那么我们在讲长连接之前我们首先要了解无线移动网络的特点。<br>由于大部分的移动无线网络运营商为了减少网关NAT映射表的负荷，如果一个链路有一段时间没有通信时就会删除其对应表，造成链路中断，正是这种刻意缩短空闲连接的释放超时，原本是想节省信道资源的作用，没想到让互联网的应用不得以远高于正常频率发送心跳来维护推送的长连接。这也是为什么会有之前的信令风暴，微信摇收费的传言，因为这类的应用发送心跳的频率是很短的，既造成了信道资源的浪费，也造成了手机电量的快速消耗。</p>
<p>推送的实现方式：</p>
<ol>
<li>客户端不断的查询服务器，检索新内容，也就是所谓的pull 或者轮询方式</li>
<li>客户端和服务器之间维持一个TCP/IP长连接，服务器向客户端push</li>
<li>服务器又新内容时，发送一条类似短信的信令给客户端，客户端收到后从服务器中下载新内容，也就是SMS的推送方式。</li>
</ol>
<p>苹果的推送系统和googleC2DM推送系统其实都是在系统级别维护一个TCP/IP长连接，都是基于第二种的方式进行推送的。第三种方式由于运营商没有免费开放这种信令导致了这种推送在成本上是无法接受的，虽然这种推送的方式非常的稳定，高效和及时。</p>
<h1 id="IOS推送"><a href="#IOS推送" class="headerlink" title="IOS推送"></a>IOS推送</h1><p>首先第一步当然是介绍一下苹果的推送机制(APNS)咯（ps:其实每一篇教程都有），先来看一张苹果官方对其推送做出解释的概要图。<br><img src="/images/network/push/APNS-process.png"></p>
<p>Provider是给你手机应用发出推送消息的服务器，而APNS（Apple Push Notification Service）则是苹果消息推送服务器。<br>你本地的服务器当需要给应用推送一条消息的时候，先要将消息发出到苹果推送服务器，然后再由苹果推送服务器将消息发到安装了该应用的手机。</p>
<p>接下来再看一张解释图：<br><img src="/images/network/push/APNS-process-detail.png"></p>
<p>根据上图的逻辑我来给大家解释一下：</p>
<ol>
<li>你的IOS应用需要去注册APNS消息推送功能。</li>
<li>当苹果APNS推送服收到来自你应用的注册消息就会返回一串device token给你（很重要）</li>
<li>将应用收到的device Token传给你本地的Push服务器。</li>
<li>当你需要为应用推送消息的时候，你本地的推送服务器会将消息，以及Device Token打包发送到苹果的APNS服</li>
<li>APNS再将消息推送给目的iphone</li>
</ol>
<p>   IOS长连接是由系统来维护的，也就是说苹果的IOS系统在系统级别维护了一个客户端和苹果服务器的长链接，IOS上的所有应用上的推送都是先将消息推送到苹果的服务器然后将苹果服务器通过这个系统级别的长链接推送到手机终端上，这样的的几个好处为：1.在手机终端始终只要维护一个长连接即可，而且由于这个长链接是系统级别的不会出现被杀死而无法推送的情况。2.省电，不会出现每个应用都各自维护一个自己的长连接。3.安全，只有在苹果注册的开发者才能够进行推送，等等。</p>
<h1 id="Android推送"><a href="#Android推送" class="headerlink" title="Android推送"></a>Android推送</h1><p>android的长连接是由每个应用各自维护的，但是google也推出了和苹果技术架构相似的推送框架，C2DM,云端推送功能，但是由于google<br>的服务器不在中国境内，其他的原因你懂的。所以导致这个推送无法使用，android的开发者不得不自己去维护一个长链接，于是每个应用如果都24小时在<br>线，那么都得各自维护一个长连接，这种电量和流量的消耗是可想而知的。虽然国内也出现了各种推送平台，但是都无法达到只维护一个长连接这种消耗的级别。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/array/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/array/" class="post-title-link" itemprop="url">Java数组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-06-09 12:26:00" itemprop="dateCreated datePublished" datetime="2016-06-09T12:26:00+08:00">2016-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-09 09:38:26" itemprop="dateModified" datetime="2021-02-09T09:38:26+08:00">2021-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-声明一个数组"><a href="#1-声明一个数组" class="headerlink" title="1.  声明一个数组"></a>1.  声明一个数组</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] aArray = <span class="keyword">new</span> String[<span class="number">5</span>];  </span><br><span class="line">String[] bArray = &#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>&#125;;  </span><br><span class="line">String[] cArray = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>&#125;;  </span><br></pre></td></tr></table></figure>
<h1 id="2-输出一个数组"><a href="#2-输出一个数组" class="headerlink" title="2.  输出一个数组"></a>2.  输出一个数组</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;  </span><br><span class="line">String intArrayString = Arrays.toString(intArray);  </span><br><span class="line"><span class="comment">// print directly will print reference value  </span></span><br><span class="line">System.out.println(intArray);  </span><br><span class="line"><span class="comment">// [I@7150bd4d  </span></span><br><span class="line">System.out.println(intArrayString);  </span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]  </span></span><br></pre></td></tr></table></figure>
<h1 id="3-从一个数组创建数组列表"><a href="#3-从一个数组创建数组列表" class="headerlink" title="3.  从一个数组创建数组列表"></a>3.  从一个数组创建数组列表</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] stringArray = &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span> &#125;;  </span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(stringArray));  </span><br><span class="line">System.out.println(arrayList);  </span><br><span class="line"><span class="comment">// [a, b, c, d, e]  </span></span><br></pre></td></tr></table></figure>
<h1 id="4-检查一个数组是否包含某个值"><a href="#4-检查一个数组是否包含某个值" class="headerlink" title="4.  检查一个数组是否包含某个值"></a>4.  检查一个数组是否包含某个值</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] stringArray = &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span> &#125;;  </span><br><span class="line"><span class="keyword">boolean</span> b = Arrays.asList(stringArray).contains(<span class="string">&quot;a&quot;</span>);  </span><br><span class="line">System.out.println(b);  </span><br><span class="line"><span class="comment">// true  </span></span><br></pre></td></tr></table></figure>
<h1 id="5-连接两个数组"><a href="#5-连接两个数组" class="headerlink" title="5.  连接两个数组"></a>5.  连接两个数组</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;  </span><br><span class="line"><span class="keyword">int</span>[] intArray2 = &#123; <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;  </span><br><span class="line"><span class="comment">// Apache Commons Lang library  </span></span><br><span class="line"><span class="keyword">int</span>[] combinedIntArray = ArrayUtils.addAll(intArray, intArray2);  </span><br></pre></td></tr></table></figure>
<h1 id="6-声明一个内联数组（Array-inline）"><a href="#6-声明一个内联数组（Array-inline）" class="headerlink" title="6.  声明一个内联数组（Array inline）"></a>6.  声明一个内联数组（Array inline）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>&#125;);  </span><br></pre></td></tr></table></figure>
<h1 id="7-把提供的数组元素放入一个字符串"><a href="#7-把提供的数组元素放入一个字符串" class="headerlink" title="7.  把提供的数组元素放入一个字符串"></a>7.  把提供的数组元素放入一个字符串</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// containing the provided list of elements  </span></span><br><span class="line"><span class="comment">// Apache common lang  </span></span><br><span class="line">String j = StringUtils.join(<span class="keyword">new</span> String[] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span> &#125;, <span class="string">&quot;, &quot;</span>);  </span><br><span class="line">System.out.println(j);  </span><br><span class="line"><span class="comment">// a, b, c  </span></span><br></pre></td></tr></table></figure>
<h1 id="8-将一个数组列表转换为数组"><a href="#8-将一个数组列表转换为数组" class="headerlink" title="8.  将一个数组列表转换为数组"></a>8.  将一个数组列表转换为数组</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] stringArray = &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span> &#125;;  </span><br><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(stringArray));  </span><br><span class="line">String[] stringArr = <span class="keyword">new</span> String[arrayList.size()];  </span><br><span class="line">arrayList.toArray(stringArr);  </span><br><span class="line"><span class="keyword">for</span> (String s : stringArr)  </span><br><span class="line">    System.out.println(s);  </span><br></pre></td></tr></table></figure>
<h1 id="9-将一个数组转换为集（set）"><a href="#9-将一个数组转换为集（set）" class="headerlink" title="9.  将一个数组转换为集（set）"></a>9.  将一个数组转换为集（set）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(stringArray));  </span><br><span class="line">System.out.println(set);  </span><br><span class="line"><span class="comment">//[d, e, b, c, a]  </span></span><br></pre></td></tr></table></figure>
<h1 id="10-逆向一个数组"><a href="#10-逆向一个数组" class="headerlink" title="10.  逆向一个数组"></a>10.  逆向一个数组</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;  </span><br><span class="line">ArrayUtils.reverse(intArray);  </span><br><span class="line">System.out.println(Arrays.toString(intArray));  </span><br><span class="line"><span class="comment">//[5, 4, 3, 2, 1]  </span></span><br></pre></td></tr></table></figure>
<h1 id="11-移除数组中的元素"><a href="#11-移除数组中的元素" class="headerlink" title="11.  移除数组中的元素"></a>11.  移除数组中的元素</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;  </span><br><span class="line"><span class="keyword">int</span>[] removed = ArrayUtils.removeElement(intArray, <span class="number">3</span>);<span class="comment">//create a new array  </span></span><br><span class="line">System.out.println(Arrays.toString(removed));  </span><br></pre></td></tr></table></figure>
<h1 id="12-将整数转换为字节数组"><a href="#12-将整数转换为字节数组" class="headerlink" title="12.  将整数转换为字节数组"></a>12.  将整数转换为字节数组</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = ByteBuffer.allocate(<span class="number">4</span>).putInt(<span class="number">8</span>).array();  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">byte</span> t : bytes) &#123;  </span><br><span class="line">   System.out.format(<span class="string">&quot;0x%x &quot;</span>, t);  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>






      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/multithread/06.BlockingQueue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/multithread/06.BlockingQueue/" class="post-title-link" itemprop="url">Java多线程6: Java阻塞队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-05-31 00:00:00" itemprop="dateCreated datePublished" datetime="2016-05-31T00:00:00+08:00">2016-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-09 09:38:26" itemprop="dateModified" datetime="2021-02-09T09:38:26+08:00">2021-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="/Java/advanced-engineer-outline/">&lt;Java高级软件工程师知识结构</a></p>
<blockquote>
<p>   Java多线程是Java基础的重要的一部分，支持多线程是Java的重要特性之一. 主要包括如下内容:</p>
<ol>
<li><a href="/Java/multithread/01.base/">Java多线程1: 线程生命周期和多线程基础</a></li>
<li><a href="/Java/multithread/02.Lock-Semaphore-Atomic/">Java多线程2: Lock、信号量、原子量与队列</a></li>
<li><a href="/Java/multithread/03.volatile/">Java多线程3: volatile</a></li>
<li><a href="/Java/multithread/04.thread-synchronization/">Java多线程4: 同步锁与Java线程同步方法比较</a></li>
<li><a href="/Java/multithread/05.ThreadPool/">Java多线程5: 线程池</a></li>
<li><a href="/Java/multithread/06.BlockingQueue/">Java多线程6: Java阻塞队列与生产者消费者模式</a></li>
</ol>
</blockquote>
<hr>
<h1 id="阻塞队列与阻塞栈"><a href="#阻塞队列与阻塞栈" class="headerlink" title="阻塞队列与阻塞栈"></a>阻塞队列与阻塞栈</h1><p><img src="images/20191201214259668_108772893.png"></p>
<p>Java定义了阻塞队列的接口<code>java.util.concurrent.BlockingQueue</code>,<br>阻塞队列的概念是, 一个指定长度的队列, 如果队列满了, 添加新元素的操作会被阻塞等待, 直到有空位为止. 同样, 当队列为空时候, 请求队列元素的操作同样会阻塞等待, 直到有可用元素为止.<br>阻塞队列还有更多实现类, 用来满足各种复杂的需求：<code>ArrayBlockingQueue</code>, <code>DelayQueue</code>, <code>LinkedBlockingQueue</code>, <code>PriorityBlockingQueue</code>, <code>SynchronousQueue</code> , 具体的API差别也很小.</p>
<p>对于阻塞栈, 与阻塞队列相似. 不同点在于栈是<code>“后入先出”</code>的结构, 每次操作的是栈顶, 而队列是“先进先出”的结构, 每次操作的是队列头.<br>Java为阻塞栈定义了接口：<code>java.util.concurrent.BlockingDeque</code></p>
<h1 id="1、核心方法"><a href="#1、核心方法" class="headerlink" title="1、核心方法"></a>1、核心方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将给定元素设置到队列中，如果设置成功返回true, 否则返回false。如果是往限定了长度的队列中设置值，推荐使用offer()方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将给定的元素设置到队列中，如果设置成功返回true, 否则返回false. e的值不能为空，否则抛出空指针异常。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将元素设置到队列中，如果队列中没有多余的空间，该方法会一直阻塞，直到队列中有多余的空间。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将给定元素在给定的时间内设置到队列中，如果设置成功返回true, 否则返回false.</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中获取值，如果队列中没有值，线程会一直阻塞，直到队列中有值，并且该方法取得了该值。</span></span><br><span class="line">    <span class="function">E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在给定的时间里，从队列中获取值，时间到了直接调用普通的poll方法，为null则直接返回null。</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取队列中剩余的空间。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remainingCapacity</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中移除指定的值。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断队列中是否拥有该值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将队列中值，全部移除，并发设置到给定的集合中。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定最多数量限制将队列中值，全部移除，并发设置到给定的集合中。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">drainTo</span><span class="params">(Collection&lt;? <span class="keyword">super</span> E&gt; c, <span class="keyword">int</span> maxElements)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="2、阻塞队列的成员"><a href="#2、阻塞队列的成员" class="headerlink" title="2、阻塞队列的成员"></a>2、阻塞队列的成员</h1><p>方法\处理方式 抛出异常 返回特殊值 一直阻塞 超时退出</p>
<p>插入方法 add(e) offer(e) put(e) offer(e,time,unit)</p>
<p>移除方法 remove() poll() take() poll(time,unit)</p>
<p>检查方法 element() peek() 不可用 不可用</p>
<p><img src="images/20191201214440080_637429054.png"></p>
<h1 id="3、成员详解"><a href="#3、成员详解" class="headerlink" title="3、成员详解"></a>3、成员详解</h1><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><pre><code>   基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。  </code></pre>
<p>　　ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><pre><code>   基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。  </code></pre>
<p>作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。</p>
<h2 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h2><pre><code>   DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。  </code></pre>
<p>使用场景：<br>       DelayQueue使用场景较少，但都相当巧妙，常见的例子比如使用一个DelayQueue来管理一个超时未响应的连接队列。</p>
<h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><pre><code>   基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。</code></pre>
<h2 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h2><pre><code>   一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。  </code></pre>
<p>　　声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别:<br>　　如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；<br>　　但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p>
<h1 id="4、秒杀demo"><a href="#4、秒杀demo" class="headerlink" title="4、秒杀demo"></a>4、秒杀demo</h1><h2 id="秒杀对列"><a href="#秒杀对列" class="headerlink" title="秒杀对列"></a>秒杀对列</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hsshy.beam.queue.jvm;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hsshy.beam.queue.entity.SuccessKilled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 秒杀队列(固定长度为100)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 科帮网 By https://blog.52itstyle.com</span></span><br><span class="line"><span class="comment"> * 创建时间   2018年5月10日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillQueue</span> </span>&#123;</span><br><span class="line">     <span class="comment">//队列大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_MAX_SIZE   = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/** 用于多线程间下单的队列 */</span></span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;SuccessKilled&gt; blockingQueue = <span class="keyword">new</span> LinkedBlockingQueue&lt;SuccessKilled&gt;(QUEUE_MAX_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有的默认构造子，保证外界无法直接实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SeckillQueue</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例</span></span><br><span class="line"><span class="comment">     * 没有绑定关系，而且只有被调用到才会装载，从而实现了延迟加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 静态初始化器，由JVM来保证线程安全</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span>  <span class="keyword">static</span> SeckillQueue queue = <span class="keyword">new</span> SeckillQueue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//单例队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SeckillQueue <span class="title">getMailQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产入队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> kill</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     * add(e) 队列未满时，返回true；队列满则抛出IllegalStateException(“Queue full”)异常——AbstractQueue </span></span><br><span class="line"><span class="comment">     * put(e) 队列未满时，直接插入没有返回值；队列满时会阻塞等待，一直等到队列未满时再插入。</span></span><br><span class="line"><span class="comment">     * offer(e) 队列未满时，返回true；队列满时返回false。非阻塞立即返回。</span></span><br><span class="line"><span class="comment">     * offer(e, time, unit) 设定等待的时间，如果在指定时间内还不能往队列中插入数据则返回false，插入成功返回true。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  Boolean  <span class="title">produce</span><span class="params">(SuccessKilled kill)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> blockingQueue.offer(kill);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费出队</span></span><br><span class="line"><span class="comment">     * poll() 获取并移除队首元素，在指定的时间内去轮询队列看有没有首元素有则返回，否者超时后返回null</span></span><br><span class="line"><span class="comment">     * take() 与带超时时间的poll类似不同在于take时候如果当前队列空了它会一直等待其他线程调用notEmpty.signal()才会被唤醒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  SuccessKilled <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> blockingQueue.take();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取队列大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> blockingQueue.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="springboot启动时执行类"><a href="#springboot启动时执行类" class="headerlink" title="springboot启动时执行类"></a>springboot启动时执行类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hsshy.beam.queue.jvm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.hsshy.beam.queue.entity.SuccessKilled;</span><br><span class="line"><span class="keyword">import</span> com.hsshy.beam.queue.service.ISeckillService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationArguments;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.ApplicationRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费秒杀队列</span></span><br><span class="line"><span class="comment"> * 创建者 科帮网</span></span><br><span class="line"><span class="comment"> * 创建时间 2018年4月3日</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ISeckillService seckillService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ApplicationArguments <span class="keyword">var</span>)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//进程内队列</span></span><br><span class="line">            SuccessKilled kill = SeckillQueue.getMailQueue().consume();</span><br><span class="line">            <span class="keyword">if</span>(kill!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                seckillService.startSeckil(kill.getId(), kill.getUserId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="controller层"><a href="#controller层" class="headerlink" title="controller层"></a>controller层</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(value=&quot;秒杀柒(进程内队列)&quot;,nickname=&quot;科帮网&quot;)</span></span><br><span class="line">   <span class="meta">@PostMapping(&quot;/startQueue&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> R <span class="title">startQueue</span><span class="params">(<span class="keyword">long</span> seckillId)</span></span>&#123;</span><br><span class="line">       seckillService.deleteSeckill(seckillId);</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">long</span> killId =  seckillId;</span><br><span class="line">       LOGGER.info(<span class="string">&quot;开始秒杀柒(正常)&quot;</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">long</span> userId = i;</span><br><span class="line">           Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   SuccessKilled kill = <span class="keyword">new</span> SuccessKilled();</span><br><span class="line">                   kill.setId(killId);</span><br><span class="line">                   kill.setUserId(userId);</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       Boolean flag = SeckillQueue.getMailQueue().produce(kill);</span><br><span class="line">                       <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                           LOGGER.info(<span class="string">&quot;用户:&#123;&#125;&#123;&#125;&quot;</span>,kill.getUserId(),<span class="string">&quot;秒杀成功&quot;</span>);</span><br><span class="line">                       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                           LOGGER.info(<span class="string">&quot;用户:&#123;&#125;&#123;&#125;&quot;</span>,userId,<span class="string">&quot;秒杀失败&quot;</span>);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                       LOGGER.info(<span class="string">&quot;用户:&#123;&#125;&#123;&#125;&quot;</span>,userId,<span class="string">&quot;秒杀失败&quot;</span>);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">           executor.execute(task);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">           Long  seckillCount = seckillService.getSeckillCount(seckillId);</span><br><span class="line">           LOGGER.info(<span class="string">&quot;一共秒杀出&#123;&#125;件商品&quot;</span>,seckillCount);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> R.ok();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="5、延时队列demo"><a href="#5、延时队列demo" class="headerlink" title="5、延时队列demo"></a>5、延时队列demo</h1><h2 id="消息体"><a href="#消息体" class="headerlink" title="消息体"></a>消息体</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hsshy.beam.queue.delay;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Delayed;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 消息体定义 实现Delayed接口就是实现两个方法即compareTo 和 getDelay最重要的就是getDelay方法，这个方法用来判断是否到期…… </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;  </span><br><span class="line">    <span class="keyword">private</span> String body; <span class="comment">// 消息内容  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> excuteTime;<span class="comment">// 延迟时长，这个是必须的属性因为要按照这个判断延时时长。  </span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> id;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBody</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> body;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExcuteTime</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> excuteTime;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">(<span class="keyword">int</span> id, String body, <span class="keyword">long</span> delayTime)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.id = id;  </span><br><span class="line">        <span class="keyword">this</span>.body = body;  </span><br><span class="line">        <span class="keyword">this</span>.excuteTime = TimeUnit.NANOSECONDS.convert(delayTime, TimeUnit.MILLISECONDS) + System.nanoTime();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 自定义实现比较方法返回 1 0 -1三个参数  </span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed delayed)</span> </span>&#123;  </span><br><span class="line">        Message msg = (Message) delayed;  </span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(<span class="keyword">this</span>.id) &gt; Integer.valueOf(msg.id) ? <span class="number">1</span>  </span><br><span class="line">                : (Integer.valueOf(<span class="keyword">this</span>.id) &lt; Integer.valueOf(msg.id) ? -<span class="number">1</span> : <span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 延迟任务是否到时就是按照这个方法判断如果返回的是负数则说明到期否则还没到期  </span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> unit.convert(<span class="keyword">this</span>.excuteTime - System.nanoTime(), TimeUnit.NANOSECONDS);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hsshy.beam.queue.delay;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.DelayQueue;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 延时队列 ,消费者从其中获取消息进行消费  </span></span><br><span class="line">    <span class="keyword">private</span> DelayQueue&lt;Message&gt; queue;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(DelayQueue&lt;Message&gt; queue)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.queue = queue;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                Message take = queue.take();  </span><br><span class="line">                System.out.println(<span class="string">&quot;消费消息id：&quot;</span> + take.getId() + <span class="string">&quot; 消息体：&quot;</span> + take.getBody());  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hsshy.beam.queue.delay;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.DelayQueue;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;  </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueTest</span> </span>&#123;  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">            <span class="comment">// 创建延时队列    </span></span><br><span class="line">            DelayQueue&lt;Message&gt; queue = <span class="keyword">new</span> DelayQueue&lt;Message&gt;();    </span><br><span class="line">            <span class="comment">// 添加延时消息,m1 延时3s    </span></span><br><span class="line">            Message m1 = <span class="keyword">new</span> Message(<span class="number">1</span>, <span class="string">&quot;world&quot;</span>, <span class="number">3000</span>);    </span><br><span class="line">            <span class="comment">// 添加延时消息,m2 延时10s    </span></span><br><span class="line">            Message m2 = <span class="keyword">new</span> Message(<span class="number">2</span>, <span class="string">&quot;hello&quot;</span>, <span class="number">10000</span>);    </span><br><span class="line">            <span class="comment">//将延时消息放到延时队列中  </span></span><br><span class="line">            queue.offer(m2);    </span><br><span class="line">            queue.offer(m1);    </span><br><span class="line">            <span class="comment">// 启动消费线程 消费添加到延时队列中的消息，前提是任务到了延期时间   </span></span><br><span class="line">            ExecutorService exec = Executors.newFixedThreadPool(<span class="number">1</span>);  </span><br><span class="line">            exec.execute(<span class="keyword">new</span> Consumer(queue));  </span><br><span class="line">            exec.shutdown();  </span><br><span class="line">        &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>【参考文献】：</p>
<p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://www.cnblogs.com/KingIceMou/p/8075343.html">https://www.cnblogs.com/KingIceMou/p/8075343.html</a><br><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=http://www.cnblogs.com/WangHaiMing/p/8798709.html">http://www.cnblogs.com/WangHaiMing/p/8798709.html</a><br><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://gitee.com/52itstyle/spring-boot-seckill">https://gitee.com/52itstyle/spring-boot-seckill</a></p>
<p><a target="_blank" rel="noopener" href="http://wsmajunfeng.iteye.com/blog/1629354">BlockingQueue（阻塞队列）详解</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ed2b56bcba3d">ArrayBlockingQueue源码解析</a></p>
<p><a target="_blank" rel="noopener" href="http://ifeve.com/java-blocking-queue/">Java中的阻塞队列</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/database/Redis/base/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/database/Redis/base/" class="post-title-link" itemprop="url">Redis</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-05-25 11:28:00" itemprop="dateCreated datePublished" datetime="2016-05-25T11:28:00+08:00">2016-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-09 09:38:26" itemprop="dateModified" datetime="2021-02-09T09:38:26+08:00">2021-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaWeb/" itemprop="url" rel="index"><span itemprop="name">JavaWeb</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>一致哈希</p>
<p>构建一个存储数据集群的关键是有一个有效的数据存储和复制机制。我希望<font color="#FF0000">通过一个行之有效的方法来说明建造一个数据集群，在这个过程中你可以随意添加或移除一个Redis节点，同时保证你的数据仍然存在，而不会消失。这个方法称为一致哈希</font></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>String：缓存、限流、计数器、分布式锁、分布式Session</li>
<li>Hash：存储用户信息、用户主页访问量、组合查询</li>
<li>List：微博关注人时间轴列表、简单队列</li>
<li>Set：赞、踩、标签、好友关系</li>
<li>Zset：排行榜</li>
</ul>
<p>IO多路复用</p>
<p>I/O多路复用技术，是为了解决进程或线程阻塞到某个I/O系统调用而出现的技术，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪，就是这个文件描述符进行读写操作之前），能够通知程序进行相应的读写操作。</p>
<p>在Redis中一个字符串最大的容量为512MB</p>
<p>对于Hash结构存储，由于Hash结构会在单个Hash元素在不足一定数量时进行压缩存储，所以可以大量节约内存。这一点在String结构里是不存在的。</p>
<p><strong>数据一致性</strong></p>
<p>真正意义上来讲数据库的数据和缓存的数据是不可能一致的，数据分为最终一致和强一致两类。如果业务中对数据的要求必须强一致那么就不能使用缓存。缓存能做的只能保证数据的最终一致性。</p>
<p>我们能做的只能是尽可能地保证数据的一致性。不管是先删库再删缓存还是先删缓存再删库，都可能出现数据不一致的情况，因为读和写操作是并发的，</p>
<p><strong>Redis的过期和内存淘汰</strong></p>
<p>Redis存储数据时我们可以设置他的过期时间。</p>
<p>Redis过期删除采用的是定期删除，默认是每100ms检测一次，遇到过期的Key则进行删除，这里的检测并不是顺序检测，而是随机检测。</p>
<p>那这样会不会有漏网之鱼？显然Redis也考虑到了这一点，当我们去读/写一个已经过期的Key时，会触发Redis的惰性删除策略，直接回干掉过期的Key。</p>
<p>内存淘汰是指用户存储的一部分Key是可以被Redis自动的删除，从而会出现从缓存中查不到数据的情况。加入我们的服务器内存为2G、但是随着业务的发展缓存的数据已经超过2G了。</p>
<p>但是这并不影响我们程序的运行，因为操作系统的可见内存并不受物理内存的限制。物理内存不够用没关系，计算机会从硬盘中划出一片空间来作为虚拟内存。这就是Redis设计两种应用场景的初衷：缓存、持久存储。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p><strong>解决方案：</strong></p>
<p>1、后台设置定时任务，主动地去更新缓存数据。这种方案容易理解，但是当Key比较分散的时候，操作起来还是比较复杂的。</p>
<p>2、分级缓存。比如设置两层缓存保护层，1级缓存失效时间短，2级缓存失效时间长。有请求过来优先从1级缓存中去查找，如果在1级缓存中没有找到相应数据，则对该线程进行加锁，这个线程再从数据库中取到数据，更新至1级和2级缓存。其他线程则直接从2级线程中获取。</p>
<p>3、提供一个拦截机制，内部维护一系列合法的Key值。当请求的Key不合法时，直接返回。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p><strong>如何避免雪崩：</strong></p>
<p>1、给缓存加上一定区间内的随机生效时间，不同的Key设置不同的失效时间，避免同一时间集体失效。</p>
<p>2、和缓存击穿解决方案类似，做二级缓存，原始缓存失效时从拷贝缓存中读取数据。</p>
<p>3、利用加锁或者队列方式避免过多请求同时对服务器进行读写操作。</p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>Redis的性能极高，读的速度是110000次/s，写的速度是81000次/s，支持事务，支持备份，丰富的数据类型。</p>
<p>任何事情都是两面性，Redis也是有缺点的：</p>
<p>1、由于是内存数据库，所以单台机器存储的数据量是有限的，需要开发者提前预估，需要及时删除不需要的数据。</p>
<p>2、当修改Redis的数据之后需要将持久化到硬盘的数据重新加入到内容中，时间比较久，这个时候Redis是无法正常运行的。</p>
<h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><h3 id="生产环境禁用命令"><a href="#生产环境禁用命令" class="headerlink" title="生产环境禁用命令"></a>生产环境禁用命令</h3><h4 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 禁止使用Keys正则匹配</span></span><br><span class="line">keys * wxdb（此处省略）cf8*</span><br></pre></td></tr></table></figure>
<p>1、redis是单线程的，其所有操作都是原子的，不会因并发产生数据异常；</p>
<p>2、使用高耗时的Redis命令是很危险的，会占用唯一的一个线程的大量处理时间，导致所有的请求都被拖慢。（例如时间复杂度为O(N)的KEYS命令，严格禁止在生产环境中使用）；</p>
<ul>
<li>运维人员进行keys *操作，该操作比较耗时，又因为redis是单线程的，所以redis被锁住；</li>
<li>此时QPS比较高，又来了几万个对redis的读写请求，因为redis被锁住，所以全部Hang在那；</li>
<li>因为太多线程Hang在那，CPU严重飙升，造成redis所在的服务器宕机；</li>
<li>所有的线程在redis那取不到数据，一瞬间全去数据库取数据，数据库就宕机了；</li>
</ul>
<h4 id="flushdb-flushall-config"><a href="#flushdb-flushall-config" class="headerlink" title="flushdb flushall config"></a>flushdb flushall config</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flushdb 清空当前数据库的所有的key</span><br><span class="line">flushall 清空整个redis服务器的所有的key</span><br><span class="line">config 客户端连接后可配置服务器</span><br></pre></td></tr></table></figure>
<p>禁用命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rename-command FLUSHALL &quot;&quot;</span><br><span class="line">rename-command FLUSHDB &quot;&quot;</span><br><span class="line">rename-command CONFIG &quot;&quot;</span><br><span class="line">rename-command KEYS &quot;&quot;</span><br></pre></td></tr></table></figure>
<p>对于FLUSHALL命令，需要设置配置文件中appendonly no，否则服务器是无法启动。</p>
<p>时间复杂度高于O(N)的命令: hgetall、lrange、smembers、zrange、sinter等，它们并非不能使用，但这些命令的时间复杂度都为O(N)，使用这些命令需要明确N的值，否则也会出现缓存宕机。</p>
<p>Redis2.8版本以后有了一个新命令scan，可以用来分批次扫描redis记录，这样肯定会导致整个查询消耗的总时间变大，但不会影响redis服务卡顿，影响服务使用。</p>
<p><strong>分层架构设计，有一条准则</strong>：站点层、服务层要做到无数据无状态，这样才能任意的加节点水平扩展，数据和状态尽量存储到后端的数据存储服务，例如数据库服务或者缓存服务。</p>
<h2 id="Redis-or-Memcached"><a href="#Redis-or-Memcached" class="headerlink" title="Redis or Memcached"></a>Redis or Memcached</h2><p>value是哈希，列表，集合，有序集合这类复杂的数据结构时，会选择redis，因为mc无法满足这些需求，最典型的场景，用户订单列表，用户消息，帖子评论列表等。</p>
<p>Redis支持持久化</p>
<p>千万不要把redis当作数据库用：</p>
<p>（1）redis的定期快照不能保证数据不丢失</p>
<p>（2）redis的AOF会降低效率，并且不能支持太大的数据量</p>
<p><strong>缓存场景，开启固化功能，有什么利弊？</strong></p>
<p>如果只是缓存场景，数据存放在数据库，缓存在redis，此时如果开启固化功能： </p>
<p><strong>优点</strong>是，redis挂了再重启，内存里能够快速恢复热数据，不会瞬时将压力压到数据库上，没有一个cache预热的过程。</p>
<p><strong>缺点</strong>是，在redis挂了的过程中，如果数据库中有数据的修改，可能导致redis重启后，数据库与redis的数据不一致。</p>
<p>redis天然支持集群功能，可以实现主动复制，读写分离。</p>
<p>redis官方也提供了sentinel集群管理工具，能够实现主从服务监控，故障自动转移，这一切，对于客户端都是透明的，无需程序改动，也无需人工介入。</p>
<p>memcache的value存储，最大为1M，如果存储的value很大，只能使用redis</p>
<p><strong>什么时候倾向于memcache？</strong></p>
<p>纯KV，数据量非常大，并发量非常大的业务，使用memcache或许更适合。</p>
<p><strong>内存分配</strong></p>
<p>memcache使用预分配内存池的方式管理内存，能够省去内存分配时间。Redis则是临时申请空间，可能导致碎片。mc会更快一些。</p>
<p><strong>虚拟内存使用</strong></p>
<p>memcache把所有的数据存储在物理内存里。redis有自己的VM机制，理论上能够存储比物理内存更多的数据，当数据超量时，会引发swap，把冷数据刷到磁盘上。数据量大时，mc会更快一些。</p>
<p><strong>网络模型</strong></p>
<p>memcache使用非阻塞IO复用模型，redis也是使用非阻塞IO复用模型。但由于redis还提供一些非KV存储之外的排序，聚合功能，在执行这些功能时，复杂的CPU计算，会阻塞整个IO调度。</p>
<p>由于redis提供的功能较多，mc会更快一些。 </p>
<p><strong>线程模型</strong></p>
<p>memcache使用多线程，主线程监听，worker子线程接受请求，执行读写，这个过程中，可能存在锁冲突。redis使用单线程，虽无锁冲突，但难以利用多核的特性提升整体吞吐量。</p>
<p>从这一点上，mc会快一些。</p>
<p><em>画外音：理论上，mc只支持kv，而redis支持了这么多功能，mc性能应该高非常多非常多，但实际并非如此，真的可能和代码质量有关。</em></p>
<p><strong>水平扩展的支持</strong></p>
<p>不管是mc和redis，服务端集群没有天然支持水平扩展，需要在客户端进行分片，这其实对调用方并不友好。如果能服务端集群能够支持水平扩展，会更完美一些。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/io/IO-Model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/io/IO-Model/" class="post-title-link" itemprop="url">IO模式(IO Model)与高性能IO设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-05-12 17:28:00" itemprop="dateCreated datePublished" datetime="2016-05-12T17:28:00+08:00">2016-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-09 09:38:26" itemprop="dateModified" datetime="2021-02-09T09:38:26+08:00">2021-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="/Java/advanced-engineer-outline/">&lt;&lt; Java高级软件工程师知识结构</a></p>
<ol>
<li>掌握InputStream、OutputStream、Reader、Writer的继承体系.</li>
<li>掌握字节流(FileInputStream、DataInputStream、BufferedInputStream、FileOutputSteam、DataOutputStream、BufferedOutputStream)和 字符流(BufferedReader、InputStreamReader、FileReader、BufferedWriter、OutputStreamWriter、PrintWriter、FileWriter), 并熟练运用.</li>
<li>掌握NIO实现原理及使用方法.</li>
</ol>
<p>Java IO包括:</p>
<ul>
<li><a href="/Java/io/IO-Model/">IO Model</a></li>
<li><a href="/Java/io/BIO/">Java BIO</a></li>
<li><a href="/Java/io/NIO/">Java NIO</a></li>
<li><a href="/Java/io/AIO/">Java AIO</a></li>
<li><a href="/Java/io/java-zip/">Java压缩</a></li>
<li><a href="/Java/io/object-serialization/">Java序列化</a></li>
<li><a href="/Java/io/java-XML-JSON/">Java XML与JSON</a></li>
</ul>
<h1 id="IO模式"><a href="#IO模式" class="headerlink" title="IO模式"></a>IO模式</h1><p>IO模式可以分为:</p>
<ul>
<li>blocking IO 阻塞IO</li>
<li>nonblocking IO 非阻塞IO</li>
<li>IO multiplexing IO多路复用</li>
<li>asynchronous IO 异步IO</li>
</ul>
<p>所有的系统I/O都分为两个阶段：等待就绪和操作。举例来说，读函数分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。</p>
<p>需要说明的是等待就绪的阻塞是不使用CPU的，是在“空等”；而真正的读写操作的阻塞是使用CPU的，真正在”干活”，而且这个过程非常快，属于memory copy，带宽通常在1GB/s级别以上，可以理解为基本不耗时。</p>
<p>对于一个network IO (这里我们以read举例), 它会涉及到两个系统对象,<br>一个是调用这个IO的process (or thread), 另一个就是系统内核(kernel).<br>当一个read操作发生时, 它会经历两个阶段：</p>
<ol>
<li>等待数据准备 (Waiting for the data to be ready)</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
</ol>
<p>这些IO Model的区别就是在两个阶段上各有不同的情况.</p>
<h2 id="阻塞IO-blocking-IO"><a href="#阻塞IO-blocking-IO" class="headerlink" title="阻塞IO(blocking IO)"></a>阻塞IO(blocking IO)</h2><p><img src="/images/java/io/model/blocking.png" alt="b"></p>
<p>当用户进程调用了recvfrom这个系统调用, kernel就开始了IO的第一个阶段：准备数据. 对于network io来说, 很多时候数据在一开始还没有到达（比如, 还没有收到一个完整的UDP包）, 这个时候kernel就要等待足够的数据到来. 而在用户进程这边, 整个进程会被阻塞. 当kernel一直等到数据准备好了, 它就会将数据从kernel中拷贝到用户内存, 然后kernel返回结果, 用户进程才解除block的状态, 重新运行起来.</p>
<p>所以, blocking IO的特点就是在IO执行的两个阶段都被block了.</p>
<h2 id="非阻塞IO-nonblocking-IO"><a href="#非阻塞IO-nonblocking-IO" class="headerlink" title="非阻塞IO(nonblocking IO)"></a>非阻塞IO(nonblocking IO)</h2><p><img src="/images/java/io/model/noblocking.png" alt="n"></p>
<p>当用户进程发出read操作时, 如果kernel中的数据还没有准备好, 那么它并不会block用户进程, 而是立刻返回一个error. 从用户进程角度讲 , 它发起一个read操作后, 并不需要等待, 而是马上就得到了一个结果. 用户进程判断结果是一个error时, 它就知道数据还没有准备好, 于是它可以再次发送read操作. 一旦kernel中的数据准备好了, 并且又再次收到了用户进程的system call, 那么它马上就将数据拷贝到了用户内存, 然后返回.</p>
<p>所以, 用户进程其实是需要不断的主动询问kernel数据好了没有.</p>
<h2 id="IO多路复用-IO-multiplexing"><a href="#IO多路复用-IO-multiplexing" class="headerlink" title="IO多路复用(IO multiplexing)"></a>IO多路复用(IO multiplexing)</h2><p><img src="/images/java/io/model/ioMultiplexing.png" alt="m"></p>
<p>IO multiplexing就是<code>select/epoll</code>, 也称为<code>event driven IO</code>. <code>select/epoll</code> 的好处就在于单个process就可以同时处理多个网络连接的IO. 它的基本原理就是<code>select/epoll</code> 这个function会不断的轮询所负责的所有socket, 当某个socket有数据到达了, 就通知用户进程. 当用户进程调用了select, 那么整个进程会被block, 而同时, kernel会“监视”所有select负责的socket, 当任何一个socket中的数据准备好了, <code>select</code>就会返回. 这个时候用户进程再调用read操作, 将数据从kernel拷贝到用户进程.</p>
<p>这个图和blocking IO的图其实并没有太大的不同, 事实上, 还更差一些. 因为这里需要使用两个system call (select 和 recvfrom), 而blocking IO只调用了一个system call (recvfrom). 但是, 用select的优势在于它可以同时处理多个connection. （多说一句. 所以, 如果处理的连接数不是很高的话, 使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好, 可能延迟还更大. select/epoll的优势并不是对于单个连接能处理得更快, 而是在于能处理更多的连接. ）</p>
<p>在<code>IO multiplexing Model</code>中, 实际中, 对于每一个socket, 一般都设置成为non-blocking, 但是, 如上图所示, 整个用户的process其实是一直被block的. 只不过process是被<code>select</code>这个函数block, 而不是被<code>socket IO</code>给block.</p>
<h2 id="异步IO-asynchronous-IO"><a href="#异步IO-asynchronous-IO" class="headerlink" title="异步IO(asynchronous IO)"></a>异步IO(asynchronous IO)</h2><p><img src="/images/java/io/model/asynchronousIO.png" alt="a"><br>用户进程发起read操作之后, 立刻就可以开始去做其它的事. 而另一方面, 从kernel的角度, 当它收到一个asynchronous read之后, 首先它会立刻返回, 所以不会对用户进程产生任何block. 然后, kernel会等待数据准备完成, 然后将数据拷贝到用户内存, 当这一切都完成之后, kernel会给用户进程发送一个signal, 告诉它read操作完成了.</p>
<h2 id="四种模式比较"><a href="#四种模式比较" class="headerlink" title="四种模式比较"></a>四种模式比较</h2><p><img src="/images/java/io/model/comparison.png" alt="1"><br><img src="/images/java/io/model/comparison2.jpg" alt="2"></p>
<p>在Java中，以socket.read()为例子：</p>
<ol>
<li>传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。</li>
<li>对于NIO，如果TCP RecvBuffer有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。</li>
<li>最新的AIO(Async I/O)里面会更进一步：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。</li>
</ol>
<p>换句话说，<br>BIO里用户最关心“我要读”，NIO里用户最关心”我可以读了”，在AIO模型里用户更需要关注的是“读完了”。<br>NIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的（消耗CPU但性能非常高）。</p>
<p><strong>blocking vs non-blocking</strong></p>
<p>调用blocking IO会一直block住对应的进程直到操作完成, 而non-blocking IO 在kernel还准备数据的情况下会立刻返回.</p>
<p><strong>synchronous IO vs asynchronous IO</strong></p>
<p>Stevens给出的定义（其实是POSIX的定义）是这样子的：</p>
<ul>
<li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</li>
<li>An asynchronous I/O operation does not cause the requesting process to be blocked;</li>
</ul>
<p><code>synchronous IO</code>做”IO operation”的时候会将process阻塞. 按照这个定义, 之前所述的blocking IO, non-blocking IO, IO multiplexing都属于synchronous IO. 有人可能会说, non-blocking IO并没有被block啊. 这里有个非常“狡猾”的地方, 定义中所指的”IO operation”是指真实的IO操作, 就是例子中的recvfrom这个system call. non-blocking IO在执行recvfrom这个system call的时候, 如果kernel的数据没有准备好, 这时候不会block进程. 但是, 当kernel中数据准备好的时候, recvfrom会将数据从kernel拷贝到用户内存中, 这个时候进程是被block了, 在这段时间内, 进程是被block的. 而asynchronous IO则不一样, 当进程发起IO 操作之后, 就直接返回再也不理睬了, 直到kernel发送一个信号, 告诉进程说IO完成. 在这整个过程中, 进程完全没有被block.</p>
<p><strong>non-blocking IO vs asynchronous IO</strong></p>
<p>在non-blocking IO中, 虽然进程大部分时间都不会被block, 但是它仍然要求进程去主动的check, 并且当数据准备完成以后, 也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存. 而asynchronous IO则完全不同. 它就像是用户进程将整个IO操作交给了他人（kernel）完成, 然后他人做完后发信号通知. 在此期间, 用户进程不需要去检查IO操作的状态, 也不需要主动的去拷贝数据.</p>
<p>最后, 再举几个不是很恰当的例子来说明这四个IO Model<br>有A, B, C, D四个人在钓鱼：<br>A用的是最老式的鱼竿, 所以呢, 得一直守着, 等到鱼上钩了再拉杆;<br>B的鱼竿有个功能, 能够显示是否有鱼上钩, 所以呢, B就和旁边的MM聊天, 隔会再看看有没有鱼上钩, 有的话就迅速拉杆;<br>C用的鱼竿和B差不多, 但他想了一个好办法, 就是同时放好几根鱼竿, 然后守在旁边, 一旦有显示说鱼上钩了, 它就将对应的鱼竿拉起来;<br>D是个有钱人, 干脆雇了一个人帮他钓鱼, 一旦那个人把鱼钓上来了, 就给D发个短信.</p>
<h1 id="IO设计模式"><a href="#IO设计模式" class="headerlink" title="IO设计模式"></a>IO设计模式</h1><blockquote>
<p>FIXME reactor和proactor模式详细</p>
</blockquote>
<h2 id="Reactor"><a href="#Reactor" class="headerlink" title="Reactor"></a>Reactor</h2><p><a target="_blank" rel="noopener" href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">Doug Lea《scalable IO in Java》</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/fxjwind/p/3363329.html">中文解读</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/doit8791/p/7461479.html">another</a></p>
<p><img src="/images/java/io/model/reactor.png"></p>
<p>首先来看看Reactor模式, Reactor模式应用于同步I/O的场景. 我们以读操作为例来看看Reactor中的具体步骤：<br>读取操作：</p>
<ol>
<li>应用程序注册读就绪事件和相关联的事件处理器</li>
<li>事件分离器等待事件的发生</li>
<li>当发生读就绪事件的时候, 事件分离器调用第一步注册的事件处理器</li>
<li>事件处理器首先执行实际的读取操作, 然后根据读取到的内容进行进一步的处理</li>
</ol>
<h2 id="Proactor"><a href="#Proactor" class="headerlink" title="Proactor"></a>Proactor</h2><p><img src="/images/java/io/model/proactor.png"></p>
<p>读取操作：</p>
<ol>
<li>应用程序初始化一个异步读取操作, 然后注册相应的事件处理器, 此时事件处理器不关注读取就绪事件, 而是关注读取完成事件, 这是区别于Reactor的关键.</li>
<li>事件分离器等待读取操作完成事件</li>
<li>在事件分离器等待读取操作完成的时候, 操作系统调用内核线程完成读取操作, 并将读取的内容放入用户传递过来的缓存区中. 这也是区别于Reactor的一点, Proactor中, 应用程序需要传递缓存区.</li>
<li>事件分离器捕获到读取完成事件后, 激活应用程序注册的事件处理器, 事件处理器直接从缓存区读取数据, 而不需要进行实际的读取操作.</li>
</ol>
<p>Proactor中写入操作和读取操作, 只不过感兴趣的事件是写入完成事件.</p>
<p>从上面可以看出, Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的, Reactor中需要应用程序自己读取或者写入数据, 而Proactor模式中, 应用程序不需要进行实际的读写过程, 它只需要从缓存区读取或者写入即可, 操作系统会读取缓存区或者写入缓存区到真正的IO设备</p>
<h2 id="IO设计模式比较"><a href="#IO设计模式比较" class="headerlink" title="IO设计模式比较"></a>IO设计模式比较</h2><p><strong>主动和被动</strong></p>
<p>Reactor被动的等待指示事件的到来并做出反应;它有一个等待的过程, 做什么都要先放到监听事件集<br>合中等待handler可用时再进行操作;Proactor直接调用异步读写操作, 调用完后立刻返回;<br>实现<br>Reactor实现了一个被动的事件分离和分发模型, 服务等待请求事件的到来, 再通过不受间断的同步处<br>理事件, 从而做出反应;<br>Proactor实现了一个主动的事件分离和分发模型;这种设计允许多个任务并发的执行, 从而提高吞吐<br>量;并可执行耗时长的任务（各个任务间互不影响）</p>
<p><strong>优点</strong></p>
<p>Reactor实现相对简单, 对于耗时短的处理场景处理高效;<br>操作系统可以在多个事件源上等待, 并且避免了多线程编程相关的性能开销和编程复杂性;<br>事件的串行化对应用是透明的, 可以顺序的同步执行而不需要加锁;<br>事务分离：将与应用无关的多路分解和分配机制和与应用相关的回调函数分离开来,<br>Proactor性能更高, 能够处理耗时长的并发场景;</p>
<p><strong>缺点</strong></p>
<p>Reactor处理耗时长的操作会造成事件分发的阻塞, 影响到后续事件的处理;<br>Proactor实现逻辑复杂;依赖操作系统对异步的支持, 目前实现了纯异步操作的操作系统少, 实现优秀<br>的如windows IOCP, 但由于其windows系统用于服务器的局限性, 目前应用范围较小;而Unix/Linux<br>系统对纯异步的支持有限, 应用事件驱动的主流还是通过select/epoll来实现;</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ul>
<li><p>BIO方式适用于连接数目比较小且固定的架构, 这种方式对服务器资源要求比较高, 并发局限于应用中, JDK1.4以前的唯一选择, 但程序直观简单易理解.</p>
</li>
<li><p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构, 比如聊天服务器, 并发局限于应用中, 编程比较复杂, JDK1.4开始支持.</p>
</li>
<li><p>AIO方式使用于连接数目多且连接比较长（重操作）的架构, 比如相册服务器, 充分调用OS参与并发操作, 编程比较复杂, JDK7开始支持.</p>
</li>
</ul>
<hr>
<p>[参考文献]:</p>
<ol>
<li>Think in Java</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/io/BIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/io/BIO/" class="post-title-link" itemprop="url">Java IO</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-05-12 17:28:00" itemprop="dateCreated datePublished" datetime="2016-05-12T17:28:00+08:00">2016-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-09 09:38:26" itemprop="dateModified" datetime="2021-02-09T09:38:26+08:00">2021-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="/Java/advanced-engineer-outline/">&lt;&lt; Java高级软件工程师知识结构</a></p>
<ol>
<li>掌握InputStream、OutputStream、Reader、Writer的继承体系。</li>
<li>掌握字节流(FileInputStream、DataInputStream、BufferedInputStream、FileOutputSteam、DataOutputStream、BufferedOutputStream)和 字符流(BufferedReader、InputStreamReader、FileReader、BufferedWriter、OutputStreamWriter、PrintWriter、FileWriter)，并熟练运用。</li>
<li>掌握NIO实现原理及使用方法。</li>
</ol>
<p>Java IO包括:</p>
<ul>
<li><a href="/Java/io/IO-Model/">IO Model</a></li>
<li><a href="/Java/io/BIO/">Java BIO</a></li>
<li><a href="/Java/io/NIO/">Java NIO</a></li>
<li><a href="/Java/io/AIO/">Java AIO</a></li>
<li><a href="/Java/io/java-zip/">Java压缩</a></li>
<li><a href="/Java/io/object-serialization/">Java序列化</a></li>
<li><a href="/Java/io/java-XML-JSON/">Java XML与JSON</a></li>
</ul>
<p>本文介绍的是Java IO的基础部分, 也叫作<code>BIO</code>.</p>
<h1 id="Java-IO-继承关系"><a href="#Java-IO-继承关系" class="headerlink" title="Java IO 继承关系"></a>Java IO 继承关系</h1><p>java.io包中包含了一系列的<code>Java IO</code>相关的类和接口：</p>
<p><img src="/images/java/io/java-io-package.png"></p>
<ul>
<li>File 文件类</li>
<li>FileDescriptor 文件描述类</li>
<li>InputStream 字节流输入抽象类</li>
<li>OutputStream 字节流输出抽象类</li>
<li>Reader 字符流输入抽象类</li>
<li>Writer 字符流输出抽象类</li>
<li>RandomAccessFile随机访问文件类 不是InputStream或者OutputStream继承层次的一部分，除了实现了DataInput和DataOutput接口（DataInputStream和DataOutputStream也实现这两个接口）外, 他和这两个继承层次没任何关系。甚至不使用InputStream和OutputStream类中的任何功能。完全是独立的类，RandomAccessFile拥有和别的IO类型本质完全不同的行为，可以在一个文件中向前和向后移动，因此重新编写了所有的方法。任何情况下都是相互独立的，直接从Object类派生而来。</li>
<li><ul>
<li>Console类,该类提供了用于读取密码的方法，可以禁止控制台回显并返回char数组，这两个特性对保证安全有作用，平时用的不多，了解就行。</li>
</ul>
</li>
<li><ul>
<li>StreamTokenizer 类，这个类非常有用，它可以把输入流解析为标记（token）, StreamTokenizer 并非派生自InputStream或者OutputStream，而是归类于io库中，因为StreamTokenizer只处理InputStream对象。</li>
</ul>
</li>
</ul>
<p>流，是编程语言的IO类库常用的概念， 所谓流是指任何有能力产出数据的数据源和任何有能力接收数据的接收端对象。”流”屏蔽了实际的IO设备中处理数据的细节。<br>Java中的流，根据处理数据类型的不同分为：字符流和字节流; 根据数据流向不同分为：输入流和输出流。可以通过类名的结尾来判断。</p>
<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p><a href="/Java/io/java-zip/">java中的压缩</a>都是面向字节的 (<code>java.util.zip</code>)。</p>
<h2 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h2><p>字节输入流都是继承于InputStream并且以InputStream结尾，InputStream表示从不同的数据源产生输入的类，这些数据源包括字节数组、String对象(StringBufferInputStream已经不再使用，需要转换为字节数组来实现)、文件、“管道”、其他种类的流组成的序列及其他数据源。每种数据源都有相应的 InputStream 子类，FilterInputStream也属于一种 InputStream， 为装饰器类提供基类，其中，“装饰器”类可以把属性或有用的接口与输入流连接在一起。<a href="/designPattern-Strategy/">装饰器模式</a></p>
<p><img src="/images/java/io/java-io-InputStream.png"></p>
<ol>
<li>PipedInputStream 作为多线程中的数据源，将其与FilterInputStream对象相连以提供有用接口</li>
<li><code>FilterInputStream</code> 类定义了一些方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span></span></span><br><span class="line"><span class="function">	在输入流中的当前位置上作标记。 </span></span><br><span class="line"><span class="function"> reset 方法的后续调用将此流重新定位在最后标记的位置上，</span></span><br><span class="line"><span class="function"> 以便后续读取操作重新读取相同的字节。</span></span><br><span class="line"><span class="function">	readlimit 参数告知此输入流在标记位置无效之前允许读取的字节数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span>  <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">	将此流重新定位到对此输入流最后调用 mark 方法时的位置。</span></span><br><span class="line"><span class="function">	此方法只执行 in.<span class="title">reset</span><span class="params">()</span>。</span></span><br><span class="line"><span class="function">	在需要提前读取一小部分数据以查看流中有什么的情况下，可以使用流的标记。</span></span><br><span class="line"><span class="function">	通过调用通用解析器常常最容易做到这一点。如果流属于通过解析处理的类型，那么解析起来就很容易。</span></span><br><span class="line"><span class="function">	如果流不属于那种类型，那么解析器应该在解析失败时抛出一个异常。</span></span><br><span class="line"><span class="function">	如果这发生在 readlimit 个字节内，那么它允许外部代码重置流，并尝试另一种解析器。</span></span><br></pre></td></tr></table></figure></li>
<li>除了DataInputStream以外的FilterInputStream类在内部修改了InputStream的行为方式，是否缓冲，是否记录读过的行，以及是否把单一字符推回输入流等。</li>
</ol>
<h2 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h2><p>接收端对象包括字节数组(但不是String)、文件或者管道。<br>字节输出流都是继承于OutputStream并以OutputStream结尾</p>
<p><img src="/images/java/io/java-io-OutputStream.png"></p>
<p>字节输入流和输出流的对应关系</p>
<p><img src="/images/java/io/InputStream-OutputStream-match.png"></p>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>字节流仅支持8位字节流，不能很好的处理16位的Unicode字符，<code>Reader</code>和<code>Writer</code>提供了兼容Unicode与面向字符的I/O功能，可以方便的实现国际化。</p>
<h2 id="Reader-字符输入流"><a href="#Reader-字符输入流" class="headerlink" title="Reader 字符输入流"></a>Reader 字符输入流</h2><p>读取字符序列的类都是继承于Reader并且以Reader结尾</p>
<p><img src="/images/java/io/java-io-Reader.png"></p>
<h2 id="Writer-字符输出流"><a href="#Writer-字符输出流" class="headerlink" title="Writer 字符输出流"></a>Writer 字符输出流</h2><p>写入字符流的类都是继承于Writer并且以Writer结尾</p>
<p><img src="/images/java/io/java-io-Writer.png"></p>
<ol>
<li>FilterWriter形同虚设： BufferedWriter并不是FilterWriter的子类，尽管FilterWriter是抽象类。没有任何子类。</li>
<li>CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据。PipedWriter 是向与其它线程共用的管道中写入数据</li>
<li>PrintWriter 和 PrintStream 极其类似，功能和使用也非常相似。</li>
<li>OutputStreamWriter 是OutputStream 到Writer 转换的桥梁</li>
</ol>
<p>字符输入流与字符输出流的对应关系</p>
<p><img src="/images/java/io/Reader-Writer-match.png"></p>
<h2 id="字节流与字符流的对应关系"><a href="#字节流与字符流的对应关系" class="headerlink" title="字节流与字符流的对应关系"></a>字节流与字符流的对应关系</h2><p><img src="/images/java/io/%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png"></p>
<p><img src="/images/java/io/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png"></p>
<h2 id="字节流与字符流的区别"><a href="#字节流与字符流的区别" class="headerlink" title="字节流与字符流的区别"></a>字节流与字符流的区别</h2><p>把一片二进制数据数据逐一输出到某个设备中，或者从某个设备中逐一读取一片二进制数据，不管输入输出设备是什么，我们要用统一的方式来完成这些操作，用一种抽象的方式进行描述，这个抽象描述方式起名为IO流，对应的抽象类为OutputStream和InputStream ，不同的实现类就代表不同的输入和输出设备，它们都是针对字节进行操作的。</p>
<p>在应用中，经常要完全是字符的一段文本输出去或读进来，用字节流可以吗？计算机中的一切最终都是二进制的字节形式存在。对于“中国”这些字符，首先要得到其对应的字节，然后将字节写入到输出流。读取时，首先读到的是字节，可是我们要把它显示为字符，我们需要将字节转换成字符。由于这样的需求很广泛，人家专门提供了字符流的包装类。</p>
<p>底层设备永远只接受字节数据，有时候要写字符串到底层设备，需要将字符串转成字节再进行写入。字符流是字节流的包装，字符流则是直接接受字符串，它内部将串转成字节，再写入底层设备，这为我们向IO设别写入或读取字符串提供了一点点方便。字符向字节转换时，要注意编码的问题，因为字符串转成字节数组，其实是转成该字符的某种编码的字节形式，读取也是反之的道理。</p>
<h1 id="字节流-1"><a href="#字节流-1" class="headerlink" title="字节流"></a>字节流</h1><h2 id="FileInputStream-文件输入流"><a href="#FileInputStream-文件输入流" class="headerlink" title="FileInputStream 文件输入流"></a>FileInputStream 文件输入流</h2><p>构造器只能接受File对象 File路径字符串或者 FileDescriptor对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">available</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     返回下一次对此输入流调用的方法可以不受阻塞地从此输入流读取（或跳过）的估计剩余字节数。</span></span><br><span class="line"><span class="function">FileDescriptor 	<span class="title">getFD</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     返回表示到文件系统中实际文件的连接的 FileDescriptor 对象，</span></span><br><span class="line"><span class="function">     该文件系统正被此 FileInputStream 使用。</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> 	<span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function">     从输入流中跳过并丢弃 n 个字节的数据。</span></span><br></pre></td></tr></table></figure>
<h2 id="FileOutputSteam-文件输出流"><a href="#FileOutputSteam-文件输出流" class="headerlink" title="FileOutputSteam 文件输出流"></a>FileOutputSteam 文件输出流</h2><p>文件输出流是用于将数据写入 File 或 FileDescriptor 的输出流。与字符流中的<code>FileWriter</code>对应.</p>
<h2 id="BufferedInputStream-缓冲输入流"><a href="#BufferedInputStream-缓冲输入流" class="headerlink" title="BufferedInputStream 缓冲输入流"></a>BufferedInputStream 缓冲输入流</h2><p>支持一次性读入多个字节</p>
<p>BufferedInputStream 为另一个输入流添加一些功能，即缓冲输入以及支持 mark 和 reset 方法的能力。<br>在创建 BufferedInputStream 时，会创建一个内部缓冲区数组。<br>在读取或跳过流中的字节时，可根据需要从包含的输入流再次填充该内部缓冲区，一次填充多个字节。</p>
<p>实现了FilterInputStream的<code>mark(int readLine)</code>方法</p>
<p>mark 操作记录输入流中的某个点，reset 操作使得在从包含的输入流中获取新字节之前，再次读取自最后一次 mark 操作后读取的所有字节。</p>
<p>构造器只能接受 InputStream</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">available</span><span class="params">()</span></span></span><br><span class="line"><span class="function">          返回可以从此输入流读取（或跳过）、且不受此输入流接下来的方法调用阻塞的估计字节数。</span></span><br></pre></td></tr></table></figure>

<h2 id="BufferedOutputStream-缓冲输出流"><a href="#BufferedOutputStream-缓冲输出流" class="headerlink" title="BufferedOutputStream 缓冲输出流"></a>BufferedOutputStream 缓冲输出流</h2><p>该类实现缓冲的字节输出流。通过设置这种输出流，应用程序就可以将各个字节写入底层输出流中，而不必针对每次字节写入调用底层系统。</p>
<p>BufferedOutputStream重写了OutputStream中的write方法,</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> off,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
<p>OutputStream写入多个字节时会逐个字节的调用单字节写入方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
<p>而 BufferedOutputStream 中的可以一次性将这些字节写入输出流, 因此效率比较高.</p>
<h2 id="DataInputStream-数据输入流"><a href="#DataInputStream-数据输入流" class="headerlink" title="DataInputStream 数据输入流"></a>DataInputStream 数据输入流</h2><p>DataInputStream几乎可以任何形式输出，而<code>readLine()</code>是唯一成不了首选的原因。</p>
<p>数据输出流允许应用程序以适当方式将基本 Java 数据类型写入输出流中。然后，应用程序可以使用数据输入流将数据读入。</p>
<p>使用DataInputStream写字符串并且能够通过DataInputStream恢复的唯一的方法是使用UTF-8编码</p>
<h2 id="DataOutputStream-数据输出流"><a href="#DataOutputStream-数据输出流" class="headerlink" title="DataOutputStream 数据输出流"></a>DataOutputStream 数据输出流</h2><p>不同的数据类型(基本数据类型和String对象)的读取方法都以<code>read</code>开头，如<code>readByte()</code>、<code>readFloat()</code>等</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DataOutputStream outputStream = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;abc.txt&quot;</span>)));</span><br><span class="line">outputStream.writeDouble(<span class="number">3.14159265358979</span>);</span><br><span class="line">outputStream.writeUTF(<span class="string">&quot;仅仅是测试&quot;</span>);</span><br><span class="line">outputStream.writeDouble(<span class="number">3.58979</span>);</span><br><span class="line">outputStream.writeUTF(<span class="string">&quot;不仅仅是测试&quot;</span>);</span><br><span class="line">outputStream.close();</span><br><span class="line"></span><br><span class="line">DataInputStream inputStream = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;abc.txt&quot;</span>)));</span><br><span class="line">System.out.println(inputStream.readDouble());</span><br><span class="line">System.out.println(inputStream.readUTF());</span><br><span class="line">System.out.println(inputStream.readDouble());</span><br><span class="line">System.out.println(inputStream.readUTF());</span><br><span class="line">inputStream.close();</span><br></pre></td></tr></table></figure>


<h1 id="字符流-1"><a href="#字符流-1" class="headerlink" title="字符流"></a>字符流</h1><h2 id="FileReader-文件输入字符流"><a href="#FileReader-文件输入字符流" class="headerlink" title="FileReader 文件输入字符流"></a>FileReader 文件输入字符流</h2><p>用来读取字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是适当的。<br>要自己指定这些值，可以先在 FileInputStream 上构造一个 InputStreamReader。<br>FileReader 用于读取字符流。要读取原始字节流，请考虑使用 FileInputStream。</p>
<h2 id="FileWriter-文件输出字符流"><a href="#FileWriter-文件输出字符流" class="headerlink" title="FileWriter 文件输出字符流"></a>FileWriter 文件输出字符流</h2><p>用来写入字符文件的便捷类。此类的构造方法假定默认字符编码和默认字节缓冲区大小都是可接受的。<br>要自己指定这些值，可以先在 FileOutputStream 上构造一个 OutputStreamWriter。</p>
<p>文件是否可用或是否可以被创建取决于底层平台。特别是某些平台一次只允许一个 FileWriter（或其他文件写入对象）打开文件进行写入。<br>在这种情况下，如果所涉及的文件已经打开，则此类中的构造方法将失败。</p>
<p>FileWriter 用于写入字符流。要写入原始字节流，请考虑使用 FileOutputStream。</p>
<h2 id="BufferedReader-缓冲字符输入流"><a href="#BufferedReader-缓冲字符输入流" class="headerlink" title="BufferedReader 缓冲字符输入流"></a>BufferedReader 缓冲字符输入流</h2><p>从<code>字符输入流</code>中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。<br>可以指定缓冲区的大小，或者可使用默认的大小。大多数情况下，默认值就足够大了。<br>通常，Reader 所作的每个读取请求都会导致对底层字符或字节流进行相应的读取请求。<br>因此，建议用 BufferedReader 包装所有其 read() 操作可能开销很高的 Reader（如 FileReader 和 InputStreamReader）。例如，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in</span><br><span class="line">   = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;foo.in&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>将缓冲指定文件的输入。如果没有缓冲，则每次调用 read() 或 readLine() 都会导致从文件中读取字节，并将其转换为字符后返回，而这是极其低效的。</p>
<p>通过用合适的 BufferedReader 替代每个 DataInputStream，可以对将 DataInputStream 用于文字输入的程序进行本地化。</p>
<p>主要的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String 	<span class="title">readLine</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	  读取一个文本行。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">ready</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	  判断此流是否已准备好被读取。</span></span><br></pre></td></tr></table></figure>
<h2 id="BufferedWriter-缓冲字符输出流"><a href="#BufferedWriter-缓冲字符输出流" class="headerlink" title="BufferedWriter 缓冲字符输出流"></a>BufferedWriter 缓冲字符输出流</h2><p>将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。<br>可以指定缓冲区的大小，或者接受默认的大小。在大多数情况下，默认值就足够大了。<br>该类提供了 newLine() 方法，它使用平台自己的行分隔符概念，此概念由系统属性 line.separator 定义。<br>并非所有平台都使用新行符 (‘\n’) 来终止各行。因此调用此方法来终止每个输出行要优于直接写入新行符。</p>
<p>通常 Writer 将其输出立即发送到底层字符或字节流。<br>除非要求提示输出，否则建议用 BufferedWriter 包装所有其 write() 操作可能开销很高的 Writer（如 FileWriters 和 OutputStreamWriters）。<br>例如，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;foo.out&quot;</span>)));</span><br></pre></td></tr></table></figure>
<p>将缓冲 PrintWriter 对文件的输出。如果没有缓冲，则每次调用 print() 方法会导致将字符转换为字节，然后立即写入到文件，而这是极其低效的。</p>
<h2 id="PrintWriter-打印输出字符流"><a href="#PrintWriter-打印输出字符流" class="headerlink" title="PrintWriter 打印输出字符流"></a>PrintWriter 打印输出字符流</h2><p>向文本输出流打印对象的格式化表示形式，支持写入各种格式的字符流。但不能写入字节流。</p>
<p>如果启用了自动刷新(<code>autoFlush</code>)，则只有在调用 println、printf 或 format 的其中一个方法时才可能完成此操作，而不是每当正好输出换行符时才完成。这些方法使用平台自有的行分隔符概念，而不是换行符。</p>
<p>为了更容易的过渡到使用<code>PrintWriter</code>，他提供了一个既能接受<code>Writer</code>对象又能接收<code>OutputStream</code>对象的构造器。<br>甚至提供了可以直接接收文件的构造器。</p>
<p>例如，基本文件输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;abc.text&quot;</span>)));</span><br><span class="line">PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(<span class="string">&quot;abc.text&quot;</span>); <span class="comment">//快捷方式</span></span><br></pre></td></tr></table></figure>
<p>构造器有:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter(File file)</span><br><span class="line">  使用指定文件创建不具有自动行刷新的新 PrintWriter。</span><br><span class="line">PrintWriter(File file, String csn)</span><br><span class="line">  创建具有指定文件和字符集且不带自动刷行新的新 PrintWriter。</span><br><span class="line">PrintWriter(OutputStream out)</span><br><span class="line">  根据现有的 OutputStream 创建不带自动行刷新的新 PrintWriter。</span><br><span class="line">PrintWriter(OutputStream out, <span class="keyword">boolean</span> autoFlush)</span><br><span class="line">  通过现有的 OutputStream 创建新的 PrintWriter。</span><br><span class="line">PrintWriter(String fileName)</span><br><span class="line">  创建具有指定文件名称且不带自动行刷新的新 PrintWriter。</span><br><span class="line">PrintWriter(String fileName, String csn)</span><br><span class="line">  创建具有指定文件名称和字符集且不带自动行刷新的新 PrintWriter。</span><br><span class="line">PrintWriter(Writer out)</span><br><span class="line">  创建不带自动行刷新的新 PrintWriter。</span><br><span class="line">PrintWriter(Writer out, <span class="keyword">boolean</span> autoFlush)</span><br><span class="line">  创建新 PrintWriter。</span><br></pre></td></tr></table></figure>
<p>构造PrintWriter的方式主要有： <code>File</code>或者文件名、<code>OutputStream</code>以及<code>Writer</code>.</p>
<p>主要的方法：</p>
<p>append方法将指定字符、字符序列和指定字符序列的子序列添加到此 writer。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PrintWriter 	<span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">PrintWriter 	<span class="title">append</span><span class="params">(CharSequence csq)</span></span></span><br><span class="line"><span class="function">PrintWriter 	<span class="title">append</span><span class="params">(CharSequence csq, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> 	<span class="title">println</span><span class="params">()</span> 通过写入行分隔符字符串终止当前行。</span></span><br></pre></td></tr></table></figure>
<p>PrintStream 存在两个重要的方法：<code>print</code>和<code>println</code>。对它们了重载，以便可打印出各种不同的类型。<br><code>print</code>可以打印的类型有 <code>boolean</code> <code>char</code> <code>char[]</code> <code>double</code> <code>float</code> <code>int</code> <code>long</code> <code>Object</code>和<code>String</code>.<br><code>println</code>的参数有<code>boolean</code> <code>char</code> <code>char[]</code> <code>double</code> <code>float</code> <code>int</code> <code>long</code> <code>Object</code>和<code>String</code>.</p>
<p><code>printf</code>、<code>format</code>和<code>write</code>可以打印更多的格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PrintWriter 	<span class="title">printf</span><span class="params">(Locale l, String format, Object... args)</span></span></span><br><span class="line"><span class="function">PrintWriter 	<span class="title">printf</span><span class="params">(String format, Object... args)</span></span></span><br><span class="line"><span class="function">PrintWriter 	<span class="title">format</span><span class="params">(Locale l, String format, Object... args)</span></span></span><br><span class="line"><span class="function">        使用指定格式字符串和参数将一个格式化字符串写入此 writer 中。</span></span><br><span class="line"><span class="function">PrintWriter 	<span class="title">format</span><span class="params">(String format, Object... args)</span></span></span><br><span class="line"><span class="function">        使用指定格式字符串和参数将一个格式化字符串写入此 writer 中。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> 	<span class="title">write</span><span class="params">(<span class="keyword">char</span>[] buf)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> 	<span class="title">write</span><span class="params">(<span class="keyword">char</span>[] buf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> 写入字符数组，字符数组的某一部分。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> 	<span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> 	<span class="title">write</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> 	<span class="title">write</span><span class="params">(String s, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">        写入单个字符、字符串及字符串的一部分。</span></span><br></pre></td></tr></table></figure>
<p>其他方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> 	<span class="title">checkError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        如果流没有关闭，则刷新流且检查其错误状态。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> 	<span class="title">setError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                指示已发生错误。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> 	<span class="title">clearError</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        清除此流的错误状态。</span></span><br></pre></td></tr></table></figure>



<h2 id="InputStreamReader-输入流转换器"><a href="#InputStreamReader-输入流转换器" class="headerlink" title="InputStreamReader 输入流转换器"></a>InputStreamReader 输入流转换器</h2><p>有时需要将字节流转换为字符流，为了实现这个目的，要用到<code>适配器(adapter)</code>类： <code>InputStreamReader</code>将<code>InputStream</code>转换为<code>Reader</code>； <code>OutputStreamWriter</code>将<code>OutputStream</code>转换为<code>Writer</code></p>
<h2 id="OutputStreamWriter-输出流转换器"><a href="#OutputStreamWriter-输出流转换器" class="headerlink" title="OutputStreamWriter 输出流转换器"></a>OutputStreamWriter 输出流转换器</h2><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h3><ol>
<li>PipedInputStream </li>
<li>PipedOutputStream </li>
<li>PipedReader </li>
<li>PipedWriter</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证管道流</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消息发送类</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Send</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> PipedOutputStream out=<span class="keyword">null</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       out = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> PipedOutputStream <span class="title">getOut</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.out;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">       String message = <span class="string">&quot;hello , Rollen&quot;</span>;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           out.write(message.getBytes());</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">try</span>&#123;</span><br><span class="line">           out.close();</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接受消息类</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Recive</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> PipedInputStream input=<span class="keyword">null</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Recive</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.input=<span class="keyword">new</span> PipedInputStream();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> PipedInputStream <span class="title">getInput</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.input;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1000</span>];</span><br><span class="line">       <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           len=<span class="keyword">this</span>.input.read(b);</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">try</span>&#123;</span><br><span class="line">           input.close();</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;接受的内容为 &quot;</span>+(<span class="keyword">new</span> String(b,<span class="number">0</span>,len)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hello</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       Send send=<span class="keyword">new</span> Send();</span><br><span class="line">       Recive recive=<span class="keyword">new</span> Recive();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//管道连接</span></span><br><span class="line">           send.getOut().connect(recive.getInput());</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">new</span> Thread(send).start();</span><br><span class="line">       <span class="keyword">new</span> Thread(recive).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SequenceInputStream"><a href="#SequenceInputStream" class="headerlink" title="SequenceInputStream"></a>SequenceInputStream</h3><p>SequenceInputStream可以认为是一个工具类，将两个或者多个输入流当成一个输入流依次读取。完全可以从IO 包中去除，还完全不影响IO 包的结构，却让其更“纯洁”――纯洁的Decorator 模式。<br>【案例】将两个文本文件合并为另外一个文本文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将两个文本文件合并为另外一个文本文件</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line">File file1 = newFile(<span class="string">&quot;d:&quot;</span> + File.separator + <span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line">File file2 = newFile(<span class="string">&quot;d:&quot;</span> + File.separator + <span class="string">&quot;hello2.txt&quot;</span>);</span><br><span class="line">File file3 = newFile(<span class="string">&quot;d:&quot;</span> + File.separator + <span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">InputStream input1 =<span class="keyword">new</span> FileInputStream(file1);</span><br><span class="line">InputStream input2 =<span class="keyword">new</span> FileInputStream(file2);</span><br><span class="line">OutputStream output =<span class="keyword">new</span> FileOutputStream(file3);</span><br><span class="line"><span class="comment">// 合并流</span></span><br><span class="line">SequenceInputStream sis = <span class="keyword">new</span> SequenceInputStream(input1, input2);</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((temp =sis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">   output.write(temp);</span><br><span class="line">&#125;</span><br><span class="line">input1.close();</span><br><span class="line">input2.close();</span><br><span class="line">output.close();</span><br><span class="line">sis.close();</span><br></pre></td></tr></table></figure>
<h1 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h1><p>支持搜寻方法，并且只适用于文件。</p>
<p>getFilePointer() 用于查找当前所处的文件位置，seek() 用于在文件内移至新的位置, length()用于判断文件的最大尺寸. 构造器支持在第二个参数中指示<code>随机读(r)</code>还是<code>读写(rw)</code>.但是不支持只写.<br>在JDK1.4后, RandomAccessFile的大多数功能由NIO存储映射文件所取代.</p>
<h2 id="断点下载"><a href="#断点下载" class="headerlink" title="断点下载"></a>断点下载</h2><blockquote>
<p>注意: </p>
<ol>
<li>使用 <code>FileWriter</code>、<code>BufferedOutputStream</code> 或者 <code>BufferedWriter</code> 写文件时，一定要清理缓冲区并且关闭输出流，否则会造成写入的内容丢失</li>
<li>使用字符流装饰字节流时，一定要都关闭掉</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>如何判断读到文件结尾? </li>
</ol>
</blockquote>
<ul>
<li>字符流: 每一个<code>Reader</code>都包含一个<code>ready()</code>方法，该方法用于判断IO是否准备完毕，但是不能是否读到文件的结尾。判断是否读到文件结尾要通过判断读入的内容是否为空判断。</li>
</ul>
<h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><h2 id="getPath-getAbsolutePath和getCanonicalPath"><a href="#getPath-getAbsolutePath和getCanonicalPath" class="headerlink" title="getPath getAbsolutePath和getCanonicalPath"></a>getPath getAbsolutePath和getCanonicalPath</h2><ul>
<li><code>public String getPath()</code> 获取为文件赋值时的路径名</li>
<li><code>public String getAbsolutePath()</code> 获取绝对路径名（包含<code>..</code>和<code>.</code>等字符）。</li>
<li><code>public String getCanonicalPath()throws IOException</code> 获取规范路径名(经过计算后的精简路径名)</li>
</ul>
<h3 id="getCanonicalPath"><a href="#getCanonicalPath" class="headerlink" title="getCanonicalPath()"></a>getCanonicalPath()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;D:\\Text.txt&quot;</span>);</span><br><span class="line">System.out.println(file.getCanonicalPath());</span><br></pre></td></tr></table></figure>
<p>Windows系统下<br>(1),确定D盘下没有Text.txt这个文件，直接执行这段代码，得到的结果是:<br><code>D:\Text.txt</code><br>注意这里试大写的Text.txt<br>(2)在D盘下建立一个文件，名叫text.txt，再次执行代码，得到结果<br><code>D:\text.txt</code></p>
<p>尝试在linux下执行上边的步骤，两次打印的结果是相同的，因为linux是大小写敏感的系统。</p>
<h2 id="遍历目录下的文件"><a href="#遍历目录下的文件" class="headerlink" title="遍历目录下的文件"></a>遍历目录下的文件</h2><ul>
<li>String[]     list()<pre><code>返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。</code></pre>
</li>
<li>String[] list(FilenameFilter filter)<pre><code>返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中满足指定过滤器的文件和目录。</code></pre>
</li>
<li>File[] listFiles()<pre><code>返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。</code></pre>
</li>
<li>File[] listFiles(FileFilter filter)<pre><code>返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</code></pre>
</li>
<li>File[] listFiles(FilenameFilter filter)<pre><code>返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。</code></pre>
</li>
</ul>
<p>上面的遍历方法中存在两个通过FilenameFilter和FileFilter过滤文件的方法。<br>这是<a href="/java-XML-JSON/">策略模式</a>的典型应用。<br>以<code>String[] list(FilenameFilter filter)</code>为例<br>list提供了基本的功能，而且按照FilenameFilter的形式提供策略，以便完善list在提供服务时所需的算法。因为list接受FilenameFilter对象作为参数， 任何实现了FilenameFilter接口的对象都可以传递给list方法，用以选择list方法的行为方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FilenameFilter</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File srcDir=<span class="keyword">new</span> File(<span class="string">&quot;~/testDir&quot;</span>);</span><br><span class="line">File[] files = srcDir.listFiles(</span><br><span class="line"> <span class="keyword">new</span> FilenameFilter()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name.endsWith(<span class="string">&quot;.java&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="设置指定权限"><a href="#设置指定权限" class="headerlink" title="设置指定权限"></a>设置指定权限</h2><h2 id="迭代创建目录"><a href="#迭代创建目录" class="headerlink" title="迭代创建目录"></a>迭代创建目录</h2><p><code>public boolean mkdirs()</code> 创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。注意，此操作失败时也可能已经成功地创建了一部分必需的父目录。</p>
<h2 id="文件系统根"><a href="#文件系统根" class="headerlink" title="文件系统根"></a>文件系统根</h2><p><code>public static File[] listRoots()</code></p>
<h1 id="样例模板"><a href="#样例模板" class="headerlink" title="样例模板"></a>样例模板</h1><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><p>无论使用任何方式打开文件或者流,必须准确的关闭, 标准的形式是在try-catch语句块的finally中关闭.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String fileName = <span class="string">&quot;abc.txt&quot;</span>;</span><br><span class="line">BufferedReader bufferedReader = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Reader reader = <span class="keyword">new</span> FileReader(fileName);</span><br><span class="line">    bufferedReader = <span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    String s;</span><br><span class="line">    <span class="keyword">while</span> ((s = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sb.append(s + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bufferedReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bufferedReader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>直接通过FileInputStream, 由于没有使用缓冲<code>BufferedInputStream</code>包装, 每次读取一组字节其实是在一个字节一个字节的从系统中读取.</p>
<h3 id="一次性读入字节数组"><a href="#一次性读入字节数组" class="headerlink" title="一次性读入字节数组"></a>一次性读入字节数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File f=<span class="keyword">new</span> File(fileName);</span><br><span class="line">InputStream in=<span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"><span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = in.read(b);</span><br><span class="line">in.close();</span><br><span class="line">String content = <span class="keyword">new</span> String(b,<span class="number">0</span>,len);</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File f=<span class="keyword">new</span> File(fileName);</span><br><span class="line">InputStream in=<span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"><span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[f.length()];</span><br><span class="line">in.read(b);</span><br><span class="line">in.close();</span><br><span class="line">String content = <span class="keyword">new</span> String(b);</span><br></pre></td></tr></table></figure>
<h3 id="逐个字节读"><a href="#逐个字节读" class="headerlink" title="逐个字节读"></a>逐个字节读</h3><p>FileInputStream的底层原理决定了和上面的读法是一样的<br>读取字节流时, 读到文件的末尾的时候会返回-1, 以此作为判断读取结束的依据.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">File f=<span class="keyword">new</span> File(fileName);</span><br><span class="line">InputStream in=<span class="keyword">new</span> FileInputStream(f);</span><br><span class="line"><span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((temp=in.read())!=(-<span class="number">1</span>))&#123;</span><br><span class="line">   b[count++]=(<span class="keyword">byte</span>)temp;</span><br><span class="line">&#125;</span><br><span class="line">in.close();</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(b));</span><br></pre></td></tr></table></figure>
<h3 id="加缓冲"><a href="#加缓冲" class="headerlink" title="加缓冲"></a>加缓冲</h3><p>使用<code>BufferedInputStream</code>包装输入流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File f=<span class="keyword">new</span> File(fileName);</span><br><span class="line">InputStream in=<span class="keyword">new</span> FileInputStream(f);</span><br><span class="line">BufferedInputStream bf = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line"><span class="keyword">byte</span>[] b=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = bf.read(b);</span><br><span class="line">in.close();</span><br><span class="line">String content = <span class="keyword">new</span> String(b,<span class="number">0</span>,len);</span><br></pre></td></tr></table></figure>
<h3 id="字符流读取"><a href="#字符流读取" class="headerlink" title="字符流读取"></a>字符流读取</h3><p>不加缓冲</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接通过字符流读文件 file可为File对象或者文件名String</span></span><br><span class="line">FileReader fileReader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line"><span class="keyword">char</span>[] content = <span class="keyword">new</span> <span class="keyword">char</span>[file.length()]; <span class="comment">// 调用该方法file必须为File对象</span></span><br><span class="line">fileReader.read(content);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(content));</span><br></pre></td></tr></table></figure>
<p>加缓冲</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建FileInputStream</span></span><br><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"><span class="comment">// 将字节流转换为字符流</span></span><br><span class="line">InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(fileInputStream);</span><br><span class="line"><span class="comment">// 给字符流加缓冲</span></span><br><span class="line">BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line">String s = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> ((s = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接通过字符流读文件 file可为File对象或者文件名String</span></span><br><span class="line">FileReader fileReader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line"><span class="comment">// 给字符流加缓冲</span></span><br><span class="line">BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line">String s;</span><br><span class="line"><span class="keyword">while</span> ((s = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">	System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><h3 id="字节流写文件"><a href="#字节流写文件" class="headerlink" title="字节流写文件"></a>字节流写文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OutputStream out =<span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">String str=<span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="keyword">byte</span>[] b=str.getBytes();</span><br><span class="line">out.write(b);</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OutputStream out =<span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">String str=<span class="string">&quot;Hello World！！&quot;</span>;</span><br><span class="line"><span class="keyword">byte</span>[] b=str.getBytes();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">   out.write(b[i]);</span><br><span class="line">&#125;</span><br><span class="line">out.close();</span><br></pre></td></tr></table></figure>
<h3 id="加缓冲-1"><a href="#加缓冲-1" class="headerlink" title="加缓冲"></a>加缓冲</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutputStream outputStream = <span class="keyword">new</span> FileOutputSteam(file);</span><br><span class="line">BufferedOutputStream bf = <span class="keyword">new</span> BufferedOutputStream(outputStream);</span><br><span class="line">bf.write(str.getBytes());</span><br></pre></td></tr></table></figure>
<h3 id="利用字节流写文件"><a href="#利用字节流写文件" class="headerlink" title="利用字节流写文件"></a>利用字节流写文件</h3><p>不加缓冲, 底层实现是逐个字符添加到系统文件中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileWriter fileWriter = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">bufferedWriter.write(<span class="string">&quot;Hellp world!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>加缓冲</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file为File对象 文件名字符串 FileDescriptor对象</span></span><br><span class="line">FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line"><span class="comment">// 字节流转换为字节流</span></span><br><span class="line">OutputStreamWriter outputStreamWriter = <span class="keyword">new</span> OutputStreamWriter(fileOutputStream);</span><br><span class="line"><span class="comment">// 加缓冲</span></span><br><span class="line">BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(outputStreamWriter);</span><br><span class="line">bufferedWriter.write(<span class="string">&quot;hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileWriter fileWriter = <span class="keyword">new</span> FileWriter(file);</span><br><span class="line">BufferedWriter bufferedWriter = <span class="keyword">new</span> BufferedWriter(fileWriter);</span><br><span class="line">bufferedWriter.write(<span class="string">&quot;Hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>


<h3 id="格式化字符输出"><a href="#格式化字符输出" class="headerlink" title="格式化字符输出"></a>格式化字符输出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;abc.text&quot;</span>)));</span><br><span class="line">PrintWriter printWriter = <span class="keyword">new</span> PrintWriter(<span class="string">&quot;abc.text&quot;</span>); <span class="comment">//快捷方式, 本身就已经添加了缓冲</span></span><br></pre></td></tr></table></figure>
<h2 id="内存中的字符串读取"><a href="#内存中的字符串读取" class="headerlink" title="内存中的字符串读取"></a>内存中的字符串读取</h2><h3 id="从内存逐个字节读入字符串"><a href="#从内存逐个字节读入字符串" class="headerlink" title="从内存逐个字节读入字符串"></a>从内存逐个字节读入字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;这是需要读入的字符串&quot;</span>;</span><br><span class="line">StringReader stringReader = <span class="keyword">new</span> StringReader(s);</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> ((c = stringReader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println((<span class="keyword">char</span>) c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    stringReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这</span><br><span class="line">是</span><br><span class="line">需</span><br><span class="line">要</span><br><span class="line">读</span><br><span class="line">入</span><br><span class="line">的</span><br><span class="line">字</span><br><span class="line">符</span><br><span class="line">串</span><br></pre></td></tr></table></figure>
<h3 id="格式化内存输入"><a href="#格式化内存输入" class="headerlink" title="格式化内存输入"></a>格式化内存输入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;这是需要输出的字符串!&quot;</span>;</span><br><span class="line">ByteArrayInputStream inputStream = <span class="keyword">new</span> ByteArrayInputStream(s.getBytes());</span><br><span class="line">DataInputStream in = <span class="keyword">new</span> DataInputStream(inputStream);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">while</span> (in.available() != <span class="number">0</span>) &#123;</span><br><span class="line">       System.out.println((<span class="keyword">char</span>) in.readByte());</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">   System.err.println(<span class="string">&quot;End of Stream&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       in.close();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DataInputStream.available()方法检测还有多少可供读取的字符</p>
<h2 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h2><p>这是采用Java IO实现的版本， 采用<a href="/Java/io/NIO/">Java NIO</a>可以大大提高效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">File file1=<span class="keyword">new</span> File(args[<span class="number">0</span>]);</span><br><span class="line">File file2=<span class="keyword">new</span> File(args[<span class="number">1</span>]);</span><br><span class="line">InputStream input=<span class="keyword">new</span> FileInputStream(file1);</span><br><span class="line">OutputStream output=<span class="keyword">new</span> FileOutputStream(file2);</span><br><span class="line"><span class="keyword">if</span>((input!=<span class="keyword">null</span>)&amp;&amp;(output!=<span class="keyword">null</span>))&#123;</span><br><span class="line">   <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>((temp=input.read())!=(-<span class="number">1</span>))&#123;</span><br><span class="line">		output.write(temp);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br><span class="line">output.close();</span><br></pre></td></tr></table></figure>
<h2 id="RandomAccessFile-1"><a href="#RandomAccessFile-1" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String fileName=<span class="string">&quot;D:&quot;</span>+File.separator+<span class="string">&quot;hello.txt&quot;</span>;</span><br><span class="line">File f=<span class="keyword">new</span> File(fileName);</span><br><span class="line">RandomAccessFile demo=<span class="keyword">new</span> RandomAccessFile(f,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">demo.writeBytes(<span class="string">&quot;asdsad&quot;</span>);</span><br><span class="line">demo.writeInt(<span class="number">12</span>);</span><br><span class="line">demo.writeBoolean(<span class="keyword">true</span>);</span><br><span class="line">demo.writeChar(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">demo.writeFloat(<span class="number">1.21f</span>);</span><br><span class="line">demo.writeDouble(<span class="number">12.123</span>);</span><br><span class="line">demo.close();</span><br></pre></td></tr></table></figure>
<h2 id="与字节数组结合"><a href="#与字节数组结合" class="headerlink" title="与字节数组结合"></a>与字节数组结合</h2><p>//TODO 与字节数组</p>
<h1 id="标准IO"><a href="#标准IO" class="headerlink" title="标准IO"></a>标准IO</h1><p>三个标准IO分别是 <code>System.out</code> <code>System.err</code>  <code>System.in</code>, <code>System.out</code>和<code>System.err</code>已经包装成<code>PrintStream</code>对象, 而<code>System.io</code>是没有被包装的未经过加工的<code>InputStream</code>, 因此在读取<code>System.io</code>之前必须对其进行包装.</p>
<p>例子: 一行一行读取系统输入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader in = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">BufferedReader stdin = <span class="keyword">new</span> BufferedReader(in);</span><br><span class="line">String s;</span><br><span class="line"><span class="keyword">while</span>((s = stdin.readLine())!=<span class="keyword">null</span> &amp;&amp; s.length!=<span class="number">0</span>)&#123;</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符输出到标准输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(System.out,<span class="keyword">true</span>);</span><br><span class="line">out.println(<span class="string">&quot;hello , world!&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="标准IO重定向"><a href="#标准IO重定向" class="headerlink" title="标准IO重定向"></a>标准IO重定向</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.setIn(in);</span><br><span class="line">System.setOut(out);</span><br><span class="line">System.setErr(out);</span><br></pre></td></tr></table></figure>
<p>//TODO 如何重定向到<code>java.swing.JTextArea</code></p>
<h1 id="Java-IO-异常与错误"><a href="#Java-IO-异常与错误" class="headerlink" title="Java IO 异常与错误"></a>Java IO 异常与错误</h1><h1 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h1><p>所谓的进程控制, 是当Java 调用系统指令启动系统进程时, 利用Java IO输出运行过程中的输出和错位信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String command = <span class="string">&quot;CMD /C ping www.baidu.com&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Process process = <span class="keyword">new</span> ProcessBuilder(command.split(<span class="string">&quot; &quot;</span>)).start();</span><br><span class="line">  InputStream inputStream = process.getInputStream();</span><br><span class="line">  InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(inputStream);</span><br><span class="line">  BufferedReader results = <span class="keyword">new</span> BufferedReader(inputStreamReader);</span><br><span class="line">  String s;</span><br><span class="line">  <span class="keyword">while</span> ((s = results.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      System.out.println(s);</span><br><span class="line">  &#125;</span><br><span class="line">  BufferedReader errors = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(process.getErrorStream()));</span><br><span class="line">  <span class="keyword">while</span> ((s = errors.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      System.out.println(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<p>[参考文献]:</p>
<ol>
<li>Think in Java</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/collection/HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/collection/HashMap/" class="post-title-link" itemprop="url">Java HashMap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-05-12 08:44:00" itemprop="dateCreated datePublished" datetime="2016-05-12T08:44:00+08:00">2016-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-09 09:38:26" itemprop="dateModified" datetime="2021-02-09T09:38:26+08:00">2021-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p><img src="_v_images/20200709141031567_1720882596.png"></p>
<p>jdk8和jdk7不一样，jdk7中没有红黑树,数组中只挂载链表。而jdk8中在桶容量大于等于64且链表节点数大于等于8的时候转换为红黑树。当红黑树节点数量小于6时又会转换为链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化容量，必须要2的n次幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子默认值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要从链表转换为红黑树时,链表节点的最小长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为红黑树时数组的最小容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// resize操作时,红黑树节点个数小于6则转换为链表。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap阈值，用于判断是否需要扩容(threshold = 容量*loadFactor)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap解决hash冲突的方法"><a href="#HashMap解决hash冲突的方法" class="headerlink" title="HashMap解决hash冲突的方法"></a>HashMap解决hash冲突的方法</h2><h2 id="Java7的死循环问题"><a href="#Java7的死循环问题" class="headerlink" title="Java7的死循环问题"></a>Java7的死循环问题</h2><h2 id="Java8-中的HashMap扩容"><a href="#Java8-中的HashMap扩容" class="headerlink" title="Java8 中的HashMap扩容"></a>Java8 中的HashMap扩容</h2><p>而newTab[j + oldCap] = hiHead;这一步，是一个非常巧妙的地方，也是本文分析的重点。</p>
<p>解释<br>经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，经过rehash之后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。对应的就是下方的resize的注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Initializes or doubles table size.  If null, allocates in</span><br><span class="line"> * accord with initial capacity target held in field threshold.</span><br><span class="line"> * Otherwise, because we are using power-of-two expansion, the</span><br><span class="line"> * elements from each bin must either stay at same index, or move</span><br><span class="line"> * with a power of two offset in the new table.</span><br><span class="line"> * &#x2F;</span><br></pre></td></tr></table></figure>

<p>看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希值(也就是根据key1算出来的hashcode值)与高位与运算的结果。</p>
<p><img src="_v_images/20200709130208070_533098526.png"></p>
<p><img src="_v_images/20200709130233960_485151198.png"></p>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。<br>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。</p>
<p>再解释：为什么刚好原位置+原数组长度就会等于新的数组中的位置呢？<br>要搞明白这个问题首先要清楚</p>
<p>HashMap的数组长度恒定为2的n次方，也就是说只会为2 4 8 16 。。。。。这种数。源码中有限制，也就是说即使你创建HashMap的时候是写的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">13</span>);</span><br></pre></td></tr></table></figure>
<p>最后数组长度也会变成16，而不是你的13. 会取与你传入的数最近的一个2的n次方的数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>那么明确这一点有什么用呢？我们知道2,4,8,16,32所对应的二进制分别为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2：  0000 0000 0000 0000 0000 0000 0000 0010</span><br><span class="line">4：  0000 0000 0000 0000 0000 0000 0000 0100</span><br><span class="line">8：  0000 0000 0000 0000 0000 0000 0000 1000</span><br><span class="line">16： 0000 0000 0000 0000 0000 0000 0001 0000</span><br><span class="line">32:  0000 0000 0000 0000 0000 0000 0010 0000</span><br></pre></td></tr></table></figure>
<p>而我们知道，0在做位与运算时与任何一个数运算结果都恒为0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 &amp; 1 &#x3D; 0</span><br><span class="line">0 &amp; 0 &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>故看源码中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) </span><br></pre></td></tr></table></figure>
<p>这一步是否为0只需要看元素的二进制数对应数组长度的二进制数1那个位置是否为0.<br>假设某个元素的hashcode为52：<br><img src="_v_images/20200709130402587_2088260774.png"></p>
<p>而假设某个元素的hashcode为100：<br><img src="_v_images/20200709130419110_1073585697.png"><br>而通过源码可以看出0就还是在原来的位置。不为0就需要变动位置了，新的位置为元素在原数组的位置+原数组的长度，那么为什么是这样呢？我们接着看<br>看之前我们先使用jdk1.7中的方式重新进行hash运算<br>HashMap在运算元素位置的时候使用为 数组长度-1。也就是15.31这种数15 31 对应的二进制为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15：0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line">31: 0000 0000 0000 0000 0000 0000 0001 1111</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是hashmap中，计算元素位置采用的是length-1，而leng是用来判断元素是否需要更换位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0)  &#x2F;&#x2F;仅仅是判断元素是否需要换位置</span><br></pre></td></tr></table></figure>
<p>这一步才是计算位置，使用的是length-1.</p>
<p>16扩容后变成32.那么1.7中计算元素的位置方式为 31&amp;52, 31&amp;100.我们把他与扩容前的15&amp;52。15&amp;100做对比看看<br><img src="_v_images/20200709130508438_597207385.png"><br>可以看到，由于每次扩容会把原数组的长度*2，那么再二进制上的表现就是多出来一个1，比如元数组16-1二进制为1111，那么扩容后的32-1的二进制就变成了1 1111<br>而扩容前和扩容后的位置是否一样完全取决于多出来的那一位与key值的hash做按位与运算之后的值值是为0还是1。为0则新位置与原位置相同，不需要换位置，不为零则需要换位置。</p>
<p>而为什么新的位置是原位置+原数组长度，是因为每次换的位置只是前面多了一个1而已。那么新位置的变化的高位进1位。而每一次高位进1都是在加上原数组长度的过程。<br><img src="_v_images/20200709130528192_2073437264.png"><br>正好1+2=3 3+4=7 7+8=15 。也就验证了新的位置为原位置+原数组长度。</p>
<p><img src="_v_images/20200709130901169_1202973639.png"></p>
<p>[参考文献]<br>————————————————</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq32933432/java/article/details/86668385">jdk8之HashMap resize方法详解（深入讲解为什么1.8中扩容后的元素新位置为原位置+原数组长度）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3797c6f83d4f">JAVA8对HashMap扩容机制的优化</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/collection/ConcurrentHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/collection/ConcurrentHashMap/" class="post-title-link" itemprop="url">探索 ConcurrentHashMap 高并发性的实现机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-05-12 08:44:00" itemprop="dateCreated datePublished" datetime="2016-05-12T08:44:00+08:00">2016-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-09 09:38:26" itemprop="dateModified" datetime="2021-02-09T09:38:26+08:00">2021-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/index.html">转载自 探索 ConcurrentHashMap 高并发性的实现机制</a></p>
<p>ConcurrentHashMap 是 Java concurrent 包的重要成员。本文将结合 Java 内存模型，来分析 ConcurrentHashMap 的 JDK 源代码。通过本文，读者将了解到 ConcurrentHashMap 高并发性的具体实现机制。这对于我们在实际应用中更加高效的使用它是很有帮助的。</p>
<p>[TOC]</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ConcurrentHashMap 是 util.concurrent 包的重要成员。本文将结合 Java 内存模型，分析 JDK 源代码，探索 ConcurrentHashMap 高并发的具体实现机制。</p>
<p>由于 ConcurrentHashMap 的源代码实现依赖于 Java 内存模型，所以阅读本文需要读者了解 <a href="/java">Java 内存模型</a>。同时，ConcurrentHashMap 的源代码会涉及到<a href="/hashing">散列算法</a>和链表数据结构，所以，读者需要对散列算法和基于链表的数据结构有所了解。</p>
<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p>由于 ConcurrentHashMap 是建立在 Java 内存模型基础上的，为了更好的理解 ConcurrentHashMap，让我们首先来了解一下 Java 的内存模型。</p>
<p>Java 语言的内存模型由一些规则组成，这些规则确定线程对内存的访问如何排序以及何时可以确保它们对线程是可见的。下面我们将分别介绍 Java 内存模型的重排序，内存可见性和 happens-before 关系。</p>
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>内存模型描述了程序的可能行为。具体的编译器实现可以产生任意它喜欢的代码 – <strong>只要所有执行这些代码产生的结果，能够和内存模型预测的结果保持一致</strong>。这为编译器实现者提供了很大的自由，包括操作的重排序。</p>
<p>编译器生成指令的次序，可以不同于源代码所暗示的“显然”版本。重排序后的指令，对于优化执行以及成熟的全局寄存器分配算法的使用，都是大有脾益的，它使得程序在计算性能上有了很大的提升。</p>
<p>重排序类型包括：</p>
<ul>
<li>编译器生成指令的次序，可以不同于源代码所暗示的“显然”版本。</li>
<li>处理器可以乱序或者并行的执行指令。</li>
<li>缓存会改变写入提交到主内存的变量的次序。</li>
</ul>
<h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p>由于现代可共享内存的多处理器架构可能导致一个线程无法马上（甚至永远）看到另一个线程操作产生的结果。所以 Java 内存模型规定了 JVM 的一种最小保证：什么时候写入一个变量对其他线程可见。</p>
<p>在现代可共享内存的多处理器体系结构中每个处理器都有自己的缓存，并周期性的与主内存协调一致。假设线程 A 写入一个变量值 V，随后另一个线程 B 读取变量 V 的值，在下列情况下，线程 B 读取的值可能不是线程 A 写入的最新值：</p>
<ul>
<li>执行线程 A 的处理器把变量 V 缓存到寄存器中。</li>
<li>执行线程 A 的处理器把变量 V 缓存到自己的缓存中，但还没有同步刷新到主内存中去。</li>
<li>执行线程 B 的处理器的缓存中有变量 V 的旧值。</li>
</ul>
<h3 id="Happens-before-关系"><a href="#Happens-before-关系" class="headerlink" title="Happens-before 关系"></a>Happens-before 关系</h3><p>happens-before 关系保证：如果线程 A 与线程 B 满足 happens-before 关系，则线程 A 执行动作的结果对于线程 B 是可见的。如果两个操作未按 happens-before 排序，JVM 将可以对他们任意重排序。</p>
<p>下面介绍几个与理解 ConcurrentHashMap 有关的 happens-before 关系法则：</p>
<ol>
<li>程序次序法则：如果在程序中，所有动作 A 出现在动作 B 之前，则线程中的每动作 A 都 happens-before 于该线程中的每一个动作 B。</li>
<li>监视器锁法则：对一个监视器的解锁 happens-before 于每个后续对同一监视器的加锁。</li>
<li>Volatile 变量法则：对 Volatile 域的写入操作 happens-before 于每个后续对同一 Volatile 的读操作。</li>
<li>传递性：如果 A happens-before 于 B，且 B happens-before C，则 A happens-before C</li>
</ol>
<h2 id="ConcurrentHashMap-的结构分析"><a href="#ConcurrentHashMap-的结构分析" class="headerlink" title="ConcurrentHashMap 的结构分析"></a>ConcurrentHashMap 的结构分析</h2><p>为了更好的理解 <code>ConcurrentHashMap</code> 高并发的具体实现，让我们先探索它的结构模型。</p>
<p><code>ConcurrentHashMap</code> 类中包含两个静态内部类 <code>HashEntry</code> 和 <code>Segment</code> 。 <code>HashEntry</code> 用来封装映射表的键 / 值对；<code>Segment</code> 用来充当锁的角色，每个 <code>Segment</code> 对象守护整个散列映射表的若干个桶。每个桶是由若干个 <code>HashEntry</code> 对象链接起来的链表。一个 <code>ConcurrentHashMap</code> 实例中包含由若干个 <code>Segment</code> 对象组成的数组。</p>
<h3 id="HashEntry-类"><a href="#HashEntry-类" class="headerlink" title="HashEntry 类"></a>HashEntry 类</h3><p>HashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。</p>
<p>清单 1.HashEntry 类的定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123; </span><br><span class="line">    <span class="keyword">final</span> K key;                       <span class="comment">// 声明 key 为 final 型</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;                   <span class="comment">// 声明 hash 值为 final 型 </span></span><br><span class="line">    <span class="keyword">volatile</span> V value;                 <span class="comment">// 声明 value 为 volatile 型</span></span><br><span class="line">    <span class="keyword">final</span> HashEntry&lt;K,V&gt; next;      <span class="comment">// 声明 next 为 final 型 </span></span><br><span class="line"></span><br><span class="line">    HashEntry(K key, <span class="keyword">int</span> hash, HashEntry&lt;K,V&gt; next, V value) &#123; </span><br><span class="line">        <span class="keyword">this</span>.key = key; </span><br><span class="line">        <span class="keyword">this</span>.hash = hash; </span><br><span class="line">        <span class="keyword">this</span>.next = next; </span><br><span class="line">        <span class="keyword">this</span>.value = value; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。下图是在一个空桶中依次插入 A，B，C 三个 HashEntry 对象后的结构图：</p>
<p><img src="/images/java/Collection_Map/concurrentHashMap_01.jpg"></p>
<p>图 1. 插入三个节点后桶的结构示意图：</p>
<p>注意：由于只能在表头插入，所以链表中节点的顺序和插入的顺序相反。</p>
<p>避免热点域</p>
<p>在 <code>ConcurrentHashMap</code>中，每一个 Segment 对象都有一个 count 对象来表示本 Segment 中包含的 <code>HashEntry</code> 对象的个数。这样当需要更新计数器时，不用锁定整个 <code>ConcurrentHashMap</code>。</p>
<h3 id="Segment-类"><a href="#Segment-类" class="headerlink" title="Segment 类"></a>Segment 类</h3><p>Segment 类继承于 <code>ReentrantLock</code> 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。</p>
<p>table 是一个由 HashEntry 对象组成的数组。table 数组的每一个数组成员就是散列映射表的一个桶。</p>
<p>count 变量是一个计数器，它表示每个 Segment 对象管理的 table 数组（若干个 HashEntry 组成的链表）包含的 HashEntry 对象的个数。每一个 Segment 对象都有一个 count 对象来表示本 Segment 中包含的 HashEntry 对象的总数。注意，之所以在每个 Segment 对象中包含一个计数器，而不是在 ConcurrentHashMap 中使用全局的计数器，是为了避免出现“热点域”而影响 ConcurrentHashMap 的并发性。</p>
<p>清单 2.Segment 类的定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 在本 segment 范围内，包含的 HashEntry 元素的个数</span></span><br><span class="line"><span class="comment">     * 该变量被声明为 volatile 型</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * table 被更新的次数</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 当 table 中包含的 HashEntry 元素的个数超过本变量值时，触发 table 的再散列</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * table 是由 HashEntry 对象组成的数组</span></span><br><span class="line"><span class="comment">     * 如果散列时发生碰撞，碰撞的 HashEntry 对象就以链表的形式链接成一个链表</span></span><br><span class="line"><span class="comment">     * table 数组的数组成员代表散列映射表的一个桶</span></span><br><span class="line"><span class="comment">     * 每个 table 守护整个 ConcurrentHashMap 包含桶总数的一部分</span></span><br><span class="line"><span class="comment">     * 如果并发级别为 16，table 则守护 ConcurrentHashMap 包含的桶总数的 1/16 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 装载因子</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor; </span><br><span class="line"></span><br><span class="line">    Segment(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> lf) &#123; </span><br><span class="line">        loadFactor = lf; </span><br><span class="line">        setTable(HashEntry.&lt;K,V&gt;newArray(initialCapacity)); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 设置 table 引用到这个新生成的 HashEntry 数组</span></span><br><span class="line"><span class="comment">     * 只能在持有锁或构造函数中调用本方法</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTable</span><span class="params">(HashEntry&lt;K,V&gt;[] newTable)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 计算临界阀值为新数组的长度与装载因子的乘积</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)(newTable.length * loadFactor); </span><br><span class="line">        table = newTable; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 根据 key 的散列值，找到 table 中对应的那个桶（table 数组的某个数组成员）</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="function">HashEntry&lt;K,V&gt; <span class="title">getFirst</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123; </span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class="line">        <span class="comment">// 把散列值与 table 数组长度减 1 的值相“与”，</span></span><br><span class="line">        <span class="comment">// 得到散列值对应的 table 数组的下标</span></span><br><span class="line">        <span class="comment">// 然后返回 table 数组中此下标对应的 HashEntry 元素</span></span><br><span class="line">        <span class="keyword">return</span> tab[hash &amp; (tab.length - <span class="number">1</span>)]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图是依次插入 ABC 三个 HashEntry 节点后，Segment 的结构示意图。</p>
<p><img src="/images/java/Collection_Map/concurrentHashMap_02.jpg"></p>
<p>图 2. 插入三个节点后 Segment 的结构示意图：</p>
<h3 id="ConcurrentHashMap-类"><a href="#ConcurrentHashMap-类" class="headerlink" title="ConcurrentHashMap 类"></a>ConcurrentHashMap 类</h3><p>ConcurrentHashMap 在默认并发级别会创建包含 16 个 Segment 对象的数组。每个 Segment 的成员对象 table 包含若干个散列表的桶。每个桶是由 HashEntry 链接起来的一个链表。如果键能均匀散列，每个 Segment 大约守护整个散列表中桶总数的 1/16。</p>
<p>清单 3.ConcurrentHashMap 类的定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span></span><br><span class="line"><span class="class">       <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 散列映射表的默认初始容量为 16，即初始默认为 16 个桶</span></span><br><span class="line"><span class="comment">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> 	 <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY= <span class="number">16</span>; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 散列映射表的默认装载因子为 0.75，该值是 table 中包含的 HashEntry 元素的个数与</span></span><br><span class="line"><span class="comment">* table 数组长度的比值</span></span><br><span class="line"><span class="comment">    * 当 table 中包含的 HashEntry 元素的个数超过了 table 数组的长度与装载因子的乘积时，</span></span><br><span class="line"><span class="comment">* 将触发 再散列</span></span><br><span class="line"><span class="comment">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR= <span class="number">0.75f</span>; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 散列表的默认并发级别为 16。该值表示当前更新线程的估计数</span></span><br><span class="line"><span class="comment">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL= <span class="number">16</span>; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * segments 的掩码值</span></span><br><span class="line"><span class="comment">    * key 的散列码的高位用来选择具体的 segment </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> segmentMask; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 偏移量</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> segmentShift; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 由 Segment 对象组成的数组</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 创建一个带有指定初始容量、加载因子和并发级别的新的空映射。</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, </span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123; </span><br><span class="line">       <span class="keyword">if</span>(!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || </span><br><span class="line">concurrencyLevel &lt;= <span class="number">0</span>) </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(); </span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(concurrencyLevel &gt; MAX_SEGMENTS) </span><br><span class="line">           concurrencyLevel = MAX_SEGMENTS; </span><br><span class="line"></span><br><span class="line">       <span class="comment">// 寻找最佳匹配参数（不小于给定参数的最接近的 2 次幂） </span></span><br><span class="line">       <span class="keyword">int</span> sshift = <span class="number">0</span>; </span><br><span class="line">       <span class="keyword">int</span> ssize = <span class="number">1</span>; </span><br><span class="line">       <span class="keyword">while</span>(ssize &lt; concurrencyLevel) &#123; </span><br><span class="line">           ++sshift; </span><br><span class="line">           ssize &lt;&lt;= <span class="number">1</span>; </span><br><span class="line">       &#125; </span><br><span class="line">       segmentShift = <span class="number">32</span> - sshift;       <span class="comment">// 偏移量值</span></span><br><span class="line">       segmentMask = ssize - <span class="number">1</span>;           <span class="comment">// 掩码值 </span></span><br><span class="line">       <span class="keyword">this</span>.segments = Segment.newArray(ssize);   <span class="comment">// 创建数组</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) </span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY; </span><br><span class="line">       <span class="keyword">int</span> c = initialCapacity / ssize; </span><br><span class="line">       <span class="keyword">if</span>(c * ssize &lt; initialCapacity) </span><br><span class="line">           ++c; </span><br><span class="line">       <span class="keyword">int</span> cap = <span class="number">1</span>; </span><br><span class="line">       <span class="keyword">while</span>(cap &lt; c) </span><br><span class="line">           cap &lt;&lt;= <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">       <span class="comment">// 依次遍历每个数组元素</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i) </span><br><span class="line">           <span class="comment">// 初始化每个数组元素引用的 Segment 对象</span></span><br><span class="line"><span class="keyword">this</span>.segments[i] = <span class="keyword">new</span> Segment&lt;K,V&gt;(cap, loadFactor); </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 创建一个带有默认初始容量 (16)、默认加载因子 (0.75) 和 默认并发级别 (16) </span></span><br><span class="line"><span class="comment"> * 的空散列映射表。</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123; </span><br><span class="line">       <span class="comment">// 使用三个默认参数，调用上面重载的构造函数来创建空散列映射表</span></span><br><span class="line"><span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>}</p>
<p>下面是 ConcurrentHashMap 的结构示意图。</p>
<p><img src="/images/java/Collection_Map/concurrentHashMap_03.jpg"></p>
<p>图 3.ConcurrentHashMap 的结构示意图：</p>
<h2 id="用分离锁实现多个线程间的并发写操作"><a href="#用分离锁实现多个线程间的并发写操作" class="headerlink" title="用分离锁实现多个线程间的并发写操作"></a>用分离锁实现多个线程间的并发写操作</h2><p>在 ConcurrentHashMap 中，线程对映射表做读操作时，<em>一般情况下</em>不需要加锁就可以完成，对容器做结构性修改的操作才需要加锁。下面以 put 操作为例说明对 ConcurrentHashMap 做结构性修改的过程。</p>
<p>首先，根据 key 计算出对应的 hash 值：</p>
<p>清单 4.Put 方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)          <span class="comment">//ConcurrentHashMap 中不允许用 null 作为映射值</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); </span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());        <span class="comment">// 计算键对应的散列码</span></span><br><span class="line">    <span class="comment">// 根据散列码找到对应的 Segment </span></span><br><span class="line">    <span class="keyword">return</span> segmentFor(hash).put(key, hash, value, <span class="keyword">false</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，根据 hash 值找到对应的<code>Segment</code> 对象：</p>
<p>清单 5.根据 hash 值找到对应的 Segment</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 使用 key 的散列码来得到 segments 数组中对应的 Segment </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123; </span><br><span class="line"><span class="comment">// 将散列值右移 segmentShift 个位，并在高位填充 0 </span></span><br><span class="line"><span class="comment">// 然后把得到的值与 segmentMask 相“与”</span></span><br><span class="line"><span class="comment">// 从而得到 hash 值对应的 segments 数组的下标值</span></span><br><span class="line"><span class="comment">// 最后根据下标值返回散列码对应的 Segment 对象</span></span><br><span class="line">    <span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在这个 Segment 中执行具体的 put 操作：</p>
<p>清单 6.在 Segment 中执行具体的 put 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123; </span><br><span class="line">    lock();  <span class="comment">// 加锁，这里是锁定某个 Segment 对象而非整个 ConcurrentHashMap </span></span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">int</span> c = count; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c++ &gt; threshold)     <span class="comment">// 如果超过再散列的阈值</span></span><br><span class="line">            rehash();              <span class="comment">// 执行再散列，table 数组的长度将扩充一倍</span></span><br><span class="line"></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class="line">        <span class="comment">// 把散列码值与 table 数组的长度减 1 的值相“与”</span></span><br><span class="line">        <span class="comment">// 得到该散列码对应的 table 数组的下标值</span></span><br><span class="line">        <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>); </span><br><span class="line">        <span class="comment">// 找到散列码对应的具体的那个桶</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = tab[index]; </span><br><span class="line"></span><br><span class="line">        HashEntry&lt;K,V&gt; e = first; </span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key))) </span><br><span class="line">            e = e.next; </span><br><span class="line"></span><br><span class="line">        V oldValue; </span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;            <span class="comment">// 如果键 / 值对以经存在</span></span><br><span class="line">            oldValue = e.value; </span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent) </span><br><span class="line">                e.value = value;    <span class="comment">// 设置 value 值</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;                        <span class="comment">// 键 / 值对不存在 </span></span><br><span class="line">            oldValue = <span class="keyword">null</span>; </span><br><span class="line">            ++modCount;         <span class="comment">// 要添加新节点到链表中，所以 modCont 要加 1  </span></span><br><span class="line">            <span class="comment">// 创建新节点，并添加到链表的头部 </span></span><br><span class="line">            tab[index] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(key, hash, first, value); </span><br><span class="line">            count = c;               <span class="comment">// 写 count 变量</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> oldValue; </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        unlock();                     <span class="comment">// 解锁</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<br>这里的加锁操作是针对（键的 hash 值对应的）某个具体的 Segment，锁定的是该 <code>Segment</code> 而不是整个 <code>ConcurrentHashMap</code>。因为插入键 / 值对操作只是在这个 Segment 包含的某个桶中完成，不需要锁定整个<code>ConcurrentHashMap</code>。此时，其他写线程对另外 15 个<code>Segment</code> 的加锁并不会因为当前线程对这个 Segment 的加锁而阻塞。同时，所有读线程几乎不会因本线程的加锁而阻塞（除非读线程刚好读到这个 Segment 中某个 <code>HashEntry</code> 的 <code>value</code> 域的值为 null，此时需要加锁后重新读取该值）。</p>
<p>相比较于 <code>HashTable</code> 和由同步包装器包装的 <code>HashMap</code>每次只能有一个线程执行读或写操作，<code>ConcurrentHashMap</code> 在并发访问性能上有了质的提高。<em>在理想状态下</em>，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设置为 16），及任意数量线程的读操作。</p>
<h2 id="用-HashEntery-对象的不变性来降低读操作对加锁的需求"><a href="#用-HashEntery-对象的不变性来降低读操作对加锁的需求" class="headerlink" title="用 HashEntery 对象的不变性来降低读操作对加锁的需求"></a>用 HashEntery 对象的不变性来降低读操作对加锁的需求</h2><p>在代码清单“HashEntry 类的定义”中我们可以看到，HashEntry 中的 key，hash，next 都声明为 final 型。这意味着，不能把节点添加到链接的中间和尾部，也不能在链接的中间和尾部删除节点。这个特性可以保证：在访问某个节点时，这个节点之后的链接不会被改变。这个特性可以大大降低处理链表时的复杂性。</p>
<p>同时，HashEntry 类的 value 域被声明为 Volatile 型，Java 的内存模型可以保证：某个写线程对 value 域的写入马上可以被后续的某个读线程“看”到。在 ConcurrentHashMap 中，不允许用 null 作为键和值，<strong>当读线程读到某个 HashEntry 的 value 域的值为 null 时，便知道产生了冲突——发生了重排序现象，需要加锁后重新读入这个 value 值。</strong>这些特性互相配合，使得读线程即使在不加锁状态下，也能正确访问 ConcurrentHashMap。</p>
<p>下面我们分别来分析线程写入的两种情形：对散列表做非结构性修改的操作和对散列表做结构性修改的操作。</p>
<p>非结构性修改操作只是更改某个 HashEntry 的 value 域的值。由于对 Volatile 变量的写入操作将与随后对这个变量的读操作进行同步。当一个写线程修改了某个 HashEntry 的 value 域后，另一个读线程读这个值域，Java 内存模型能够保证读线程读取的一定是更新后的值。所以，写线程对链表的非结构性修改能够被后续不加锁的读线程“看到”。</p>
<p>对 ConcurrentHashMap 做结构性修改，实质上是对某个桶指向的链表做结构性修改。如果能够确保：在读线程遍历一个链表期间，写线程对这个链表所做的结构性修改不影响读线程继续正常遍历这个链表。那么读 / 写线程之间就可以安全并发访问这个 ConcurrentHashMap。</p>
<p>结构性修改操作包括 put，remove，clear。下面我们分别分析这三个操作。</p>
<p>clear 操作只是把 ConcurrentHashMap 中所有的桶“置空”，每个桶之前引用的链表依然存在，只是桶不再引用到这些链表（所有链表的结构并没有被修改）。正在遍历某个链表的读线程依然可以正常执行对该链表的遍历。</p>
<p>从上面的代码清单“在 Segment 中执行具体的 put 操作”中，我们可以看出：put 操作如果需要插入一个新节点到链表中时 , 会在链表头部插入这个新节点。此时，链表中的原有节点的链接并没有被修改。也就是说：插入新健 / 值对到链表中的操作不会影响读线程正常遍历这个链表。</p>
<p>下面来分析 remove 操作，先让我们来看看 remove 操作的源代码实现。</p>
<p>清单 7.remove 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key, <span class="keyword">int</span> hash, Object value)</span> </span>&#123; </span><br><span class="line">lock();         <span class="comment">// 加锁</span></span><br><span class="line"><span class="keyword">try</span>&#123; </span><br><span class="line">    <span class="keyword">int</span> c = count - <span class="number">1</span>; </span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class="line">    <span class="comment">// 根据散列码找到 table 的下标值</span></span><br><span class="line">    <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>); </span><br><span class="line">    <span class="comment">// 找到散列码对应的那个桶</span></span><br><span class="line">    HashEntry&lt;K,V&gt; first = tab[index]; </span><br><span class="line">    HashEntry&lt;K,V&gt; e = first; </span><br><span class="line">    <span class="keyword">while</span>(e != <span class="keyword">null</span>&amp;&amp; (e.hash != hash || !key.equals(e.key))) </span><br><span class="line">        e = e.next; </span><br><span class="line"></span><br><span class="line">    V oldValue = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">if</span>(e != <span class="keyword">null</span>) &#123; </span><br><span class="line">        V v = e.value; </span><br><span class="line">        <span class="keyword">if</span>(value == <span class="keyword">null</span>|| value.equals(v)) &#123; <span class="comment">// 找到要删除的节点</span></span><br><span class="line">            oldValue = v; </span><br><span class="line">            ++modCount; </span><br><span class="line">            <span class="comment">// 所有处于待删除节点之后的节点原样保留在链表中</span></span><br><span class="line">            <span class="comment">// 所有处于待删除节点之前的节点被克隆到新链表中</span></span><br><span class="line">            HashEntry&lt;K,V&gt; newFirst = e.next;<span class="comment">// 待删节点的后继结点</span></span><br><span class="line">            <span class="keyword">for</span>(HashEntry&lt;K,V&gt; p = first; p != e; p = p.next) </span><br><span class="line">                newFirst = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(p.key, p.hash, </span><br><span class="line">                                              newFirst, p.value); </span><br><span class="line">            <span class="comment">// 把桶链接到新的头结点</span></span><br><span class="line">            <span class="comment">// 新的头结点是原链表中，删除节点之前的那个节点</span></span><br><span class="line">            tab[index] = newFirst; </span><br><span class="line">            count = c;      <span class="comment">// 写 count 变量</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> oldValue; </span><br><span class="line">&#125; <span class="keyword">finally</span>&#123; </span><br><span class="line">    unlock();               <span class="comment">// 解锁</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 get 操作一样，首先根据散列码找到具体的链表；然后遍历这个链表找到要删除的节点；最后把待删除节点之后的所有节点原样保留在新链表中，把待删除节点之前的每个节点克隆到新链表中。下面通过图例来说明 remove 操作。假设写线程执行 remove 操作，要删除链表的 C 节点，另一个读线程同时正在遍历这个链表。</p>
<p><img src="/images/java/Collection_Map/concurrentHashMap_04.jpg"></p>
<p>图 4. 执行删除之前的原链表：</p>
<p><img src="/images/java/Collection_Map/concurrentHashMap_05.jpg"></p>
<p>图 5. 执行删除之后的新链表</p>
<p>从上图可以看出，删除节点 C 之后的所有节点原样保留到新链表中；删除节点 C 之前的每个节点被克隆到新链表中，<em>注意：它们在新链表中的链接顺序被反转了</em>。</p>
<p>在执行 remove 操作时，原始链表并没有被修改，也就是说：读线程不会受同时执行 remove 操作的并发写线程的干扰。</p>
<p>综合上面的分析我们可以看出，写线程对某个链表的结构性修改不会影响其他的并发读线程对这个链表的遍历访问。</p>
<h2 id="用-Volatile-变量协调读写线程间的内存可见性"><a href="#用-Volatile-变量协调读写线程间的内存可见性" class="headerlink" title="用 Volatile 变量协调读写线程间的内存可见性"></a>用 Volatile 变量协调读写线程间的内存可见性</h2><p>由于内存可见性问题，未正确同步的情况下，写线程写入的值可能并不为后续的读线程可见。</p>
<p>下面以写线程 M 和读线程 N 来说明 ConcurrentHashMap 如何协调读 / 写线程间的内存可见性问题。</p>
<p>图 6. 协调读 - 写线程间的内存可见性的示意图：</p>
<p><img src="/images/java/Collection_Map/concurrentHashMap_06.jpg"></p>
<p>假设线程 M 在写入了 volatile 型变量 count 后，线程 N 读取了这个 volatile 型变量 count。</p>
<p>根据 happens-before 关系法则中的程序次序法则，A appens-before 于 B，C happens-before D。</p>
<p>根据 Volatile 变量法则，B happens-before C。</p>
<p>根据传递性，连接上面三个 happens-before 关系得到：A appens-before 于 B； B appens-before C；C happens-before D。也就是说：写线程 M 对链表做的结构性修改，在读线程 N 读取了同一个 volatile 变量后，对线程 N 也是可见的了。</p>
<p>虽然线程 N 是在未加锁的情况下访问链表。Java 的内存模型可以保证：只要之前对链表做结构性修改操作的写线程 M 在退出写方法前写 volatile 型变量 count，读线程 N 在读取这个 volatile 型变量 count 后，就一定能“看到”这些修改。</p>
<p>ConcurrentHashMap 中，每个 Segment 都有一个变量 count。它用来统计 Segment 中的 HashEntry 的个数。这个变量被声明为 volatile。</p>
<p>清单 8.Count 变量的声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>
<p> 所有不加锁读方法，在进入读方法时，首先都会去读这个 count 变量。比如下面的 get 方法：</p>
<p>清单 9.get 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key, <span class="keyword">int</span> hash)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(count != <span class="number">0</span>) &#123;       <span class="comment">// 首先读 count 变量</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = getFirst(hash); </span><br><span class="line">        <span class="keyword">while</span>(e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span>(e.hash == hash &amp;&amp; key.equals(e.key)) &#123; </span><br><span class="line">                V v = e.value; </span><br><span class="line">                <span class="keyword">if</span>(v != <span class="keyword">null</span>)            </span><br><span class="line">                    <span class="keyword">return</span> v; </span><br><span class="line">                <span class="comment">// 如果读到 value 域为 null，说明发生了重排序，加锁后重新读取</span></span><br><span class="line">                <span class="keyword">return</span> readValueUnderLock(e); </span><br><span class="line">            &#125; </span><br><span class="line">            e = e.next; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ConcurrentHashMap 中，所有执行写操作的方法（put, remove, clear），在对链表做结构性修改之后，在退出写方法前都会去写这个 count 变量。所有未加锁的读操作（get, contains, containsKey）在读方法中，都会首先去读取这个 count 变量。</p>
<p>根据 Java 内存模型，对 同一个 volatile 变量的写 / 读操作可以确保：写线程写入的值，能够被之后未加锁的读线程“看到”。</p>
<p>这个特性和前面介绍的 HashEntry 对象的不变性相结合，使得在 ConcurrentHashMap 中，读线程在读取散列表时，基本不需要加锁就能成功获得需要的值。这两个特性相配合，不仅减少了请求同一个锁的频率（读操作一般不需要加锁就能够成功获得值），也减少了持有同一个锁的时间（只有读到 value 域的值为 null 时 , 读线程才需要加锁后重读）。</p>
<h2 id="ConcurrentHashMap-实现高并发的总结"><a href="#ConcurrentHashMap-实现高并发的总结" class="headerlink" title="ConcurrentHashMap 实现高并发的总结"></a>ConcurrentHashMap 实现高并发的总结</h2><h3 id="基于通常情形而优化"><a href="#基于通常情形而优化" class="headerlink" title="基于通常情形而优化"></a>基于通常情形而优化</h3><p>在实际的应用中，散列表一般的应用场景是：除了少数插入操作和删除操作外，绝大多数都是读取操作，而且读操作在大多数时候都是成功的。正是基于这个前提，ConcurrentHashMap 针对读操作做了大量的优化。通过 HashEntry 对象的不变性和用 volatile 型变量协调线程间的内存可见性，使得 大多数时候，读操作不需要加锁就可以正确获得值。这个特性使得 ConcurrentHashMap 的并发性能在分离锁的基础上又有了近一步的提高。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 <code>HashTable 和</code>用同步包装器包装的 HashMap（Collections.synchronizedMap(new HashMap())），ConcurrentHashMap 拥有更高的并发性。在 HashTable 和由同步包装器包装的 HashMap 中，使用一个全局的锁来同步不同线程间的并发访问。同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器。这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成<code>串行化</code>的了。</p>
<p>在使用锁来协调多线程间并发访问的模式下，减小对锁的竞争可以有效提高并发性。有两种方式可以减小对锁的竞争：</p>
<ol>
<li>减小请求 同一个锁的 频率。</li>
<li>减少持有锁的 时间。</li>
</ol>
<p>ConcurrentHashMap 的高并发性主要来自于三个方面：</p>
<ol>
<li>用分离锁实现多个线程间的更深层次的共享访问。</li>
<li>用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。</li>
<li>通过对同一个 Volatile 变量的写/读访问，协调不同线程间读/写操作的内存可见性。</li>
</ol>
<p>使用分离锁，减小了请求 <em>同一个锁</em> 的频率。</p>
<p>通过 HashEntery 对象的不变性及对同一个 Volatile 变量的读/写来协调内存可见性，使得 读操作大多数时候不需要加锁就能成功获取到需要的值。由于散列映射表在实际应用中大多数操作都是成功的 读操作，所以 2 和 3 既可以减少请求同一个锁的频率，也可以有效减少持有锁的时间。</p>
<p>通过减小请求同一个锁的频率和尽量减少持有锁的时间 ，使得 ConcurrentHashMap 的并发性相对于 HashTable 和<code>用同步包装器包装的 HashMap</code>有了质的提高。</p>
<h2 id="Java-8中的优化"><a href="#Java-8中的优化" class="headerlink" title="Java 8中的优化"></a>Java 8中的优化</h2><p>参考文献</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/collection/collection-map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/collection/collection-map/" class="post-title-link" itemprop="url">Java Collection与Map</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-05-12 08:44:00" itemprop="dateCreated datePublished" datetime="2016-05-12T08:44:00+08:00">2016-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-09 09:38:26" itemprop="dateModified" datetime="2021-02-09T09:38:26+08:00">2021-02-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="/Java/advanced-engineer-outline/">&lt;&lt; Java高级软件工程师知识结构</a></p>
<blockquote>
<ol>
<li>掌握Collection和Map的继承体系。</li>
<li>掌握ArrayList、LinkedList、Vector、Stack、PriorityQueue、HashSet、LinkedHashSet、TreeSet、HashMap、</li>
<li>LinkedHashMap、TreeMap、WeakHashMap、EnumMap、HashTable的特点和实现原理。<br>4.掌握CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap的实现原理和适用场景。</li>
</ol>
</blockquote>
<h1 id="Java-Collection与Map的继承关系"><a href="#Java-Collection与Map的继承关系" class="headerlink" title="Java Collection与Map的继承关系"></a>Java Collection与Map的继承关系</h1><p>在程序设计中, 集合可以存储和传递一组数据. 集合虽然比不上数组的查询速度, 但是有更加方便的功能,<br>如可变长度、键值对、去重复等.<br>其家族成员有:</p>
<p><img src="/images/java/Collection_Map/java-collections-integrated-relation.png"></p>
<p><code>Collection</code>是一个接口, 该接口允许添加和查找一个或多个元素、<code>生成迭代器</code>等功能.</p>
<p><code>List</code> <code>Set</code>和<code>Queue</code>分别是继承了<code>Collocation</code>的子接口.<br><code>List</code>用于存放可重复可为<code>null</code>的元素的有序集合. 并且可以对元素进行精确地控制, 可根据整数索引访问元素.<br><code>Set</code>用于存放不可重复可为<code>null</code>的元素的集合,<br><code>Map</code>并没有继承<code>Collection</code>, 是由一系列键值对组成的集合. 在<code>Map</code>中一个<code>key</code>对应一个<code>value</code>, key不能相同.</p>
<h1 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h1><p>实现了List接口的集合主要有 <code>ArrayList</code> <code>LinkedList</code> <code>Vector</code> <code>Stack</code></p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p><strong>特性</strong></p>
<ol>
<li><strong>可重复</strong>, <strong>可为null</strong>: 添加元素是将元素存放到数组中</li>
<li><strong>有序</strong></li>
<li>擅长随机访问： 快速检索 增删慢</li>
<li><strong>非线程同步</strong><br>通过<code>Collections.synchronizedList(new ArrayList());</code>转换为线程安全的List</li>
</ol>
<p><strong>实现原理</strong><br>动态数组, 底层也是通过<code>单个Java数组</code>实现的, <code>ArrayList</code>根据元素个数动态调整内部数组的长度以达到实现动态数组的效果.<br>内部数组的初始长度为10, 当添加的元素的个数超出了内部数组的长度时, 调用JNI函数对内部数组实现扩容（为原长度的<code>150%</code>）和复制.<br>本质上, <code>ArrayList</code>是采用了<strong>线性表</strong>的结构, 因此, <code>ArrayList</code>具有快速检索的优点也具有增删慢的缺点.</p>
<p><strong>复杂度</strong><br>添加n个元素需要O(n)时间</p>
<blockquote>
<p><strong>优化建议 :</strong><br>如果确定了插入元素的多少, 最好可以指定初始容量值,<br>避免过多的进行扩容和复制而浪费时间.</p>
</blockquote>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p><strong>特性</strong></p>
<ol>
<li><strong>不能随机访问</strong></li>
<li><strong>非线程同步</strong><br> 通过<code>Collections.synchronizedList(new LinkedList());</code>转换为线程安全的List</li>
<li>善于<strong>插入和删除</strong> 不善于随机访问</li>
</ol>
<p><strong>实现原理</strong><br>双向链表, 可以通过<code>get</code> <code>remove</code> <code>insert</code>方法操作首部和尾部的元素.</p>
<p><strong>复杂度</strong></p>
<p><strong>与ArrayList对比</strong><br>由于<code>ArrayList</code>是线性表的形式存储的, 需要连续的存储空间. 而<code>LinkedList</code>不需要连续,<br>因此在存储数据量较大的情况下, 优先选择<code>LinkedList</code>.</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p><strong>特性</strong></p>
<ol>
<li><strong>线程同步</strong></li>
<li>与ArrayList一样 <strong>???</strong></li>
</ol>
<p><strong>实现原理</strong><br>线程安全的动态数组, 内部也是采用单个数组</p>
<p><strong>复杂度</strong></p>
<h2 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack 栈"></a>Stack 栈</h2><p><strong>特性</strong></p>
<ol>
<li><strong>后进先出的栈</strong></li>
<li>提供了除了ArrayList和Vector以外的栈操作方法:<ul>
<li>push 压入栈</li>
<li>pop  出栈</li>
<li>peek 得到栈顶</li>
<li>empty 测试栈是否为空</li>
<li>search 检测一个元素在栈中的位置</li>
</ul>
</li>
</ol>
<p><strong>实现原理</strong><br>用<code>Vector</code>构建,而非继承自<code>Vector</code></p>
<p><strong>复杂度</strong></p>
<p>【样例】: 使用栈实现计算器</p>
<h1 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h1><p><strong>特性</strong></p>
<ol>
<li><strong>不可重复</strong></li>
<li><strong>最多只允许一个null</strong></li>
</ol>
<h2 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h2><p><strong>特性</strong></p>
<ol>
<li>枚举专用Set</li>
<li>不是同步的<br>多线程情况下, 最好在创建时完成这一操作, 以防止意外的非同步访问<br><code>Set&lt;MyEnum&gt; s = Collections.synchronizedSet(EnumSet.noneOf(MyEnum.class));</code></li>
<li>枚举 set 中所有键都必须来自单个枚举类型, 该枚举类型在创建 set 时显式或隐式地指定.</li>
</ol>
<p><strong>实现原理</strong></p>
<p>//TODO</p>
<p><strong>复杂度</strong></p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p><strong>特性</strong></p>
<ol>
<li><strong>速度最快的集合</strong></li>
<li>不能重复，最多一个为null</li>
</ol>
<p><strong>实现原理</strong><br>内部存在一个HashMap, 借助于HashCode来实现, 所以不保证元素的顺序</p>
<p><strong>复杂度</strong></p>
<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p><strong>特性</strong></p>
<ol>
<li>有序</li>
</ol>
<p><strong>实现原理</strong><br>内部是<code>LinkedHashMap</code>实现的<br>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它 <strong>同时使用链表维护元素的次序</strong> 。<br>当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。<br>LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</p>
<p><strong>复杂度</strong></p>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p><strong>特性</strong></p>
<ol>
<li>总是处于排序状态的Set(顺序取决于元素的自然顺序或者创建Set时指定的Comparator)</li>
<li>非线程同步<br> 多线程情况下,最好在创建时进行, 以防止对 set 的意外非同步访问：<br> <code>SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));</code></li>
</ol>
<p><strong>实现原理</strong><br>内部由TreeMap(使用<a target="_blank" rel="noopener" href="http://www.cnblogs.com/liqizhou/archive/2012/09/27/java%E4%B8%ADtreemap%E5%92%8Ctreeset%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91.html">红黑树</a>)来实现</p>
<p><strong>复杂度</strong></p>
<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p><strong>特性</strong></p>
<ol>
<li>键值对</li>
<li>Key不能重复</li>
</ol>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><strong>特性</strong></p>
<ol>
<li><strong>线程不安全</strong></li>
<li>初始容量设定</li>
</ol>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><a target="_blank" rel="noopener" href="http://www.importnew.com/7099.html">参考链接: HashMap的工作原理</a></p>
<p>以哈希表的数据结构实现. 内部存在一个哈希表数组, 每个数组元素又有一组长度不确定的链表.</p>
<p><img src="/images/java/Collection_Map/java-collections-hashtable.png"></p>
<p><code>HashMap</code>是基于hashing的原理，我们使用<code>put(key, value)</code>存储对象到HashMap中，使用<code>get(key)</code>从HashMap中获取对象。当我们给<code>put()</code>方法传递键和值时，我们先对键调用<code>hashCode()</code>方法，返回的hashCode用于找到bucket位置来储存<strong>Entry对象</strong>。”这里关键点在于指出，HashMap是在bucket中储存<strong>键对象和值对象</strong>，作为Map.Entry。</p>
<p><code>HashMap</code>在bucket中存储<code>Map.Entry</code>对象，每个Map.Entry保存有key和value。</p>
<h3 id="get的工作原理"><a href="#get的工作原理" class="headerlink" title="get的工作原理"></a>get的工作原理</h3><p>当使用get(key)方法，<br>首先调用hashing方法，利用<code>key.hashcode</code>计算key所在的bucket，找到相应的bucket后。<br>然后遍历bucket中的Map.Entry，首先比对<code>key.hashcode</code>值，其次比对(key值或<code>key.equals</code>方法比对两个对象)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp;  ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">return</span> e;</span><br></pre></td></tr></table></figure>
<p>在这里，使用了 <code>&amp;&amp;</code> 的短路特性: 只要第一个条件不满足，不再比较后面的条件；只有前面的条件满足了，才比较后面的条件。<br>等价于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(e.hash==hash)&#123;</span><br><span class="line">  <span class="keyword">if</span>((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))&#123;</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="key的hashcode相同的情况"><a href="#key的hashcode相同的情况" class="headerlink" title="key的hashcode相同的情况"></a>key的<code>hashcode</code>相同的情况</h3><p>因为<code>hashcode</code>相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。当<code>hashcode</code>相同时，还会调用key.equals比对两个key对象是否相同。</p>
<h3 id="负载因子-0-75"><a href="#负载因子-0-75" class="headerlink" title="负载因子 0.75"></a>负载因子 0.75</h3><p>“如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？”<br>默认的负载因子大小为 0.75，也就是说，当一个map填满了 75% 的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。<br>这个过程叫作 <strong>rehashing</strong>，因为它调用hash方法找到新的bucket位置。</p>
<h3 id="rehashing-过程"><a href="#rehashing-过程" class="headerlink" title="rehashing 过程"></a>rehashing 过程</h3><p>重新调整HashMap大小存在的问题:<br>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候， HashMap 并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。</p>
<h3 id="key类型的选择与提速"><a href="#key类型的选择与提速" class="headerlink" title="key类型的选择与提速"></a>key类型的选择与提速</h3><ul>
<li><p>hashing的概念</p>
</li>
<li><p>HashMap 中解决碰撞的方法</p>
</li>
<li><p>equals()和hashCode()的应用，以及它们在HashMap中的重要性</p>
</li>
<li><p><strong>不可变对象的好处</strong></p>
<p>使用不可变的、声明作final的对象，并且采用合适的<code>equals()</code>和<code>hashCode()</code>方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用 String，Interger 这样的wrapper类作为键是非常好的选择。而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。</p>
<p>不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。<strong>不可变性还有其他的优点如线程安全</strong>。如果你可以仅仅通过将某个field声明成final就能<strong>保证hashCode是不变的</strong>，那么请这么做吧。</p>
<p>因为获取对象的时候要用到<code>equals()</code>和<code>hashCode()</code>方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的<code>hashcode</code>的话，那么碰撞的几率就会小些，这样就能提高<code>HashMap</code>的性能。</p>
</li>
</ul>
<p><strong>复杂度</strong></p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p><strong>特性</strong></p>
<ol>
<li>非线程同步</li>
<li>有序： 可以按照访问顺序或者插入顺序排序</li>
</ol>
<p><strong>实现原理</strong><br>底层使用哈希表与<strong>双向链表</strong>来保存所有元素。其基本操作与父类 HashMap 相似</p>
<p>LinkedHashMap 定义了排序模式 accessOrder，该属性为 boolean 型变量，对于访问顺序，为 true；<br>对于插入顺序，则为 false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。</p>
<p>//TODO 排序模式</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p><strong>特性</strong></p>
<ol>
<li><strong>可排序</strong></li>
<li>不是同步的<br><code>SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));</code></li>
</ol>
<p><strong>实现原理</strong><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/liqizhou/archive/2012/09/27/java%E4%B8%ADtreemap%E5%92%8Ctreeset%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91.html">红黑树</a>的数据结构, 实现了SortedMap接口</p>
<p><strong>复杂度</strong></p>
<p><strong>应用</strong><br>TreeMap 常用于在接口参数拼接中，以自动对key排序</p>
<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><p><strong>特性</strong></p>
<ol>
<li>当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值</li>
</ol>
<p><strong>实现原理</strong><br>使用<a target="_blank" rel="noopener" href="http://www.cnblogs.com/-OYK/archive/2011/10/24/2222874.html" title="Java中的四种引用类型">弱引用</a>作为内部数据的存储方案。 WeakHashMap可以作为简单缓存表的解决方案，<br>当系统内存不够的时候，垃圾收集器会自动的清除没有在其他任何地方被引用的键值对。</p>
<h2 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h2><p><strong>特性</strong></p>
<ol>
<li>Key必须是Enum</li>
<li>EnumMap的key不允许为null，value可以为null，按照key在enum中的顺序进行保存，非线程安全。</li>
</ol>
<p><strong>实现原理</strong></p>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p><strong>特性</strong></p>
<ol>
<li><strong>线程安全</strong></li>
<li>性能比HashMap差</li>
</ol>
<p><strong>实现原理</strong><br>哈希表<br>使用 synchronized 锁住所有的读写操作</p>
<p><strong>复杂度</strong></p>
<h1 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h1><blockquote>
<p>// FIXME 实现原理</p>
</blockquote>
<p>队列, 它主要分为两大类:</p>
<ul>
<li>一类是阻塞式队列, 队列满了以后再插入元素则会抛出异常, 主要包括<ul>
<li><code>ArrayBlockQueue</code></li>
<li><code>PriorityBlockingQueue</code></li>
<li><code>LinkedBlockingQueue</code></li>
</ul>
</li>
<li>另一类是双端队列, 支持在头、尾两端插入和移除元素, 主要包括：<ul>
<li><code>ArrayDeque</code></li>
<li><code>LinkedBlockingDeque</code></li>
<li><code>LinkedList</code></li>
</ul>
</li>
</ul>
<p>常见的队列有:</p>
<ol>
<li>ArrayDeque, （数组双端队列）</li>
<li>PriorityQueue, （优先级队列）</li>
<li>ConcurrentLinkedQueue, （基于链表的并发队列）</li>
<li>DelayQueue, （延期阻塞队列）（阻塞队列实现了BlockingQueue接口）</li>
<li>ArrayBlockingQueue, （基于数组的并发阻塞队列）</li>
<li>LinkedBlockingQueue, （基于链表的FIFO阻塞队列）</li>
<li>LinkedBlockingDeque, （基于链表的FIFO双端阻塞队列）</li>
<li>PriorityBlockingQueue, （带优先级的无界阻塞队列）</li>
<li>SynchronousQueue （并发同步阻塞队列）</li>
</ol>
<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>无界优先级队列<br><strong>特性</strong></p>
<ol>
<li>有序:<ul>
<li>顺序取决于元素的自然顺序或者创建队列时指定的Comparator</li>
<li>依靠自然顺序的优先级队列还不允许插入不可比较的对象（这样做可能导致 ClassCastException）。</li>
</ul>
</li>
<li>不允许元素为null</li>
<li>优先级队列是无界的<br>有一个内部容量，控制着用于存储队列元素的数组大小。它通常至少等于队列的大小。<br>随着不断向优先级队列添加元素，其容量会自动增加。无需指定容量增加策略的细节。</li>
<li>非线程安全</li>
</ol>
<h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>无界优先级阻塞队列<br><strong>特性</strong></p>
<ol>
<li>有序: 与PriorityQueue相同</li>
<li>不允许元素为null</li>
<li>无界: 资源耗尽时执行add会失败（导致 OutOfMemoryError）</li>
<li>线程安全</li>
</ol>
<h1 id="几种特殊的"><a href="#几种特殊的" class="headerlink" title="几种特殊的"></a>几种特殊的</h1><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a><code>CopyOnWriteArrayList</code></h2><p><code>ArrayList</code>的一个线程安全的变体, 所有可变操作（<code>add</code>、<code>set</code> 等等）都是通过对底层数组进行一次新的复制作为新的内部数组来实现的.</p>
<ul>
<li>这一般需要很大的开销, 但是当遍历操作的数量大大超过可变操作的数量时, 这种方法可能比其他替代方法更有效.</li>
<li>在不能或不想进行同步遍历, 但又需要从并发线程中排除冲突时, 它也很有用.</li>
</ul>
<p><code>“快照”风格</code>的迭代器方法在创建迭代器时使用了对数组状态的引用. 此数组在迭代器的生存期内不会更改, 因此不可能发生冲突, 并且迭代器保证不会抛出<code>ConcurrentModificationException</code>. 创建迭代器以后, 迭代器就不会反映列表的添加、移除或者更改. 在迭代器上进行的元素更改操作（remove、set 和 add）不受支持. 这些方法将抛出 <code>UnsupportedOperationException</code>.</p>
<p>允许使用所有元素, 包括 null.</p>
<p>内存一致性效果：</p>
<p>当存在其他并发 collection 时, 将对象放入 <code>CopyOnWriteArrayList</code> 之前的线程中的操作 <code>happen-before</code><br>随后通过另一线程从 <code>CopyOnWriteArrayList</code> 中访问或移除该元素的操作.</p>
<p>这个类和ArrayList最大的区别就是add(E) 的时候。容器会自动copy一份出来然后再尾部add(E)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">Object[] elements = getArray();</span><br><span class="line"><span class="keyword">int</span> len = elements.length;</span><br><span class="line">Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">newElements[len] = e;</span><br><span class="line">setArray(newElements);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a><code>CopyOnWriteArraySet</code></h2><p>对其所有操作使用内部 <code>CopyOnWriteArrayList</code> 的 Set. 因此, 它共享以下相同的基本属性：</p>
<p>它最适合于具有以下特征的应用程序：</p>
<ul>
<li>set 大小通常保持很小, 只读操作远多于可变操作, 需要在遍历期间防止线程间的冲突.</li>
<li>它是线程安全的.</li>
<li>因为通常需要复制整个基础数组, 所以可变操作（add、set 和 remove 等等）的开销很大.</li>
<li>迭代器不支持可变 remove 操作.</li>
<li>使用迭代器进行遍历的速度很快, 并且不会与其他线程发生冲突. 在构造迭代器时, 迭代器依赖于不变的数组快照.</li>
</ul>
<p><strong>示例用法</strong></p>
<p>以下代码使用一个写时复制（copy-on-write）的 set, 以维护在状态更新时执行某项操作的一组 Handler 对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;Handler&gt; handlers = <span class="keyword">new</span> CopyOnWriteArraySet&lt;Handler&gt;();</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHandler</span><span class="params">(Handler h)</span> </span>&#123;</span><br><span class="line">handlers.add(h);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">long</span> internalState;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">changeState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">internalState = ...;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">changeState();</span><br><span class="line"><span class="keyword">for</span> (Handler handler : handlers)</span><br><span class="line">    handler.handle();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><blockquote>
<p>   //FIXME 重写介绍</p>
</blockquote>
<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><ol>
<li>结构</li>
</ol>
<p><img src="/images/java/Collection_Map/concurrentHashMap-construction.png" alt="c"></p>
<ol>
<li>详情请参考: <a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/index.html">探索 ConcurrentHashMap 高并发性的实现机制</a>的<a href="/Java/collection/ConcurrentHashMap/">本地版</a></li>
</ol>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="Collections类中的静态方法"><a href="#Collections类中的静态方法" class="headerlink" title="Collections类中的静态方法"></a>Collections类中的静态方法</h2><p>在 Collections类中有多个静态方法，它们可以获取通过同步方法封装非同步集合而得到的集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Collection <span class="title">synchronizedCollention</span><span class="params">(Collection c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">synchronizedList</span><span class="params">(list l)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title">synchronizedMap</span><span class="params">(Map m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set <span class="title">synchronizedSet</span><span class="params">(Set s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SortedMap <span class="title">synchronizedSortedMap</span><span class="params">(SortedMap sm)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SortedSet <span class="title">synchronizedSortedSet</span><span class="params">(SortedSet ss)</span></span></span><br></pre></td></tr></table></figure>
<p>这些方法基本上返回具有同步集合方法版本的新类。比如，为了创建多线程安全且由ArrayList支持的List，可以使用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = Collection.synchronizedList(<span class="keyword">new</span> ArrayList());</span><br></pre></td></tr></table></figure>
<p>注意，ArrayList实例马上封装起来，不存在对未同步化ArrayList的直接引用（即直接封装匿名实例）。这是一种最安全的途径。如果另一个线程要直接引用ArrayList实例，它可以执行非同步修改。</p>
<p>//FIXME 实现原理</p>
<h2 id="CopyOnWrite机制"><a href="#CopyOnWrite机制" class="headerlink" title="CopyOnWrite机制"></a>CopyOnWrite机制</h2><h2 id="synchronized机制"><a href="#synchronized机制" class="headerlink" title="synchronized机制"></a>synchronized机制</h2><h2 id="ReteenLock机制"><a href="#ReteenLock机制" class="headerlink" title="ReteenLock机制"></a>ReteenLock机制</h2><h2 id="ConcurrentHashMap是个特例"><a href="#ConcurrentHashMap是个特例" class="headerlink" title="ConcurrentHashMap是个特例"></a>ConcurrentHashMap是个特例</h2><h1 id="异同点"><a href="#异同点" class="headerlink" title="异同点"></a>异同点</h1><h2 id="Vector-和-ArrayList"><a href="#Vector-和-ArrayList" class="headerlink" title="Vector 和 ArrayList"></a>Vector 和 ArrayList</h2><ol>
<li>Vector是线程同步的, 所以它也是线程安全的, 而ArrayList是线程异步的, 是不安全的. 如果不考虑到线程的安全因素, 一般用ArrayList效率比较高.</li>
<li>如果集合中的元素的数目大于目前集合数组的长度时, Vector增长率为目前数组长度的100%, 而ArrayList增长率为目前数组长度的50%. 如果在集合中使用数据量比较大的数据, 用Vector有一定的优势.</li>
<li>如果查找一个指定位置的数据, Vector和ArrayList使用的时间是相同的, 都是<code>O(1)</code>,这个时候使用Vector和ArrayList都可以; 而如果移动一个指定位置的数据花费的时间为<code>O(n-i)</code>  n为总长度, 这个时候就应该考虑到使用LinkedList, 因为它移动一个指定位置的数据所花费的时间为<code>O(1)</code>, 而查询一个指定位置的数据时花费的时间为<code>O(i)</code>.</li>
</ol>
<h2 id="Arraylist和LinkedList"><a href="#Arraylist和LinkedList" class="headerlink" title="Arraylist和LinkedList"></a>Arraylist和LinkedList</h2><ol>
<li>ArrayList是实现了基于动态数组的数据结构, LinkedList基于链表的数据结构.</li>
<li>对于随机访问<code>get</code>和<code>set</code>, <code>ArrayList</code>优于<code>LinkedList</code>, 因为<code>LinkedList</code>要移动指针.</li>
<li>对于新增和删除操作<code>add</code>和<code>remove</code>, <code>LinkedList</code>比较占优势, 因为<code>ArrayList</code>要移动数据.<br>这一点要看实际情况的. 若只对单条数据插入或删除, <code>ArrayList</code>的速度反而优于<code>LinkedList</code>. 但若是批量随机的插入删除数据, <code>LinkedList</code>的速度大大优于<code>ArrayList</code>. 因为<code>ArrayList</code>每插入一条数据, 要移动插入点及之后的所有数据.</li>
</ol>
<h2 id="HashMap-与-TreeMap"><a href="#HashMap-与-TreeMap" class="headerlink" title="HashMap 与 TreeMap"></a>HashMap 与 TreeMap</h2><ol>
<li>HashMap通过hashcode对其内容进行快速查找, 而TreeMap中所有的元素都保持着某种固定的顺序,<br> 如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）.</li>
<li>在Map 中插入、删除和定位元素, HashMap 是最好的选择. 但如果您要按自然顺序或自定义顺序遍历键, 那么TreeMap会更好.<br>使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现.  这个TreeMap没有调优选项, 因为该树总处于平衡状态.</li>
</ol>
<h2 id="HashMap与HashTable的区别"><a href="#HashMap与HashTable的区别" class="headerlink" title="HashMap与HashTable的区别"></a>HashMap与HashTable的区别</h2><ol>
<li>继承不同<br><code>public class Hashtable extends Dictionary implements Map</code><br><code>public class HashMap  extends AbstractMap implements Map</code></li>
<li>Hashtable 中的方法是同步的, 而HashMap中的方法在缺省情况下是非同步的. 在多线程并发的环境下, 可以直接使用Hashtable, 但是要使用HashMap的话就要自己增加同步处理了.</li>
<li>Hashtable中, key和value都不允许出现null值, 在HashMap中, null可以作为键, 这样的键只有一个; 可以有一个或多个键所对应的值为null. 当get()方法返回null值时, 即可以表示 HashMap中没有该键,也可以表示该键所对应的值为null. 因此, 在HashMap中不能由get()方法来判断HashMap中是否存在某个键, 而应该用containsKey()方法来判断.</li>
<li>两个遍历方式的内部实现上不同.<br>Hashtable、HashMap都使用了 Iterator. 而由于历史原因, Hashtable还使用了Enumeration的方式 .</li>
<li>哈希值的使用不同, HashTable直接使用对象的hashCode. 而HashMap重新计算hash值.</li>
<li>Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式. HashTable中hash数组默认大小是11, 增加的方式是 old*2+1. HashMap中hash数组的默认大小是16, 而且一定是2的指数</li>
</ol>
<h2 id="对集合的选择"><a href="#对集合的选择" class="headerlink" title="对集合的选择"></a>对集合的选择</h2><h3 id="对List的选择"><a href="#对List的选择" class="headerlink" title="对List的选择"></a>对List的选择</h3><ol>
<li>对于随机查询与迭代遍历操作, 数组比所有的容器都要快. 所以在随机访问中一般使用ArrayList</li>
<li>LinkedList使用双向链表对元素的增加和删除提供了非常好的支持, 而ArrayList执行增加和删除元素需要进行元素位移.</li>
<li>对于Vector而已, 我们一般都是避免使用.</li>
<li>将ArrayList当做首选, 毕竟对于集合元素而已我们都是进行遍历, 只有当程序的性能因为List的频繁插入和删除而降低时, 再考虑LinkedList.</li>
</ol>
<h3 id="对Set的选择"><a href="#对Set的选择" class="headerlink" title="对Set的选择"></a>对Set的选择</h3><ol>
<li><code>HashSet</code>由于使用<code>HashCode</code>实现, 所以在某种程度上来说它的性能永远比<code>TreeSet</code>要好, 尤其是进行增加和查找操作.</li>
<li>虽然<code>TreeSet</code>没有<code>HashSet</code>性能好, 但是由于它可以维持元素的排序, 所以它还是存在用武之地的.</li>
</ol>
<h3 id="对Map的选择"><a href="#对Map的选择" class="headerlink" title="对Map的选择"></a>对Map的选择</h3><ol>
<li>HashMap与HashSet同样, 支持快速查询. 虽然HashTable的速度也不慢, 但是在HashMap面前还是稍微慢了些, 所以HashMap在查询方面可以取代HashTable.</li>
<li>由于TreeMap需要维持内部元素的顺序, 所以它通常要比HashMap和HashTable慢.</li>
</ol>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组复制System-arrayCopy"><a href="#数组复制System-arrayCopy" class="headerlink" title="数组复制System.arrayCopy"></a>数组复制<code>System.arrayCopy</code></h3><p>该方法是个JNI函数, 是在JVM中实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*从src的srcPos位置复制数据到dest的destPos位置, 长度为length</span></span><br><span class="line"><span class="comment">*src - 源数组.</span></span><br><span class="line"><span class="comment">*srcPos - 源数组中的起始位置.</span></span><br><span class="line"><span class="comment">*dest - 目标数组.</span></span><br><span class="line"><span class="comment">*destPos - 目标数据中的起始位置.</span></span><br><span class="line"><span class="comment">*length - 要复制的数组元素的数量.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="Arrays-copyOf"><a href="#Arrays-copyOf" class="headerlink" title="Arrays.copyOf"></a>Arrays.copyOf</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 由U类型复制为T类型？</span></span><br><span class="line"><span class="comment">* original - 要复制的数组</span></span><br><span class="line"><span class="comment">* newLength - 要返回的副本的长度</span></span><br><span class="line"><span class="comment">* newType - 要返回的副本的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">  T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">? (T[]) <span class="keyword">new</span> Object[newLength]</span><br><span class="line">: (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">  System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line"> Math.min(original.length, newLength));</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Arrays-asList-将数组转换为ArrayList"><a href="#Arrays-asList-将数组转换为ArrayList" class="headerlink" title="Arrays.asList: 将数组转换为ArrayList"></a>Arrays.asList: 将数组转换为ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;T&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Arrays.asList返回的<code>ArrayList</code>并不是<code>java.util.ArrayList</code>, 只是<code>Arrays</code>的内部类. 该类只提供了一些基本的操作,</p>
<ol>
<li>size：元素数量</li>
<li>toArray：转换为数组, 实现了数组的浅拷贝.</li>
<li>get：获得指定元素.</li>
<li>contains：是否包含某元素.<br>asList返回的是一个长度不可变的列表. 数组是多长, 转换成的列表是多长, 我们是无法通过add、remove来增加或者减少其长度的<br>我们经常需要使用到Arrays这个工具的asList()方法将其转换成列表. 方便是方便, 但是有时候会出现莫名其妙的问题. 如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] datas = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">  List list = Arrays.asList(datas);</span><br><span class="line">  System.out.println(list.size());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<p>结果是1, 为什么会是1而不是5呢？先注意这个参数: T…a, 这个参数是一个泛型的变长参数, 我们知道 <strong>基本数据类型是不可能泛型化的</strong> ,也就是说8个基本数据类型是不可作为泛型参数的, 但是为什么编译器没有报错呢？这是因为数组会当做一个对象来处理, 它是可以泛型的, 所以我们的程序是把一个int型的数组作为了T的类型,所以在转换之后List中就只会存在一个类型为int数组的元素了.<br>所以我们这样的程序<code>System.out.println(datas.equals(list.get(0)));</code>输出结果肯定是<code>true</code>.<br>当然如果将int改为Integer, 则长度就会变成5了.</p>
<h3 id="Arrays-fill"><a href="#Arrays-fill" class="headerlink" title="Arrays.fill"></a>Arrays.fill</h3><p>使用值填充数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">Arrays.fill(a,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 使用0填充数组a</span></span><br></pre></td></tr></table></figure>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h3><p>Map的遍历,都是需要转换为Collection</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = ...;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>由Map生成<code>Collection</code>, 获取所有的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; values = map.values();</span><br><span class="line">Iterator&lt;String&gt; iterator = values.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>由Map.keySet, 遍历key值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">Iterator&lt;String&gt; keyIterator = keySet.iterator();</span><br></pre></td></tr></table></figure></li>
<li><p>获取Map.Entry类型的Set</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; entryIterator = entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line">	Map.Entry&lt;String, String&gt; entry = entryIterator.next();</span><br><span class="line">	String key = entry.getKey();</span><br><span class="line">	String value = entry.getValue();</span><br><span class="line">	System.out.println(key + <span class="string">&quot;\t&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Collection的遍历方法"><a href="#Collection的遍历方法" class="headerlink" title="Collection的遍历方法"></a>Collection的遍历方法</h3></li>
<li><p>Iterator 迭代子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; values2 = map.values();</span><br><span class="line">Iterator&lt;String&gt; iterator2 = values2.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">	System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>foreach</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String valueItem : values2) &#123;</span><br><span class="line">	System.out.println(valueItem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>List特有的遍历方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">assert</span> list != <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">	System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当然也可以写成</span></span><br><span class="line"><span class="keyword">for</span> (String aList : list) &#123;</span><br><span class="line">	System.out.println(aList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>List遍历方式有三种:</p>
<ul>
<li>下标遍历</li>
<li>Iterator遍历</li>
<li>Foreach遍历（最快）</li>
</ul>
</li>
</ol>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><blockquote>
<p>FIXME 排序：集合自带排序 对集合排序</p>
</blockquote>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Java中有多少种数据结构-分别是什么？"><a href="#Java中有多少种数据结构-分别是什么？" class="headerlink" title="Java中有多少种数据结构, 分别是什么？"></a>Java中有多少种数据结构, 分别是什么？</h2><pre><code>- List：是列表, 有下标值, 存储元素可以重复, 遍历元素是有序的.
- Set：是散列集, 无下标值, 存储元素不可重复, 遍历元素时无序的.
- Map：是以键值对存储, 一个key一个value, key不可以重复, value可以重复.
- 数组：指定类型, 固定长度, 元素存储地址是连续的.
- 树：元素以树形结构存储, 只有一个根节点.
- 栈：元素是先进后出, 后进先出.
- 向量：动态数组, 可以存储任何类型元素, 动态长度, 元素存储地址是连续的.
- 队列：元素存储是排列有序的, 一定保证先进的先出, 后进的后出.</code></pre>
<hr>
<p>修改记录:</p>
<ol>
<li>HashMap的详细实现原理 重写ConcurrentHashMap介绍     2016-08-20</li>
</ol>
<hr>
<p>参考文献:</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://cmsblogs.com/?p=106">java提高篇（二十）集合大家族</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/softwave/article/details/4166598">Java集合类详解</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/index.html">探索 ConcurrentHashMap 高并发性的实现机制</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/18/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/20/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">aaronzhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">224</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">114</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aaronzhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
