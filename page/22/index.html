<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Guadazi">
<meta property="og:url" content="http://example.com/page/22/index.html">
<meta property="og:site_name" content="Guadazi">
<meta property="og:locale">
<meta property="article:author" content="aaronzhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/22/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Guadazi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Guadazi</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/reflection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/reflection/" class="post-title-link" itemprop="url">Java 反射</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-10-14 00:00:00" itemprop="dateCreated datePublished" datetime="2015-10-14T00:00:00+08:00">2015-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-16 15:17:28" itemprop="dateModified" datetime="2021-01-16T15:17:28+08:00">2021-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="在多级类继承中-如何找到方法是在哪个类实现的"><a href="#在多级类继承中-如何找到方法是在哪个类实现的" class="headerlink" title="在多级类继承中, 如何找到方法是在哪个类实现的?"></a>在多级类继承中, 如何找到方法是在哪个类实现的?</h2><p>currentObject 是ContextWrapper 的子类的对象, <code>mBase</code>是定义在 <code>currentObject</code>某一个父类的字段,<br><code>mBase</code>中的某个方法<code>getSharedPerences()</code>是定义在某个父类中的抽象方法,<br>如何确定该方法是在哪个父类中实现的?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  Field field = ContextWrapper.class.getDeclaredField(<span class="string">&quot;mBase&quot;</span>);</span><br><span class="line">  field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">  Object object = field.get(currentObject);</span><br><span class="line">  Log.i(TAG,<span class="string">&quot;the real implement class is &quot;</span> + filed.getClass().getName());</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getSharedPerences()</code>方法一定定义在<code>mBase</code>类中. 妙哉!<br>获得<code>mBase</code>对象的类名就是该方法的实现类.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/android-network/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/android-network/" class="post-title-link" itemprop="url">Android网络编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-09-23 00:00:00" itemprop="dateCreated datePublished" datetime="2015-09-23T00:00:00+08:00">2015-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-16 15:17:28" itemprop="dateModified" datetime="2021-01-16T15:17:28+08:00">2021-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Android 网络开发</p>
<p>网络功能是 Android 的最基本的功能之一, 本文将详细介绍 Android 网络开发.</p>
<ol>
<li>Android网络编程专题之二:搭建测试服务器 目的是为了测试 Android 网络代码</li>
<li>Android网络编程专题之三:模拟简单的网络应用</li>
</ol>
<ul>
<li>下载并显示图片</li>
<li>HttpURLConnection GET和POST请求</li>
<li>HttpClient: apache-commons-httpclient GET和POST请求</li>
<li>WebView</li>
</ul>
<ol start="3">
<li>Android网络编程专题之四:第三方框架</li>
</ol>
<ul>
<li>AsyncHttpClient<ul>
<li>post</li>
<li>get</li>
<li>文件上传</li>
</ul>
</li>
<li>SmartImage</li>
</ul>
<ol start="4">
<li>Android网络编程专题之五:多线程断点下载</li>
</ol>
<h1 id="Android配置"><a href="#Android配置" class="headerlink" title="Android配置"></a>Android配置</h1><p>网络连接需要声明网络服务权限:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="简单的服务器端"><a href="#简单的服务器端" class="headerlink" title="简单的服务器端"></a>简单的服务器端</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p>为了支持Android的网络测试，搭建一个服务器端工程，满足如下几个要求：</p>
<ol>
<li>并支持Session和Cookie</li>
<li>支持文件上传</li>
<li>图片查看</li>
</ol>
<p>访问<code>/SimpleServer</code>进入登陆界面</p>
<p><img src="/images/android/network/android-network-SimpleServer-index.png"></p>
<p>登陆成功，显示相关的信息</p>
<p><img src="/images/android/network/android-network-SimpleServer-loginSuccess.png"></p>
<p>登陆失败，显示失败信息</p>
<p><img src="/images/android/network/android-network-SimpleServer-loginFailure.png"></p>
<p>下载图片地址</p>
<p><code>/SimpleServer/gyy.jpg</code></p>
<p><img src="/images/android/network/android-network-SimpleServer-image.png"></p>
<p>文件上传</p>
<p><code>/SimpleServer/uploadFile.jsp</code></p>
<p><img src="/images/android/network/android-network-SimpleServer-uploadServer1.png"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Eclipse工程目录如下</p>
<p><img src="/images/android/network/android-network-SimpleServer-project.png"></p>
<ol>
<li>创建打开<code>/SimpleServer/</code>的默认页面<code>login.jsp</code></li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">	pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>登陆<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">		姓名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> &gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">		密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> &gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;get 提交&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;login&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">		姓名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> &gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">		密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> &gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;post 提交&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面有两个表单，分别用于使用<code>get</code>方法和<code>post</code>方法请求，发送请求到action–<code>login</code></p>
<ol start="2">
<li>在<code>web.xml</code>中注册</li>
</ol>
<p>在<code>web-app</code>节点下创建<code>welcome-file-list</code>子节点<br>添加页面</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>login.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>welcome-file</code>是默认的欢迎页面，在不指定子页面的情况下，按照<code>welcome-file-list</code>的顺序寻找页面，直到找到页面。<br>如果所有的页面都找不到，则只能显示404了</p>
<ol start="3">
<li>在<code>web.xml</code>中注册login action</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>login<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>club.guadazi.ss.LoginAction<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>login<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>LoginAction</li>
</ol>
<p>页面登陆，登陆成功后将用户名记录到Session中，如果Session中用户名不为null则代表已经登陆。<br>如果登陆失败，输出错误信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> club.guadazi.ss;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginAction</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LoginAction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">		HttpSession session = req.getSession();</span><br><span class="line">		Object pwdAttribute = req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">		Object nameAttribute = req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (pwdAttribute != <span class="keyword">null</span> &amp;&amp; <span class="string">&quot;abc.123&quot;</span>.equals((String) pwdAttribute)</span><br><span class="line">    &amp;&amp; nameAttribute != <span class="keyword">null</span>) &#123;</span><br><span class="line">			String name = (String) nameAttribute;</span><br><span class="line">			session.setAttribute(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">			resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">			resp.sendRedirect(<span class="string">&quot;info.jsp&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			resp.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">			PrintWriter writer = resp.getWriter();</span><br><span class="line">			writer.print(<span class="string">&quot;&lt;html&gt;&lt;head&gt;&quot;</span>);</span><br><span class="line">			writer.print(<span class="string">&quot;&lt;title&gt;&quot;</span> + <span class="string">&quot;欢迎 post&quot;</span> + <span class="string">&quot;&lt;/title&gt;&quot;</span>);</span><br><span class="line">			writer.print(<span class="string">&quot;&lt;/head&gt;&quot;</span>);</span><br><span class="line">			writer.print(<span class="string">&quot;&lt;center&gt;登陆失败!&lt;/center&gt;&quot;</span>);</span><br><span class="line">			writer.flush();</span><br><span class="line">			writer.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">   <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">		doPost(req, resp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Servlet实现的过程，继承HttpServlet，HttpServlet类含有处理post和get请求的方法，重写相应的方法即可。<br>Session用于保存一次会话的所有信息，Session以键值对的形式保存信息。常常用于记录登陆信息，当登陆成功后记录用户信息到Session，<br>在其他的页面上可以判断是否登陆，如果未登陆，则显示登陆页面。<br><code>HttpServletRequest.getParameter</code>可以获取页面表单在发请求时携带的参数。<br><code>resp.sendRedirect(&quot;info.jsp&quot;);</code>页面重定向</p>
<ol start="5">
<li>info.jsp 登陆成功后显示的页面</li>
</ol>
<p>需要在头部增加Session中用户名判断信息</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">	HttpSession session2 = request.getSession();</span><br><span class="line">	Object nameObject = session2.getAttribute(&quot;name&quot;);</span><br><span class="line">	if (nameObject == null) &#123;</span><br><span class="line">		/* 		response.sendRedirect(&quot;/SimpleServer&quot;); */</span><br><span class="line">%&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line">	未登录 <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/SimpleServer&quot;</span>&gt;</span>点击登陆<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line">&lt;%</span><br><span class="line">	return;</span><br><span class="line">	&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<p>当为登陆时不再显示下面的信息直接return</p>
<ol start="6">
<li>上传文件页面</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;uploadFileAction&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;filename&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">value</span>=<span class="string">&quot;Press&quot;</span>&gt;</span> to upload the file!</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>enctype</code>必须指定为<code>multipart/form-data</code></p>
<ol start="7">
<li>上传文件Action</li>
</ol>
<p>使用Apache的commons-fileupload工具包在doPost方法中实现上传文件<br>commons-fileupload依赖commons-io包</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">DiskFileItemFactory factory = <span class="keyword">new</span> DiskFileItemFactory();</span><br><span class="line">ServletFileUpload fileUpload = <span class="keyword">new</span> ServletFileUpload(factory);</span><br><span class="line"><span class="keyword">if</span> (!ServletFileUpload.isMultipartContent(req)) &#123;</span><br><span class="line">  PrintWriter writer = resp.getWriter();</span><br><span class="line">  writer.println(<span class="string">&quot;is not multipart content!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  List&lt;FileItem&gt; list = fileUpload.parseRequest(req);</span><br><span class="line">  <span class="keyword">for</span> (FileItem fileItem : list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fileItem.isFormField()) &#123;</span><br><span class="line">      String name = fileItem.getName();</span><br><span class="line">      String value = fileItem.getString();</span><br><span class="line">      ServletOutputStream outputStream = resp.getOutputStream();</span><br><span class="line">      outputStream.write((name + <span class="string">&quot;:&quot;</span> + value).getBytes());</span><br><span class="line">      outputStream.close();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      String fileName = fileItem.getName();</span><br><span class="line">      String realPath = <span class="comment">/* this.getServletContext().getRealPath */</span>(<span class="string">&quot;/Users/Mariaaron/upload/&quot;</span>);</span><br><span class="line">      System.out.println(realPath);</span><br><span class="line">      FileOutputStream out = <span class="keyword">new</span> FileOutputStream(realPath + fileName);</span><br><span class="line">      InputStream in = fileItem.getInputStream();</span><br><span class="line">      <span class="keyword">byte</span> buffer[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">      <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((len = in.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        out.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">      &#125;</span><br><span class="line">      out.close();</span><br><span class="line">      in.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileUploadException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>源文件与war包的<a target="_blank" rel="noopener" href="http://pan.baidu.com/s/1qW89zyc" title="SimpleServer源码与war包下载">下载地址</a></p>
<h1 id="简单网络操作"><a href="#简单网络操作" class="headerlink" title="简单网络操作"></a>简单网络操作</h1><p>Android 网络</p>
<h2 id="Android-网络连接线程"><a href="#Android-网络连接线程" class="headerlink" title="Android 网络连接线程"></a>Android 网络连接线程</h2><ol>
<li>在 Android 中, 主线程负责更新 UI, 因此,主线程也称为 UI 线程.</li>
<li>除了ProcessBar等几个少数的控件外, 几乎所有的 UI 控件必须在主线程更新.</li>
<li>为了防止 UI 载入和更新出现卡顿, 网络连接/大图片载入以及一些大型的计算必须在子线程进行.</li>
<li>网络操作必须放在子线程, 在子线程使用 Handler 更新 UI.<br>异步框架<code>AsyncHttpClient</code>就是基于这个原理实现的.</li>
</ol>
<p>Android提供了在子线程更新 UI 的 API:<br><code>Activity.runOnUiThread(Thread thread)</code> 方法,将 Runnable 中的任务放到UI 线程执行:<br/><br>// 如果当前线程就是UI 线程立即执行,否者将把 Runnable 线程 join 到UI 线程中执行.</p>
<h2 id="Java-Socket"><a href="#Java-Socket" class="headerlink" title="Java Socket"></a>Java Socket</h2><blockquote>
<p>android简单聊天工具</p>
</blockquote>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>类 URL 代表一个统一资源定位符，它是指向互联网“资源”的指针。</p>
<p>创建一个到 URL 的连接需要几个步骤：</p>
<p>  openConnection() ———— 时间 —————-&gt;    connect()<br>对影响到远程资源连接的参数进行操作 ———— 时间 —————-&gt; 与资源交互；查询头字段和内容。</p>
<ol>
<li>通过在 URL 上调用 openConnection 方法创建连接对象。</li>
<li>处理设置参数和一般请求属性。</li>
<li>使用 connect 方法建立到远程对象的实际连接。</li>
<li>远程对象变为可用。远程对象的头字段和内容变为可访问。</li>
</ol>
<p>使用以下方法修改设置参数：</p>
<p>   setAllowUserInteraction<br>   setDoInput<br>   setDoOutput<br>   setIfModifiedSince<br>   setUseCaches</p>
<p>使用以下方法修改一般请求属性：</p>
<p>   setRequestProperty</p>
<p>使用 setDefaultAllowUserInteraction 和 setDefaultUseCaches 可设置 AllowUserInteraction 和 UseCaches 参数的默认值。</p>
<p>上面每个 set 方法都有一个用于获取参数值或一般请求属性值的对应 get 方法。适用的具体参数和一般请求属性取决于协议。</p>
<p>在建立到远程对象的连接后，以下方法用于访问头字段和内容：</p>
<p>   getContent<br>   getHeaderField<br>   getInputStream<br>   getOutputStream</p>
<p>某些头字段需要经常访问。以下方法：</p>
<p>   getContentEncoding<br>   getContentLength<br>   getContentType<br>   getDate<br>   getExpiration<br>   getLastModifed</p>
<p>提供对这些字段的便捷访问。getContent 方法使用 getContentType 方法以确定远程对象类型；子类重写 getContentType 方法很容易。</p>
<p>一般情况下，所有的预连接参数和一般请求属性都可忽略：预连接参数和一般请求属性默认为敏感值。对于此接口的大多数客户端而言，只有两个需要的方法：getInputStream 和 getContent，它们通过便捷方法镜像到 URL 类中。</p>
<h2 id="URLConnection"><a href="#URLConnection" class="headerlink" title="URLConnection"></a>URLConnection</h2><p>例子: 布局文件中的Button被调用时，调用loadImage方法</p>
<p>在loadImage方法中</p>
<ol>
<li>判断收入的图片地址是否为空</li>
<li>启动新的子线程，在子线程中</li>
</ol>
<p>`URLConnection urlConnection = url.openConnection();’<br>返回一个 URLConnection 对象，它表示到 URL 所引用的远程对象的连接。<br>每次调用此 URL 的协议处理程序的 openConnection 方法都打开一个新的连接。</p>
<p>如果 URL 的协议（例如，HTTP 或 JAR）存在属于以下包或其子包之一的公共、专用 URLConnection 子类：java.lang、java.io、java.util、java.net，<br>返回的连接将为该子类的类型。例如，对于 HTTP，将返回 HttpURLConnection，对于 JAR，将返回 JarURLConnection。</p>
<p>‘InputStream inputStream = urlConnection.getInputStream();’<br>从打开的连接读取输入流</p>
<blockquote>
<p>‘InputStream inputStream = urlConnection.openStream();’<br>是<code>openConnection().getInputStream()</code>的缩写形式。</p>
</blockquote>
<p>‘Bitmap bitmap = BitmapFactory.decodeStream(inputStream);`<br>把输入流解码成位图对象</p>
<ol start="3">
<li><p>创建Message，将位图对象作为<code>Message.obj</code>, 向Handler发送消息</p>
</li>
<li><p>Handler执行，更新UI</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ImageView imageView;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadImage</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> String imageUrl = imageUrlEdit.getText().toString().trim();</span><br><span class="line">   <span class="keyword">if</span> (TextUtils.isEmpty(imageUrl)) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               URL url = <span class="keyword">new</span> URL(imageUrl);</span><br><span class="line">               HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">               urlConnection.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">               <span class="keyword">if</span> (urlConnection.getResponseCode() == <span class="number">200</span>) &#123;</span><br><span class="line">                   InputStream inputStream = urlConnection.getInputStream();</span><br><span class="line">                   Bitmap bitmap;</span><br><span class="line">                   bitmap = BitmapFactory.decodeStream(inputStream);</span><br><span class="line">                   Message message = <span class="keyword">new</span> Message();</span><br><span class="line">                   message.what = SHOW_IMAGE_BY_URL;</span><br><span class="line">                   message.obj = bitmap;</span><br><span class="line">                   handler.sendMessage(message);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">&quot;请求失败!&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadImage2</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> String imageUrl = imageUrlEdit.getText().toString().trim();</span><br><span class="line">   <span class="keyword">if</span> (TextUtils.isEmpty(imageUrl)) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               URL url = <span class="keyword">new</span> URL(imageUrl);</span><br><span class="line">               HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">               urlConnection.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">               <span class="keyword">if</span> (urlConnection.getResponseCode() == <span class="number">200</span>) &#123;</span><br><span class="line">                   InputStream inputStream = urlConnection.getInputStream();</span><br><span class="line">                   <span class="keyword">final</span> Bitmap bitmap = BitmapFactory.decodeStream(inputStream);</span><br><span class="line">                   <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * runOnUiThread 方法,将 Runnable 中的任务放到UI 线程执行:&lt;br/&gt;</span></span><br><span class="line"><span class="comment">                    * 如果当前线程就是UI 线程立即执行,否者将把 Runnable 线程 join 到UI 线程中执行.</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                   runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                           imageView.setImageBitmap(bitmap);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> showImageByUrl:</span><br><span class="line">                Bitmap bitmap = (Bitmap) msg.obj;</span><br><span class="line">                imageView.setImageBitmap(bitmap);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    imageView = (ImageView) findViewById(R.id.iv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="HttpURLConnection"><a href="#HttpURLConnection" class="headerlink" title="HttpURLConnection"></a>HttpURLConnection</h2><p>对于上面的例子，URL的scheme是HTTP类型的，<code>URL.openConnection</code>返回的对象就是<code>HttpURLConnection</code>对象。</p>
<p>get和post方式发送登录请求的代码和纯Java环境是一模一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loginUrlGet</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String path = loginPath + <span class="string">&quot;?name=&quot;</span> + name + <span class="string">&quot;&amp;password=&quot;</span> + password;</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(path);</span><br><span class="line">        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">        urlConnection.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (urlConnection.getResponseCode() == <span class="number">200</span>) &#123;</span><br><span class="line">            InputStream inputStream = urlConnection.getInputStream();</span><br><span class="line">            String content = readAsString(inputStream);</span><br><span class="line">            showResponseOnWebView(content);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">&quot;请求失败!&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loginUrlPost</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; requestParams = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        requestParams.put(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">        requestParams.put(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">        StringBuilder params = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : requestParams.entrySet()) &#123;</span><br><span class="line">            params.append(entry.getKey());</span><br><span class="line">            params.append(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">            params.append(URLEncoder.encode(entry.getValue(), <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">            params.append(<span class="string">&quot;&amp;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (params.length() &gt; <span class="number">0</span>) params.deleteCharAt(params.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] data = params.toString().getBytes();</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(loginPath);</span><br><span class="line">        HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class="line">        conn.setRequestMethod(<span class="string">&quot;POST&quot;</span>);<span class="comment">//必须大写</span></span><br><span class="line">        conn.setDoOutput(<span class="keyword">true</span>);</span><br><span class="line">        conn.setRequestProperty(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;Keep-Alive&quot;</span>);<span class="comment">//维持长连接</span></span><br><span class="line">        conn.setRequestProperty(<span class="string">&quot;Charset&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        conn.setRequestProperty(<span class="string">&quot;Content-Length&quot;</span>, String.valueOf(data.length));</span><br><span class="line">        conn.setRequestProperty(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">        DataOutputStream outStream = <span class="keyword">new</span> DataOutputStream(conn.getOutputStream());</span><br><span class="line">        outStream.write(data);</span><br><span class="line">        outStream.flush();</span><br><span class="line">        <span class="keyword">if</span> (conn.getResponseCode() == <span class="number">200</span>) &#123;</span><br><span class="line">            String result = readAsString(conn.getInputStream());</span><br><span class="line">            outStream.close();</span><br><span class="line">            showResponseOnWebView(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子只是实现了登录，如果当服务器端使用了Session时，再访问其他页面登录信息是无法联系起来的。<br>而HttpClient可以</p>
<h3 id="多线程下载"><a href="#多线程下载" class="headerlink" title="多线程下载"></a>多线程下载</h3><p>见 <a href="#nulti_download">下文</a></p>
<h2 id="HttpClient-apache-commons-httpclient"><a href="#HttpClient-apache-commons-httpclient" class="headerlink" title="HttpClient: apache-commons-httpclient"></a>HttpClient: apache-commons-httpclient</h2><p>HttpClient类似于Http的客户端，也就是浏览器。<br>它会保存会话，记录登录信息，Cookie等</p>
<p>看登录并访问的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loginHttpClientPost</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">    HttpClient httpClient = <span class="keyword">new</span> DefaultHttpClient();</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">    map.put(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">    String path = loginPath;</span><br><span class="line">    path += <span class="string">&quot;?&quot;</span>;</span><br><span class="line">    Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : entries) &#123;</span><br><span class="line">        String key = entry.getKey();</span><br><span class="line">        String value = entry.getValue();</span><br><span class="line">        path += key + <span class="string">&quot;=&quot;</span> + value;</span><br><span class="line">        path += <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path = path.substring(<span class="number">0</span>, path.length() - <span class="number">1</span>);</span><br><span class="line">    HttpPost httpPost = <span class="keyword">new</span> HttpPost(path);</span><br><span class="line">    String responseString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HttpResponse response = httpClient.execute(httpPost);</span><br><span class="line">        <span class="keyword">if</span> (response.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</span><br><span class="line">            responseString = EntityUtils.toString(response.getEntity());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            responseString = <span class="string">&quot;Error Response: &quot;</span></span><br><span class="line">                    + response.getStatusLine().toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    showResponseOnWebView(responseString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loginHttpClientGet</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建 HttpParams 以用来设置 HTTP 参数（这一部分不是必需的）</span></span><br><span class="line">    BasicHttpParams httpParams = <span class="keyword">new</span> BasicHttpParams();</span><br><span class="line">    <span class="comment">// 设置连接超时和 Socket 超时，以及 Socket 缓存大小</span></span><br><span class="line">    HttpConnectionParams.setConnectionTimeout(httpParams, <span class="number">20</span> * <span class="number">1000</span>);</span><br><span class="line">    HttpConnectionParams.setSoTimeout(httpParams, <span class="number">20</span> * <span class="number">1000</span>);</span><br><span class="line">    HttpConnectionParams.setSocketBufferSize(httpParams, <span class="number">8192</span>);</span><br><span class="line">    <span class="comment">// 设置重定向，缺省为 true</span></span><br><span class="line">    HttpClientParams.setRedirecting(httpParams, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 设置 user agent</span></span><br><span class="line">    String userAgent = <span class="string">&quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.2) Gecko/20100115 Firefox/3.6&quot;</span>;</span><br><span class="line">    HttpProtocolParams.setUserAgent(httpParams, userAgent);</span><br><span class="line">    <span class="comment">// 创建一个 HttpClient 实例</span></span><br><span class="line">    <span class="comment">// 注意 HttpClient httpClient = new HttpClient(); 是Commons HttpClient</span></span><br><span class="line">    <span class="comment">// 中的用法，在 Android 1.5 中我们需要使用 Apache 的缺省实现 DefaultHttpClient</span></span><br><span class="line">    HttpClient httpClient = <span class="keyword">new</span> DefaultHttpClient(httpParams);</span><br><span class="line">    Map params2 = <span class="keyword">new</span> HashMap();</span><br><span class="line">    params2.put(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">    params2.put(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">    String url = loginPath;</span><br><span class="line">     <span class="comment">/* 建立HTTPGet对象 */</span></span><br><span class="line">    String paramStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    Iterator iter = params2.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        Map.Entry entry = (Map.Entry) iter.next();</span><br><span class="line">        Object key = entry.getKey();</span><br><span class="line">        Object val = entry.getValue();</span><br><span class="line">        paramStr += paramStr = <span class="string">&quot;&amp;&quot;</span> + key + <span class="string">&quot;=&quot;</span> + val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!paramStr.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">        paramStr = paramStr.replaceFirst(<span class="string">&quot;&amp;&quot;</span>, <span class="string">&quot;?&quot;</span>);</span><br><span class="line">        url += paramStr;</span><br><span class="line">    &#125;</span><br><span class="line">    HttpGet httpGet = <span class="keyword">new</span> HttpGet(url);</span><br><span class="line">    String strResult = <span class="string">&quot;doGetError&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/* 发送请求并等待响应 */</span></span><br><span class="line">        HttpResponse httpResponse = httpClient.execute(httpGet);</span><br><span class="line">        <span class="comment">/* 若状态码为200 ok */</span></span><br><span class="line">        <span class="keyword">if</span> (httpResponse.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">/* 读返回数据 */</span></span><br><span class="line">            strResult = EntityUtils.toString(httpResponse.getEntity());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            strResult = <span class="string">&quot;Error Response: &quot;</span></span><br><span class="line">                    + httpResponse.getStatusLine().toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClientProtocolException e) &#123;</span><br><span class="line">        strResult = e.getMessage().toString();</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        strResult = e.getMessage().toString();</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        strResult = e.getMessage().toString();</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    showResponseOnWebView(strResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<a href="3">示例工程</a>中, 服务器端在登录成功后会跳转到info.jsp页面，详见第一节</p>
<p>使用URLConnection是无法实现的。而HttpClient可以实现跳转并显示登录信息。</p>
<h2 id="WebView"><a href="#WebView" class="headerlink" title="WebView"></a>WebView</h2><p>WebView是Android内置的WebKit内核网页显示控件，使用WebView可以显示本地和网站页面。so powerful!<br>默认使用UTF-8编码</p>
<h3 id="显示本地页面中文乱码"><a href="#显示本地页面中文乱码" class="headerlink" title="显示本地页面中文乱码"></a>显示本地页面中文乱码</h3><p>显示本地页面可以使用的API有：loadData 和loadDataWithBaseURL</p>
<p>WebView.loadData(content, “text/html”, “UTF-8”);出现中文乱码了，<br>改成 loadData(data, “text/html; charset=UTF-8”, null);就不会乱码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebView.loadDataWithBaseURL(basePath, content, <span class="string">&quot;text/html&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, <span class="keyword">null</span>);<span class="comment">// 可以正常显示</span></span><br><span class="line">WebView.loadDataWithBaseURL(<span class="keyword">null</span>, content, <span class="string">&quot;text/html&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, <span class="keyword">null</span>);<span class="comment">// 无乱码 但无法显示图片</span></span><br></pre></td></tr></table></figure>
<p>使用loadDataWithBaseURL时,如果不传入URL时,刷新会造成白屏,因为刷新时调用的的是reload方法,<br>reload是根据传入的URL进行一次重新加载即再次loadUrl(url),不传入URL时,默认的的URL是about:blank</p>
<p>使用loadData,刷新只是从缓存里面取，但是在4.0以上的,如果按照API里所写的loadData(data, “UTF-8”, null);时会乱码,<br>如果写成<code>loadData(data, &quot;text/html; charset=UTF-8&quot;, null);</code><br>loadData最终的机制是会把传入的三个参数拼接在一起,<br>然后再进行loadUrl操作,参数就是data, “text/html; charset=UTF-8”, null这三个进行拼装,加入text/html; charset=UTF-8就相当于限定了页面的字符</p>
<p>loadData(detail,”text/html;charset=UTF-8”, null); 在小米 One S上仍然存在中文乱码的情况，<br>改成 WebView.loadDataWithBaseURL(null, detail, “text/html”, “UTF-8”, null); 就没问题。<br>在小米手机上设置<code>settings.setDefaultTextEncodingName(&quot;utf-8&quot;)</code><br>在 webview 的 settings 属性里指定 utf-8 就可以了</p>
<h1 id="第三方框架"><a href="#第三方框架" class="headerlink" title="第三方框架"></a>第三方框架</h1><h2 id="AsyncHttpClient"><a href="#AsyncHttpClient" class="headerlink" title="AsyncHttpClient"></a>AsyncHttpClient</h2><p><a target="_blank" rel="noopener" href="https://github.com/loopj/android-async-http">Github的地址</a></p>
<h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">loginASyncHttpGet</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">    AsyncHttpClient asyncHttpClient = <span class="keyword">new</span> AsyncHttpClient();</span><br><span class="line">    RequestParams requestParams = <span class="keyword">new</span> RequestParams();</span><br><span class="line">    requestParams.put(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">    requestParams.put(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">    asyncHttpClient.get(loginPath, requestParams, <span class="keyword">new</span> AsyncHttpResponseHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">loginASyncHttpPost</span><span class="params">(String name, String password)</span> </span>&#123;</span><br><span class="line">    AsyncHttpClient asyncHttpClient = <span class="keyword">new</span> AsyncHttpClient();</span><br><span class="line">    RequestParams requestParams = <span class="keyword">new</span> RequestParams();</span><br><span class="line">    requestParams.put(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">    requestParams.put(<span class="string">&quot;password&quot;</span>, password);</span><br><span class="line">    asyncHttpClient.post(loginPath, requestParams, <span class="keyword">new</span> AsyncHttpResponseHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uploadFileAsyncHttpClient</span><span class="params">(String  selectFilePath)</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(selectFilePath);</span><br><span class="line">    <span class="keyword">if</span> (file.exists() &amp;&amp; file.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        AsyncHttpClient client = <span class="keyword">new</span> AsyncHttpClient();</span><br><span class="line">        RequestParams params = <span class="keyword">new</span> RequestParams();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            params.put(<span class="string">&quot;profile_picture&quot;</span>, file);</span><br><span class="line"></span><br><span class="line">            client.post(uploadUrlEditTex.getText().toString(), params, <span class="keyword">new</span> AsyncHttpResponseHandler() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">&quot;文件上传成功!&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable throwable, String s)</span> </span>&#123;</span><br><span class="line">                    Toast.makeText(MainActivity.<span class="keyword">this</span>, <span class="string">&quot;文件上传失败!&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;文件不存在&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SmartImage"><a href="#SmartImage" class="headerlink" title="SmartImage"></a>SmartImage</h2><p><a target="_blank" rel="noopener" href="https://github.com/loopj/android-smart-image-view">Github地址</a></p>
<p><a target="_blank" rel="noopener" href="http://loopj.com/android-smart-image-view/">官网</a></p>
<h1 id="多线程断点下载"><a href="#多线程断点下载" class="headerlink" title="多线程断点下载"></a>多线程断点下载</h1><p><a target="_blank" rel="noopener" href="http://pan.baidu.com/s/1pJDvG6Z" title="多线程下载">示例代码下载地址</a></p>
<h2 id="多线程下载-1"><a href="#多线程下载-1" class="headerlink" title="多线程下载"></a>多线程下载</h2><p><a name="nulti_download">多线程下载</a>即将一个文件分割成若干部分，交给多个线程同时去下载，每个线程下载文件的一部分。以达到提速的目的。</p>
<p>为了实现多线程下载，需要如下几个步骤：</p>
<ol>
<li>为每个线程分配要下载的文件的位置</li>
<li>在本地创建同等大小的文件区域</li>
<li>从服务器下载文件的某一段数据</li>
<li>每个线程下载指定位置的数据并写入文件对应的位置</li>
</ol>
<h3 id="为每个线程分配要下载的文件的位置"><a href="#为每个线程分配要下载的文件的位置" class="headerlink" title="为每个线程分配要下载的文件的位置"></a>为每个线程分配要下载的文件的位置</h3><p><img src="/images/android/network/android-network-multidownload-dispatcher.png"></p>
<h3 id="在本地创建同等大小的文件区域"><a href="#在本地创建同等大小的文件区域" class="headerlink" title="在本地创建同等大小的文件区域"></a>在本地创建同等大小的文件区域</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建文件，大小与待下载的文件大小一致</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> objPath 创建文件文件名，包含完整路径</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> fileLength 文件的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createFile</span><span class="params">(String  objPath,<span class="keyword">long</span> fileLength)</span> </span>&#123;</span><br><span class="line">	RandomAccessFile raf = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		raf = <span class="keyword">new</span> RandomAccessFile(objPath, <span class="string">&quot;rwd&quot;</span>);</span><br><span class="line">		raf.setLength(fileLength);</span><br><span class="line">		raf.close();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从服务器下载文件的某一段数据"><a href="#从服务器下载文件的某一段数据" class="headerlink" title="从服务器下载文件的某一段数据"></a>从服务器下载文件的某一段数据</h3><p>在HTTP协议中， RequestProperty <code>Range</code>用于指定下载文件片段的范围<br>格式为<code>&quot;bytes=&lt;开始位置&gt;-&lt;结束位置&gt;&quot;</code><br>一旦设定了Range属性，服务器会返回 206，表示支持部分下载。<br>不设定Range属性，服务器返回 200，表示连接正常, 可以下载。</p>
<p>因此发送请求的格式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//downloadUrl为下载文件的网址</span></span><br><span class="line">URL url = <span class="keyword">new</span> URL(downloadUrl);</span><br><span class="line"><span class="comment">//打开远程连接</span></span><br><span class="line">HttpURLConnection conn = (HttpURLConnection) url.openConnection();</span><br><span class="line">conn.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line"><span class="comment">//设置下载的位置</span></span><br><span class="line">conn.setRequestProperty(<span class="string">&quot;Range&quot;</span>, <span class="string">&quot;bytes=&quot;</span> + startPosition + <span class="string">&quot;-&quot;</span> + endPosition);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">206</span> == conn.getResponseCode())</span><br><span class="line"><span class="comment">// DO SOMETHING</span></span><br></pre></td></tr></table></figure>
<h3 id="每个线程下载指定位置的数据并写入文件对应的位置"><a href="#每个线程下载指定位置的数据并写入文件对应的位置" class="headerlink" title="每个线程下载指定位置的数据并写入文件对应的位置"></a>每个线程下载指定位置的数据并写入文件对应的位置</h3><p>衔接上一段程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从打开的连接读入输入流</span></span><br><span class="line">InputStream inputStream = conn.getInputStream();</span><br><span class="line"><span class="comment">// 创建写入文件的RandomAccessFile对象</span></span><br><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(objPath, <span class="string">&quot;rwd&quot;</span>);</span><br><span class="line"><span class="comment">//随机写文件，跳到相应的位置</span></span><br><span class="line">raf.seek(startPosition);</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> lenCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span> ((len = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">	lenCount += len;</span><br><span class="line">	raf.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后记得关闭掉输入流</span></span><br><span class="line">raf.close();</span><br><span class="line">inputStream.close();</span><br></pre></td></tr></table></figure>


<h3 id="RandomAccessFile"><a href="#RandomAccessFile" class="headerlink" title="RandomAccessFile"></a>RandomAccessFile</h3><p>RandomAccessFile是一个强大的随机文件读写API，创建该对象时的参数设置为<code>&quot;rwd&quot;</code>表示立即写入硬盘</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RandomAccessFile</span><span class="params">(File file,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String mode)</span></span></span><br><span class="line"><span class="function">                 <span class="keyword">throws</span> FileNotFoundException</span></span><br><span class="line"><span class="function">创建从中读取和向其中写入（可选）的随机访问文件流，该文件由 File 参数指定。将创建一个新的 FileDescriptor 对象来表示此文件的连接。</span></span><br><span class="line"><span class="function">mode 参数指定用以打开文件的访问模式。允许的值及其含意为：</span></span><br><span class="line"><span class="function">值含意</span></span><br><span class="line"><span class="function">&quot;r&quot;	以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。</span></span><br><span class="line"><span class="function">&quot;rw&quot;	打开以便读取和写入。如果该文件尚不存在，则尝试创建该文件。</span></span><br><span class="line"><span class="function">&quot;rws&quot;	打开以便读取和写入，对于 &quot;rw&quot;，还要求对文件的内容或元数据的每个更新都同步写入到底层存储设备。</span></span><br><span class="line"><span class="function">&quot;rwd&quot;  	打开以便读取和写入，对于 &quot;rw&quot;，还要求对文件内容的每个更新都同步写入到底层存储设备。 &quot;rws&quot; 和 &quot;rwd&quot; 模式的工作方式极其类似 FileChannel 类的 <span class="title">force</span><span class="params">(<span class="keyword">boolean</span>)</span> 方法，分别传递 <span class="keyword">true</span> 和 <span class="keyword">false</span> 参数，除非它们始终应用于每个 I/O 操作，并因此通常更为高效。如果该文件位于本地存储设备上，那么当返回此类的一个方法的调用时，可以保证由该调用对此文件所做的所有更改均被写入该设备。这对确保在系统崩溃时不会丢失重要信息特别有用。如果该文件不在本地设备上，则无法提供这样的保证。</span></span><br><span class="line"><span class="function">&quot;rwd&quot; 模式可用于减少执行的 I/O 操作数量。使用 &quot;rwd&quot; 仅要求更新要写入存储的文件的内容；使用 &quot;rws&quot; 要求更新要写入的文件内容及其元数据，这通常要求至少一个以上的低级别 I/O 操作。</span></span><br><span class="line"><span class="function">如果存在安全管理器，则使用 file 参数的路径名作为其参数调用它的 checkRead 方法，以查看是否允许对该文件进行读取访问。如果该模式允许写入，那么还使用该路径参数调用该安全管理器的 checkWrite 方法，以查看是否允许对该文件进行写入访问。</span></span><br><span class="line"><span class="function">参数：</span></span><br><span class="line"><span class="function">file - 该文件对象</span></span><br><span class="line"><span class="function">mode - 访问模式，如 上所述</span></span><br><span class="line"><span class="function">抛出：</span></span><br><span class="line"><span class="function">IllegalArgumentException - 如果此模式参数与 &quot;r&quot;、 &quot;rw&quot;、 &quot;rws&quot; 或 &quot;rwd&quot; 的其中一个不相等</span></span><br><span class="line"><span class="function">FileNotFoundException - 如果该模式为 &quot;r&quot;，但给定的文件对象不表示一个现有的常规文件，或者该模式以 &quot;rw&quot; 开头，但给定的文件对象不表示一个现有的可写常规文件，而且无法创建具有该名称的新常规文件，或者在打开或创建该文件时发生一些其他错误</span></span><br><span class="line"><span class="function">SecurityException - 如果存在安全管理器，并且其 checkRead 方法拒绝对该文件的读取访问，或者该模式为 &quot;rw&quot;，并且该安全管理器的 checkWrite 方法拒绝对该文件的写入访问</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seek</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seek</span><span class="params">(<span class="keyword">long</span> pos)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
<p>seek是个牛逼的，像一个游标，跳到指定的位置写数据</p>
<h2 id="断点下载"><a href="#断点下载" class="headerlink" title="断点下载"></a>断点下载</h2><p>当下载大文件时，异常下载中断或暂停下载， 为了防止造成下载资源浪费，为每一个线程提供一个记录，用于记住已经下载文件的位置。当再次启动下载时，读取记录，从中断位置继续下载。</p>
<p>为了兼容不同设备(PC和Android)存储记录文件，本文定义一个接口为不同的存储提供不同的对象，类似于适配器模式.</p>
<ul>
<li>SameDirFileBreakPointManager： 在目标文件同目录下建立记录文件(PC和Android)</li>
<li>SqliteBreakPointManager： 使用Sqlite记录(Android)</li>
<li>PropertyFileBreakPointManager：使用SharedPerferences记录(Android)</li>
</ul>
<p><img src="/images/android/network/android-network-multidownload-breakpointmanager-uml.png"></p>
<p>工程的调用关系</p>
<p><img src="/images/android/network/android-network-multidownload-uml.png"></p>
<pre><code>参考文献</code></pre>
<ol>
<li><a target="_blank" rel="noopener" href="http://pan.baidu.com/s/1sjOMIgl" title="Android network 项目工程">itheima的教程</a> (密码: yfqk)</li>
</ol>
<p><img src="/images/android/network/android-network-multidownload-itheima.png"></p>
<ol start="2">
<li><a target="_blank" rel="noopener" href="http://pan.baidu.com/s/1qW89zyc">SimpleServer源码</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/multithread/running-in-turn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/multithread/running-in-turn/" class="post-title-link" itemprop="url">多线程等待的N中打开方式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-08-29 00:00:00" itemprop="dateCreated datePublished" datetime="2015-08-29T00:00:00+08:00">2015-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-16 15:17:28" itemprop="dateModified" datetime="2021-01-16T15:17:28+08:00">2021-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="2个线程轮流输出"><a href="#2个线程轮流输出" class="headerlink" title="2个线程轮流输出"></a>2个线程轮流输出</h1><p> A、B两个线程轮流输出1~100的数字<br/><br> A线程输出: 1、3、5…47、49、    52、54…98、100 <br/><br> B线程输出: 2、4、6…48、50、51、53、55…97、99 两个线程输出个数相同</p>
<blockquote>
<p>分析：</p>
<ol>
<li>每个线程持有一把锁，运行时，首先获取自己的锁，运行完释放另一个线程的锁</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A、B两个线程轮流输出1~100的数字&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * A线程输出: 1、3、5...47、49、    52、54...98、100 &lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * B线程输出: 2、4、6...48、50、51、53、55...97、99 两个线程输出个数相同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunningInTurn</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个线程 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Semaphore thisSemaphore;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Semaphore nextSemaphore;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String name, Semaphore thisSemaphore, Semaphore nextSemaphore, <span class="keyword">int</span> initialValue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.thisSemaphore = thisSemaphore;</span><br><span class="line">            <span class="keyword">this</span>.nextSemaphore = nextSemaphore;</span><br><span class="line">            <span class="keyword">this</span>.value = initialValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (value &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    thisSemaphore.acquire();</span><br><span class="line">                    System.out.println(name + <span class="string">&quot;:\t&quot;</span> + value);</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">if</span> (value == <span class="number">50</span>) &#123;</span><br><span class="line">                        value = <span class="number">51</span>;</span><br><span class="line">                        System.out.println(name + <span class="string">&quot;:\t&quot;</span> + value);</span><br><span class="line">                        cnt++;</span><br><span class="line">                        value += <span class="number">2</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value == <span class="number">49</span>) &#123;</span><br><span class="line">                        value = <span class="number">52</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        value += <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nextSemaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(name + <span class="string">&quot; cnt : &quot;</span> + cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Semaphore aSemaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">        Semaphore bSemaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">        Worker workerA = <span class="keyword">new</span> Worker(<span class="string">&quot;a&quot;</span>, aSemaphore, bSemaphore, <span class="number">1</span>);</span><br><span class="line">        Worker workerB = <span class="keyword">new</span> Worker(<span class="string">&quot;b&quot;</span>, bSemaphore, aSemaphore, <span class="number">2</span>);</span><br><span class="line">        bSemaphore.acquire();</span><br><span class="line">        workerA.start();</span><br><span class="line">        workerB.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/multithread/02.Lock-Semaphore-Atomic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/multithread/02.Lock-Semaphore-Atomic/" class="post-title-link" itemprop="url">Java多线程2: Lock、信号量、原子量与队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-08-29 00:00:00" itemprop="dateCreated datePublished" datetime="2015-08-29T00:00:00+08:00">2015-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-16 15:17:28" itemprop="dateModified" datetime="2021-01-16T15:17:28+08:00">2021-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="/Java/advanced-engineer-outline/">&lt;&lt;Java高级软件工程师知识结构</a></p>
<pre><code>Java多线程是Java基础的重要的一部分，支持多线程是Java的重要特性之一. 主要包括如下内容:</code></pre>
<blockquote>
<ol>
<li><a href="/Java/multithread/01.base/">Java多线程1: 线程生命周期和多线程基础</a></li>
<li><a href="/Java/multithread/02.Lock-Semaphore-Atomic/">Java多线程2: Lock、信号量、原子量与队列</a></li>
<li><a href="/Java/multithread/03.volatile/">Java多线程3: volatile</a></li>
<li><a href="/Java/multithread/04.thread-synchronization/">Java多线程4: 同步锁与Java线程同步方法比较</a></li>
<li><a href="/Java/multithread/05.ThreadPool/">Java多线程5: 线程池</a></li>
<li><a href="/Java/multithread/06.BlockingQueue/">Java多线程6: Java阻塞队列与生产者消费者模式</a></li>
</ol>
</blockquote>
<p>更详细内容请参考博文 <a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3923167.html">Java并发编程：Lock</a></p>
<p>Sun在Java5中, 对Java线程的类库做了大量的扩展</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>在<code>java.util.concurrent.locks</code> 包下面, 里面有三个重要的接口<code>Condition</code>、<code>Lock</code>、<code>ReadWriteLock</code>.</p>
<h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p><code>Condition</code> 将 Object 监视器方法（<code>wait</code>、<code>notify</code> 和 <code>notifyAll</code>）分解成截然不同的对象, 以便通过将这些对象与任意 <code>Lock</code> 实现组合使用, 为每个对象提供多个等待 <code>set</code> （<code>wait-set</code>）.</p>
<h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p><code>Lock</code>实现提供了比使用 <code>synchronized</code> 方法和语句可获得的更广泛的锁定操作.</p>
<h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p><code>ReadWriteLock</code>维护了一对相关的锁定, 一个用于只读操作, 另一个用于写入操作.</p>
<h2 id="Lock-与-synchronized的区别"><a href="#Lock-与-synchronized的区别" class="headerlink" title="Lock 与 synchronized的区别"></a>Lock 与 synchronized的区别</h2><p>见文献 <a target="_blank" rel="noopener" href="http://blog.csdn.net/natian306/article/details/18504111">深入研究 Java Synchronize 和 Lock 的区别与用法</a></p>
<ol>
<li><p>用法上的区别<br><code>synchronized</code>可以加在方法或代码块上，而<code>Lock</code>必须指定起始位置，一般使用<code>ReentrantLock</code>类做为锁，多个线程中必须要使用一个<code>ReentrantLock</code>类做为对象才能保证锁的生效。且在加锁和解锁处需要通过<code>lock()</code>和<code>unlock()</code>显式指出。所以一般会在<code>finally</code>块中写<code>unlock()</code>以防死锁。</p>
<ol>
<li>ReentrantLock非阻塞</li>
<li>ReentrantLock CAS实现无锁</li>
<li>可以指定等待时间，可以中断</li>
<li>公平锁：按照申请顺序</li>
<li>可以指定条件</li>
<li><code>await</code>必须与<code>while</code>一起使用  </li>
<li>Lock可以知道线程有没有成功获取到锁。这个是synchronized无法办到的</li>
<li>synchronized在发生异常时，会自动释放线程占有的锁，不会导致死锁现象发生；<br>而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li>
</ol>
</li>
<li><p>性能上的区别<br><code>synchronized</code>是托管给JVM执行的，而lock是java写的控制锁的代码。<code>synchronized</code>是悲观锁，线程获取到的是<code>独占锁</code>。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。多个线程竞争资源，CPU频繁切换效率变低。</p>
<p><code>Lock</code>使用的是乐观锁，乐观锁就是CAS，调用CPU的指令，效率比较高。是非阻塞算法。 每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁实现的机制就是CAS操作（Compare and Swap）。获得锁的一个方法是compareAndSetState. CPU提供了指令，可以自动更新共享数据，而且能够检测到其他线程的干扰，而 compareAndSet() 就用这些代替了锁定。这个算法称作<code>非阻塞算法</code>，意思是一个线程的失败或者挂起不应该影响其他线程的失败或挂起的算法。</p>
</li>
<li><p>用途上的区别<br>高并发情况下，比较适合使用Lock，特别是在下面的情况下:</p>
<ul>
<li>某个线程在等待一个锁的控制权的这段时间需要中断</li>
<li>需要分开处理一些<code>wait-notify</code>，<code>ReentrantLock</code>里面的<code>Condition</code>应用，能够控制<code>notify</code>哪个线程</li>
<li>具有公平锁功能，每个到来的线程都将排队等候</li>
</ul>
</li>
</ol>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock是唯一实现了Lock接口的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建并发访问的账户</span></span><br><span class="line">MyCount myCount = <span class="keyword">new</span> MyCount(<span class="string">&quot;95599200901215522&quot;</span>, <span class="number">10000</span>);</span><br><span class="line"><span class="comment">//创建一个锁对象</span></span><br><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//创建一个线程池</span></span><br><span class="line">ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">//创建一些并发访问用户, 一个信用卡, 存的存, 取的取, 好热闹啊</span></span><br><span class="line">User u1 = <span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>, myCount, -<span class="number">4000</span>, lock);</span><br><span class="line">User u2 = <span class="keyword">new</span> User(<span class="string">&quot;张三他爹&quot;</span>, myCount, <span class="number">6000</span>, lock);</span><br><span class="line">User u3 = <span class="keyword">new</span> User(<span class="string">&quot;张三他弟&quot;</span>, myCount, -<span class="number">8000</span>, lock);</span><br><span class="line">User u4 = <span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>, myCount, <span class="number">800</span>, lock);</span><br><span class="line"><span class="comment">//在线程池中执行各个用户的操作</span></span><br><span class="line">pool.execute(u1);</span><br><span class="line">pool.execute(u2);</span><br><span class="line">pool.execute(u3);</span><br><span class="line">pool.execute(u4);</span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 信用卡的用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;                <span class="comment">//用户名</span></span><br><span class="line">  <span class="keyword">private</span> MyCount myCount;        <span class="comment">//所要操作的账户</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> iocash;                 <span class="comment">//操作的金额, 当然有正负之分了</span></span><br><span class="line">  <span class="keyword">private</span> Lock myLock;                <span class="comment">//执行操作所需的锁对象</span></span><br><span class="line">  User(String name, MyCount myCount, <span class="keyword">int</span> iocash, Lock myLock) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.myCount = myCount;</span><br><span class="line">    <span class="keyword">this</span>.iocash = iocash;</span><br><span class="line">    <span class="keyword">this</span>.myLock = myLock;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    myLock.lock();</span><br><span class="line">    <span class="comment">//执行现金业务</span></span><br><span class="line">    System.out.println(name + <span class="string">&quot;正在操作&quot;</span> + myCount + <span class="string">&quot;账户, 金额为&quot;</span> + iocash + <span class="string">&quot;, 当前金额为&quot;</span> + myCount.getCash());</span><br><span class="line">    myCount.setCash(myCount.getCash() + iocash);</span><br><span class="line">    System.out.println(name + <span class="string">&quot;操作&quot;</span> + myCount + <span class="string">&quot;账户成功, 金额为&quot;</span> + iocash + <span class="string">&quot;, 当前金额为&quot;</span> + myCount.getCash());</span><br><span class="line">    <span class="comment">//释放锁, 否则别的线程没有机会执行了</span></span><br><span class="line">    myLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 信用卡账户, 可随意透支</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCount</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String oid;         <span class="comment">//账号</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> cash;             <span class="comment">//账户余额</span></span><br><span class="line">  MyCount(String oid, <span class="keyword">int</span> cash) &#123;</span><br><span class="line">          <span class="keyword">this</span>.oid = oid;</span><br><span class="line">          <span class="keyword">this</span>.cash = cash;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getOid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> oid;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOid</span><span class="params">(String oid)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.oid = oid;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> cash;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCash</span><span class="params">(<span class="keyword">int</span> cash)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.cash = cash;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;MyCount&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;oid=&#x27;&quot;</span> + oid + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&quot;, cash=&quot;</span> + cash +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h3><p>Java线程中的中断，提供了三个方法:</p>
<ul>
<li>interrupt()<br>  通知线程中断, 但是线程不会立即中断, 只会将interrupt标志位设置为  true, 当在线程中获取到这个标志位时自行判断</li>
<li>interrupted()<br>  判断是否中断, 如果未中断, 立即设置为中断</li>
<li>isInterrupted()<br>  判断是否中断</li>
</ul>
<p>这三个方法都不能使线程中断执行。而ReetrantLock提供了响应的方案。</p>
<p>ReentrantLock的lock机制有2种，忽略中断锁和响应中断锁，这给我们带来了很大的灵活性。</p>
<p>比如：如果A、B2个线程去竞争锁，A线程得到了锁，B线程等待，但是A线程这个时候实在有太多事情要处理，就是一直不返回，B线程可能就会等不及了，想中断自己，不再等待这个锁了，转而处理其他事情。这个时候ReentrantLock就提供了2种机制，</p>
<ul>
<li>第一，B线程中断自己（或者别的线程中断它），但是ReentrantLock不去响应，继续让B线程等待，你再怎么中断，我全当耳边风（synchronized原语就是如此）；Lock.lock()也不会响应中断操作</li>
<li>第二，B线程中断自己（或者别的线程中断它），ReentrantLock处理了这个中断，并且不再等待这个锁的到来，完全放弃。<br>  在Thread类中使用lock.lockInterruptibly();锁定时可以响应中断操作，当调用Thread.interupt()方法，该lock会放弃锁定，抛出InterruptedException异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> isProcess = <span class="keyword">false</span>;</span><br><span class="line">ReentrantLock lock  = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition processReady = lock.newCondition();</span><br><span class="line">thread: run() &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    isProcess = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(!isProcessReady) &#123;  </span><br><span class="line">    <span class="comment">//isProcessReady 是另外一个线程的控制变量</span></span><br><span class="line">      processReady.await();</span><br><span class="line">      <span class="comment">//释放了lock，在此等待signal</span></span><br><span class="line">     &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.unlock();</span><br><span class="line">          isProcess = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        MyThread thread1 = <span class="keyword">new</span> MyThread(test);</span><br><span class="line">        MyThread thread2 = <span class="keyword">new</span> MyThread(test);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread2.interrupt();</span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        lock.lockInterruptibly();   </span><br><span class="line">        <span class="comment">//注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出</span></span><br><span class="line">        <span class="keyword">try</span> &#123;   </span><br><span class="line">            System.out.println(thread.getName()+<span class="string">&quot;得到了锁&quot;</span>);</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span>(    ;     ;) &#123;</span><br><span class="line">                <span class="keyword">if</span>(System.currentTimeMillis() - startTime &gt;= Integer.MAX_VALUE)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//插入数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;执行finally&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">&quot;释放了锁&quot;</span>);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Test test = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(Test test)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.test = test;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.insert(Thread.currentThread());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;被中断&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读写锁-ReadWriteLock"><a href="#读写锁-ReadWriteLock" class="headerlink" title="读写锁 ReadWriteLock"></a>读写锁 ReadWriteLock</h2><p>为了提高性能, Java提供了读写锁, 在读的地方使用读锁, 在写的地方使用写锁, 灵活控制, 在一定程度上提高了程序的执行效率.<br>Java中读写锁有个接口<code>java.util.concurrent.locks.ReadWriteLock</code>, 也有具体的实现<code>ReentrantReadWriteLock</code></p>
<p>ReadWriteLock也是一个接口，在它里面只定义了两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the lock used for writing.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和writeLock()用来获取读锁和写锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建并发访问的账户</span></span><br><span class="line">MyCount myCount = <span class="keyword">new</span> MyCount(<span class="string">&quot;95599200901215522&quot;</span>, <span class="number">10000</span>);</span><br><span class="line"><span class="comment">//创建一个锁对象</span></span><br><span class="line">ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//创建一个线程池</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//创建一些并发访问用户, 一个信用卡, 存的存, 取的取, 好热闹啊</span></span><br><span class="line">User u1 = <span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>, myCount, -<span class="number">4000</span>, lock, <span class="keyword">false</span>);</span><br><span class="line">User u2 = <span class="keyword">new</span> User(<span class="string">&quot;张三他爹&quot;</span>, myCount, <span class="number">6000</span>, lock, <span class="keyword">false</span>);</span><br><span class="line">User u3 = <span class="keyword">new</span> User(<span class="string">&quot;张三他弟&quot;</span>, myCount, -<span class="number">8000</span>, lock, <span class="keyword">false</span>);</span><br><span class="line">User u4 = <span class="keyword">new</span> User(<span class="string">&quot;张三&quot;</span>, myCount, <span class="number">800</span>, lock, <span class="keyword">false</span>);</span><br><span class="line">User u5 = <span class="keyword">new</span> User(<span class="string">&quot;张三他爹&quot;</span>, myCount, <span class="number">0</span>, lock, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//在线程池中执行各个用户的操作</span></span><br><span class="line">pool.execute(u1);</span><br><span class="line">pool.execute(u2);</span><br><span class="line">pool.execute(u3);</span><br><span class="line">pool.execute(u4);</span><br><span class="line">pool.execute(u5);</span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 信用卡的用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;                <span class="comment">//用户名</span></span><br><span class="line">  <span class="keyword">private</span> MyCount myCount;        <span class="comment">//所要操作的账户</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> iocash;                 <span class="comment">//操作的金额, 当然有正负之分了</span></span><br><span class="line">  <span class="keyword">private</span> ReadWriteLock myLock;                <span class="comment">//执行操作所需的锁对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> ischeck;        <span class="comment">//是否查询</span></span><br><span class="line">  User(String name, MyCount myCount, <span class="keyword">int</span> iocash, ReadWriteLock myLock, <span class="keyword">boolean</span> ischeck) &#123;</span><br><span class="line">          <span class="keyword">this</span>.name = name;</span><br><span class="line">          <span class="keyword">this</span>.myCount = myCount;</span><br><span class="line">          <span class="keyword">this</span>.iocash = iocash;</span><br><span class="line">          <span class="keyword">this</span>.myLock = myLock;</span><br><span class="line">          <span class="keyword">this</span>.ischeck = ischeck;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ischeck) &#123;</span><br><span class="line">            <span class="comment">//获取读锁</span></span><br><span class="line">            myLock.readLock().lock();</span><br><span class="line">            System.out.println(<span class="string">&quot;读：&quot;</span> + name + <span class="string">&quot;正在查询&quot;</span> + myCount + <span class="string">&quot;账户, 当前金额为&quot;</span> + myCount.getCash());</span><br><span class="line">            <span class="comment">//释放读锁</span></span><br><span class="line">            myLock.readLock().unlock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获取写锁</span></span><br><span class="line">            myLock.writeLock().lock();</span><br><span class="line">            <span class="comment">//执行现金业务</span></span><br><span class="line">            System.out.println(<span class="string">&quot;写：&quot;</span> + name + <span class="string">&quot;正在操作&quot;</span> + myCount + <span class="string">&quot;账户, 金额为&quot;</span> + iocash + <span class="string">&quot;, 当前金额为&quot;</span> + myCount.getCash());</span><br><span class="line">            myCount.setCash(myCount.getCash() + iocash);</span><br><span class="line">            System.out.println(<span class="string">&quot;写：&quot;</span> + name + <span class="string">&quot;操作&quot;</span> + myCount + <span class="string">&quot;账户成功, 金额为&quot;</span> + iocash + <span class="string">&quot;, 当前金额为&quot;</span> + myCount.getCash());</span><br><span class="line">            <span class="comment">//释放写锁</span></span><br><span class="line">            myLock.writeLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 信用卡账户, 可随意透支</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCount</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String oid;         <span class="comment">//账号</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cash;             <span class="comment">//账户余额</span></span><br><span class="line">        MyCount(String oid, <span class="keyword">int</span> cash) &#123;</span><br><span class="line">                <span class="keyword">this</span>.oid = oid;</span><br><span class="line">                <span class="keyword">this</span>.cash = cash;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getOid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> oid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOid</span><span class="params">(String oid)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.oid = oid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cash;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCash</span><span class="params">(<span class="keyword">int</span> cash)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.cash = cash;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;MyCount&#123;&quot;</span> +</span><br><span class="line">                          <span class="string">&quot;oid=&#x27;&quot;</span> + oid + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                          <span class="string">&quot;, cash=&quot;</span> + cash +</span><br><span class="line">                          <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="条件变量-Condition"><a href="#条件变量-Condition" class="headerlink" title="条件变量 Condition"></a>条件变量 Condition</h1><p>条件变量就是表示条件的一种变量. 但是必须说明, 这里的条件是没有实际含义的, 仅仅是个标记而已, 并且条件的含义往往通过代码来赋予其含义.</p>
<p>条件变量都实现了<code>java.util.concurrent.locks.Condition</code>接口, 条件变量的实例化是<strong>通过一个<code>Lock</code>对象上调用<code>newCondition()</code>方法</strong>来获取的, 这样, 条件就和一个锁对象绑定起来了. 因此, Java中的条件变量只能和锁配合使用, 来控制并发程序访问竞争资源的安全.</p>
<p>在Java5中, 一个锁可以有多个条件, 每个条件上可以有多个线程等待, 通过调用<code>await()</code>方法, 可以让线程在该条件下等待. 当调用<code>signalAll()</code>方法, 又可以唤醒该条件下的等待的线程.</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>有一个账户, 多个用户（线程）在同时操作这个账户, 有的存款有的取款, 存款随便存, 取款有限制, 不能透支, 任何试图透支的操作都将等待里面有足够存款才执行操作.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建并发访问的账户</span></span><br><span class="line">MyCount myCount = <span class="keyword">new</span> MyCount(<span class="string">&quot;95599200901215522&quot;</span>, <span class="number">10000</span>);</span><br><span class="line"><span class="comment">//创建一个线程池</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">Thread t1 = <span class="keyword">new</span> SaveThread(<span class="string">&quot;张三&quot;</span>, myCount, <span class="number">2000</span>);</span><br><span class="line">Thread t2 = <span class="keyword">new</span> SaveThread(<span class="string">&quot;李四&quot;</span>, myCount, <span class="number">3600</span>);</span><br><span class="line">Thread t3 = <span class="keyword">new</span> DrawThread(<span class="string">&quot;王五&quot;</span>, myCount, <span class="number">2700</span>);</span><br><span class="line">Thread t4 = <span class="keyword">new</span> SaveThread(<span class="string">&quot;老张&quot;</span>, myCount, <span class="number">600</span>);</span><br><span class="line">Thread t5 = <span class="keyword">new</span> DrawThread(<span class="string">&quot;老牛&quot;</span>, myCount, <span class="number">1300</span>);</span><br><span class="line">Thread t6 = <span class="keyword">new</span> DrawThread(<span class="string">&quot;胖子&quot;</span>, myCount, <span class="number">800</span>);</span><br><span class="line"><span class="comment">//执行各个线程</span></span><br><span class="line">pool.execute(t1);</span><br><span class="line">pool.execute(t2);</span><br><span class="line">pool.execute(t3);</span><br><span class="line">pool.execute(t4);</span><br><span class="line">pool.execute(t5);</span><br><span class="line">pool.execute(t6);</span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存款线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SaveThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;     <span class="comment">//操作人</span></span><br><span class="line">  <span class="keyword">private</span> MyCount myCount; <span class="comment">//账户</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> x;   <span class="comment">//存款金额</span></span><br><span class="line">  SaveThread(String name, MyCount myCount, <span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.myCount = myCount;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    myCount.saving(x, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取款线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DrawThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name; <span class="comment">//操作人</span></span><br><span class="line">  <span class="keyword">private</span> MyCount myCount; <span class="comment">//账户</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> x; <span class="comment">//存款金额</span></span><br><span class="line">  DrawThread(String name, MyCount myCount, <span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.myCount = myCount;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    myCount.drawing(x, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通银行账户, 不可透支</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCount</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String oid;                         <span class="comment">//账号</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> cash;                             <span class="comment">//账户余额</span></span><br><span class="line">  <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();                <span class="comment">//账户锁</span></span><br><span class="line">  <span class="keyword">private</span> Condition _save = lock.newCondition();    <span class="comment">//存款条件</span></span><br><span class="line">  <span class="keyword">private</span> Condition _draw = lock.newCondition();    <span class="comment">//取款条件</span></span><br><span class="line">  MyCount(String oid, <span class="keyword">int</span> cash) &#123;</span><br><span class="line">    <span class="keyword">this</span>.oid = oid;</span><br><span class="line">    <span class="keyword">this</span>.cash = cash;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 存款</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> x        操作金额</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name 操作人</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saving</span><span class="params">(<span class="keyword">int</span> x, String name)</span> </span>&#123;</span><br><span class="line">    lock.lock();                        <span class="comment">//获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      cash += x;                    <span class="comment">//存款</span></span><br><span class="line">      System.out.println(name + <span class="string">&quot;存款&quot;</span> + x + <span class="string">&quot;, 当前余额为&quot;</span> + cash);</span><br><span class="line">    &#125;</span><br><span class="line">    _draw.signalAll();            <span class="comment">//唤醒所有等待线程.</span></span><br><span class="line">    lock.unlock();                    <span class="comment">//释放锁</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 取款</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> x        操作金额</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> name 操作人</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawing</span><span class="params">(<span class="keyword">int</span> x, String name)</span> </span>&#123;</span><br><span class="line">    lock.lock();                                 <span class="comment">//获取锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (cash - x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            _draw.await();             <span class="comment">//阻塞取款操作</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cash -= x;                     <span class="comment">//取款</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot;取款&quot;</span> + x + <span class="string">&quot;, 当前余额为&quot;</span> + cash);</span><br><span class="line">          &#125;</span><br><span class="line">          _save.signalAll();             <span class="comment">//唤醒所有存款操作</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();                     <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/shihuacai/article/details/8856370">参考来源：未引入样例</a></p>
<p> 一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。用给定的计数初始化 CountDownLatch。由于调用了 countDown() 方法，所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行</p>
<p>在一些应用场合中，需要等待某个条件达到要求后才能做后面的事情；同时当线程都完成后也会触发事件，以便进行后面的操作。 这个时候就可以使用CountDownLatch。CountDownLatch最重要的方法是countDown()和await()，前者主要是倒数一次，后者是等待倒数到0，如果没有到达0，就只有阻塞等待了。</p>
<h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><p>countDown</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">递减锁存器的计数，如果计数到达零，则释放所有等待的线程。如果当前计数大于零，则将计数减少。</span></span><br><span class="line"><span class="function">如果新的计数为零，出于线程调度目的，将重新启用所有的等待线程。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">如果当前计数等于零，则不发生任何操作。</span></span><br></pre></td></tr></table></figure>
<p>await</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                     TimeUnit unit)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断或超出了指定的等待时间。</span></span><br><span class="line"><span class="function">如果当前计数为零，则此方法立刻返回 <span class="keyword">true</span> 值。</span></span><br><span class="line"><span class="function">如果当前计数大于零，则出于线程调度目的，将禁用当前线程，</span></span><br><span class="line"><span class="function">且在发生以下三种情况之一前，该线程将一直处于休眠状态：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">由于调用 <span class="title">countDown</span><span class="params">()</span> 方法，计数到达零；或者其他某个线程中断当前线程；</span></span><br><span class="line"><span class="function">或者已超出指定的等待时间。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">如果计数到达零，则该方法返回 <span class="keyword">true</span> 值。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">如果当前线程：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">在进入此方法时已经设置了该线程的中断状态；或者在等待时被中断，</span></span><br><span class="line"><span class="function">则抛出 InterruptedException，并且清除当前线程的已中断状态。</span></span><br><span class="line"><span class="function">如果超出了指定的等待时间，则返回值为 <span class="keyword">false</span>。如果该时间小于等于零，则此方法根本不会等待。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">参数：</span></span><br><span class="line"><span class="function">    timeout - 要等待的最长时间</span></span><br><span class="line"><span class="function">    unit - timeout 参数的时间单位。</span></span><br><span class="line"><span class="function">返回：</span></span><br><span class="line"><span class="function">    如果计数到达零，则返回 <span class="keyword">true</span>；如果在计数到达零之前超过了等待时间，则返回 <span class="keyword">false</span></span></span><br><span class="line"><span class="function">抛出：</span></span><br><span class="line"><span class="function">    InterruptedException - 如果当前线程在等待时被中断</span></span><br></pre></td></tr></table></figure>


<h2 id="在控制访问量上的应用"><a href="#在控制访问量上的应用" class="headerlink" title="在控制访问量上的应用"></a>在控制访问量上的应用</h2><h1 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h1><p>Java的信号量实际上是一个功能完备的计数器, 对控制一定资源的消费与回收有着很重要的意义, 信号量常常用于多线程的代码中, 并能监控有多少数目的线程等待获取资源, 并且通过信号量可以得知<strong>可用资源的数目</strong>等等, 这里总是在强调“数目”二字, 但不能指出来有哪些在等待, 哪些资源可用.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyPool myPool = <span class="keyword">new</span> MyPool(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">//创建线程池</span></span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    MyThread t1 = <span class="keyword">new</span> MyThread(<span class="string">&quot;任务A&quot;</span>, myPool, <span class="number">3</span>);</span><br><span class="line">    MyThread t2 = <span class="keyword">new</span> MyThread(<span class="string">&quot;任务B&quot;</span>, myPool, <span class="number">12</span>);</span><br><span class="line">    MyThread t3 = <span class="keyword">new</span> MyThread(<span class="string">&quot;任务C&quot;</span>, myPool, <span class="number">7</span>);</span><br><span class="line">    <span class="comment">//在线程池中执行任务</span></span><br><span class="line">    threadPool.execute(t1);</span><br><span class="line">    threadPool.execute(t2);</span><br><span class="line">    threadPool.execute(t3);</span><br><span class="line">    <span class="comment">//关闭池</span></span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Semaphore sp;     <span class="comment">//池相关的信号量</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 池的大小, 这个大小会传递给信号量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> size 池的大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  MyPool(<span class="keyword">int</span> size) &#123;</span><br><span class="line">    <span class="keyword">this</span>.sp = <span class="keyword">new</span> Semaphore(size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Semaphore <span class="title">getSp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSp</span><span class="params">(Semaphore sp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sp = sp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String threadname;            <span class="comment">//线程的名称</span></span><br><span class="line">  <span class="keyword">private</span> MyPool pool;                        <span class="comment">//自定义池</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> x;                                    <span class="comment">//申请信号量的大小</span></span><br><span class="line">  MyThread(String threadname, MyPool pool, <span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">this</span>.threadname = threadname;</span><br><span class="line">    <span class="keyword">this</span>.pool = pool;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//从此信号量获取给定数目的许可</span></span><br><span class="line">      pool.getSp().acquire(x);</span><br><span class="line">      <span class="comment">//TODO 也许这里可以做更复杂的业务</span></span><br><span class="line">      System.out.println(threadname + <span class="string">&quot;成功获取了&quot;</span> + x + <span class="string">&quot;个许可！&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//释放给定数目的许可, 将其返回到信号量.</span></span><br><span class="line">      pool.getSp().release(x);</span><br><span class="line">      System.out.println(threadname + <span class="string">&quot;释放了&quot;</span> + x + <span class="string">&quot;个许可！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><h1 id="原子量"><a href="#原子量" class="headerlink" title="原子量"></a>原子量</h1><p>所谓的原子量即操作变量的操作是“原子的”, 该操作不可再分, 因此是线程安全的.<br>为何要使用原子变量呢, 原因是多个线程对单个变量操作也会引起一些问题.<br>Java5之后, 专门提供了用来进行单变量多线程并发安全访问的工具包<code>java.util.concurrent.atomic</code>, 其中的类也很简单.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原子量, 每个线程都可以自由操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> AtomicLong aLong = <span class="keyword">new</span> AtomicLong(<span class="number">10000</span>);</span><br><span class="line">lock.lock();</span><br><span class="line">System.out.println(name + <span class="string">&quot;执行了&quot;</span> + x + <span class="string">&quot;, 当前余额：&quot;</span> + aLong.addAndGet(x));</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>
<h1 id="锁-1"><a href="#锁-1" class="headerlink" title="锁"></a>锁</h1><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，<br>可重入性 实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。<br>举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，<br>此时线程不必重新去申请锁，而是可以直接执行方法method2。</p>
<p>看下面这段代码就明白了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个方法method1和method2都用synchronized修饰了，假如某一时刻，线程A执行到了method1，此时线程A获取了这个对象的锁，<br>而由于method2也是synchronized方法，假如synchronized不具备可重入性，此时线程A需要重新申请锁。但是这就会造成一个问题，<br>因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，这样就会线程A一直等待永远不会获取到的锁。</p>
<p>由于synchronized和Lock都具备可重入性，所以不会发生上述现象。</p>
<h2 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h2><p>可中断锁：顾名思义，就是可以相应中断的锁。</p>
<p>在Java中，synchronized就不是可中断锁，而Lock是可中断锁。<br>如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，<br>可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。<br>lockInterruptibly()的用法时已经体现了Lock的可中断性。</p>
<h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p>公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。</p>
<p>非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。<br>在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。</p>
<p>而对于ReentrantLock和ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。</p>
<p>看一下这2个类的源代码就清楚了：</p>
<p><img src="/images/java/multithread/02.lock/1.jpg"></p>
<p>在ReentrantLock中定义了2个静态内部类，一个是<code>NotFairSync</code>，一个是<code>FairSync</code>，分别用来实现非公平锁和公平锁。</p>
<p>我们可以在创建ReentrantLock对象时，通过以下方式来设置锁的公平性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>如果参数为true表示为公平锁，为false为非公平锁。默认情况下，如果使用无参构造器，则是非公平锁。</p>
<p><img src="/images/java/multithread/02.lock/2.jpg"></p>
<p>另外在ReentrantLock类中定义了很多方法，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">isFair() &#x2F;&#x2F;判断锁是否是公平锁</span><br><span class="line">isLocked() &#x2F;&#x2F;判断锁是否被任何线程获取了</span><br><span class="line">isHeldByCurrentThread() &#x2F;&#x2F;判断锁是否被当前线程获取了</span><br><span class="line">hasQueuedThreads() &#x2F;&#x2F;判断是否有线程在等待该锁</span><br></pre></td></tr></table></figure>
<p>在ReentrantReadWriteLock中也有类似的方法，同样也可以设置为公平锁和非公平锁。不过要记住，ReentrantReadWriteLock并未实现Lock接口，它实现的是ReadWriteLock接口。</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。<br>正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。<br>ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。<br>可以通过readLock()获取读锁，通过writeLock()获取写锁。</p>
<h1 id="减少锁带来的开销"><a href="#减少锁带来的开销" class="headerlink" title="减少锁带来的开销"></a>减少锁带来的开销</h1><h2 id="使用Java-API中的并发类库"><a href="#使用Java-API中的并发类库" class="headerlink" title="使用Java API中的并发类库"></a>使用Java API中的并发类库</h2><pre><code>可以采用java.util.concurrent等包下面的并发类，通常它们已经经过了充分的优化，能有效地支持高并发环境下的操作，并发类中大量采用了非阻塞算法，有些利用了CAS实现无锁。这里有一个小提示：使用并发哈希表时应优先采用ConcurrentHashMap而不是Hashtable，前者通过分解锁的方法使得效率更高。</code></pre>
<h2 id="用CAS代替锁"><a href="#用CAS代替锁" class="headerlink" title="用CAS代替锁"></a>用CAS代替锁</h2><pre><code>和第一点中提到的一样，CAS可以减小锁的开销，但是CAS本身是基于轮询的操作，实际使用中反而可能增加开销，这一点需要实验来测试。</code></pre>
<h2 id="减小锁的粒度"><a href="#减小锁的粒度" class="headerlink" title="减小锁的粒度"></a>减小锁的粒度</h2><pre><code>尽可能缩小锁定的范围，可以从两个方面入手。第一是只锁定所需的对象，少用synchronized(this)。第二是尽可能缩小锁定的方法块，缩小临界区大小，避免将不必要的操作也归入临界区。</code></pre>
<h2 id="拆分锁"><a href="#拆分锁" class="headerlink" title="拆分锁"></a>拆分锁</h2><pre><code>将普通的对象锁、互斥锁按照场景拆分为读写锁或像ConcurrentHashMap一样拆分为若干把锁。</code></pre>
<h2 id="利用写时复制"><a href="#利用写时复制" class="headerlink" title="利用写时复制"></a>利用写时复制</h2><pre><code>对于读操作次数远远大于写操作的场景，可以在读操作时不加锁，写操作时利用写时复制来完成，但是内存占用会相应上升。</code></pre>
<p>其次，系统中的线程数最好不是固定的，而是按CPU数来计算，这样当CPU增加时，相应的系统会自动增加线程提高并发率。<br>最后，如果对系统的CPU使用率还不满意，应当考虑分解一些单线程任务，改为多线程并发执行，以提高效率。<br>增加内存时，需要进行如下调整：<br>首先类似于线程数按CPU数计算，将Cache大小按内存大小计算，扩展内存后，Cache可以自动增长大小。<br>其次，可以分配更大的JVM堆内存给虚拟机，能减少OOM发生的几率。</p>
<hr>
<p>【参考文献】:</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/multithread/05.ThreadPool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/multithread/05.ThreadPool/" class="post-title-link" itemprop="url">Java多线程5: 线程池使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-08-29 00:00:00" itemprop="dateCreated datePublished" datetime="2015-08-29T00:00:00+08:00">2015-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-16 15:17:28" itemprop="dateModified" datetime="2021-01-16T15:17:28+08:00">2021-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Sun在Java5中, 对Java线程的类库做了大量的扩展, 其中 <a href="/Java/multithread/05.ThreadPool/">线程池</a> 就是Java5的新特征之一</p>
<h1 id="线程池使用"><a href="#线程池使用" class="headerlink" title="线程池使用"></a>线程池使用</h1><ul>
<li>线程池的作用:<br>   线程池作用就是限制系统中执行线程的数量. 根据系统的环境情况, 可以自动或手动设置线程数量, 达到运行的最佳效果;<br>   少了浪费系统资源, 多了造成系统拥挤效率不高. 用线程池控制线程数量, 其他线程排队等候.<br>   一个任务执行完毕, 再从队列的中取最前面的任务开始执行. 若队列中没有等待进程, 线程池的这一资源处于等待.<br>   当一个新任务需要运行时, 如果线程池中有等待的工作线程, 就可以开始运行了; 否则进入等待队列. </li>
<li>为什么要用线程池:<ol>
<li>减少了创建和销毁线程的次数, 每个工作线程都可以被重复利用, 可执行多个任务. </li>
<li>可以根据系统的承受能力, 调整线程池中工作线线程的数目, 防止因为消耗过多的内存, 而把服务器累趴下(每个线程需要大约1MB内存, 线程开的越多, 消耗的内存也就越大, 最后死机). </li>
</ol>
</li>
</ul>
<p>在Java5中, 需要了解<code>java.util.concurrent.Executors</code>类的API, 这个类提供大量创建线程池的静态方法, 是必须掌握的.<br>Java里面线程池的顶级接口是<code>Executor</code>, 但是严格意义上讲 <code>Executor</code> 并不是一个线程池, 而只是一个执行线程的工具. 真正的线程池接口是 <code>ExecutorService</code>. </p>
<p>比较重要的几个类: </p>
<ul>
<li><code>ExecutorService</code> 真正的线程池接口. </li>
<li><code>ScheduledExecutorService</code> 能和Timer/TimerTask类似, 解决那些需要任务重复执行的问题. </li>
<li><code>ThreadPoolExecutor ExecutorService</code>的默认实现. </li>
<li><code>ScheduledThreadPoolExecutor</code> 继承<code>ThreadPoolExecutor</code>的<code>ScheduledExecutorService</code>接口实现, 周期性任务调度的类实现. </li>
</ul>
<p>要配置一个线程池是比较复杂的, 在<code>Executors</code>类里面提供了一些 <a href="/designPattern/factory/">静态工厂</a> 用于简便的生成一些常用的线程池. </p>
<ol>
<li>newSingleThreadExecutor<br>创建一个单线程的线程池. 这个线程池只有一个线程在工作, 也就是相当于单线程串行执行所有任务. 如果这个唯一的线程因为异常结束, 那么会有一个新的线程来替代它. 此线程池保证所有任务的执行顺序按照任务的提交顺序执行. </li>
<li>newFixedThreadPool<br>创建固定大小的线程池. 每次提交一个任务就创建一个线程, 直到线程达到线程池的最大大小. 线程池的大小一旦达到最大值就会保持不变, 如果某个线程因为执行异常而结束, 那么线程池会补充一个新线程. </li>
<li>newCachedThreadPool<br>创建一个可缓存的线程池. 如果线程池的大小超过了处理任务所需要的线程, 那么就会回收部分空闲（60秒不执行任务）的线程, 当任务数增加时, 此线程池又可以智能的添加新线程来处理任务. 此线程池不会对线程池大小做限制, 线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小. </li>
<li>newScheduledThreadPool<br>创建一个大小无限的线程池. 此线程池支持定时以及周期性执行任务的需求. </li>
</ol>
<h2 id="可重用固定线程数的线程池"><a href="#可重用固定线程数的线程池" class="headerlink" title="可重用固定线程数的线程池"></a>可重用固定线程数的线程池</h2><p>Executors.newFixedThreadPool</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个可重用固定线程数的线程池</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//创建实现了Runnable接口对象, Thread对象当然也实现了Runnable接口</span></span><br><span class="line">Thread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread t3 = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread t4 = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread t5 = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="comment">//将线程放入池中进行执行</span></span><br><span class="line">pool.execute(t1);</span><br><span class="line">pool.execute(t2);</span><br><span class="line">pool.execute(t3);</span><br><span class="line">pool.execute(t4);</span><br><span class="line">pool.execute(t5);</span><br><span class="line"><span class="comment">//虽然放入了5个Runnable, 但必须在两个线程中循环执行. </span></span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>
<h2 id="单个worker线程的Executor"><a href="#单个worker线程的Executor" class="headerlink" title="单个worker线程的Executor"></a>单个<code>worker</code>线程的<code>Executor</code></h2><p>Executors.newSingleThreadExecutor</p>
<p>创建一个使用单个 <code>worker</code> 线程的 Executor, 以无界队列方式来运行该线程.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>
<p>以上两种连接池, 大小都是固定的, 当要加入的池的线程（或者任务）超过池最大尺寸时候, 则入此线程池需要排队等待.<br>一旦池中有线程完毕, 则排队等待的某个线程会入池执行. 如果当前线程在执行任务时突然中断, 则会创建一个新的线程替代它继续执行任务</p>
<h2 id="可变尺寸的线程池"><a href="#可变尺寸的线程池" class="headerlink" title="可变尺寸的线程池"></a>可变尺寸的线程池</h2><p>Executors.newCachedThreadPool</p>
<p>创建一个可根据需要创建新线程的线程池, 但是在以前构造的线程可用时将重用它们.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>
<h2 id="延迟连接池"><a href="#延迟连接池" class="headerlink" title="延迟连接池"></a>延迟连接池</h2><p>Executors.newScheduledThreadPool</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个线程池, 它可安排在给定延迟后运行命令或者定期地执行.</span></span><br><span class="line">ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">Thread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread t3 = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread t4 = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread t5 = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="comment">//将线程放入池中进行执行</span></span><br><span class="line">pool.execute(t1);</span><br><span class="line">pool.execute(t2);</span><br><span class="line">pool.execute(t3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用延迟执行风格的方法</span></span><br><span class="line">pool.schedule(t4, <span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">pool.schedule(t5, <span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>
<h2 id="单任务延迟连接池"><a href="#单任务延迟连接池" class="headerlink" title="单任务延迟连接池"></a>单任务延迟连接池</h2><p>Executors.newSingleThreadScheduledExecutor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个单线程执行程序, 它可安排在给定延迟后运行命令或者定期地执行.</span></span><br><span class="line">ScheduledExecutorService pool = Executors.newSingleThreadScheduledExecutor();</span><br></pre></td></tr></table></figure>




<h1 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h1><p>在实现上, 线程池包含两个部分: <code>worker</code>线程组和等待队列. 当没有等待队列时, 线程都不能等待或缓冲, 所有的线程在放入的时候, 即决定开始执行或不执行. 其他情况下, 均是<code>worker</code>线程组从等待队列中取”任务”.</p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建等待队列</span></span><br><span class="line">BlockingQueue&lt;Runnable&gt; bqueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//创建一个单线程执行程序, 它可安排在给定延迟后运行命令或者定期地执行.</span></span><br><span class="line">ThreadPoolExecutor pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,TimeUnit.MILLISECONDS,bqueue);</span><br></pre></td></tr></table></figure>
<p>创建自定义线程池的构造方法很多, 本例中参数的含义如下: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span></span></span><br></pre></td></tr></table></figure>
<p>用给定的初始参数和默认的线程工厂及处理程序创建新的 <code>ThreadPoolExecutor</code>.<br>使用 <code>Executors</code> 工厂方法之一比使用此通用构造方法方便得多.</p>
<ul>
<li>参数: <ul>
<li>corePoolSize - 池中所保存的线程数, 包括空闲线程.</li>
<li>maximumPoolSize - 池中允许的最大线程数.</li>
<li>keepAliveTime - 当线程数大于核心时, 此为终止前多余的空闲线程等待新任务的最长时间.</li>
<li>unit - keepAliveTime参数的时间单位.</li>
<li>workQueue - 执行前用于保持任务的队列. 此队列仅保持由 <code>execute</code> 方法提交的 <code>Runnable</code> 任务.</li>
</ul>
</li>
<li>抛出: <ul>
<li>IllegalArgumentException - 如果 corePoolSize 或 keepAliveTime 小于零, 或者 maximumPoolSize 小于或等于零, 或者 corePoolSize 大于 maximumPoolSize.</li>
<li>NullPointerException - 如果 workQueue 为 null</li>
</ul>
</li>
</ul>
<p>自定义连接池稍微麻烦些, 不过通过创建的<code>ThreadPoolExecutor</code>线程池对象, 可以获取到当前线程池的尺寸、正在执行任务的线程数、工作队列等等</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>下面介绍一下几个类的源码: </p>
<ol>
<li><code>ExecutorService  newFixedThreadPool(int nThreads)</code>: 固定大小线程池.<br> 可以看到, <code>corePoolSize</code> 和 <code>maximumPoolSize</code>的大小是一样的（实际上, 后面会介绍, 如果使用无界<code>queue</code>的话<code>maximumPoolSize</code>参数是没有意义的）, <code>keepAliveTime</code>和<code>unit</code>的设值表明什么？-就是该实现不想<code>keep alive</code>！最后的<code>BlockingQueue</code>选择了<code>LinkedBlockingQueue</code>, 该queue有一个特点, 他是无界的. <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>ExecutorService  newSingleThreadExecutor()</code>: 单线程<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">                (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                         <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                         <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>ExecutorService newCachedThreadPool()</code>: 无界线程池, 可以进行自动线程回收<br>这个实现就有意思了. 首先是无界的线程池, 所以我们可以发现maximumPoolSize为big big. 其次BlockingQueue的选择上使用<code>SynchronousQueue</code>. 可能对于该<code>BlockingQueue</code>有些陌生, 简单说: 该QUEUE中, 每个插入操作必须等待另一个线程的对应移除操作. <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                          <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                          <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2></li>
</ol>
<p>先从<code>BlockingQueue&lt;Runnable&gt; workQueue</code>这个入参开始说起. 在JDK中, 其实已经说得很清楚了, 一共有三种类型的queue. </p>
<p>所有 <code>BlockingQueue</code> 都可用于传输和保持提交的任务. 可以使用此队列与池大小进行交互: </p>
<p>如果运行的线程少于 <code>corePoolSize</code>, 则 <code>Executor</code>始终首选添加新的线程, 而不进行排队. （如果当前运行的线程小于<code>corePoolSize</code>, 则任务根本不会存放, 添加到queue中, 而是直接抄家伙（thread）开始运行）</p>
<p>如果运行的线程等于或多于 <code>corePoolSize</code>, 则 <code>Executor</code> 始终首选将请求加入队列, 而不添加新的线程.<br>如果无法将请求加入队列, 则创建新的线程, 除非创建此线程超出 <code>maximumPoolSize</code>, 在这种情况下, 任务将被拒绝.<br>queue上的三种类型. </p>
<p>排队有三种通用策略: </p>
<ul>
<li>直接提交. 工作队列的默认选项是 <code>SynchronousQueue</code>, 它将任务直接提交给线程而不保持它们. 在此, 如果不存在可用于立即运行任务的线程, 则试图把任务加入队列将失败, 因此会构造一个新的线程. 此策略可以避免在处理可能具有内部依赖性的请求集时出现锁. 直接提交通常要求无界 <code>maximumPoolSizes</code> 以避免拒绝新提交的任务. 当命令以超过队列所能处理的平均数连续到达时, 此策略允许无界线程具有增长的可能性. </li>
<li>无界队列. 使用无界队列（例如, 不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待. 这样, 创建的线程就不会超过 corePoolSize. （因此, maximumPoolSize的值也就无效了. ）当每个任务完全独立于其他任务, 即任务执行互不影响时, 适合于使用无界队列; 例如, 在 Web页服务器中. 这种排队可用于处理瞬态突发请求, 当命令以超过队列所能处理的平均数连续到达时, 此策略允许无界线程具有增长的可能性. </li>
<li>有界队列. 当使用有限的 maximumPoolSizes时, 有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽, 但是可能较难调整和控制. 队列大小和最大池大小可能需要相互折衷: 使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销, 但是可能导致人工降低吞吐量. 如果任务频繁阻塞（例如, 如果它们是 I/O边界）, 则系统可能为超过您许可的更多线程安排时间. 使用小型队列通常要求较大的池大小, CPU使用率较高, 但是可能遇到不可接受的调度开销, 这样也会降低吞吐量. </li>
</ul>
<h3 id="BlockingQueue的选择"><a href="#BlockingQueue的选择" class="headerlink" title="BlockingQueue的选择."></a>BlockingQueue的选择.</h3><ul>
<li>例子一: 使用直接提交策略, 也即SynchronousQueue.<br>首先SynchronousQueue是无界的, 也就是说他存数任务的能力是没有限制的, 但是由于该Queue本身的特性, 在某次添加元素后必须等待其他线程取走后才能继续添加. 在这里不是核心线程便是新创建的线程, 但是我们试想一样下, 下面的场景.<br>我们使用一下参数构造ThreadPoolExecutor: </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">        <span class="number">2</span>, <span class="number">3</span>, <span class="number">30</span>, TimeUnit.SECONDS,</span><br><span class="line">                 <span class="keyword">new</span>  SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                <span class="keyword">new</span> RecorderThreadFactory(<span class="string">&quot;CookieRecorderPool&quot;</span>),</span><br><span class="line">         <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>
<p> 当核心线程已经有2个正在运行.</p>
<ul>
<li>此时继续来了一个任务（A）, 根据前面介绍的“如果运行的线程等于或多于 corePoolSize, 则 Executor始终首选将请求加入队列, 而不添加新的线程. ”,所以A被添加到queue中. </li>
<li>又来了一个任务（B）, 且核心2个线程还没有忙完, OK, 接下来首先尝试1中描述, 但是由于使用的SynchronousQueue, 所以一定无法加入进去. <ul>
<li>此时便满足了上面提到的“如果无法将请求加入队列, 则创建新的线程, 除非创建此线程超出maximumPoolSize, 在这种情况下, 任务将被拒绝. ”, 所以必然会新建一个线程来运行这个任务. </li>
<li>暂时还可以, 但是如果这三个任务都还没完成, 连续来了两个任务, 第一个添加入queue中, 后一个呢？queue中无法插入, 而线程数达到了maximumPoolSize, 所以只好执行异常策略了. </li>
</ul>
</li>
</ul>
<p>所以在使用SynchronousQueue通常要求maximumPoolSize是无界的, 这样就可以避免上述情况发生（如果希望限制就直接使用有界队列）. 对于使用SynchronousQueue的作用jdk中写的很清楚: 此策略可以避免在处理可能具有内部依赖性的请求集时出现锁.<br>什么意思？如果你的任务A1, A2有内部关联, A1需要先运行, 那么先提交A1, 再提交A2, 当使用SynchronousQueue我们可以保证, A1必定先被执行, 在A1么有被执行前, A2不可能添加入queue中. </p>
<ul>
<li><p>例子二: 使用无界队列策略, 即LinkedBlockingQueue<br>这个就拿newFixedThreadPool来说, 根据前文提到的规则:<br>如果运行的线程少于 corePoolSize, 则 Executor 始终首选添加新的线程, 而不进行排队. 那么当任务继续增加, 会发生什么呢？<br>如果运行的线程等于或多于 corePoolSize, 则 Executor 始终首选将请求加入队列, 而不添加新的线程. OK, 此时任务变加入队列之中了, 那什么时候才会添加新线程呢？<br>如果无法将请求加入队列, 则创建新的线程, 除非创建此线程超出 maximumPoolSize, 在这种情况下, 任务将被拒绝. 这里就很有意思了, 可能会出现无法加入队列吗？不像SynchronousQueue那样有其自身的特点, 对于无界队列来说, 总是可以加入的（资源耗尽, 当然另当别论）. 换句说, 永远也不会触发产生新的线程！corePoolSize大小的线程数会一直运行, 忙完当前的, 就从队列中拿任务开始运行. 所以要防止任务疯长, 比如任务运行的实行比较长, 而添加任务的速度远远超过处理任务的时间, 而且还不断增加, 不一会儿就爆了. </p>
</li>
<li><p>例子三: 有界队列, 使用ArrayBlockingQueue.<br>这个是最为复杂的使用, 所以JDK不推荐使用也有些道理. 与上面的相比, 最大的特点便是可以防止资源耗尽的情况发生.<br>举例来说, 请看如下构造方法: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">    <span class="number">2</span>, <span class="number">4</span>, <span class="number">30</span>, TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">new</span> RecorderThreadFactory(<span class="string">&quot;CookieRecorderPool&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br></pre></td></tr></table></figure>
<p>假设, 所有的任务都永远无法执行完.<br>对于首先来的A,B来说直接运行, 接下来, 如果来了C,D, 他们会被放到queue中, 如果接下来再来E,F, 则增加线程运行E, F. 但是如果再来任务, 队列无法再接受了, 线程数也到达最大的限制了, 所以就会使用拒绝策略来处理. </p>
</li>
</ul>
<h3 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h3><p>jdk中的解释是: 当线程数大于核心时, 此为终止前多余的空闲线程等待新任务的最长时间.<br>有点拗口, 其实这个不难理解, 在使用了“池”的应用中, 大多都有类似的参数需要配置. 比如数据库连接池, DBCP中的maxIdle, minIdle参数.<br>什么意思？接着上面的解释, 后来向老板派来的工人始终是“借来的”, 俗话说“有借就有还”, 但这里的问题就是什么时候还了, 如果借来的工人刚完成一个任务就还回去, 后来发现任务还有, 那岂不是又要去借？这一来一往, 老板肯定头也大死了. </p>
<p>合理的策略: 既然借了, 那就多借一会儿. 直到“某一段”时间后, 发现再也用不到这些工人时, 便可以还回去了. 这里的某一段时间便是keepAliveTime的含义, TimeUnit为keepAliveTime值的度量. </p>
<p>RejectedExecutionHandler<br>另一种情况便是, 即使向老板借了工人, 但是任务还是继续过来, 还是忙不过来, 这时整个队伍只好拒绝接受了.<br>RejectedExecutionHandler接口提供了对于拒绝任务的处理的自定方法的机会. 在ThreadPoolExecutor中已经默认包含了4中策略, 因为源码非常简单, 这里直接贴出来.<br>CallerRunsPolicy: 线程调用运行该任务的 execute 本身. 此策略提供简单的反馈控制机制, 能够减缓新任务的提交速度. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">               r.run();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>这个策略显然不想放弃执行任务. 但是由于池中已经没有任何资源了, 那么就直接使用调用该execute的线程本身来执行. </p>
<p>AbortPolicy:<br>处理程序遭到拒绝将抛出运行时RejectedExecutionException</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p> 这种策略直接抛出异常, 丢弃任务. </p>
<p>DiscardPolicy: 不能执行的任务将被删除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p> 这种策略和AbortPolicy几乎一样, 也是丢弃任务, 只不过他不抛出异常.<br>DiscardOldestPolicy: 如果执行程序尚未关闭, 则位于工作队列头部的任务将被删除, 然后重试执行程序（如果再次失败, 则重复此过程）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">               e.getQueue().poll();</span><br><span class="line">               e.execute(r);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>该策略就稍微复杂一些, 在pool没有关闭的前提下首先丢掉缓存在队列中的最早的任务, 然后重新尝试运行该任务. 这个策略需要适当小心.<br>设想:如果其他线程都还在运行, 那么新来任务踢掉旧任务, 缓存在queue中, 再来一个任务又会踢掉queue中最老任务. </p>
<p>总结:<br>keepAliveTime和maximumPoolSize及BlockingQueue的类型均有关系. 如果BlockingQueue是无界的, 那么永远不会触发maximumPoolSize, 自然keepAliveTime也就没有了意义.<br>反之, 如果核心数较小, 有界BlockingQueue数值又较小, 同时keepAliveTime又设的很小, 如果任务频繁, 那么系统就会频繁的申请回收线程. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                     <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h2 id="有返回值的线程池"><a href="#有返回值的线程池" class="headerlink" title="有返回值的线程池"></a>有返回值的线程池</h2><p>可返回值的任务必须实现<code>Callable</code>接口, 类似的, 无返回值的任务必须<code>Runnable</code>接口.<br>执行<code>Callable</code>取到<code>Callable</code>任务返回的<code>Object</code>了.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个线程池</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//创建两个有返回值的任务</span></span><br><span class="line">Callable c1 = <span class="keyword">new</span> MyCallable(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">Callable c2 = <span class="keyword">new</span> MyCallable(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"><span class="comment">//执行任务并获取Future对象</span></span><br><span class="line">Future f1 = pool.submit(c1);</span><br><span class="line">Future f2 = pool.submit(c2);</span><br><span class="line"><span class="comment">//从Future对象上获取任务的返回值, 并输出到控制台</span></span><br><span class="line">System.out.println(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>+f1.get().toString());</span><br><span class="line">System.out.println(<span class="string">&quot;&gt;&gt;&gt;&quot;</span>+f2.get().toString());</span><br><span class="line"><span class="comment">//关闭线程池</span></span><br><span class="line">pool.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>【参考文献】:</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/sd0902/article/details/8395677">Java线程池使用说明</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/multithread/31.multithreadWaitedSample01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/multithread/31.multithreadWaitedSample01/" class="post-title-link" itemprop="url">Java多线程等待的N种打开方式(第一篇)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-08-12 00:00:00" itemprop="dateCreated datePublished" datetime="2015-08-12T00:00:00+08:00">2015-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-16 15:17:28" itemprop="dateModified" datetime="2021-01-16T15:17:28+08:00">2021-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>单核CPU就是”一根筋”，只是简单的一条一条的串行执行机器指令，且每个时钟周期内只执行一条指令，如果一个进程不间断的运行，那么就只能运行一个任务；</p>
<p>将CPU的运行时间划分成一个个的时间段，这就是时间片(time slice)，进程通过抢占时间片，以达到交替执行的效果，宏观上，多个任务同时运行，JVM正是采用抢占式调度的方式根据优先级来”有限”的控制线程的运行。</p>
<p>为了提高代码的执行效率，编译器会在编译时做指令重排等优化，这就造成了在多线程运行时，出现与单线程运行不一致的情况。再加上，为了优化多核执行效率，造成各个线程访问的变量值与内存主存的值不一致的情况，就出现<strong>内存可见性</strong>问题。</p>
<p>JMM通过内存屏障、CAS和mutex lock指令等手段，实现各种各样的锁，究竟Java提供了哪些方法可以实现线程的等待呢，接下来以一个样例场景打开”Java多线程等待的N中方式”。</p>
<h2 id="题目与约定"><a href="#题目与约定" class="headerlink" title="题目与约定"></a>题目与约定</h2><blockquote>
<p> 假设有A、B、C三个线程，C必须等待A和B都结束时才能运行，</p>
<p> 约定每个线程的耗时操作为方法<code>doWork(String threadName)</code></p>
</blockquote>
<p>接下来将以此样例分析实现方法和Java实现的原理：</p>
<ol>
<li>第一篇: monitor</li>
</ol>
<ul>
<li>Thread.join等待线程完成</li>
<li>Object.wait-notify等待唤醒</li>
<li>LockSupport</li>
</ul>
<ol start="2">
<li>第二篇: AQS</li>
</ol>
<ul>
<li>CountDownLatch</li>
<li>ReentrantLock</li>
<li>Semaphore</li>
<li>CyclicBarrier循环屏障</li>
</ul>
<ol start="3">
<li>第三篇: 队列</li>
</ol>
<ul>
<li>Future</li>
<li>BlockingDeque</li>
<li>ListenableFuture</li>
</ul>
<h2 id="Thread-Join等待线程完成"><a href="#Thread-Join等待线程完成" class="headerlink" title="Thread.Join等待线程完成"></a>Thread.Join等待线程完成</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis,<span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure>
<p>等待最多<code>millis</code>毫秒+<code>nanos</code>纳秒等待完成完成，通过循环调用<code>this.wait</code>等待<code>this.isAlive</code>条件完成，当调用<code>this.notifyAll</code>方法时，此线程终止。建议应用程序不要在线程实例上使用<code>wait</code>、<code>notify</code>或<code>notifyAll</code>。</p>
<h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Thread threadA = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  doWork(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">final</span> Thread threadB = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  doWork(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">final</span> Thread threadC = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    threadA.join(); <span class="comment">// 等待A结束</span></span><br><span class="line">    threadB.join(); <span class="comment">// 等待B结束</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  doWork(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 启动A、B两个线程</span></span><br><span class="line">threadA.start();</span><br><span class="line">threadB.start();</span><br><span class="line"><span class="comment">// 启动C线程</span></span><br><span class="line">threadC.start();</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread A starting </span><br><span class="line">Thread B starting </span><br><span class="line">Thread B finished</span><br><span class="line">Thread A finished</span><br><span class="line">Thread C starting </span><br><span class="line">Thread C finished</span><br></pre></td></tr></table></figure>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        join(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123; <span class="comment">// 0表示没有设置超时时间</span></span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;<span class="comment">//isAlive获取线程状态，无限等待直到previousThread线程结束</span></span><br><span class="line">                wait(<span class="number">0</span>); <span class="comment">//调用Object中的wait方法实现线程的阻塞</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//阻塞直到超时</span></span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123; </span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试此线程是否存活，如果此线程started并且还没有死亡，则存活</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &lt;code&gt;true&lt;/code&gt; 如果此线程存活;</span></span><br><span class="line"><span class="comment">     *          &lt;code&gt;false&lt;/code&gt; 否则.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;      </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 导致当前线程等待，直到另一个线程调用此对象的notify()方法或notifyAll()方法</span></span><br><span class="line"><span class="comment">     * 当前线程必须拥有此对象的监视器。当前线程释放此监视器的所有权，并等待，直到另一个线程通过调用notify方法或notifyAll方法唤通知等待此对象的监视器的线程唤醒。然后，线程等待，直到它可以重新获得监视器的所有权并继续执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JavaThread::exit</span><span class="params">(<span class="keyword">bool</span> destroy_vm, ExitType exit_type)</span> </span>&#123;</span><br><span class="line">  assert(<span class="keyword">this</span> == JavaThread::current(),  <span class="string">&quot;thread consistency check&quot;</span>);</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 在线程对象上通知等待者。必须在线程上调用exit()之后执行此操作（如果该线程是守护线程组中的最后一个线程，则通知等待对象之前，线程组应设置已破坏的位）。</span></span><br><span class="line">  ensure_join(<span class="keyword">this</span>); </span><br><span class="line">  assert(!<span class="keyword">this</span>-&gt;has_pending_exception(), <span class="string">&quot;ensure_join should have cleared&quot;</span>);</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>


<p><code>join</code>方法本质是调用的<code>Object</code>中的<code>wait</code>方法实现线程的阻塞，调用wait方法必须要获取锁，所以<code>join</code>方法是被<code>synchronized</code>修饰的，<code>synchronized</code>修饰在方法层面相当于<code>synchronized(this)</code>,<code>this</code>就是<code>previousThread</code>本身的实例，两次调用join的<code>previousThread</code>分别是A和B两个线程，此时<code>previousThread</code>线程对象的监视器也就只有一个C线程在等待，因此当<code>previousThread</code>执行完的时候，通过<code>notify</code>和<code>notifyAll</code>会立即唤醒(只有一个线程嘛)。</p>
<p>此例子中，有两把锁存在，分别等待<code>threadA</code>和<code>threadB</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">threadA.join(); <span class="comment">// 调用threadA.wait(),threadA运行完后,默认会唤醒threadA对象上等待的threadC</span></span><br><span class="line">threadB.join(); <span class="comment">// 调用threadB.wait(),threadB运行完后,默认会唤醒threadB对象上等待的threadC</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：建议调用<code>Thread.join</code>的时候，不要在线程实例上同时调用<code>wait</code>、<code>nofity</code>和<code>notifyAll</code>方法</p>
</blockquote>
<h2 id="Object-wait-notify等待唤醒"><a href="#Object-wait-notify等待唤醒" class="headerlink" title="Object.wait-notify等待唤醒"></a>Object.wait-notify等待唤醒</h2><p><code>wait-nofity</code>是Object中的等待唤醒组合，实现等待两个线程完成，可以使用一把锁，也可以使用两把锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一把锁的解法</span></span><br><span class="line"><span class="comment">// finishedCount是一个数组对象，可以通过这个对象实现C等待A和B完成，C循环扫描完成个数</span></span><br><span class="line"><span class="keyword">int</span>[] finishedCount = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">Thread aThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  doWork(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (finishedCount) &#123;</span><br><span class="line">    <span class="comment">// 完成一个，加一</span></span><br><span class="line">    finishedCount[<span class="number">0</span>]++;</span><br><span class="line">    <span class="comment">// 唤醒C</span></span><br><span class="line">    finishedCount.notify();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Thread bThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  doWork(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">  <span class="keyword">synchronized</span> (finishedCount) &#123;</span><br><span class="line">    <span class="comment">// 完成一个，加一</span></span><br><span class="line">    finishedCount[<span class="number">0</span>]++;</span><br><span class="line">    <span class="comment">// 唤醒C</span></span><br><span class="line">    finishedCount.notify();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Thread cThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  <span class="comment">// 循环扫描完成个数，只到两个都完成</span></span><br><span class="line">  <span class="keyword">while</span> (finishedCount[<span class="number">0</span>] &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (finishedCount) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        finishedCount.wait();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  doWork(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">aThread.start();</span><br><span class="line">bThread.start();</span><br><span class="line">cThread.start();</span><br></pre></td></tr></table></figure>
<p>C在对象<code>finishedCount</code>上等待，A和B完成时，首先把<code>finishedCount</code>加一，然后唤醒C</p>
<p>C被唤醒时，判断A和B已经完成（<code>finishedCount</code>是否为2），完成则开始执行C的任务</p>
<h3 id="Object-wait-notify实现原理"><a href="#Object-wait-notify实现原理" class="headerlink" title="Object.wait-notify实现原理"></a>Object.wait-notify实现原理</h3><p><img src="/Users/averyzhang/yun_sync/wiki-own/images/java/multithread/monitor/monitor_lock_diy.png"></p>
<p>在HotSpot虚拟机中，<code>monitor</code>采用<code>ObjectMonitor</code>实现。</p>
<p><code>ObjectMonitor</code>对象中有两个队列，都用来保存<code>ObjectWaiter</code>对象，分别是<code>WaitSet</code> 和 <code>EntrySet</code>。<code>_owner</code>用来指向获得ObjectMonitor对象的线程</p>
<p><code>ObjectWaiter</code>对象是双向链表结构，保存了<code>_thread</code>（当前线程）以及当前的状态<code>TState</code>等数据， 每个等待锁的线程都会被封装成<code>ObjectWaiter</code>对象。<br><code>_WaitSet</code> ：处于wait状态的线程，会被加入到wait set；</p>
<p><code>_EntrySet</code>：处于等待锁block状态的线程，会被加入到entry set；</p>
<h4 id="wait方法实现"><a href="#wait方法实现" class="headerlink" title="wait方法实现"></a>wait方法实现</h4><p><code>lock.wait()</code>方法最终通过<code>ObjectMonitor</code>的 <code>wait(jlong millis, bool interruptable, TRAPS)</code>实现</p>
<ol>
<li><p>将当前线程封装成<code>ObjectWaiter</code>对象node</p>
</li>
<li><p>通过<code>ObjectMonitor::AddWaiter</code>方法将node添加到<code>_WaitSet</code>列表中</p>
</li>
<li><p>通过<code>ObjectMonitor::exit</code>方法释放当前的<code>ObjectMonitor</code>对象，这样其它竞争线程就可以获取该<code>ObjectMonitor</code>对象</p>
</li>
<li><p>最终底层的<code>park</code>方法会挂起线程</p>
</li>
</ol>
<p><code>ObjectSynchorizer::wait</code>方法通过<code>Object</code>对象找到<code>ObjectMonitor</code>对象来调用方法 <code>ObjectMonitor::wait()</code>，通过调用<code>ObjectMonitor::AddWaiter()</code>可以把新建的<code>ObjectWaiter</code>对象，放入到<code>_WaitSet</code>队列的末尾，然后在<code>ObjectMonitor::exit</code>释放锁，接着通过执行<code>thread_ParkEvent-&gt;park</code>来挂起线程，也就是进行<code>wait</code>。</p>
<h4 id="notify方法实现"><a href="#notify方法实现" class="headerlink" title="notify方法实现"></a>notify方法实现</h4><p><code>lock.notify()</code>方法最终通过ObjectMonitor的<code>void notify(TRAPS)</code>实现：<br>1、如果当前<em>WaitSet为空，即没有正在等待的线程，则直接返回；<br>2、通过<code>ObjectMonitor::DequeueWaiter</code>方法，获取</em><code>WaitSet</code>列表中的第一个<code>ObjectWaiter</code>节点，实现也很简单。</p>
<blockquote>
<p>这里需要注意的是，在jdk的notify方法注释是随机唤醒一个线程，其实是第一个ObjectWaiter节点</p>
</blockquote>
<p>3、根据不同的策略，将取出来的<code>ObjectWaiter</code>节点，加入到<code>_EntryList</code>或则通过<code>Atomic::cmpxchg_ptr</code>指令进行自旋操作cxq，具体代码实现有点长，这里就不贴了，有兴趣的同学可以看objectMonitor::notify方法；</p>
<h4 id="notifyAll方法实现"><a href="#notifyAll方法实现" class="headerlink" title="notifyAll方法实现"></a>notifyAll方法实现</h4><p><code>lock.notifyAll()</code>方法最终通过<code>ObjectMonitor</code>的<code>void notifyAll(TRAPS)</code>实现：<br>通过<code>for</code>循环取出<code>_WaitSet</code>的<code>ObjectWaiter</code>节点，并根据不同策略，加入到<code>_EntryList</code>或则进行自旋操作。</p>
<p>从JVM的方法实现中，可以发现：<code>notify</code>和<code>notifyAll</code>并不会释放所占有的<code>ObjectMonitor</code>对象，其实真正释放<code>ObjectMonitor</code>对象的时间点是在执行<code>monitorexit</code>指令，一旦释放<code>ObjectMonitor</code>对象了，entry set中<code>ObjectWaiter</code>节点所保存的线程就可以开始竞争ObjectMonitor对象进行加锁操作了。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/">https://docs.oracle.com/javase/8/docs/</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/multithread/32.multithreadWaitedSample02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/multithread/32.multithreadWaitedSample02/" class="post-title-link" itemprop="url">Java多线程等待的N种打开方式(2)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-08-12 00:00:00" itemprop="dateCreated datePublished" datetime="2015-08-12T00:00:00+08:00">2015-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-16 15:17:28" itemprop="dateModified" datetime="2021-01-16T15:17:28+08:00">2021-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><code>CountDownLatch</code> 的作用：当一个线程需要另外一个或多个线程完成后，再开始执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>); <span class="comment">//等待2次countdown</span></span><br><span class="line"><span class="keyword">final</span> Thread ta = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  doWork(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">  countDownLatch.countDown();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">final</span> Thread tb = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  doWork(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">  countDownLatch.countDown();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">final</span> Thread tc = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException e1) &#123;</span><br><span class="line">    e1.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  doWork(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">ta.start();</span><br><span class="line">tb.start();</span><br><span class="line">tc.start();</span><br></pre></td></tr></table></figure>
<h3 id="CountDownLatch实现原理"><a href="#CountDownLatch实现原理" class="headerlink" title="CountDownLatch实现原理"></a>CountDownLatch实现原理</h3><p><code>CountDownLatch</code>是通过<code>AQS</code>实现的。 <code>AQS</code> 全称 <code>AbstractQueuedSynchronizer</code>，是 <code>java.util.concurrent</code> 中提供的一种高效且可扩展的同步机制。它可以用来实现依赖 int 状态(<code>state</code>)的同步器，除了<code>CountDownLatch</code>，<code>ReentrantLock</code>、<code>Semaphore</code> 等功能实现都使用了它。</p>
<p>在调用 <code>awit()</code>和<code>countDown()</code>的时候，发生了几个关键的调用关系</p>
<p><img src="https://images2018.cnblogs.com/blog/273364/201806/273364-20180608074920780-931190535.png" alt="img"></p>
<p>首先在 <code>CountDownLatch</code> 类内部定义了一个 <code>Sync</code> 内部类，这个内部类就是继承自 <code>AbstractQueuedSynchronizer</code> 的，并且重写了方法 <code>tryAcquireShared</code>和<code>tryReleaseShared</code>。当调用 <code>awit()</code>方法时，<code>CountDownLatch</code> 会调用内部类<code>Sync</code> 的 <code>acquireSharedInterruptibly()</code> 方法，然后在这个方法中会调用 <code>tryAcquireShared</code> 方法，这个方法就是 <code>CountDownLatch</code> 的内部类 <code>Sync</code> 里重写的 <code>AbstractQueuedSynchronizer</code> 的方法。调用 <code>countDown()</code> 方法同理。</p>
<h4 id="AQS的使用方法"><a href="#AQS的使用方法" class="headerlink" title="AQS的使用方法"></a>AQS的使用方法</h4><p>使用 <code>AbstractQueuedSynchronizer</code> 的标准化方式，大致分为两步：</p>
<ol>
<li><p>内部持有继承自 <code>AbstractQueuedSynchronizer</code> 的对象 <code>Sync</code>；</p>
</li>
<li><p>并在 <code>Sync</code> 内重写 <code>AbstractQueuedSynchronizer</code> 的<code>protected</code> 部分或全部方法，这些方法包括如下几个：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用者可以通过重写这些方法，加入自己的判断逻辑，例如 <code>CountDownLatch</code> 在 <code>tryAcquireShared</code>中加入了判断，判断 <code>state</code> 是否不为0，如果不为0，才符合调用条件。</p>
<ul>
<li><p><code>tryAcquire</code>和<code>tryRelease</code>是对应的，前者是独占模式获取，后者是独占模式释放。</p>
</li>
<li><p><code>tryAcquireShared</code>和<code>tryReleaseShared</code>是对应的，前者是共享模式获取，后者是共享模式释放。</p>
<p><code>CountDownLatch</code> 重写的方法 <code>tryAcquireShared</code> 实现如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断 <code>state</code> 值是否为0，为0 返回1，否则返回 -1。<code>state</code> 值是 <code>AbstractQueuedSynchronizer</code> 类中的一个 <code>volatile</code> 变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure>
<p>在 <code>CountDownLatch</code> 中这个 <code>state</code> 值就是计数器，在调用 <code>await</code> 方法的时候，将值赋给 <code>state</code> 。</p>
<h2 id="等待线程入队"><a href="#等待线程入队" class="headerlink" title="等待线程入队"></a><strong>等待线程入队</strong></h2><p>调用 <code>await()</code> 方法时，先去获取 <code>state</code> 的值，当计数器不为0的时候，说明还有需要等待的线程在运行，则调用 <code>doAcquireSharedInterruptibly</code> 方法，尝试加入等待队列 ，即调用 <code>addWaiter()</code>方法， 源码如下：</p>
<p><strong>AQS 的核心部分</strong>: AQS 用内部的一个 Node 类维护一个 CHL Node FIFO 队列。将当前线程加入等待队列，并通过 <code>parkAndCheckInterrupt（）</code>方法实现当前线程的阻塞。下面一大部分都是在说明 CHL 队列的实现，里面用 CAS 实现队列出入不会发生阻塞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    	<span class="comment">//加入等待队列 				      </span></span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    	<span class="comment">// 进入 CAS 循环</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//当一个节点(关联一个线程)进入等待队列后， 获取此节点的 prev 节点 </span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// 如果获取到的 prev 是 head，也就是队列中第一个等待线程</span></span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// 再次尝试申请 反应到 CountDownLatch 就是查看是否还有线程需要等待(state是否为0)</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="comment">// 如果 r &gt;=0 说明 没有线程需要等待了 state==0</span></span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//尝试将第一个线程关联的节点设置为 head </span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//经过自旋tryAcquireShared后，state还不为0，就会到这里，第一次的时候，waitStatus是0，那么node的waitStatus就会被置为SIGNAL，第二次再走到这里，就会用LockSupport的park方法把当前线程阻塞住</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我看看到上面先执行了 addWaiter() 方法，就是将当前线程加入等待队列，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line"> <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// 尝试快速入队操作，因为大多数时候尾节点不为 null</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//如果尾节点为空(也就是队列为空) 或者尝试CAS入队失败(由于并发原因)，进入enq方法</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面是向等待队列中添加等待者（waiter）的方法。首先构造一个 Node 实体，参数为当前线程和一个mode，这个mode有两种形式，一个是 SHARED ，一个是 EXCLUSIVE，请看上面的代码。然后执行下面的入队操作 addWaiter，和 enq() 方法的 else 分支操作是一样的，这里的操作如果成功了，就不用再进到 enq() 方法的循环中去了，可以提高性能。如果没有成功，再调用 enq() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 死循环+CAS保证所有节点都入队</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="comment">// 如果队列为空 设置一个空节点作为 head</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//加入队尾</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>说明：循环加 CAS 操作是实现乐观锁的标准方式，CAS 是为了实现原子操作而出现的，所谓的原子操作指操作执行期间，不会受其他线程的干扰。Java 实现的 CAS 是调用 unsafe 类提供的方法，底层是调用 c++ 方法，直接操作内存，在 cpu 层面加锁，直接对内存进行操作。</p>
<p>上面是 AQS 等待队列入队方法，操作在无限循环中进行，如果入队成功则返回新的队尾节点，否则一直自旋，直到入队成功。假设入队的节点为 node ，上来直接进入循环，在循环中，先拿到尾节点。</p>
<p>1、if 分支，如果尾节点为 null，说明现在队列中还没有等待线程，则尝试 CAS 操作将头节点初始化，然后将尾节点也设置为头节点，因为初始化的时候头尾是同一个，这和 AQS 的设计实现有关， AQS 默认要有一个虚拟节点。此时，尾节点不在为空，循环继续，进入 else 分支；</p>
<p>2、else 分支，如果尾节点不为 null， node.prev = t ，也就是将当前尾节点设置为待入队节点的前置节点。然后又是利用 CAS 操作，将待入队的节点设置为队列的尾节点，如果 CAS 返回 false，表示未设置成功，继续循环设置，直到设置成功，接着将之前的尾节点（也就是倒数第二个节点）的 next 属性设置为当前尾节点，对应 t.next = node 语句，然后返回当前尾节点，退出循环。</p>
<p>setHeadAndPropagate 方法负责将自旋等待或被 LockSupport 阻塞的线程唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//备份现在的 head</span></span><br><span class="line">        Node h = head;  </span><br><span class="line">    	<span class="comment">//抢到锁的线程被唤醒 将这个节点设置为head</span></span><br><span class="line">        setHead(node)</span><br><span class="line">    	<span class="comment">// propagate 一般都会大于0 或者存在可被唤醒的线程</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="comment">// 只有一个节点 或者是共享模式 释放所有等待线程 各自尝试抢占锁</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Node 对象中有一个属性是 waitStatus ，它有四种状态，分别是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程已被 cancelled ，这种状态的节点将会被忽略，并移出队列</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 表示当前线程已被挂起，并且后继节点可以尝试抢占锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//线程正在等待某些条件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"><span class="comment">//共享模式下 无条件所有等待线程尝试抢占锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h3 id="等待线程被唤醒"><a href="#等待线程被唤醒" class="headerlink" title="等待线程被唤醒"></a><strong>等待线程被唤醒</strong></h3><p>当执行 CountDownLatch 的 countDown（）方法，将计数器减一，也就是state减一，当减到0的时候，等待队列中的线程被释放。是调用 AQS 的 releaseShared 方法来实现的，下面代码中的方法是按顺序调用的，摘到了一起，方便查看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AQS类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// arg 为固定值 1</span></span><br><span class="line">    	<span class="comment">// 如果计数器state 为0 返回true，前提是调用 countDown() 之前不能已经为0</span></span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            <span class="comment">// 唤醒等待队列的线程</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CountDownLatch 重写的方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    		<span class="comment">// 依然是循环+CAS配合 实现计数器减1</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// AQS类</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="comment">// 如果节点状态为SIGNAL，则他的next节点也可以尝试被唤醒</span></span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将节点状态设置为PROPAGATE，表示要向下传播，依次唤醒</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>因为这是共享型的，当计数器为 0 后，会唤醒等待队列里的所有线程，所有调用了 await() 方法的线程都被唤醒，并发执行。这种情况对应到的场景是，有多个线程需要等待一些动作完成，比如一个线程完成初始化动作，其他5个线程都需要用到初始化的结果，那么在初始化线程调用 countDown 之前，其他5个线程都处在等待状态。一旦初始化线程调用了 countDown ，其他5个线程都被唤醒，开始执行。</p>
<h2 id="Lock-condition"><a href="#Lock-condition" class="headerlink" title="Lock.condition"></a>Lock.condition</h2><h2 id="CyclicBarrier循环屏障"><a href="#CyclicBarrier循环屏障" class="headerlink" title="CyclicBarrier循环屏障"></a>CyclicBarrier循环屏障</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, () -&gt; doWork(<span class="string">&quot;C&quot;</span>));</span><br><span class="line"><span class="keyword">final</span> Thread ta = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  doWork(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    cyclicBarrier.await();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">final</span> Thread tb = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  doWork(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    cyclicBarrier.await();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ta.start();</span><br><span class="line">tb.start();</span><br></pre></td></tr></table></figure>
<h2 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line">Thread ta = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    semaphore.acquire();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">    e1.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  doWork(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">  semaphore.release();</span><br><span class="line">&#125;);</span><br><span class="line">Thread tb = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    semaphore.acquire();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">    e1.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  doWork(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">  semaphore.release();</span><br><span class="line">&#125;);</span><br><span class="line">Thread tc = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    semaphore.acquire(<span class="number">2</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">    e1.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  doWork(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">ta.start();</span><br><span class="line">tb.start();</span><br><span class="line">tc.start();</span><br></pre></td></tr></table></figure>
<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, TimeUnit.MINUTES, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;());</span><br><span class="line">Future&lt;Boolean&gt; aFuture = executor.submit(() -&gt; &#123;</span><br><span class="line">  doWork(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line">Future&lt;Boolean&gt; bFuture = executor.submit(() -&gt; &#123;</span><br><span class="line">  doWork(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    aFuture.get();</span><br><span class="line">    bFuture.get();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e1) &#123;</span><br><span class="line">    e1.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  doWork(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LinkedBlockingDeque&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">Thread ta = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  doWork(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">  queue.add(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">Thread tb = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  doWork(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">  queue.add(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">Thread tc = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    queue.take();</span><br><span class="line">    queue.take();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">  doWork(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">ta.start();</span><br><span class="line">tb.start();</span><br><span class="line">tc.start();</span><br></pre></td></tr></table></figure>
<h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><h2 id="ListenableFuture"><a href="#ListenableFuture" class="headerlink" title="ListenableFuture"></a>ListenableFuture</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/">https://docs.oracle.com/javase/8/docs/</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/bigdata/hive/base/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/bigdata/hive/base/" class="post-title-link" itemprop="url">Hive base</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-08-12 00:00:00" itemprop="dateCreated datePublished" datetime="2015-08-12T00:00:00+08:00">2015-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-16 15:17:29" itemprop="dateModified" datetime="2021-01-16T15:17:29+08:00">2021-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="base"><a href="#base" class="headerlink" title="base"></a>base</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/multithread/01.thread-lifecycle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/multithread/01.thread-lifecycle/" class="post-title-link" itemprop="url">线程生命周期</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-08-12 00:00:00" itemprop="dateCreated datePublished" datetime="2015-08-12T00:00:00+08:00">2015-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-16 15:17:28" itemprop="dateModified" datetime="2021-01-16T15:17:28+08:00">2021-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>理解Java多线程, 需要深入理解`线程状态和锁`</code></pre>
<p>[TOC]</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>由于每个时钟周期内, CPU 实际上只能执行一条指令. CPU每一个时刻只能做一件事, 多线程是通过任务调度给CPU分配任务实现的, 多线程的目的是为了最大限度的利用CPU资源.</p>
<p>操作系统负责管理进程和线程, 轮流(没有固定的顺序)分配每个进程很短的时间(不一定是均分), 然后在每个线程内部, 程序代码自己处理该进程内部线程的时间分配, 多个线程之间相互的切换去执行, 这个切换时间也是非常短的.</p>
<h2 id="程序、进程、线程之间的关系"><a href="#程序、进程、线程之间的关系" class="headerlink" title="程序、进程、线程之间的关系"></a>程序、进程、线程之间的关系</h2><ul>
<li>程序是一段静态的代码，是应用软件执行的蓝本。</li>
<li>进程是程序一次动态执行的过程，它对应了从代码加载、执行完毕的一个完整过程，这也是进程开始到消亡的过程。</li>
<li>线程是进程中独立、可调度的执行单元，是执行中最小单位。</li>
<li>一个程序一般是一个进程，但一个程序中也可以有多个进程。</li>
<li>一个进程中可以有多个线程，但只有一个主线程。</li>
<li>Java应用程序中默认的主线程是main方法，如果main方法中创建了其他线程，JVM就会执行其他的线程。</li>
</ul>
<h2 id="Java-进程"><a href="#Java-进程" class="headerlink" title="Java 进程"></a>Java 进程</h2><p>Java编写的程序是运行在JVM中的, 启动一个Java应用程序,  就会启动一个JVM进程. 在同一个JVM进程中, 有且只有一个进程, 就是它自己. 因此, 所有的程序代码的运行都是以线程运行的. 同一个进程中的所有线程共享一块内存块,  <strong>因此线程间通信很容易且速度很快</strong>.</p>
<ul>
<li>Java 中的线程是一个对象, 与其他 Java 中的对象一样, 具有变量和方法, 生死于堆上.</li>
</ul>
<p>调用栈</p>
<ul>
<li>Java 中的每个线程都有一个调用栈, 即使不创建任何新的线程,  线程也在后台运行着.</li>
<li>一旦创建一个新的线程,  就产生一个新的调用栈.</li>
</ul>
<h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><p>在JVM上运行一个应用程序时,  JVM首先寻找程序入口的<code>main()</code>方法,  然后运行<code>main()</code>方法, 此时就产生了一个Java线程, 这个线程就是主线程. 当main方法结束后,  主线程运行完成,  如果不存在额外的线程运行,  JVM进程随即退出.</p>
<p>调度的方式有两种：分时调度和抢占式调度, Java中采用的是<em>抢占式调度</em></p>
<h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static int MAX_PRIORITY</span><br><span class="line">          线程可以具有的最高优先级.</span><br><span class="line">static int MIN_PRIORITY</span><br><span class="line">          线程可以具有的最低优先级.</span><br><span class="line">static int NORM_PRIORITY</span><br><span class="line">          分配给线程的默认优先级.</span><br></pre></td></tr></table></figure>
<p>当线程池中线程都具有相同的优先级, 调度程序的JVM实现自由选择它喜欢的线程. 这时候调度程序的操作有两种可能：<br>一是选择一个线程运行, 直到它阻塞或者运行完成为止.<br>二是时间分片, 为池内的每个线程提供均等的运行机会.</p>
<p>1~10之间的值是没有保证的. 一些JVM可能不能识别10个不同的值, 而将这些优先级进行每两个或多个合并, 变成少于10个的优先级, 则两个或多个优先级的线程可能被映射为一个优先级.</p>
<p>与线程休眠类似, 线程的优先级仍然无法保障线程的执行次序. 只不过, 优先级高的线程获取CPU资源的概率较大, 优先级低的并非没机会执行.</p>
<h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p>创建–运行–中断–死亡</p>
<ul>
<li>创建：线程构造</li>
<li>运行：调用start()方法，进入run()方法</li>
<li>中断：sleep()、wait()</li>
<li>死亡：执行完run()方法或强制run()方法结束，线程死亡</li>
</ul>
<h1 id="线程的状态与转换"><a href="#线程的状态与转换" class="headerlink" title="线程的状态与转换"></a>线程的状态与转换</h1><p><img src="/images/java/multithread/01.base/Java-Thread-statue-01.png" alt="线程生命周期与状态转换"></p>
<h2 id="new与新建状态"><a href="#new与新建状态" class="headerlink" title="new与新建状态"></a>new与新建状态</h2><p>新建线程有两个方法: 继承Thread类 和 实现Runnable接口.</p>
<p>Runnable 接口的定义如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现<code>Runnable</code>接口就需要实现run方法. <code>run</code>方法的内容就是线程要执行的任务.<br>Thread类, 是实现了Runable接口的类, 因此在Thread类中也存在run方法.</p>
<p>新建线程有若干种重载方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由于 Thread 实现了 Runnable 接口,</span></span><br><span class="line"><span class="comment">//这种形式也可以以 Thread 对象为参数</span></span><br></pre></td></tr></table></figure>
<h2 id="start-启动与就绪状态-即可运行状态"><a href="#start-启动与就绪状态-即可运行状态" class="headerlink" title="start 启动与就绪状态(即可运行状态)"></a>start 启动与就绪状态(即可运行状态)</h2><p>调用<code>Thread.start()</code>方法, 该线程进入Runable(可运行)状态, 等待分配 CPU 资源, 当抢占到CPU资源时,<br>该线程启动,开始执行run方法.</p>
<p><code>Thread.start()</code>是唯一可以新建线程的方法. 执行 Thread.run() 和 Runable.run() 只会执行run方法, 不会启动新的线程.</p>
<p>一旦线程启动, 它就永远不能再重新启动. 只有一个新的线程可以被启动, 并且只能一次. 一个可运行的线程或死线程可以被重新启动.</p>
<p>线程的调度是JVM的一部分, 在一个CPU的机器上, 实际上一次只能运行一个线程. 一次只有一个<strong>线程栈</strong>执行. JVM线程调度程序决定实际运行哪个处于可运行状态的线程. 众多可运行线程中的某一个会被选中作为当前线程. 可运行线程被选择运行的顺序是没有保障的. 尽管通常采用队列形式, 但这是没有保障的. 队列形式是指当一个线程完成“一轮”时, 它移到可运行队列的尾部等待, 直到它最终排队到该队列的前端为止, 它才能被再次选中. 事实上, 我们把它称为<em>可运行池</em>而不是一个可运行队列, 目的是帮助认识线程并<em>不都是</em>以某种有保障的顺序排列成一个队列的事实.</p>
<h2 id="Running-运行"><a href="#Running-运行" class="headerlink" title="Running 运行"></a>Running 运行</h2><p>运行状态, 执行<code>run()</code>方法的内容.</p>
<p>当 Java 虚拟机继续执行线程, 直到下面任一情况出现为止:</p>
<ul>
<li>调用 Runtime的 exit 方法 <code>System.exit()</code></li>
<li>非守护线程全部停止运行, 无论是从 <code>run</code> 方法返回还是通过抛出一个传播到 <code>run</code> 方法之外的异常.</li>
</ul>
<p>几种特殊情况可能使线程离开运行状态：</p>
<ol>
<li>线程的<code>run()</code>方法完成.</li>
<li>在对象上调用<code>wait()</code>方法（不是在线程上调用）.</li>
<li>线程不能在对象上获得锁定, 它正试图运行该对象的方法代码.</li>
<li>线程调度程序可以决定将当前运行状态移动到可运行状态, 以便让另一个线程获得运行机会, 而不需要任何理由.</li>
</ol>
<h2 id="sleep-休眠"><a href="#sleep-休眠" class="headerlink" title="sleep() 休眠"></a>sleep() 休眠</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  Thread.sleep();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原始定义</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>
<p>调用 Thread 的静态方法可以进入休眠, sleep()作用：</p>
<ul>
<li>执行带锁的代码时, 不会释放锁</li>
<li>进入Blocked状态</li>
<li>线程在mills时间内不会醒来</li>
<li>mills时间到了, 线程变为<code>Runnable</code>状态</li>
<li>再次进入运行状态, 继续执行 sleep() 后面的代码</li>
</ul>
<p><code>Thread.sleep(long millis)</code>和<code>Thread.sleep(long millis, int nanos)</code>静态方法强制当前正在执行的线程休眠（暂停执行）, 以“减慢线程”.<br>当线程睡眠时, 它入睡在某个地方, 在苏醒之前不会返回到可运行状态. 当睡眠时间到期, 则返回到可运行状态.<br>线程睡眠的原因：线程执行太快, 或者需要强制进入下一轮, 因为Java规范不保证合理的轮换.</p>
<p>当休眠一定时间后, 线程会苏醒, 进入准备状态等待执行.</p>
<h2 id="Blocked-阻塞状态"><a href="#Blocked-阻塞状态" class="headerlink" title="Blocked 阻塞状态"></a>Blocked 阻塞状态</h2><p>阻塞状态是线程因为某种原因放弃CPU使用权, 暂时停止运行. 直到线程进入就绪状态, 才有机会转到运行状态. 阻塞的情况分三种：</p>
<ul>
<li>等待阻塞：运行的线程执行<code>wait()</code>方法, JVM会把该线程放入等待池中.</li>
<li>同步阻塞：运行的线程在获取对象的同步锁时, 若该同步锁被别的线程占用, 则JVM会把该线程放入锁池中.</li>
<li>其他阻塞：运行的线程执行<code>sleep()</code>或<code>join()</code>方法, 或者发出了<code>I/O</code>请求时, JVM会把该线程置为阻塞状态.<pre><code> 当`sleep()`状态超时、`join()`等待线程终止或者超时、或者`I/O`处理完毕时, 线程重新转入就绪状态.</code></pre>
</li>
</ul>
<h2 id="Synchronized锁与同步"><a href="#Synchronized锁与同步" class="headerlink" title="Synchronized锁与同步"></a>Synchronized锁与同步</h2><p><a href="/Java/multithread/01.1.monitor-synchronized/">monitor与synchronized</a></p>
<p>在 Java 中每个对象都有一个锁,(问题来了: Java对象锁信息保存在哪里?) 并且对象的锁同时只能被一个线程使用, 因此当某个线程得到对象的锁时, 其他线程也就没办法获得锁.<br>利用对象的锁, 可以实现只允许一个线程访问, 即同步.</p>
<p>当线程运行到 <code>synchronized</code> 时, 首先检测是否可以获得对象的锁, 如果可以获得,则马上获取锁. 如果不能获取锁, 线程阻塞, 开始等待其他线程释放锁.</p>
<p>当同步锁被释放时, 线程重新进入 Runnable 可运行状态.</p>
<p>需要同步时,一定要搞清楚<code>加锁的对象是什么</code></p>
<p>关于锁和同步, 有一下几个要点：</p>
<ul>
<li>只能同步方法, 而不能同步变量和类；</li>
<li>每个对象只有一个锁；当提到同步时, 应该清楚在什么上同步？也就是说, 在哪个对象上同步？</li>
<li>不必同步类中所有的方法, 类可以同时拥有同步和非同步方法.</li>
<li>线程睡眠(执行<code>sleep</code>)时, 它所持的任何锁都不会释放.</li>
<li>线程可以获得多个锁. 比如, 在一个对象的同步方法里面调用另外一个对象的同步方法, 则获取了两个对象的同步锁.</li>
</ul>
<h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><p>在方法名称前面增加 <code>synchronized</code> 关键字, 此时相当于以类的对象(即<code>this</code>)作为对象锁.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object1)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 <code>object1</code>作为对象锁</p>
<h3 id="同步静态方法"><a href="#同步静态方法" class="headerlink" title="同步静态方法"></a>同步静态方法</h3><ol>
<li><p>静态方法同步是以方法所在的class对象作为锁的.<br> 要同步静态方法, 需要一个用于整个类对象的锁, 这个对象是就是这个类（XXX.class).<br> 例如：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    Xxx.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Xxx.class)&#123;</span><br><span class="line">            Xxx.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 实质上, 线程进入该对象的的一种池中, 必须在那里等待, 直到其锁被释放</p>
</li>
<li><p>调用同一个类中的静态同步方法的线程将彼此阻塞, 它们都是锁定在相同的Class对象上.</p>
</li>
<li><p>静态同步方法和非静态同步方法将永远不会彼此阻塞, 因为静态方法锁定在Class对象上, 非静态方法锁定在该类的对象上.<br>对于非静态字段中可更改的数据, 通常使用非静态方法访问.<br>对于静态字段中可更改的数据, 通常使用静态方法访问.</p>
</li>
</ol>
<p><strong>减少锁定时间</strong></p>
<p>线程同步的目的是为了保护多个线程访问一个资源时对资源的破坏. 线程同步方法是通过锁来实现, 每个对象都有且仅有一个锁, 这个锁与一个特定的对象关联, 线程一旦获取了对象锁, 其他访问该对象的线程就无法再访问该对象的其他同步方法.</p>
<p><strong>synchronized中慎用sleep和yield</strong></p>
<p>在使用<code>synchronized</code>关键字时候, 应该尽可能避免在<code>synchronized</code>方法或<code>synchronized块</code>中使用<code>sleep</code>或者<code>yield</code>方法:<br>因为<code>synchronized</code>程序块占有着对象锁, 你休息那么其他的线程只能一边等着你醒来执行完了才能执行. 不但严重影响效率, 也不合逻辑. 同样, 在同步程序块内调用<code>yield</code>方法让出CPU资源也没有意义, 因为你占用着锁, 其他互斥线程还是无法访问同步程序块. 当然与同步程序块无关的线程可以获得更多的执行时间.</p>
<h2 id="wait-等待-与-notify-notifyAll-通知"><a href="#wait-等待-与-notify-notifyAll-通知" class="headerlink" title="wait 等待 与 notify/notifyAll 通知"></a><code>wait</code> 等待 与 <code>notify</code>/<code>notifyAll</code> 通知</h2><p><code>wait</code> 让本线程等待, <code>notify</code> 通知某个线程不再等待</p>
<p><code>wait()</code>作用主要有:</p>
<ul>
<li>释放锁</li>
<li>不继续执行 wait 后面的代码</li>
<li>本线程进入等待阻塞</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1038007/why-should-wait-always-be-called-inside-a-loop">wait必须与while一起使用:(避免假唤醒)</a></p>
<blockquote>
<p>A thread can also wake up without being notified, interrupted, or timing out, a so-called spurious wakeup. While this will rarely occur in practice, applications must guard against it by testing for the condition that should have caused the thread to be awakened, and continuing to wait if the condition is not satisfied. In other words, waits should always occur in loops, like this one:<br>线程也可以在没有被通知，中断或超时的情况下唤醒，即所谓的虚假唤醒。 虽然这在实践中很少发生，但应用程序必须通过测试应该导致线程被唤醒的条件来防范它，并且如果条件不满足则继续等待。 换句话说，等待应该总是出现在循环中</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!condition) &#123;</span><br><span class="line">     obj.wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>notify</code>()与 <code>notifyAll</code>()<br>针对同一个对象锁上的线程, 主要的作用是:</p>
<ul>
<li>不再等待, 从等待 Blocked 中转出</li>
<li>进入 Runnable 状态, 等待获取 CPU 资源. ??</li>
</ul>
<p><strong>线程唤醒 notify</strong></p>
<p>Object类中的<code>notify()</code>方法, 唤醒在此对象监视器上等待的单个线程. 如果所有线程都在此对象上等待, 则会选择唤醒其中一个线程. 选择是任意性的, 并在对实现做出决定时发生. 线程通过调用其中一个 <code>wait</code> 方法, 在对象的监视器上等待.  直到当前的线程放弃此对象上的锁定, 才能继续执行被唤醒的线程. 被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如, 唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势. 类似的方法还有一个<code>notifyAll()</code>, 唤醒在此对象监视器上等待的所有线程.</p>
<p><code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>都是Object的实例方法. 与每个对象具有锁一样, 每个对象可以有一个<code>线程列表</code>, 他们等待来自该信号（通知）. 线程通过执行对象上的wait()方法获得这个等待列表.</p>
<p>这3个方法<strong>必须处于synchronized代码块或者synchronized方法中</strong>，否则就会抛出IllegalMonitorStateException异常，这是因为这几个方法必须拿到当前对象的监视器monitor对象，也就是说notify/notifyAll和wait方法依赖于monitor对象，</p>
<p><strong>千万注意</strong></p>
<p>当在对象上调用<code>wait()</code>方法时, 执行该代码的线程立即<code>放弃</code>它在对象上的锁. 然而调用<code>notify()</code>时, 并不意味着这时线程会放弃其锁. 如果线程仍然在完成同步代码, 则线程在移出之前不会放弃锁. 因此, 只要调用notify()并不意味着这时该锁变得可用.</p>
<p><code>notifyAll()</code> 方法, 起到的是一个通知作用,<strong>不释放锁, 也不获取锁.</strong> 只是告诉该对象上等待的线程“可以竞争执行了, 都醒来去执行吧”</p>
<h2 id="yield-让步"><a href="#yield-让步" class="headerlink" title="yield() 让步"></a>yield() 让步</h2><ul>
<li>当前线程让出, 进入<code>Runnable可执行状态</code></li>
<li>但是<strong>继续占着锁</strong></li>
<li>同级别或较高级别的开始竞争 CPU 资源</li>
</ul>
<p>Thread.yield()方法作用是：暂停当前正在执行的线程对象, 并执行其他线程.<br>yield()应该做的是让当前运行线程回到可运行状态, 以允许具有相同优先级的其他线程获得运行机会.</p>
<p>yield()从未导致线程转到等待/睡眠/阻塞状态. 在大多数情况下, yield()将导致线程从运行状态转到可运行状态, 但有可能没有效果.</p>
<p>// TODO 使用场景</p>
<h2 id="join-合并"><a href="#join-合并" class="headerlink" title="join() 合并"></a>join() 合并</h2><p>假设在 A 线程中,执行<code>B.join()</code> , B 线程放到 A 线程前面执行. A 线程转入阻塞状态首先执行 B 线程,<br>直到执行完 B 线程后, A 线程转入可运行状态就绪, 获取到 CPU 资源后再继续执行 join 后面的代码</p>
<p>还有 join() 的重载形式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B.join(<span class="number">1000</span>);  </span><br></pre></td></tr></table></figure>
<p>首先执行 B 1000毫秒, 1000毫秒后, 即使是没有执行完, 也会停止执行 B 线程, 开始执行join 语句后面的代码</p>
<p>请看join的原始定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Waits at most &#123;<span class="doctag">@code</span> millis&#125; milliseconds for this thread to</span></span><br><span class="line"><span class="comment">* die. A timeout of &#123;<span class="doctag">@code</span> 0&#125; means to wait forever.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt; This implementation uses a loop of &#123;<span class="doctag">@code</span> this.wait&#125; calls</span></span><br><span class="line"><span class="comment">* conditioned on &#123;<span class="doctag">@code</span> this.isAlive&#125;. As a thread terminates the</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> this.notifyAll&#125; method is invoked. It is recommended that</span></span><br><span class="line"><span class="comment">* applications not use &#123;<span class="doctag">@code</span> wait&#125;, &#123;<span class="doctag">@code</span> notify&#125;, or</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> notifyAll&#125; on &#123;<span class="doctag">@code</span> Thread&#125; instances.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment">*         the time to wait in milliseconds</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">*          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment">*          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment">*          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment">*          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实Join 方法实现是通过wait实现的.<br>当main 线程调用t.join 时候, main 线程会获得线程对象t 的锁 （wait 意味着拿到该对象的锁), 调用该对象的wait( 等待时间) ,直到该对象唤醒main 线程, 比如退出后.</p>
<h2 id="stop-停止"><a href="#stop-停止" class="headerlink" title="stop 停止"></a>stop 停止</h2><p>避免使用stop()，是因为它不安全。它会解除由线程获取的所有锁定，而且如果对象处于一种不连贯状态，那么其他线程能在那种状态下检查和修改它们。结果很难检查出真正的问题所在。</p>
<h2 id="suspend-暂停"><a href="#suspend-暂停" class="headerlink" title="suspend 暂停"></a>suspend 暂停</h2><p>suspend()方法容易发生死锁。调用suspend()的时候，目标线程会停下来，但却仍然持有在这之前获得的锁定。此时，其他任何线程都不能访问锁定的资源，除非被”挂起”的线程恢复运行。对任何线程来说，如果它们想恢复目标线程，同时又试图使用任何一个锁定的资源，就会造成死锁。所以不应该使用suspend()，而应在自己的Thread类中置入一个标志，指出线程应该活动还是挂起。若标志指出线程应该挂起，便用wait()命其进入等待状态。若标志指出线程应当恢复，则用一个notify()重新启动线程。</p>
<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        返回对当前正在执行的线程对象的引用.</span></span><br><span class="line"><span class="function">ClassLoader <span class="title">getContextClassLoader</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        返回该线程的上下文 ClassLoader.</span></span><br><span class="line"><span class="function">Thread.State <span class="title">getState</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        返回该线程的状态.</span></span><br><span class="line"><span class="function">ThreadGroup <span class="title">getThreadGroup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        返回该线程所属的线程组.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">holdsLock</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function">        当且仅当当前线程在指定的对象上保持监视器锁时, 才返回 <span class="keyword">true</span>.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultUncaughtExceptionHandler</span><span class="params">(Thread.UncaughtExceptionHandler eh)</span></span></span><br><span class="line"><span class="function">          设置当线程”由于未捕获到异常而突然终止, 并且没有为该线程定义其他处理程序时”所调用的默认处理程序.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        已过时.</span></span><br><span class="line"><span class="function">        stop 的许多使用都应由只修改某些变量以指示目标线程应该停止运行的代码来取代.</span></span><br><span class="line"><span class="function">        目标线程应定期检查该变量, 并且如果该变量指示它要停止运行,  则从其运行方法依次返回.</span></span><br><span class="line"><span class="function">        如果目标线程等待很长时间（例如基于一个条件变量）,  则应使用 interrupt 方法来中断该等待.</span></span><br></pre></td></tr></table></figure>
<h3 id="线程中断与synchronized"><a href="#线程中断与synchronized" class="headerlink" title="线程中断与synchronized"></a>线程中断与synchronized</h3><p>线程中断</p>
<p>正如中断二字所表达的意义，在线程运行(run方法)中间打断它，在Java中，提供了以下3个有关线程中断的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中断线程（实例方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> Thread.interrupt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断线程是否被中断（实例方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> Thread.isInterrupted();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否被中断并清除当前中断状态（静态方法）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> Thread.interrupted();</span><br></pre></td></tr></table></figure>
<p>当一个线程处于被阻塞状态或者试图执行一个阻塞操作时，使用Thread.interrupt()方式中断该线程，注意此时将会抛出一个InterruptedException的异常，同时中断状态将会被复位(由中断状态改为非中断状态)，如下代码将演示该过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptSleepThread3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//while在try中，通过异常中断就可以退出run循环</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="comment">//当前线程处于阻塞状态，异常必须捕捉处理，无法往外抛出</span></span><br><span class="line">                        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Interruted When Sleep&quot;</span>);</span><br><span class="line">                    <span class="keyword">boolean</span> interrupt = <span class="keyword">this</span>.isInterrupted();</span><br><span class="line">                    <span class="comment">//中断状态被复位</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;interrupt:&quot;</span>+interrupt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//中断处于阻塞状态的线程</span></span><br><span class="line">        t1.interrupt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出结果:</span></span><br><span class="line"><span class="comment">           Interruted When Sleep</span></span><br><span class="line"><span class="comment">           interrupt:false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上述代码所示，我们创建一个线程，并在线程中调用了sleep方法从而使线程进入阻塞状态，启动线程后，调用线程实例对象的interrupt方法中断阻塞异常，并抛出InterruptedException异常，此时中断状态也将被复位。除了阻塞中断的情景，我们还可能会遇到处于运行期且非阻塞的状态的线程，这种情况下，直接调用Thread.interrupt()中断线程是不会得到任响应的，如下代码，将无法中断非阻塞状态下的线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruputThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;未被中断&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出结果(无限执行):</span></span><br><span class="line"><span class="comment">             未被中断</span></span><br><span class="line"><span class="comment">             未被中断</span></span><br><span class="line"><span class="comment">             未被中断</span></span><br><span class="line"><span class="comment">             ......</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然我们调用了interrupt方法，但线程t1并未被中断，因为<strong>处于非阻塞状态的线程需要我们手动进行中断检测并结束程序</strong>，改进后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruputThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="comment">//判断当前线程是否被中断</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.isInterrupted())&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程中断&quot;</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;已跳出循环,线程中断!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">        t1.interrupt();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 输出结果:</span></span><br><span class="line"><span class="comment">            线程中断</span></span><br><span class="line"><span class="comment">            已跳出循环,线程中断!</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一种是当线程处于阻塞状态或者试图执行一个阻塞操作时，我们可以使用实例方法interrupt()进行线程中断，执行中断操作后将会抛出interruptException异常(该异常必须捕捉无法向外抛出)并将中断状态复位，</li>
<li>另外一种是当线程处于运行状态时，我们也可调用实例方法interrupt()进行线程中断，但同时必须手动判断中断状态，并编写中断线程的代码(其实就是结束run方法体的代码)。有时我们在编码时可能需要兼顾以上两种情况，那么就可以如下编写：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//判断当前线程是否已中断,注意interrupted方法是静态的,执行后会对中断状态进行复位</span></span><br><span class="line">    <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上线程的中断操作对于正在等待获取的锁对象的synchronized方法或者代码块并不起作用，也就是对于synchronized来说，<strong>如果一个线程在等待锁，那么结果只有两种，要么它获得这把锁继续执行，要么它就保存等待，即使调用中断线程的方法，也不会生效</strong>。演示代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Created by zejian on 2017/6/2.</span></span><br><span class="line"><span class="comment">* Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedBlocked</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Trying to call f()&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123; <span class="comment">// Never releases lock</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在构造器中创建新线程并启动获取对象锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SynchronizedBlocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//该线程已持有当前实例锁</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                f(); <span class="comment">// Lock acquired by this thread</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//中断判断</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;中断线程!!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SynchronizedBlocked sync = <span class="keyword">new</span> SynchronizedBlocked();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(sync);</span><br><span class="line">        <span class="comment">//启动后调用f()方法,无法获取当前实例锁处于等待状态</span></span><br><span class="line">        t.start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//中断线程,无法生效</span></span><br><span class="line">        t.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在<code>SynchronizedBlocked</code>构造函数中创建一个新线程并启动获取调用f()获取到当前实例锁，由于<code>SynchronizedBlocked</code>自身也是线程，启动后在其run方法中也调用了f()，但由于对象锁被其他线程占用，导致t线程只能等到锁，此时我们调用了<code>t.interrupt();</code>但并不能中断线程。</p>
<h1 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h1><p>线程A当前持有互斥所锁 lock1 ，线程B当前持有互斥锁 lock2 。 接下来，当线程A仍然持有lock1时，它试图获取lock2，因为线程B正持有lock2，因此线程A会阻塞等待线程B对lock2的释放。如果此时线程B在持有lock2的时候，也在试图获取lock1，因为线程A正持有lock1，因此线程B会阻塞等待A对lock1的释放。二者都在等待对方所持有锁的释放，而二者却又都没释放自己所持有的锁，这时二者便会一直阻塞下去。这种情形称为死锁。</p>
<p>规避死锁：</p>
<ol>
<li>只在必要的最短时间内持有锁，考虑使用同步语句块代替整个同步方法；</li>
<li>尽量编写不在同一时刻需要持有多个锁的代码，如果不可避免，则确保线程持有第二个锁的时间尽量短暂；</li>
<li>创建和使用一个大锁来代替若干小锁，并把这个锁用于互斥，而不是用作单个对象的对象级别锁；</li>
</ol>
<h1 id="同步方案"><a href="#同步方案" class="headerlink" title="同步方案"></a>同步方案</h1><p>在需要同步的时候，第一选择应该是synchronized关键字，这是最安全的方式，尝试其他任何方式都是有风险的。尤其在jdK1.5之后，对synchronized同步机制做了很多优化，如：自适应的自旋锁、锁粗化、锁消除、轻量级锁等，使得它的性能明显有了很大的提升。</p>
<p>[volatile][a-volatile] 也是确保可见性的方法之一，但是不能实现原子性</p>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>如果同一个方法内同时有两个或更多线程，则每个线程有自己的局部变量拷贝， 采用 <code>synchronized</code> 修饰符实现的同步机制叫做互斥锁机制，它所获得的锁叫做互斥锁。 每个对象都有一个monitor(锁标记)，当线程拥有这个锁标记时才能访问这个资源，没有锁标记便进入锁池。 任何一个对象系统都会为其创建一个互斥锁，这个锁是为了分配给线程的，防止打断原子操作。每个对象的锁只能分配给一个线程，因此叫做互斥锁。</p>
<p>互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。synchronized 关键字经过编译后，会在同步块的前后分别形成 <code>monitorenter</code> 和 <code>monitorexit</code> <code>这两个字节码指令。根据虚拟机规范的要求，在执行monitorenter</code> 指令时，首先要尝试获取对象的锁，如果获得了锁，把锁的计数器加1，相应地，在执行 <code>monitorexit</code> 指令时会将锁计数器减1，当计数器为0时，锁便被释放了。由于synchronized同步块对同一个线程是可重入的，因此一个线程可以多次获得同一个对象的互斥锁，同样，要释放相应次数的该互斥锁，才能最终释放掉该锁。</p>
<p>当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法? 分几种情况：</p>
<ol>
<li>其他方法前是否加了synchronized关键字，如果没加，则能。</li>
<li>如果这个方法内部调用了wait，则可以进入其他synchronized方法。</li>
<li>如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。</li>
<li>如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。</li>
</ol>
<h1 id="线程安全类"><a href="#线程安全类" class="headerlink" title="线程安全类"></a>线程安全类</h1><p>请查看 <a href="/Java/collection-map/">Java集合</a></p>
<h1 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h1><p>线程总体分两类：用户线程和守候线程.</p>
<p>当所有用户线程执行完毕的时候, JVM自动关闭. 但是守候线程却不独立于JVM, 守候线程一般是由操作系统或者用户自己创建的.</p>
<p>举例来说, JVM的垃圾回收、内存管理等线程都是守护线程.<br>还有就是在做数据库应用时候, 使用的数据库连接池, 连接池本身也包含着很多后台线程, 监控连接个数、超时时间、状态等等.</p>
<h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><p>有一个后台运行的线程,  按照指定的时间执行定时任务. <code>Timer.schedual()</code>方法向后台线程添加定时任务,<br>后台线程按照的既定的时间执行定时任务.</p>
<p>调用<code>Timer.cancel()</code>取消所有已安排的定时任务,  正在的执行的任务不会被取消.</p>
<p>调用构造方法, 后台线程就已经启动.</p>
<hr>
<p>[参考文献]：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/README/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/README/" class="post-title-link" itemprop="url">项目规范</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2015-07-22 00:00:00" itemprop="dateCreated datePublished" datetime="2015-07-22T00:00:00+08:00">2015-07-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-16 15:17:29" itemprop="dateModified" datetime="2021-01-16T15:17:29+08:00">2021-01-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Growth/" itemprop="url" rel="index"><span itemprop="name">Growth</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="wiki-guadazi"><a href="#wiki-guadazi" class="headerlink" title="wiki.guadazi"></a>wiki.guadazi</h1><p>本工程是呱嗒子WIKI <a target="_blank" rel="noopener" href="http://wiki.zhangzuofeng.cn/">http://wiki.zhangzuofeng.cn</a> 的建设项目。项目下的所有文件是WIKI文章的源码。文章以<a target="_blank" rel="noopener" href="http://www.appinn.com/markdown/">markdown</a>格式书写。</p>
<p>2017-04-18</p>
<p>这一天是一生中需要牢记的一次机会，</p>
<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><table>
<thead>
<tr>
<th>目录</th>
<th>备注</th>
<th align="center">文章catagory</th>
</tr>
</thead>
<tbody><tr>
<td>Java</td>
<td>Java通用的文章，如J2SE、Java通用的工具等</td>
<td align="center">Java</td>
</tr>
<tr>
<td>Java/IO</td>
<td>Java IO</td>
<td align="center">Java</td>
</tr>
<tr>
<td>Java/multithread</td>
<td>Java多线程</td>
<td align="center">Java</td>
</tr>
<tr>
<td>JavaWeb</td>
<td>J2EE相关的内容，包括J2EE通用标准和第三方框架，如JSP、Servlet、EJB、Struts2、Spring、Hibernate、MyBatis、Netty等</td>
<td align="center">JavaWeb</td>
</tr>
<tr>
<td>JavaWeb/JSP-Servlet</td>
<td>JSP与Servlet</td>
<td align="center">JavaWeb</td>
</tr>
<tr>
<td>JavaWeb/EJB</td>
<td>EJB</td>
<td align="center">JavaWeb</td>
</tr>
<tr>
<td>JavaWeb/Struts2</td>
<td>Struts2</td>
<td align="center">JavaWeb</td>
</tr>
<tr>
<td>JavaWeb/Spring</td>
<td>Spring相关的内容</td>
<td align="center">JavaWeb</td>
</tr>
<tr>
<td>JavaWeb/Hibernate</td>
<td></td>
<td align="center">JavaWeb</td>
</tr>
<tr>
<td>JavaWeb/MyBatis</td>
<td></td>
<td align="center">JavaWeb</td>
</tr>
<tr>
<td>JavaWeb/Netty</td>
<td></td>
<td align="center">JavaWeb</td>
</tr>
<tr>
<td>web</td>
<td>web前端相关，如Javascript、JQuery、EasyUI等</td>
<td align="center">web</td>
</tr>
<tr>
<td>data-struct</td>
<td>数据结构与算法</td>
<td align="center">DataStruct</td>
</tr>
<tr>
<td>network</td>
<td>计算机网络</td>
<td align="center">Network</td>
</tr>
<tr>
<td>database</td>
<td>数据库</td>
<td align="center">DataBase</td>
</tr>
<tr>
<td>database/MySQL</td>
<td>MySQL数据库</td>
<td align="center">DataBase</td>
</tr>
<tr>
<td>design-pattern</td>
<td>设计模式</td>
<td align="center">DesignPattern</td>
</tr>
<tr>
<td>bigdata</td>
<td>大数据</td>
<td align="center">BigData</td>
</tr>
<tr>
<td>nuecai</td>
<td>面试题与面试经验总结</td>
<td align="center">-</td>
</tr>
<tr>
<td>projects</td>
<td>项目案例分析与设计</td>
<td align="center">projects</td>
</tr>
<tr>
<td>software-engineering</td>
<td>软件工程与项目管理</td>
<td align="center">SoftwareEngineering</td>
</tr>
<tr>
<td>tools</td>
<td>开发工具与小软件的使用</td>
<td align="center">Tools</td>
</tr>
<tr>
<td>images</td>
<td>图片目录，文章引用的图片全部放在该目录下，子目录的结构与文章的目录结构相同</td>
<td align="center">-</td>
</tr>
<tr>
<td>temp</td>
<td>临时文件，默认不会发布到网络上，只是作为临时笔记或文件的备份,可以不遵循hexo规范</td>
<td align="center">-</td>
</tr>
</tbody></table>
<p>此外，两个文件<code>deploy_git.sh</code>和<code>server_deploy.sh</code>为用于部署的shell，**勿动!**不要在网页上编辑。</p>
<h1 id="文章撰写"><a href="#文章撰写" class="headerlink" title="文章撰写"></a>文章撰写</h1><p>所有的文章必须按照固定的规范，即hexo的文章规范。<br>快捷的方法—直接复制同类文件</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/21/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><span class="page-number current">22</span><a class="page-number" href="/page/23/">23</a><a class="extend next" rel="next" href="/page/23/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">aaronzhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">226</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">111</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aaronzhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
