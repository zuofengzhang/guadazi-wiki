<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Guadazi">
<meta property="og:url" content="http://example.com/page/22/index.html">
<meta property="og:site_name" content="Guadazi">
<meta property="og:locale">
<meta property="article:author" content="aaronzhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/22/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Guadazi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Guadazi</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/io/NIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/io/NIO/" class="post-title-link" itemprop="url">Java NIO(占坑)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-04-04 11:28:00" itemprop="dateCreated datePublished" datetime="2016-04-04T11:28:00+08:00">2016-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-04 09:10:28" itemprop="dateModified" datetime="2021-04-04T09:10:28+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="/Java/advanced-engineer-outline/">&lt;&lt; Java高级软件工程师知识结构</a></p>
<ol>
<li>掌握InputStream、OutputStream、Reader、Writer的继承体系. </li>
<li>掌握字节流(FileInputStream、DataInputStream、BufferedInputStream、FileOutputSteam、DataOutputStream、BufferedOutputStream)和 字符流(BufferedReader、InputStreamReader、FileReader、BufferedWriter、OutputStreamWriter、PrintWriter、FileWriter), 并熟练运用. </li>
<li>掌握NIO实现原理及使用方法. </li>
</ol>
<p>Java IO包括:</p>
<ul>
<li><a href="/Java/io/IO-Model/">IO Model</a></li>
<li><a href="/Java/io/BIO/">Java BIO</a></li>
<li><a href="/Java/io/NIO/">Java NIO</a></li>
<li><a href="/Java/io/AIO/">Java AIO</a></li>
<li><a href="/Java/io/java-zip/">Java压缩</a></li>
<li><a href="/Java/io/object-serialization/">Java序列化</a></li>
<li><a href="/Java/io/java-XML-JSON/">Java XML与JSON</a></li>
</ul>
<pre><code>感谢`蔡毅`同学对NIO与AIO的深入研究</code></pre>
<p>文后的参考文献 <a target="_blank" rel="noopener" href="http://blog.csdn.net/kunluntaishan/article/details/53536386"> <strong>Java NIO浅析</strong> </a> 需要重点关注</p>
<p><a target="_blank" rel="noopener" href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">Doug Lea《scalable IO in Java》</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/fxjwind/p/3363329.html">中文解读</a></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>新的输入/输出(NIO)库是在JDK 1.4中引入的. NIO弥补了原来的I/O的不足, 它在标准java中提供了高速的、面向块的I/O.<br>   NIO与 <a href="/Java/io/BIO/">BIO</a> 最重要的区别是数据打包和传输的方式的不同, 原来的 I/O 以流 的方式处理数据, 而 NIO 以块 的方式处理数据.  <br>   面向流的I/O系统一次一个字节地处理数据. 一个输入流产生一个字节的数据, 一个输出流消费一个字节的数据. 为流式数据创建过滤器非常容易. 链接几个过滤器, 以便每个过滤器只负责单个复杂处理机制的一部分, 这样也是相对简单的. 不利的一面是, 面向流的I/O通常相当慢.  <br>   NIO与 <a href="/Java/io/BIO/">BIO</a> 有同样的作用和目的, 但是它使用块I/O的处理方式. 每一个操作都在一步中产生或者消费一个数据块. 按块处理数据比按(流式的)字节处理数据要快得多. 但是面向块的I/O缺少一些面向流的I/O所具有的优雅性和简单性. </p>
<p> </p>
<p>从一个例子开始 <br>     下面我们从一个简单的使用IO和NIO读取一个文件中的内容为例, 来进入NIO的学习之旅.<br>     使用IO来读取指定文件中的前1024字节并打印出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 使用IO读取指定文件的前1024个字节的内容.  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> file 指定文件名称.  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> java.io.IOException IO异常.  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ioRead</span><span class="params">(String file)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line"> FileInputStream in = <span class="keyword">new</span> FileInputStream(file);  </span><br><span class="line"> <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];  </span><br><span class="line"> in.read(b);  </span><br><span class="line"> System.out.println(<span class="keyword">new</span> String(b));  </span><br><span class="line">&#125;  </span><br><span class="line">​</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 使用NIO读取指定文件的前1024个字节的内容.  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> file 指定文件名称.  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> java.io.IOException IO异常.  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nioRead</span><span class="params">(String file)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line"> FileInputStream in = <span class="keyword">new</span> FileInputStream(file);  </span><br><span class="line"> FileChannel channel = in.getChannel();  </span><br><span class="line"> ​</span><br><span class="line"> ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);  </span><br><span class="line"> channel.read(buffer);  </span><br><span class="line"> <span class="keyword">byte</span>[] b = buffer.array();  </span><br><span class="line"> System.out.println(<span class="keyword">new</span> String(b));  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>从上面的例子中可以看出, NIO以 <code>通道Channel</code> 和 <code>缓冲区Buffer</code> 为基础来实现面向块的IO数据处理. 下面将讨论并学习NIO 库的核心概念以及从高级的特性到底层编程细节的几乎所有方面. </p>
<h1 id="核心概念：通道和缓冲区"><a href="#核心概念：通道和缓冲区" class="headerlink" title="核心概念：通道和缓冲区"></a>核心概念：通道和缓冲区</h1><p>通道和缓冲区是NIO中的核心对象, 几乎在每一个I/O操作中都要使用它们</p>
<ul>
<li>通道Channel 是对原I/O包中的流的模拟. 到任何目的地(或来自任何地方)的所有数据都必须通过一个Channel对象. </li>
<li>缓冲区Buffer 实质上是一个容器对象. 发送给一个通道的所有对象都必须首先放到缓冲区中；同样地, 从通道中读取的任何数据都要读到缓冲区中</li>
</ul>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>Buffer是一个容器对象, 它包含一些要写入或者刚读出的数据. 在NIO中加入Buffer对象, 体现了新库与原I/O的一个重要区别. 在面向流的I/O中, 您将数据直接写入或者将数据直接读到Stream对象中；<br>在NIO库中, 所有数据都是用缓冲区处理的. 在读取数据时, 它是直接读到缓冲区中的. 在写入数据时, 它是写入到缓冲区中的. 任何时候访问NIO中的数据, 您都是将它放到缓冲区中.  <br>缓冲区实质上是一个数组. 通常它是一个字节数组, 但是也可以使用其他种类的数组. 但是一个缓冲区不仅仅是一个数组. 缓冲区提供了对数据的结构化访问, 而且还可以跟踪系统的读/写进程.  </p>
<p>最常用的缓冲区类型是 <code>ByteBuffer</code> .  一个ByteBuffer可以在其底层字节数组上进行get/set操作(即字节的获取和设置).  <br>ByteBuffer不是NIO中唯一的缓冲区类型. 事实上, 对于每一种基本Java类型都有一种缓冲区类型：</p>
<ul>
<li><code>ByteBuffer</code></li>
<li><code>CharBuffer</code></li>
<li><code>ShortBuffer</code></li>
<li><code>IntBuffer</code></li>
<li><code>LongBuffer</code></li>
<li><code>FloatBuffer</code></li>
<li><code>DoubleBuffer</code></li>
</ul>
<p>每一个Buffer类都是Buffer接口的一个实例.  除了ByteBuffer,  每一个Buffer类都有完全一样的操作, 只是它们所处理的数据类型不一样. 因为大多数标准I/O操作都使用 ByteBuffer , 所以它具有所有共享的缓冲区操作以及一些特有的操作. </p>
<p>下面的例子使用类型化的缓冲区<code>FloatBuffer</code>的一个应用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个容量为10的新的 float 缓冲区  </span></span><br><span class="line">FloatBuffer buffer = FloatBuffer.allocate(<span class="number">10</span>);  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;  </span><br><span class="line">  <span class="keyword">float</span> f = (<span class="keyword">float</span>) Math.sin((((<span class="keyword">float</span>) i) / <span class="number">10</span>) * (<span class="number">2</span> * Math.PI));  </span><br><span class="line">  buffer.put(f);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 反转此缓冲区  </span></span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="comment">// 告知在当前位置和限制之间是否有元素  </span></span><br><span class="line"><span class="keyword">while</span> (buffer.hasRemaining()) &#123;  </span><br><span class="line">  <span class="keyword">float</span> f = buffer.get();  </span><br><span class="line">  System.out.println(f);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><p><code>Channel</code>是对原I/O包中的流的模拟, 可以通过它读取和写入数据. 通道就像流, 所有数据都通过<code>Buffer</code>对象来处理. 您永远不会将字节直接写入通道中, 相反, 是将数据写入包含一个或者多个字节的缓冲区. 同样, 您不会直接从通道中读取字节, 而是将数据从通道 读入缓冲区, 再从缓冲区获取这个字节</p>
<p>**通道与流的不同之处在于通道是双向的. ** 而流只是在一个方向上移动(一个流必须是InputStream或者OutputStream的子类),  而通道可以用于读、写或者同时用于读写. 因为它们是双向的, 所以通道可以比流更好地反映底层操作系统的真实情况. 特别是在UNIX模型中, 底层操作系统通道是双向的. </p>
<h1 id="从理论到实践：NIO中的读和写"><a href="#从理论到实践：NIO中的读和写" class="headerlink" title="从理论到实践：NIO中的读和写"></a>从理论到实践：NIO中的读和写</h1><p>读和写是I/O的基本过程. 从一个通道中读取很简单：只需创建一个缓冲区, 然后让通道将数据读到这个缓冲区中. 写入也相当简单：创建一个缓冲区, 用数据填充它, 然后让通道用这些数据来执行写入操作.  </p>
<h2 id="从文件中读取"><a href="#从文件中读取" class="headerlink" title="从文件中读取"></a>从文件中读取</h2><p>首先从FileInputStream获取一个FileChannel对象, 然后使用这个通道来读取数据.  </p>
<p>在NIO系统中, 任何时候执行一个读操作, 您都是从通道中读取, 但是您不是直接从通道读取. 因为所有数据最终都驻留在缓冲区中, 所以您是从通道读到缓冲区中</p>
<p>   因此读取文件涉及三个步骤：</p>
<p>  (1) 从 FileInputStream 获取 Channel<br>  (2) 创建 Buffer<br>  (3) 将数据从 Channel 读到 Buffer 中</p>
<p>现在, 让我们看一下这个过程. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步是获取通道. 从 FileInputStream 获取通道：</span></span><br><span class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream( <span class="string">&quot;readandshow.txt&quot;</span> );  </span><br><span class="line">FileChannel fc = fin.getChannel();  </span><br><span class="line"><span class="comment">// 下一步是创建缓冲区：</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );  </span><br><span class="line"><span class="comment">// 最后, 需要将数据从通道读到缓冲区中：</span></span><br><span class="line">fc.read( buffer );  </span><br></pre></td></tr></table></figure>
<p>不需要告诉通道要读多少数据到缓冲区中. 每一个缓冲区都有复杂的内部统计机制, 它会跟踪已经读了多少数据以及还有多少空间可以容纳更多的数据. </p>
<h2 id="写入文件："><a href="#写入文件：" class="headerlink" title="写入文件："></a>写入文件：</h2><p>在 NIO 中写入文件类似于从文件中读取. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先从 FileOutputStream 获取一个通道：</span></span><br><span class="line">FileOutputStream fout = <span class="keyword">new</span> FileOutputStream( <span class="string">&quot;writesomebytes.txt&quot;</span> );  </span><br><span class="line">FileChannel fc = fout.getChannel();  </span><br><span class="line"><span class="comment">// 下一步是创建一个缓冲区并在其中放入一些数据, 这里, 用message来表示一个持有数据的数组. </span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; message.length; ++i) &#123;  </span><br><span class="line">  buffer.put( message[i] );  </span><br><span class="line">&#125;  </span><br><span class="line">buffer.flip();  </span><br><span class="line"> <span class="comment">// 最后一步是从缓冲区写入通道中：</span></span><br><span class="line">fc.write( buffer );  </span><br></pre></td></tr></table></figure>
<h2 id="读写结合"><a href="#读写结合" class="headerlink" title="读写结合"></a>读写结合</h2><p>将一个文件的所有内容拷贝到另一个文件中. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 将一个文件的所有内容拷贝到另一个文件中. ​</span></span><br><span class="line"><span class="comment">* 执行三个基本操作： </span></span><br><span class="line"><span class="comment">* 首先创建一个 Buffer, 然后从源文件中将数据读到这个缓冲区中, </span></span><br><span class="line"><span class="comment">* 然后将缓冲区写入目标文件.  </span></span><br><span class="line"><span class="comment">* 程序不断重复 — 读、写、读、写 — 直到源文件结束.  </span></span><br><span class="line"><span class="comment">*  ​</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line">String infile = <span class="string">&quot;C:\\copy.sql&quot;</span>;  </span><br><span class="line">String outfile = <span class="string">&quot;C:\\copy.txt&quot;</span>;  </span><br><span class="line">​</span><br><span class="line"><span class="comment">// 获取源文件和目标文件的输入输出流  </span></span><br><span class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream(infile);  </span><br><span class="line">FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(outfile);  </span><br><span class="line">​</span><br><span class="line"><span class="comment">// 获取输入输出通道  </span></span><br><span class="line">FileChannel fcin = fin.getChannel();  </span><br><span class="line">FileChannel fcout = fout.getChannel();  </span><br><span class="line">​</span><br><span class="line"><span class="comment">// 创建缓冲区  </span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);  </span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">  <span class="comment">// clear方法重设缓冲区, 使它可以接受读入的数据  </span></span><br><span class="line">  buffer.clear();  </span><br><span class="line">  ​</span><br><span class="line">  <span class="comment">// 从输入通道中将数据读到缓冲区  </span></span><br><span class="line">  <span class="keyword">int</span> r = fcin.read(buffer);  </span><br><span class="line">  ​</span><br><span class="line">  <span class="comment">// read方法返回读取的字节数, 可能为零, </span></span><br><span class="line">  <span class="comment">// 如果该通道已到达流的末尾, 则返回-1  </span></span><br><span class="line">  <span class="keyword">if</span> (r == -<span class="number">1</span>) &#123;  </span><br><span class="line">    <span class="keyword">break</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  ​</span><br><span class="line">  <span class="comment">// flip方法让缓冲区可以将新读入的数据写入另一个通道  </span></span><br><span class="line">  buffer.flip();  </span><br><span class="line">  ​</span><br><span class="line">  <span class="comment">// 从输出通道中将数据写入缓冲区  </span></span><br><span class="line">  fcout.write(buffer);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h1 id="缓冲区内部实现"><a href="#缓冲区内部实现" class="headerlink" title="缓冲区内部实现"></a>缓冲区内部实现</h1><p>每一个缓冲区都有复杂的内部统计机制, 它会跟踪已经读了多少数据以及还有多少空间可以容纳更多的数据, 以便我们对缓冲区的操作. </p>
<p>本节介绍两个重要的缓冲区组件：状态变量和访问方法. 虽然NIO的内部统计机制初看起来可能很复杂, 但是您很快就会看到大部分的实际工作都已经替您完成了. 您只需像平时使用字节数组和索引变量一样进行操作即可. </p>
<h2 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h2><p>状态变量是”内部统计机制”的关键.  每一个读/写操作都会改变缓冲区的状态. 通过记录和跟踪这些变化, 缓冲区就能够管理内部地自己的资源. </p>
<p>每一种Java基本类型的缓冲区都是抽象类Buffer的子类, 从Buffer的源代码中可以发现, 它定义了三个私有属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> limit;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;  </span><br></pre></td></tr></table></figure>
<p>实际上, 这三个属性值可以指定缓冲区在任意时刻的状态和它所包含的数据.<br>我们知道, 每一个基本类型的缓冲区底层实际上就是一个该类型的数组. 如在ByteBuffer中, 有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] hb;  </span><br></pre></td></tr></table></figure>
<p>在从通道读取时, 所读取的数据将放被到底层的数组中；同理, 向通道中写入时, 将从底层数组中将数据写入通道. 下面我们来具体介绍这三个变量的作用：</p>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>position变量跟踪了向缓冲区中写入了多少数据或者从缓冲区中读取了多少数据.<br>更确切的说, 当您从通道中读取数据到缓冲区中时, 它指示了下一个数据将放到数组的哪一个元素中. 比如, 如果您从通道中读三个字节到缓冲区中, 那么缓冲区的position将会设置为3, 指向数组中第4个元素. 反之, 当您从缓冲区中获取数据进行写通道时, 它指示了下一个数据来自数组的哪一个元素. 比如, 当您从缓冲区写了5个字节到通道中, 那么缓冲区的 position 将被设置为5, 指向数组的第六个元素. </p>
<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>limit变量表明还有多少数据需要取出(在从缓冲区写入通道时), 或者还有多少空间可以放入数据(在从通道读入缓冲区时).<br>position总是小于或者等于limit. </p>
<h3 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h3><p>capacity变量表明可以储存在缓冲区中的最大数据容量. 实际上, 它指定了底层数组的大小—或者至少是指定了准许我们使用的底层数组的容量.  <br>limit总是小于或者等于capacity. </p>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>下面我们就以数据从一个输入通道拷贝到一个输出通道为例, 来详细分析每一个变量, 并说明它们是如何协同工作的：</p>
<p>初始变量： </p>
<p>我们首先观察一个新创建的缓冲区, 以ByteBuffer为例, 假设缓冲区的大小为8个字节, ByteBuffer初始状态如下：</p>
<p><img src="/images/java/io/NIO/01.gif" alt="NIO缓冲区内部实现机制"></p>
<p>回想一下 , limit决不能大于capacity, 此例中这两个值都被设置为8. 我们通过将它们指向数组的尾部之后(第8个槽位)来说明这点. </p>
<p><img src="/images/java/io/NIO/02.gif" alt="NIO缓冲区内部实现机制"></p>
<p>我们再将position设置为0. 表示如果我们读一些数据到缓冲区中, 那么下一个读取的数据就进入 slot 0. 如果我们从缓冲区写一些数据, 从缓冲区读取的下一个字节就来自slot 0. position设置如下所示：</p>
<p><img src="/images/java/io/NIO/03.gif" alt="NIO缓冲区内部实现机制"></p>
<p>由于缓冲区的最大数据容量capacity不会改变, 所以我们在下面的讨论中可以忽略它. </p>
<p>第一次读取： <br>   现在我们可以开始在新创建的缓冲区上进行读/写操作了. 首先从输入通道中读一些数据到缓冲区中. 第一次读取得到三个字节. 它们被放到数组中从position开始的位置, 这时position被设置为0. 读完之后, position就增加到了3, 如下所示, limit没有改变. </p>
<p><img src="/images/java/io/NIO/04.gif" alt="NIO缓冲区内部实现机制"></p>
<p>第二次读取： <br>   在第二次读取时, 我们从输入通道读取另外两个字节到缓冲区中. 这两个字节储存在由position所指定的位置上,  position因而增加2, limit没有改变. </p>
<p><img src="/images/java/io/NIO/05.gif" alt="NIO缓冲区内部实现机制"></p>
<p>flip： <br>   现在我们要将数据写到输出通道中. 在这之前, 我们必须调用flip()方法.  其源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	limit = position;  </span><br><span class="line">	position = <span class="number">0</span>;  </span><br><span class="line">	mark = -<span class="number">1</span>;  </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p>   这个方法做两件非常重要的事：<br>   i  将limit设置为当前position.<br>   ii 将position设置为0. </p>
<p>   上一个图显示了在flip之前缓冲区的情况. 下面是在flip之后的缓冲区：</p>
<p><img src="/images/java/io/NIO/06.gif" alt="NIO缓冲区内部实现机制"></p>
<p>   我们现在可以将数据从缓冲区写入通道了. position被设置为0, 这意味着我们得到的下一个字节是第一个字节. limit已被设置为原来的position, 这意味着它包括以前读到的所有字节, 并且一个字节也不多.<br>第一次写入： <br>   在第一次写入时, 我们从缓冲区中取四个字节并将它们 写入输出通道. 这使得position增加到4, 而limit不变, 如下所示：</p>
<p><img src="/images/java/io/NIO/07.gif" alt="NIO缓冲区内部实现机制"></p>
<p>第二次写入： <br>   我们只剩下一个字节可写了. limit在我们调用flip()时被设置为5, 并且position不能超过limit.  所以最后一次写入操作从缓冲区取出一个字节并将它写入输出通道. 这使得position增加到5, 并保持limit不变, 如下所示：</p>
<p><img src="/images/java/io/NIO/08.gif" alt="NIO缓冲区内部实现机制"></p>
<p>clear： <br>   最后一步是调用缓冲区的clear()方法. 这个方法重设缓冲区以便接收更多的字节. 其源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	position = <span class="number">0</span>;  </span><br><span class="line">	limit = capacity;  </span><br><span class="line">	mark = -<span class="number">1</span>;  </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p>clear做两种非常重要的事情：</p>
<p>i 将limit设置为与capacity相同.  <br>ii 设置position为0.  </p>
<p>下图显示了在调用clear()后缓冲区的状态,  此时缓冲区现在可以接收新的数据了. </p>
<p><img src="/images/java/io/NIO/09.gif" alt="NIO缓冲区内部实现机制"></p>
<p> </p>
<h2 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h2><p>程序需要直接处理数据. 例如, 您可能需要将用户数据保存到磁盘. 在这种情况下, 您必须将这些数据直接放入缓冲区, 然后用通道将缓冲区写入磁盘.  或者, 您可能想要从磁盘读取用户数据. 在这种情况下, 您要将数据从通道读到缓冲区中, 然后检查缓冲区中的数据.  <br>   实际上, 每一个基本类型的缓冲区都为我们提供了直接访问缓冲区中数据的方法, 我们以ByteBuffer为例, 分析如何使用其提供的get()和put()方法直接访问缓冲区中的数据. </p>
<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>   ByteBuffer类中有四个get()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="function">ByteBuffer <span class="title">get</span><span class="params">( <span class="keyword">byte</span> dst[] )</span></span>;  </span><br><span class="line"><span class="function">ByteBuffer <span class="title">get</span><span class="params">( <span class="keyword">byte</span> dst[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length )</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">byte</span> <span class="title">get</span><span class="params">( <span class="keyword">int</span> index )</span></span>;</span><br></pre></td></tr></table></figure>
<p>   第一个方法获取单个字节. 第二和第三个方法将一组字节读到一个数组中. 第四个方法从缓冲区中的特定位置获取字节. 那些返回ByteBuffer的方法只是返回调用它们的缓冲区的this值.  <br>   前三个get()方法是相对的, 而最后一个方法是绝对的. “相对”意味着get()操作服从limit和position值, 更明确地说, 字节是从当前position读取的, 而position在get之后会增加. 另一方面, 一个“绝对”方法会忽略limit和position值, 也不会影响它们. 事实上, 它完全绕过了缓冲区的统计方法.  </p>
<p>上面列出的方法对应于ByteBuffer类. 其他类有等价的get()方法, 这些方法除了不是处理字节外, 其它方面是是完全一样的, 它们处理的是与该缓冲区类相适应的类型. </p>
<h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><p>   ByteBuffer类中有五个put()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ByteBuffer <span class="title">put</span><span class="params">( <span class="keyword">byte</span> b )</span></span>;  </span><br><span class="line"><span class="function">ByteBuffer <span class="title">put</span><span class="params">( <span class="keyword">byte</span> src[] )</span></span>;  </span><br><span class="line"><span class="function">ByteBuffer <span class="title">put</span><span class="params">( <span class="keyword">byte</span> src[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length )</span></span>;  </span><br><span class="line"><span class="function">ByteBuffer <span class="title">put</span><span class="params">( ByteBuffer src )</span></span>;  </span><br><span class="line"><span class="function">ByteBuffer <span class="title">put</span><span class="params">( <span class="keyword">int</span> index, <span class="keyword">byte</span> b )</span></span>;</span><br></pre></td></tr></table></figure>
<p>   第一个方法 写入（put）单个字节. 第二和第三个方法写入来自一个数组的一组字节. 第四个方法将数据从一个给定的源ByteBuffer写入这个ByteBuffer. 第五个方法将字节写入缓冲区中特定的 位置 . 那些返回ByteBuffer的方法只是返回调用它们的缓冲区的this值.  <br>   与get()方法一样, 我们将把put()方法划分为“相对”或者“绝对”的. 前四个方法是相对的, 而第五个方法是绝对的.  <br>   上面显示的方法对应于ByteBuffer类. 其他类有等价的put()方法, 这些方法除了不是处理字节之外, 其它方面是完全一样的. 它们处理的是与该缓冲区类相适应的类型.  </p>
<h3 id="类型化的-get-和-put-方法"><a href="#类型化的-get-和-put-方法" class="headerlink" title="类型化的 get() 和 put() 方法"></a>类型化的 get() 和 put() 方法</h3><p>   除了前些小节中描述的get()和put()方法,  ByteBuffer还有用于读写不同类型的值的其他方法, 如下所示</p>
<p> -  <code>getByte()</code><br> -  <code>getChar()</code><br> -  <code>getShort()</code><br> -  <code>getInt()</code><br> -  <code>getLong()</code><br> -  <code>getFloat()</code><br> -  <code>getDouble()</code><br> -  <code>putByte()</code><br> -  <code>putChar()</code><br> -  <code>putShort()</code><br> -  <code>putInt()</code><br> -  <code>putLong()</code><br> -  <code>putFloat()</code><br> -  <code>putDouble()</code></p>
<p>   事实上, 这其中的每个方法都有两种类型：一种是相对的, 另一种是绝对的. 它们对于读取格式化的二进制数据（如图像文件的头部）很有用. </p>
<p> </p>
<h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>   下面的内部循环概括了使用缓冲区将数据从输入通道拷贝到输出通道的过程. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line"> buffer.clear();  </span><br><span class="line"> <span class="keyword">int</span> r = fcin.read( buffer );  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (r==-<span class="number">1</span>) &#123;  </span><br><span class="line"> 	<span class="keyword">break</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line"> buffer.flip();  </span><br><span class="line"> fcout.write( buffer );  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>   read()和write()调用得到了极大的简化, 因为许多工作细节都由缓冲区完成了. clear()和flip()方法用于让缓冲区在读和写之间切换. </p>
<h1 id="连网和异步IO"><a href="#连网和异步IO" class="headerlink" title="连网和异步IO"></a>连网和异步IO</h1><p>连网是学习异步I/O的很好基础, 而异步I/O对于在Java语言中执行任何输入/输出过程的人来说, 无疑都是必须具备的知识. NIO中的连网与NIO中的其他任何操作没有什么不同, 它依赖通道和缓冲区, 而您通常使用InputStream和OutputStream来获得通道. </p>
<h2 id="异步-I-O"><a href="#异步-I-O" class="headerlink" title="异步 I/O"></a>异步 I/O</h2><p>   异步I/O是一种“没有阻塞地读写数据”的方法. 通常, 在代码进行read()调用时, 代码会阻塞直至有可供读取的数据. 同样,  write()调用将会阻塞直至数据能够写入.  但异步I/O调用不会阻塞. 相反, 您可以注册对特定I/O事件的兴趣：如可读的数据的到达、新的套接字连接等等, 而在发生这样的事件时, 系统将会告诉您.  <br>   异步I/O的一个优势在于, 它允许您同时根据大量的输入和输出执行I/O. 同步程序常常要求助于轮询, 或者创建许许多多的线程以处理大量的连接. 使用异步I/O, 您可以监听任何数量的通道上的事件, 不用轮询, 也不用额外的线程.<br>   我们来看一个基于非阻塞I/O的服务器端的处理流程, 它接受网络连接并向它们echo它们可能发送的数据. 在这里假设它能同时监听多个端口, 并处理来自所有这些端口的连接. 下面是其主方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span> <span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">  <span class="comment">// 创建一个新的选择器  </span></span><br><span class="line">  Selector selector = Selector.open();  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开在每个端口上的监听, 并向给定的选择器注册此通道接受客户端连接的I/O事件.   </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ports.length; i++) &#123;  </span><br><span class="line">    <span class="comment">// 打开服务器套接字通道  </span></span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();  </span><br><span class="line">    <span class="comment">// 设置此通道为非阻塞模式  </span></span><br><span class="line">    ssc.configureBlocking(<span class="keyword">false</span>);  </span><br><span class="line">    <span class="comment">// 绑定到特定地址  </span></span><br><span class="line">    ServerSocket ss = ssc.socket();  </span><br><span class="line">    InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(ports[i]);  </span><br><span class="line">    ss.bind(address);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向给定的选择器注册此通道的接受连接事件  </span></span><br><span class="line">    ssc.register(selector, SelectionKey.OP_ACCEPT);  </span><br><span class="line">    System.out.println(<span class="string">&quot;Going to listen on &quot;</span> + ports[i]);  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">    <span class="comment">// 这个方法会阻塞, 直到至少有一个已注册的事件发生.   </span></span><br><span class="line">    <span class="comment">// 当一个或者更多的事件发生时, 此方法将返回所发生的事件的数量.   </span></span><br><span class="line">    <span class="keyword">int</span> num = selector.select();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代所有的选择键, 以处理特定的I/O事件.   </span></span><br><span class="line">    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();  </span><br><span class="line">    Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();  </span><br><span class="line"></span><br><span class="line">    SocketChannel sc;  </span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;  </span><br><span class="line">      SelectionKey key = iter.next();  </span><br><span class="line">      <span class="keyword">if</span> ((key.readyOps() </span><br><span class="line">      &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) &#123;  </span><br><span class="line">        <span class="comment">// 接受服务器套接字撒很能够传入的新的连接, 并处理接受连接事件.   </span></span><br><span class="line">        ServerSocketChannel ssc = (ServerSocketChannel) key.channel();  </span><br><span class="line">        sc = ssc.accept();  </span><br><span class="line">        <span class="comment">// 将新连接的套接字通道设置为非阻塞模式  </span></span><br><span class="line">        sc.configureBlocking(<span class="keyword">false</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接受连接后, 在此通道上从新注册读取事件, 以便接收数据.   </span></span><br><span class="line">        sc.register(selector, SelectionKey.OP_READ);  </span><br><span class="line">        <span class="comment">// 删除处理过的选择键  </span></span><br><span class="line">        iter.remove();  </span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Got connection from &quot;</span> + sc);  </span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((key.readyOps() </span><br><span class="line">      &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ) &#123;  </span><br><span class="line">          <span class="comment">// 处理读取事件, 读取套接字通道中发来的数据.   </span></span><br><span class="line">          sc = (SocketChannel) key.channel();  </span><br><span class="line"></span><br><span class="line">          <span class="comment">// 读取数据  </span></span><br><span class="line">          <span class="keyword">int</span> bytesEchoed = <span class="number">0</span>;  </span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">            echoBuffer.clear();  </span><br><span class="line">            <span class="keyword">int</span> r = sc.read(echoBuffer);  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r == -<span class="number">1</span>) &#123;  </span><br><span class="line">              <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            echoBuffer.flip();  </span><br><span class="line">            sc.write(echoBuffer);  </span><br><span class="line"></span><br><span class="line">            bytesEchoed += r;  </span><br><span class="line">          &#125;  </span><br><span class="line">          System.out.println(<span class="string">&quot;Echoed &quot;</span> + bytesEchoed + <span class="string">&quot; from &quot;</span> + sc);  </span><br><span class="line">          <span class="comment">// 删除处理过的选择键  </span></span><br><span class="line">          iter.remove();  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3)    Selectors</p>
<p>Selector是异步<code>I/O</code>中的核心对象. Selector就是注册对各种<code>I/O</code>事件的兴趣的地方, 而且当那些事件发生时, 就是这个对象告诉您所发生的事件. 所以, 我们需要做的第一件事就是创建一个Selector：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();  </span><br></pre></td></tr></table></figure>
<p>然后, 我们将对不同的通道对象调用<code>register()</code>方法, 以便注册我们对这些对象中发生的I/O事件的兴趣. <code>register()</code>的第一个参数就是这个Selector对象.  </p>
<p>4)    打开一个<code>ServerSocketChannel</code></p>
<p>在服务端为了接收连接, 我们需要一个<code>ServerSocketChannel</code>.  事实上, 我们要监听的每一个端口都需要有一个<code>ServerSocketChannel</code>. 对于每一个端口, 我们打开一个<code>ServerSocketChannel</code>,  如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();  </span><br><span class="line">ssc.configureBlocking( <span class="keyword">false</span> );  </span><br><span class="line">ServerSocket ss = ssc.socket();  </span><br><span class="line">InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress( ports[i] );  </span><br><span class="line">ss.bind( address );  </span><br></pre></td></tr></table></figure>
<p>第一行创建一个新的<code>ServerSocketChannel</code>, 最后三行将它绑定到给定的端口. 第二行将<code>ServerSocketChannel</code>设置为非阻塞的. 我们必须对每一个要使用的套接字通道调用这个方法, 否则异步<code>I/O</code>就不能工作.</p>
<p>5)    选择键</p>
<p>下一步是将新打开的<code>ServerSocketChannels</code>注册到<code>Selector</code>上. 为此我们使用<code>ServerSocketChannel.register()</code>方法, 如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = ssc.register( selector, SelectionKey.OP_ACCEPT );  </span><br></pre></td></tr></table></figure>
<p><code>register()</code>方法的第一个参数总是这个<code>Selector</code>. 第二个参数是<code>OP_ACCEPT</code>, 这里它指定我们想要监听<code>accept</code>事件, 也就是在新的连接建立时所发生的事件. 这是适用于<code>ServerSocketChannel</code>的唯一事件类型.  </p>
<p>请注意对<code>register()</code>的调用的返回值. <code>SelectionKey</code>代表这个通道在此<code>Selector</code>上的这个注册. 当某个<code>Selector</code>通知您某个传入事件时, 它是通过提供对应于该事件的<code>SelectionKey</code>来进行的. <code>SelectionKey</code>还可以用于取消通道的注册.<br>  <br>6)    内部循环</p>
<p>现在已经注册了我们对一些 <code>I/O</code> 事件的兴趣, 下面将进入主循环. 使用 <code>Selectors</code> 的几乎每个程序都像下面这样使用内部循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = selector.select();  </span><br><span class="line"></span><br><span class="line">Set selectedKeys = selector.selectedKeys();  </span><br><span class="line">Iterator it = selectedKeys.iterator();  </span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;  </span><br><span class="line">SelectionKey key = (SelectionKey)it.next();  </span><br><span class="line"><span class="comment">// ... 处理I/O事件...  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<ul>
<li>调用<code>Selector</code>的<code>select()</code>方法. 这个方法会阻塞, 直到至少有一个已注册的事件发生. 当一个或者更多的事件发生时, <code>select()</code>方法将返回所发生的事件的数量.  </li>
<li>调用<code>Selector</code>的<code>selectedKeys()</code>方法, 它返回发生了事件的<code>SelectionKey</code>对象的一个集合.  </li>
<li>通过迭代<code>SelectionKeys</code>并依次处理每个<code>SelectionKey</code>来处理事件. 对于每一个<code>SelectionKey</code>, 您必须确定发生的是什么<code>I/O</code>事件, 以及这个事件影响哪些<code>I/O</code>对象.</li>
</ul>
<p>7)    监听新连接</p>
<p>程序执行到这里, 我们仅注册了<code>ServerSocketChannel</code>,  并且仅注册它们“接收”事件. 为确认这一点, 我们对<code>SelectionKey</code>调用<code>readyOps()</code>方法, 并检查发生了什么类型的事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((key.readyOps() &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) &#123;  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>可以肯定地说, <code>readOps()</code>方法告诉我们该事件是新的连接. </p>
<p>8)    接受新的连接</p>
<p>因为我们知道这个服务器套接字上有一个传入连接在等待, 所以可以安全地接受它；也就是说, 不用担心<code>accept()</code>操作会阻塞：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = (ServerSocketChannel)key.channel();  </span><br><span class="line">SocketChannel sc = ssc.accept();  </span><br></pre></td></tr></table></figure>
<p>下一步是将新连接的SocketChannel配置为非阻塞的. 而且由于接受这个连接的目的是为了读取来自套接字的数据, 所以我们还必须将SocketChannel注册到Selector上, 如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc.configureBlocking( <span class="keyword">false</span> );  </span><br><span class="line">SelectionKey newKey = sc.register( selector, SelectionKey.OP_READ );  </span><br></pre></td></tr></table></figure>
<p>注意我们使用register()的OP_READ参数, 将SocketChannel注册用于“读取”而不是“接受”新连接.</p>
<p>9)    删除处理过的SelectionKey</p>
<p>在处理SelectionKey之后, 我们几乎可以返回主循环了. 但是我们必须首先将处理过的SelectionKey从选定的键集合中删除. 如果我们没有删除处理过的键, 那么它仍然会在主集合中以一个激活的键出现, 这会导致我们尝试再次处理它. 我们调用迭代器的remove()方法来删除处理过的SelectionKey：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it.remove();  </span><br></pre></td></tr></table></figure>
<p>现在我们可以返回主循环并接受从一个套接字中传入的数据(或者一个传入的I/O事件)了.  </p>
<p>10) 传入的I/O</p>
<p>当来自一个套接字的数据到达时, 它会触发一个I/O事件. 这会导致在主循环中调用Selector.select(), 并返回一个或者多个I/O事件. 这一次,  SelectionKey将被标记为OP_READ事件, 如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((key.readyOps() &amp; SelectionKey.OP_READ)  </span><br><span class="line">== SelectionKey.OP_READ) &#123;  </span><br><span class="line"><span class="comment">// Read the data  </span></span><br><span class="line">SocketChannel sc = (SocketChannel)key.channel();  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>与以前一样, 我们取得发生I/O事件的通道并处理它. 在本例中, 由于这是一个echo server, 我们只希望从套接字中读取数据并马上将它发送回去. 关于这个过程的细节, 请参见附件中的源代码 (MultiPortEcho.java).  </p>
<p>11)    回到主循环</p>
<p>每次返回主循环, 我们都要调用select的Selector()方法, 并取得一组SelectionKey. 每个键代表一个I/O事件. 我们处理事件, 从选定的键集中删除SelectionKey, 然后返回主循环的顶部.</p>
<p>说明： 这个程序有点过于简单, 因为它的目的只是展示异步I/O所涉及的技术. 在现实的应用程序中, 您需要通过将通道从Selector中删除来处理关闭的通道. 而且您可能要使用多个线程. 这个程序可以仅使用一个线程, 因为它只是一个演示, 但是在现实场景中, 创建一个线程池来负责I/O事件处理中的耗时部分会更有意义. </p>
<h1 id="缓冲区更多内容"><a href="#缓冲区更多内容" class="headerlink" title="缓冲区更多内容"></a>缓冲区更多内容</h1><p>比如缓冲区分配、包装和分片. 我们还会讨论NIO带给Java平台的一些新功能. 我们将学如何创建不同类型的缓冲区以达到不同的目的, 如可保护数据不被修改的“只读缓冲区”, 和直接映射到底层操作系统缓冲区的“直接缓冲区”, 以及如何在 NIO 中创建内存映射文件. </p>
<p>   1) 缓冲区分配和包装</p>
<p>在能够读和写之前, 必须有一个缓冲区. 要创建缓冲区, 您必须“分配”它. 我们使用静态方法allocate()来分配缓冲区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );  </span><br></pre></td></tr></table></figure>
<p>   allocate()方法分配一个具有指定大小的底层数组, 并将它包装到一个缓冲区对象中, 在本例中是一个ByteBuffer.<br>   您还可以将一个现有的数组转换为缓冲区, 如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> array[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];  </span><br><span class="line">ByteBuffer buffer = ByteBuffer.wrap( array );  </span><br></pre></td></tr></table></figure>
<p>   本例使用了wrap()方法将一个数组包装为缓冲区. 必须非常小心地进行这类操作. 一旦完成包装, 底层数据就可以通过缓冲区或者直接访问.<br> <br>2) 缓冲区分片 </p>
<p>   slice()方法根据现有的缓冲区创建一个子缓冲区. 也就是说, 它创建一个新的缓冲区, 新缓冲区与原来的缓冲区的一部分共享数据.<br>  <br>   使用例子可以最好地说明这点. 让我们首先创建一个长度为10的ByteBuffer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">10</span> );  </span><br></pre></td></tr></table></figure>
<p>   然后使用数据来填充这个缓冲区, 在第n个槽中放入数字n：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;buffer.capacity(); ++i) &#123;  </span><br><span class="line"> buffer.put( (<span class="keyword">byte</span>)i );  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>   现在我们对这个缓冲区“分片”, 以创建一个包含槽3到槽6的子缓冲区. 在某种意义上, 子缓冲区就像原来的缓冲区中的一个窗口 . </p>
<p>   窗口的起始和结束位置通过设置position和limit值来指定, 然后调用Buffer的slice()方法进行分片：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.position( <span class="number">3</span> );  </span><br><span class="line">buffer.limit( <span class="number">7</span> );  </span><br><span class="line">ByteBuffer slice = buffer.slice();  </span><br></pre></td></tr></table></figure>
<p>   该“片段”是缓冲区的子缓冲区. 不过, “片段”和“缓冲区”共享同一个底层数据数组, 我们在下一节将会看到这一点. </p>
<ol start="3">
<li>缓冲区片份和数据共享 </li>
</ol>
<p>   我们已经创建了原缓冲区的子缓冲区, 并且已经知道缓冲区和子缓冲区共享同一个底层数据数组. 让我们看看这意味着什么.  </p>
<p>   我们遍历子缓冲区, 将每一个元素乘以11来改变它. 例如, 5会变成55. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;slice.capacity(); ++i) &#123;  </span><br><span class="line"> <span class="keyword">byte</span> b = slice.get( i );  </span><br><span class="line"> b *= <span class="number">11</span>;  </span><br><span class="line"> slice.put( i, b );  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>   最后, 再看一下原缓冲区中的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buffer.position( <span class="number">0</span> );  </span><br><span class="line">buffer.limit( buffer.capacity() );  </span><br><span class="line"><span class="keyword">while</span> ( buffer.remaining() &gt; <span class="number">0</span> ) &#123;  </span><br><span class="line"> System.out.println( buffer.get() );  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>   结果表明只有在子缓冲区窗口中的元素被改变了： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">33</span><br><span class="line">44</span><br><span class="line">55</span><br><span class="line">66</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<p>   缓冲区片对于促进抽象非常有帮助. 可以编写自己的函数处理整个缓冲区, 而且如果想要将这个过程应用于子缓冲区上, 您只需取主缓冲区的一个片, 并将它传递给您的函数. 这比编写自己的函数来取额外的参数以指定要对缓冲区的哪一部分进行操作更容易.  </p>
<ol start="4">
<li>只读缓冲区</li>
</ol>
<p>只读缓冲区的含义已经很直白了：您可以读取它们, 但是不能向它们写入. 可以通过调用缓冲区的<code>asReadOnlyBuffer()</code>方法, 来将任何常规缓冲区转换为只读缓冲区, 这个方法返回一个与原缓冲区完全相同的缓冲区(并与其共享数据), 只不过它是只读的.  </p>
<p>   只读缓冲区对于保护数据很有用. 在将缓冲区传递给某个对象的方法时, 您无法知道这个方法是否会修改缓冲区中的数据. 创建一个只读的缓冲区可以保证该缓冲区不会被修改. 不能将只读的缓冲区转换为可写的缓冲区.  </p>
<ol start="5">
<li>直接和间接缓冲区 </li>
</ol>
<p>   另一种有用的ByteBuffer是直接缓冲区. “直接缓冲区”是为加快I/O速度, 而以一种特殊的方式分配其内存的缓冲区. 实际上, 直接缓冲区的准确定义是与实现相关的. </p>
<blockquote>
<p>Sun的文档是这样描述直接缓冲区的： 给定一个直接字节缓冲区, Java虚拟机将尽最大努力直接对它执行本机I/O操作. 也就是说, 它会在每一次调用底层操作系统的本机I/O操作之前(或之后), 尝试避免将缓冲区的内容拷贝到一个中间缓冲区中(或者从一个中间缓冲区中拷贝数据).  </p>
</blockquote>
<p>附件中, 您可以在例子程序FastCopyFile.java中看到直接缓冲区的实际应用, 这个程序是CopyFile.java的另一个版本, 它使用了直接缓冲区以提高速度. 还可以用内存映射文件创建直接缓冲区.  </p>
<ol start="6">
<li>内存映射文件I/O</li>
</ol>
<p>   内存映射文件I/O是一种读和写文件数据的方法, 它可以比常规的基于流或者基于通道的I/O快得多.  </p>
<p>内存映射文件I/O是通过使文件中的数据神奇般地出现为内存数组的内容来完成的. 这其初听起来似乎不过就是将整个文件读到内存中, 但是事实上并不是这样. 一般来说, 只有文件中实际读取或者写入的部分才会送入（或者映射）到内存中.  </p>
<p><strong>内存映射并不真的神奇或者多么不寻常. 现代操作系统一般根据需要将文件的部分映射为内存的部分, 从而实现文件系统. Java内存映射机制不过是在底层操作系统中可以采用这种机制时, 提供了对该机制的访问</strong></p>
<p>尽管创建内存映射文件相当简单, 但是向它写入可能是危险的. 仅只是改变数组的单个元素这样的简单操作, 就可能会直接修改磁盘上的文件. 修改数据与将 数据保存到磁盘是没有分开的. </p>
<ol start="7">
<li>将文件映射到内存</li>
</ol>
<p>了解内存映射的最好方法是使用例子. 在下面的例子中, 我们要将一个FileChannel (它的全部或者部分)映射到内存中. 为此我们将使用<code>FileChannel.map()</code>方法. 下面代码行将文件的前1024个字节映射到内存中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MappedByteBuffer mbb = fc.map( FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">1024</span> );  </span><br></pre></td></tr></table></figure>
<p>map()方法返回一个<code>MappedByteBuffer</code>, 它是ByteBuffer的子类. 因此, 您可以像使用其他任何ByteBuffer 一样使用新映射的缓冲区, 操作系统会在需要时负责执行行映射.</p>
<ol>
<li>分散和聚集 </li>
</ol>
<ol>
<li>概述：</li>
</ol>
<p>分散/聚集I/O是使用多个而不是单个缓冲区来保存数据的读写方法.  <br>一个分散的读取就像一个常规通道读取, 只不过它是将数据读到一个缓冲区数组中而不是读到单个缓冲区中. 同样地, 一个聚集写入是向缓冲区数组而不是向单个缓冲区写入数据. 分散/聚集I/O对于将数据流划分为单独的部分很有用, 这有助于实现复杂的数据格式. </p>
<ol start="2">
<li>分散/聚集 I/O：</li>
</ol>
<p>通道可以有选择地实现两个新的接口：ScatteringByteChannel和GatheringByteChannel. 一个 ScatteringByteChannel是一个具有两个附加读方法的通道：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">read</span><span class="params">( ByteBuffer[] dsts )</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">read</span><span class="params">( ByteBuffer[] dsts, <span class="keyword">int</span> offset, <span class="keyword">int</span> length )</span></span>;</span><br></pre></td></tr></table></figure>
<p>这些long read()方法很像标准的read方法, 只不过它们不是取单个缓冲区而是取一个缓冲区数组.  </p>
<p>在“分散读取”中, 通道依次填充每个缓冲区. 填满一个缓冲区后, 它就开始填充下一个. 在某种意义上, 缓冲区数组就像一个大缓冲区.  </p>
<ol start="3">
<li>分散/聚集的应用： </li>
</ol>
<p>分散/聚集I/O对于将数据划分为几个部分很有用. 例如, 您可能在编写一个使用消息对象的网络应用程序, 每一个消息被划分为固定长度的头部和固定长度的正文. 您可以创建一个刚好可以容纳头部的缓冲区和另一个刚好可以容难正文的缓冲区. 当您将它们放入一个数组中并使用分散读取来向它们读入消息时, 头部和正文将整齐地划分到这 两个缓冲区中.  </p>
<p>我们从缓冲区所得到的方便性对于缓冲区数组同样有效. 因为每一个缓冲区都跟踪自己还可以接受多少数据, 所以分散读取会自动找到有空间接受数据的第一个缓冲区. 在这个缓冲区填满后, 它就会移动到下一个缓冲区.  </p>
<ol start="4">
<li>聚集写入： </li>
</ol>
<p>聚集写入类似于分散读取, 只不过是用来写入. 它也有接受缓冲区数组的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">write</span><span class="params">( ByteBuffer[] srcs )</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">write</span><span class="params">( ByteBuffer[] srcs, <span class="keyword">int</span> offset, <span class="keyword">int</span> length )</span></span>;</span><br></pre></td></tr></table></figure>
<p>聚集写对于把一组单独的缓冲区中组成单个数据流很有用. 为了与上面的消息例子保持一致, 您可以使用聚集写入来自动将网络消息的各个部分组装为单个数据流, 以便跨越网络传输消息.  <br>从附件的例子程序 UseScatterGather.java 中可以看到分散读取和聚集写入的实际应用. </p>
<h1 id="文件锁定"><a href="#文件锁定" class="headerlink" title="文件锁定"></a>文件锁定</h1><ol>
<li>概述： </li>
</ol>
<p>文件锁定初看起来可能让人迷惑. 它似乎指的是防止程序或者用户访问特定文件. 事实上, <strong>文件锁就像常规的Java对象锁, 它们是“劝告式”的（advisory）锁</strong>. <strong>它们不阻止任何形式的数据访问, 相反, 它们通过锁的共享和获取来允许系统的不同部分相互协调</strong>. 您可以锁定整个文件或者文件的一部分. 如果您获取一个排它锁, 那么其他人就不能获得同一个文件或者文件的一部分上的锁. 如果您获得一个共享锁, 那么其他人可以获得同一个文件或者文件一部分上的共享锁, 但是不能获得排它锁. 文件锁定并不总是出于保护数据的目的. 例如, 您可能临时锁定一个文件以保证特定 的写操作成为原子的, 而不会有其他程序的干扰.  大多数操作系统提供了文件系统锁, 但是它们并不都是采用同样的方式. 有些实现提供了共享锁, 而另一些仅提供了排它锁. 事实上, 有些实现使得文件的锁定部分不可访问, 尽管大多数实现不是这样的.  在这里, 我们将学习如何在 NIO 中执行简单的文件锁过程, 还将探讨一些保证被锁定的文件尽可能可移植的方法.  </p>
<ol start="2">
<li>锁定文件： </li>
</ol>
<p>要获取文件的一部分上的锁, 您要调用一个打开的FileChannel上的lock()方法. 注意, 如果要获取一个排它锁, 您必须以写方式打开文件. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile( <span class="string">&quot;usefilelocks.txt&quot;</span>, <span class="string">&quot;rw&quot;</span> );  </span><br><span class="line">FileChannel fc = raf.getChannel();  </span><br><span class="line">FileLock lock = fc.lock( start, end, <span class="keyword">false</span> );  </span><br></pre></td></tr></table></figure>
<p>   在拥有锁之后, 您可以执行需要的任何敏感操作, 然后再释放锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.release();  </span><br></pre></td></tr></table></figure>
<p>   在释放锁后, 尝试获得锁的其他任何程序都有机会获得它.  <br>   本附件的例子程序UseFileLocks.java必须与它自己并行运行. 这个程序获取一个文件上的锁, 持有三秒钟, 然后释放它. 如果同时运行这个程序的多个实例, 您会看到每个实例依次获得锁.  </p>
<ol start="3">
<li>文件锁定和可移植性：</li>
</ol>
<p>文件锁定可能是一个复杂的操作, 特别是考虑到 不同的操作系统是以不同的方式实现锁这一事实. 下面的指导原则将帮助您尽可能保持代码的可移植性： </p>
<p>i 只使用排它锁.  </p>
<p>ii 将所有的锁视为劝告式的（advisory）.  </p>
<h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><ol>
<li>概述： </li>
</ol>
<p>根据Sun的文档, 一个Charset是“十六位Unicode字符序列与字节序列之间的一个命名的映射”. 实际上, 一个Charset允许您以尽可能最具可移植性的方式读写字符序列.  </p>
<p>Java语言被定义为基于Unicode. 然而在实际上, 许多人编写代码时都假设一个字符在磁盘上或者在网络流中用一个字节表示. 这种假设在许多情况下成立, 但是并不是在所有情况下都成立, 而且随着计算机变得对Unicode越来越友好, 这个假设就日益变得不能成立了.  </p>
<p>在这里, 我们将看一下如何使用Charsets以适合现代文本格式的方式处理文本数据. 这里将使用的示例程序相当简单, 不过, 它触及了使用Charset的所有关键方面：为给定的字符编码创建Charset, 以及使用该Charset解码和编码文本数据.  </p>
<ol start="2">
<li>编码/解码： </li>
</ol>
<p>要读和写文本, 我们要分别使用CharsetDecoder和CharsetEncoder. 将它们称为“编码器”和“解码器” 是有道理的. 一个字符不再表示一个特定的位模式, 而是表示字符系统中的一个实体. 因此, 由某个实际的位模式表示的字符必须以某种特定的编码来表示.  </p>
<p>CharsetDecoder用于将逐位表示的一串字符转换为具体的char值. 同样, 一个CharsetEncoder用于将字符转换回位.  </p>
<ol start="3">
<li>处理文本的正确方式： </li>
</ol>
<p>现在我们将分析这个例子程序UseCharsets.java. 这个程序非常简单：它从一个文件中读取一些文本, 并将该文本写入另一个文件. 但是它把该数据当作文本数据, 并使用CharBuffer来将该数句读入一个CharsetDecoder中. 同样, 它使用CharsetEncoder来写回该数据.  </p>
<p>我们将假设字符以ISO-8859-1(Latin1)字符集（这是ASCII的标准扩展）的形式储存在磁盘上. 尽管我们必须为使用Unicode做好准备, 但是也必须认识到不同的文件是以不同的格式储存的, 而ASCII无疑是非常普遍的一种格式. 事实上, 每种Java实现都要求对以下字符编码提供完全的支持： </p>
<p>   US-ASCII <br>   ISO-8859-1 <br>   UTF-8 <br>   UTF-16BE <br>   UTF-16LE <br>   UTF-16 </p>
<ol start="4">
<li>示例程序： </li>
</ol>
<p>   在打开相应的文件、将输入数据读入名为inputData的ByteBuffer之后, 我们的程序必须创建ISO-8859-1字符集的一个实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Charset latin1 = Charset.forName( <span class="string">&quot;ISO-8859-1&quot;</span> );  </span><br></pre></td></tr></table></figure>
<p>   然后, 创建一个解码器（用于读取）和一个编码器 （用于写入）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CharsetDecoder decoder = latin1.newDecoder();  </span><br><span class="line">CharsetEncoder encoder = latin1.newEncoder();</span><br></pre></td></tr></table></figure>
<p>   为了将字节数据解码为一组字符, 我们把ByteBuffer传递给CharsetDecoder,  结果得到一个CharBuffer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharBuffer cb = decoder.decode( inputData );  </span><br></pre></td></tr></table></figure>
<p>   如果想要处理字符, 我们可以在程序的此处进行. 但是我们只想无改变地将它写回, 所以没有什么要做的.  </p>
<p>   要写回数据, 我们必须使用CharsetEncoder将它转换回字节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer outputData = encoder.encode( cb );  </span><br></pre></td></tr></table></figure>
<p>   在转换完成之后, 我们就可以将数据写到文件中了. </p>
<h2 id="Java-NIO-bug"><a href="#Java-NIO-bug" class="headerlink" title="Java NIO bug"></a>Java NIO bug</h2><p>JDK 原生 NIO 程序的问题</p>
<p>JDK 原生也有一套网络应用程序 API，但是存在一系列问题，主要如下：</p>
<p>NIO 的类库和 API 繁杂，使用麻烦。你需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等。</p>
<p>需要具备其他的额外技能做铺垫。例如熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的 NIO 程序。</p>
<p>可靠性能力补齐，开发工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等。</p>
<p>NIO 编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大。</p>
<p>JDK NIO 的 Bug。例如臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。</p>
<p>官方声称在 JDK 1.6 版本的 update 18 修复了该问题，但是直到 JDK 1.7 版本该问题仍旧存在，只不过该 Bug 发生概率降低了一些而已，它并没有被根本解决。</p>
<hr>
<p>[参考文献]</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html">NIO 入门</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/kunluntaishan/article/details/53536386"> <strong>Java NIO浅析</strong> </a></li>
<li><a target="_blank" rel="noopener" href="http://zhangshixi.iteye.com/blog/679959">NIO学习系列：核心概念及基本读写</a></li>
<li><a target="_blank" rel="noopener" href="http://zhangshixi.iteye.com/blog/683767">NIO学习系列：连网和异步IO</a></li>
<li><a target="_blank" rel="noopener" href="http://zhangshixi.iteye.com/blog/684544">NIO学习系列：缓冲区更多特性及分散/聚集IO</a></li>
<li><a target="_blank" rel="noopener" href="http://zhangshixi.iteye.com/blog/685022">NIO学习系列：文件锁定和字符集</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/database/MySQL/struct_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/database/MySQL/struct_1/" class="post-title-link" itemprop="url">MySQL架构1 主从复制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-04-03 11:30:00" itemprop="dateCreated datePublished" datetime="2016-04-03T11:30:00+08:00">2016-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-04 09:10:28" itemprop="dateModified" datetime="2021-04-04T09:10:28+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DataStruct/" itemprop="url" rel="index"><span itemprop="name">DataStruct</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>主从复制的几种方式</strong></p>
<p><strong>同步复制</strong></p>
<p>所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,…,slave-n完成后才能返回。</p>
<p>这样，显然不可取，也不是MYSQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间。</p>
<p><strong>异步复制</strong></p>
<p>如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心。MYSQL的默认设置。</p>
<p><strong>半同步复制</strong></p>
<p>master只保证slaves中的一个操作成功，就返回，其他slave不管。这个功能，是由google为MYSQL引入的。</p>
<p><img src="/images/database/MySQL/master_slave_01.png"></p>
<p>当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave,那是发N次，还是只发一次？</p>
<p>如果只发一次，发给了slave-1，那slave-2,slave-3,…它们怎么办？</p>
<p>显然，应该发N次。实际上，在MYSQL   master内部，维护N个线程，每一个线程负责将二进制日志文件发往对应的slave。master既要负责写操作，还的维护N个线程，负担会很重。可以这样，slave-1是master的从，slave-1又是slave-2,slave-3,…的主，同时slave-1不再负责select。slave-1将master的复制线程的负担，转移到自己的身上。这就是所谓的多级复制的概念。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/Socket/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/Socket/" class="post-title-link" itemprop="url">Java Socket</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-03-24 00:00:00" itemprop="dateCreated datePublished" datetime="2016-03-24T00:00:00+08:00">2016-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-04 09:10:28" itemprop="dateModified" datetime="2021-04-04T09:10:28+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计算机网络的基本知识"><a href="#计算机网络的基本知识" class="headerlink" title="计算机网络的基本知识"></a>计算机网络的基本知识</h1><p>两台计算机设备通过网络进行通信需要满足一些必然的条件: 1. IP地址 2. 协议 3. 端口号</p>
<p>TCP/IP模型是目前应用最为广泛的网络模型.</p>
<p><img src="/images/java/socket/tcp_ip.png"></p>
<p>TCP/IP协议是传输层协议</p>
<p>常见的应用层协议有:</p>
<ul>
<li>DNS 域名系统(Domain Name System，DNS)：用于实现网络设备名字到IP地址映射的网络服务。</li>
<li>HTTP 超文本传输协议 用于实现WWW服务</li>
<li>FTP 文件传输协议</li>
<li>TELNET 远程登录协议</li>
<li>SMTP 简单邮件传输协议</li>
<li>简单网络管理协议(simple Network Management Protocol，SNMP)：用于管理与监视网络设备。</li>
</ul>
<p>端口</p>
<ol>
<li><p>用来区分不同的应用程序</p>
</li>
<li><p>端口号的范围为0<del>65535,其中0</del>1023是系统保留端口</p>
</li>
<li><p>一个应用可以绑定多个端口:</p>
<p><img src="/images/java/socket/port_of_qq.png"></p>
</li>
<li><p>IP地址和端口号组成了所谓的Socket, Socket是网络上运行的程序之间双向通信链路的终结点,是TCP和UDP的基础</p>
</li>
<li><p>常用的端口号有: http 80 ftp 21 telnet 23</p>
</li>
</ol>
<h1 id="Java对网路通信的支持"><a href="#Java对网路通信的支持" class="headerlink" title="Java对网路通信的支持"></a>Java对网路通信的支持</h1><ul>
<li>InetAddress<br>用于标示网络上的硬件资源,也就是IP地址</li>
<li>URL<br>统一资源定位符 通过URL可以直接读取或写入网络上的数据</li>
<li>Socket<br>使用TCP协议实现网络通信的Socket相关的类</li>
<li>Datagram<br>使用UDP协议,将数据保存在数据报中,通过网络进行通信.</li>
</ul>
<h2 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取本机的InetAddress实例</span></span><br><span class="line">InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">System.out.println(<span class="string">&quot;计算名：&quot;</span> + address.getHostName());</span><br><span class="line">System.out.println(<span class="string">&quot;IP地址：&quot;</span> + address.getHostAddress());</span><br><span class="line"><span class="keyword">byte</span>[] bytes = address.getAddress();<span class="comment">// 获取字节数组形式的IP地址</span></span><br><span class="line">System.out.println(<span class="string">&quot;字节数组形式的IP：&quot;</span> + Arrays.toString(bytes));</span><br><span class="line">System.out.println(address);<span class="comment">// 直接输出InetAddress对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据机器名获取InetAddress实例</span></span><br><span class="line"><span class="comment">// InetAddress address2=InetAddress.getByName(&quot;laurenyang&quot;);</span></span><br><span class="line">InetAddress address2 = InetAddress.getByName(<span class="string">&quot;1.1.1.10&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;计算名：&quot;</span> + address2.getHostName());</span><br><span class="line">System.out.println(<span class="string">&quot;IP地址：&quot;</span> + address2.getHostAddress());</span><br></pre></td></tr></table></figure>

<h2 id="Socket通信与Socket类"><a href="#Socket通信与Socket类" class="headerlink" title="Socket通信与Socket类"></a>Socket通信与Socket类</h2><p>TCP协议是面向连接 可靠的 有序的, 以字节流的方式发送数据</p>
<p>基于TCP协议实现网络通信的类</p>
<ul>
<li> 客户端的Socket类</li>
<li> 服务端的ServerSocket类</li>
</ul>
<p>Client.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">//1.创建客户端Socket，指定服务器地址和端口</span></span><br><span class="line">	Socket socket=<span class="keyword">new</span> Socket(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">	<span class="comment">//2.获取输出流，向服务器端发送信息</span></span><br><span class="line">	OutputStream os=socket.getOutputStream();<span class="comment">//字节输出流</span></span><br><span class="line">	PrintWriter pw=<span class="keyword">new</span> PrintWriter(os);<span class="comment">//将输出流包装为打印流</span></span><br><span class="line">	pw.write(<span class="string">&quot;用户名：alice;密码：789&quot;</span>);</span><br><span class="line">	pw.flush();</span><br><span class="line">	socket.shutdownOutput();<span class="comment">//关闭输出流</span></span><br><span class="line">	<span class="comment">//3.获取输入流，并读取服务器端的响应信息</span></span><br><span class="line">	InputStream is=socket.getInputStream();</span><br><span class="line">	BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">	String info=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">while</span>((info=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我是客户端，服务器说：&quot;</span>+info);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//4.关闭资源</span></span><br><span class="line">	br.close();</span><br><span class="line">	is.close();</span><br><span class="line">	pw.close();</span><br><span class="line">	os.close();</span><br><span class="line">	socket.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Server.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 基于TCP协议的Socket通信，实现用户登陆</span></span><br><span class="line"><span class="comment"> * 服务器端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">//1.创建一个服务器端Socket，即ServerSocket，指定绑定的端口，并监听此端口</span></span><br><span class="line">	ServerSocket serverSocket=<span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">	Socket socket=<span class="keyword">null</span>;</span><br><span class="line">	<span class="comment">//记录客户端的数量</span></span><br><span class="line">	<span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">	System.out.println(<span class="string">&quot;***服务器即将启动，等待客户端的连接***&quot;</span>);</span><br><span class="line">	<span class="comment">//循环监听等待客户端的连接</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">		<span class="comment">//调用accept()方法开始监听，等待客户端的连接</span></span><br><span class="line">		socket=serverSocket.accept();</span><br><span class="line">		<span class="comment">//创建一个新的线程</span></span><br><span class="line">		ServerThread serverThread=<span class="keyword">new</span> ServerThread(socket);</span><br><span class="line">		<span class="comment">//启动线程</span></span><br><span class="line">		serverThread.start();</span><br><span class="line"></span><br><span class="line">		count++;<span class="comment">//统计客户端的数量</span></span><br><span class="line">		System.out.println(<span class="string">&quot;客户端的数量：&quot;</span>+count);</span><br><span class="line">		InetAddress address=socket.getInetAddress();</span><br><span class="line">		System.out.println(<span class="string">&quot;当前客户端的IP：&quot;</span>+address.getHostAddress());</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServerThread.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 服务器线程处理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 和本线程相关的Socket</span></span><br><span class="line">	Socket socket = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.socket = socket;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//线程执行的操作，响应客户端的请求</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		InputStream is=<span class="keyword">null</span>;</span><br><span class="line">		InputStreamReader isr=<span class="keyword">null</span>;</span><br><span class="line">		BufferedReader br=<span class="keyword">null</span>;</span><br><span class="line">		OutputStream os=<span class="keyword">null</span>;</span><br><span class="line">		PrintWriter pw=<span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//获取输入流，并读取客户端信息</span></span><br><span class="line">			is = socket.getInputStream();</span><br><span class="line">			isr = <span class="keyword">new</span> InputStreamReader(is);</span><br><span class="line">			br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">			String info=<span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">while</span>((info=br.readLine())!=<span class="keyword">null</span>)&#123;<span class="comment">//循环读取客户端的信息</span></span><br><span class="line">				System.out.println(<span class="string">&quot;我是服务器，客户端说：&quot;</span>+info);</span><br><span class="line">			&#125;</span><br><span class="line">			socket.shutdownInput();<span class="comment">//关闭输入流</span></span><br><span class="line">			<span class="comment">//获取输出流，响应客户端的请求</span></span><br><span class="line">			os = socket.getOutputStream();</span><br><span class="line">			pw = <span class="keyword">new</span> PrintWriter(os);</span><br><span class="line">			pw.write(<span class="string">&quot;欢迎您！&quot;</span>);</span><br><span class="line">			pw.flush();<span class="comment">//调用flush()方法将缓冲输出</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="comment">//关闭资源</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(pw!=<span class="keyword">null</span>)</span><br><span class="line">					pw.close();</span><br><span class="line">				<span class="keyword">if</span>(os!=<span class="keyword">null</span>)</span><br><span class="line">					os.close();</span><br><span class="line">				<span class="keyword">if</span>(br!=<span class="keyword">null</span>)</span><br><span class="line">					br.close();</span><br><span class="line">				<span class="keyword">if</span>(isr!=<span class="keyword">null</span>)</span><br><span class="line">					isr.close();</span><br><span class="line">				<span class="keyword">if</span>(is!=<span class="keyword">null</span>)</span><br><span class="line">					is.close();</span><br><span class="line">				<span class="keyword">if</span>(socket!=<span class="keyword">null</span>)</span><br><span class="line">					socket.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多线程Socket通信优化"><a href="#多线程Socket通信优化" class="headerlink" title="多线程Socket通信优化"></a>多线程Socket通信优化</h2><ol>
<li><p>完成新客户端的绑定,启动多线程时, 设置优先级, 为设置优先级可能会导致运行时速度非常慢, 可降低优先级</p>
</li>
<li><p>对于同一个Socket, 如果关闭了输出流,则与该输出流关联的Socket也会被关闭,所以一般不用关闭流, 直接关闭socket即可.</p>
</li>
<li><p>使用TCP通信传输对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用ObjectOutputStream 对象序列化流,传递对象</span></span><br><span class="line">OutputStream os=socket.getOutputStream();</span><br><span class="line">ObjectOutputStream oos=<span class="keyword">new</span> ObjectOutputStream(os);</span><br><span class="line">User user=<span class="keyword">new</span> User();</span><br><span class="line">oos.writeObject(user);</span><br><span class="line">socket.shutdownOutput();</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><p>使用TCP通信传输文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BufferedOutputStream fos=<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line"><span class="keyword">byte</span>[] buf =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=clientInputStream.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">  fos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">  fos.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="UDP协议与Datagram"><a href="#UDP协议与Datagram" class="headerlink" title="UDP协议与Datagram"></a>UDP协议与Datagram</h2></li>
</ol>
<p>UDP协议(用户数据报协议)是无连接 不可靠 无序的. UDP协议以数据报作为数据传输的载体.<br>进行数据传输时,首先要将传输的数据定义成数据报(Datagram),在数据报中指明数据所要达到的Socket(主机地址和端口号),然后再讲数据报发送出去.</p>
<ul>
<li>DatagramPacket: 表示数据报包</li>
<li>DatagramSocket: 进行端对端通信的类</li>
</ul>
<p>UDPClient.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 向服务器端发送数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//1.定义服务器的地址、端口号、数据</span></span><br><span class="line">InetAddress address=InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> port=<span class="number">8800</span>;</span><br><span class="line"><span class="keyword">byte</span>[] data=<span class="string">&quot;用户名：admin;密码：123&quot;</span>.getBytes();</span><br><span class="line"><span class="comment">//2.创建数据报，包含发送的数据信息</span></span><br><span class="line">DatagramPacket packet=<span class="keyword">new</span> DatagramPacket(data, data.length, address, port);</span><br><span class="line"><span class="comment">//3.创建DatagramSocket对象</span></span><br><span class="line">DatagramSocket socket=<span class="keyword">new</span> DatagramSocket();</span><br><span class="line"><span class="comment">//4.向服务器端发送数据报</span></span><br><span class="line">socket.send(packet);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 接收服务器端响应的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//1.创建数据报，用于接收服务器端响应的数据</span></span><br><span class="line"><span class="keyword">byte</span>[] data2=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">DatagramPacket packet2=<span class="keyword">new</span> DatagramPacket(data2, data2.length);</span><br><span class="line"><span class="comment">//2.接收服务器响应的数据</span></span><br><span class="line">socket.receive(packet2);</span><br><span class="line"><span class="comment">//3.读取数据</span></span><br><span class="line">String reply=<span class="keyword">new</span> String(data2, <span class="number">0</span>, packet2.getLength());</span><br><span class="line">System.out.println(<span class="string">&quot;我是客户端，服务器说：&quot;</span>+reply);</span><br><span class="line"><span class="comment">//4.关闭资源</span></span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>
<p>UDPServer.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 接收客户端发送的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1.创建服务器端DatagramSocket，指定端口</span></span><br><span class="line">DatagramSocket socket=<span class="keyword">new</span> DatagramSocket(<span class="number">8800</span>);</span><br><span class="line"><span class="comment">//2.创建数据报，用于接收客户端发送的数据</span></span><br><span class="line"><span class="keyword">byte</span>[] data =<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];<span class="comment">//创建字节数组，指定接收的数据包的大小</span></span><br><span class="line">DatagramPacket packet=<span class="keyword">new</span> DatagramPacket(data, data.length);</span><br><span class="line"><span class="comment">//3.接收客户端发送的数据</span></span><br><span class="line">System.out.println(<span class="string">&quot;****服务器端已经启动，等待客户端发送数据&quot;</span>);</span><br><span class="line">socket.receive(packet);<span class="comment">//此方法在接收到数据报之前会一直阻塞</span></span><br><span class="line"><span class="comment">//4.读取数据</span></span><br><span class="line">String info=<span class="keyword">new</span> String(data, <span class="number">0</span>, packet.getLength());</span><br><span class="line">System.out.println(<span class="string">&quot;我是服务器，客户端说：&quot;</span>+info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 向客户端响应数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1.定义客户端的地址、端口号、数据</span></span><br><span class="line">InetAddress address=packet.getAddress();</span><br><span class="line"><span class="keyword">int</span> port=packet.getPort();</span><br><span class="line"><span class="keyword">byte</span>[] data2=<span class="string">&quot;欢迎您!&quot;</span>.getBytes();</span><br><span class="line"><span class="comment">//2.创建数据报，包含响应的数据信息</span></span><br><span class="line">DatagramPacket packet2=<span class="keyword">new</span> DatagramPacket(data2, data2.length, address, port);</span><br><span class="line"><span class="comment">//3.响应客户端</span></span><br><span class="line">socket.send(packet2);</span><br><span class="line"><span class="comment">//4.关闭资源</span></span><br><span class="line">socket.close();</span><br></pre></td></tr></table></figure>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p><a href="/android-network/">参见 Android 网路编程</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * URL常用方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//创建一个URL实例</span></span><br><span class="line">  URL imooc=<span class="keyword">new</span> URL(<span class="string">&quot;http://www.imooc.com&quot;</span>);</span><br><span class="line">  <span class="comment">//?后面表示参数，#后面表示锚点</span></span><br><span class="line">  URL url=<span class="keyword">new</span> URL(imooc, <span class="string">&quot;/index.html?username=tom#test&quot;</span>);</span><br><span class="line">  System.out.println(<span class="string">&quot;协议：&quot;</span>+url.getProtocol());</span><br><span class="line">  System.out.println(<span class="string">&quot;主机：&quot;</span>+url.getHost());</span><br><span class="line">  <span class="comment">//如果未指定端口号，则使用默认的端口号，此时getPort()方法返回值为-1</span></span><br><span class="line">  System.out.println(<span class="string">&quot;端口：&quot;</span>+url.getPort());</span><br><span class="line">  System.out.println(<span class="string">&quot;文件路径：&quot;</span>+url.getPath());</span><br><span class="line">  System.out.println(<span class="string">&quot;文件名：&quot;</span>+url.getFile());</span><br><span class="line">  System.out.println(<span class="string">&quot;相对路径：&quot;</span>+url.getRef());</span><br><span class="line">  System.out.println(<span class="string">&quot;查询字符串：&quot;</span>+url.getQuery());</span><br><span class="line">&#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 使用URL读取网页内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">//创建一个URL实例</span></span><br><span class="line"> URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line"> <span class="comment">//通过URL的openStream方法获取URL对象所表示的资源的字节输入流</span></span><br><span class="line"> InputStream is = url.openStream();</span><br><span class="line"> <span class="comment">//将字节输入流转换为字符输入流</span></span><br><span class="line"> InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(is, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"> <span class="comment">//为字符输入流添加缓冲</span></span><br><span class="line"> BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"> String data = br.readLine();<span class="comment">//读取数据</span></span><br><span class="line"> <span class="keyword">while</span> (data != <span class="keyword">null</span>) &#123;<span class="comment">//循环读取数据</span></span><br><span class="line">   System.out.println(data);<span class="comment">//输出数据</span></span><br><span class="line">   data = br.readLine();</span><br><span class="line"> &#125;</span><br><span class="line"> br.close();</span><br><span class="line"> isr.close();</span><br><span class="line"> is.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HttpURLConnection"><a href="#HttpURLConnection" class="headerlink" title="HttpURLConnection"></a>HttpURLConnection</h2><p><a href="/android-network/">参见 Android 网路编程</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/jdbc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/jdbc/" class="post-title-link" itemprop="url">JDBC(占坑)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-03-12 11:03:00" itemprop="dateCreated datePublished" datetime="2016-03-12T11:03:00+08:00">2016-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-04 09:10:28" itemprop="dateModified" datetime="2021-04-04T09:10:28+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JDBC的使用步骤"><a href="#JDBC的使用步骤" class="headerlink" title="JDBC的使用步骤"></a>JDBC的使用步骤</h1><h2 id="注册驱动-只做一次"><a href="#注册驱动-只做一次" class="headerlink" title="注册驱动 只做一次"></a>注册驱动 只做一次</h2><p><strong>方式一</strong>：</p>
<p><code>Class.forName(&quot;com.MySQL.jdbc.Driver&quot;);</code></p>
<p>推荐这种方式，不会对具体的驱动类产生依赖。</p>
<p><strong>方式二</strong>：</p>
<p><code>DriverManager.registerDriver(&quot;com.MySQL.jdbc.Driver&quot;);</code></p>
<p>会造成DriverManager中产生两个一样的驱动，并会对具体的驱动类产生依赖。</p>
<p><strong>方式三</strong>：</p>
<p><code>System.setProperty(“jdbc.drivers”, “driver1:driver2”);</code></p>
<p>虽然不会对具体的驱动类产生依赖；但注册不太方便，所以很少使用。 </p>
<p>Jar包地址:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>




<h2 id="建立连接Connection"><a href="#建立连接Connection" class="headerlink" title="建立连接Connection"></a>建立连接Connection</h2><p><code>Connection conn = DriverManager.getConnection(url, user, password);  </code></p>
<p><strong>url格式：</strong><br><code>JDBC:子协议:子名称//主机名:端口/数据库名？属性名=属性值&amp;…</code><br>User,password可以用“属性名=属性值”方式告诉数据库；<br>其他参数如：<code>useUnicode=true&amp;characterEncoding=GBK</code>。</p>
<h2 id="创建执行SQL的语句Statement"><a href="#创建执行SQL的语句Statement" class="headerlink" title="创建执行SQL的语句Statement"></a>创建执行SQL的语句Statement</h2><p>Statement</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Statement st = conn.createStatement();  </span><br><span class="line">st.executeQuery(sql);  </span><br></pre></td></tr></table></figure>
<p>PreparedStatement</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String sql = “select * from table_name where col_name=?”;  </span><br><span class="line">PreparedStatement ps = conn.preparedStatement(sql);  </span><br><span class="line">ps.setString(<span class="number">1</span>, “col_value”);  </span><br><span class="line">ps.executeQuery(); </span><br></pre></td></tr></table></figure>


<h2 id="处理执行结果ResultSet"><a href="#处理执行结果ResultSet" class="headerlink" title="处理执行结果ResultSet"></a>处理执行结果ResultSet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rs = statement.executeQuery(sql);  </span><br><span class="line">While(rs.next())&#123;  </span><br><span class="line">rs.getString(“col_name”);  </span><br><span class="line">rs.getInt(“col_name”);  </span><br><span class="line"><span class="comment">//…  </span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<h2 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h2><p>释放ResultSet, Statement,Connection.</p>
<p>数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。</p>
<h1 id="使用JDBC来实现CRUD的操作"><a href="#使用JDBC来实现CRUD的操作" class="headerlink" title="使用JDBC来实现CRUD的操作"></a>使用JDBC来实现CRUD的操作</h1><h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><p>在这里定义了一个用户信息表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tb_user_info` (</span><br><span class="line">  `user_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">  `gender` enum(<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;女&#x27;</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">  `birthday` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;生日&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`user_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">10000</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 COMMENT<span class="operator">=</span><span class="string">&#x27;用户信息表&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h2><p>与该表对应的Entity为:</p>
<p><img src="/images/java/jdbc/sample-01-uml.png"></p>
<h2 id="JDBC的CRUD"><a href="#JDBC的CRUD" class="headerlink" title="JDBC的CRUD"></a>JDBC的CRUD</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * database connection</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">connection</span><span class="params">(<span class="keyword">final</span> String url, <span class="keyword">final</span> String name, <span class="keyword">final</span> String password)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        Connection connection = DriverManager.getConnection(url, name, password);</span><br><span class="line">        <span class="keyword">this</span>.connection = connection;</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UserInfo&gt; <span class="title">list</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> ps)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = p * ps;</span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(<span class="string">&quot;select * from tb_user_info limit &quot;</span> + start + <span class="string">&quot;,&quot;</span> + ps);</span><br><span class="line">        ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line">        ArrayList&lt;UserInfo&gt; list = <span class="keyword">new</span> ArrayList&lt;UserInfo&gt;();</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            <span class="keyword">int</span> userId = resultSet.getInt(<span class="string">&quot;user_id&quot;</span>);</span><br><span class="line">            String name = resultSet.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            Timestamp birthday = resultSet.getTimestamp(<span class="string">&quot;birthday&quot;</span>);</span><br><span class="line">            String gender = resultSet.getString(<span class="string">&quot;gender&quot;</span>);</span><br><span class="line">            UserInfo userInfo = <span class="keyword">new</span> UserInfo(userId, name, gender, birthday);</span><br><span class="line">            list.add(userInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UserInfo&gt; <span class="title">findByName</span><span class="params">(String name)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(<span class="string">&quot;select * from tb_user_info where name = ?&quot;</span>);</span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>, name);</span><br><span class="line">        ResultSet resultSet = preparedStatement.executeQuery();</span><br><span class="line">        ArrayList&lt;UserInfo&gt; list = <span class="keyword">new</span> ArrayList&lt;UserInfo&gt;();</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            <span class="keyword">int</span> userId = resultSet.getInt(<span class="string">&quot;user_id&quot;</span>);</span><br><span class="line">            Timestamp birthday = resultSet.getTimestamp(<span class="string">&quot;birthday&quot;</span>);</span><br><span class="line">            String gender = resultSet.getString(<span class="string">&quot;gender&quot;</span>);</span><br><span class="line">            UserInfo userInfo = <span class="keyword">new</span> UserInfo(userId, name, gender, birthday);</span><br><span class="line">            list.add(userInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addUser</span><span class="params">(UserInfo userInfo)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(<span class="string">&quot;insert into tb_user_info values(default,?,?,?)&quot;</span>);</span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>, userInfo.getName());</span><br><span class="line">        preparedStatement.setString(<span class="number">2</span>, userInfo.getGender());</span><br><span class="line">        preparedStatement.setTimestamp(<span class="number">3</span>, userInfo.getBirthday());</span><br><span class="line">        <span class="keyword">int</span> influenceLines = preparedStatement.executeUpdate();</span><br><span class="line">        <span class="keyword">return</span> influenceLines;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(<span class="string">&quot;delete from tb_user_info where user_id = ?&quot;</span>);</span><br><span class="line">        preparedStatement.setInt(<span class="number">1</span>, userId);</span><br><span class="line">        <span class="keyword">int</span> influenceLines = preparedStatement.executeUpdate();</span><br><span class="line">        <span class="keyword">return</span> influenceLines;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(UserInfo userInfo)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        PreparedStatement preparedStatement = connection.prepareStatement(<span class="string">&quot;update tb_user_info set name=? , gender = ? , birthday = ? where user_id = ?&quot;</span>);</span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>, userInfo.getName());</span><br><span class="line">        preparedStatement.setString(<span class="number">2</span>, userInfo.getGender());</span><br><span class="line">        preparedStatement.setTimestamp(<span class="number">3</span>, userInfo.getBirthday());</span><br><span class="line">        preparedStatement.setInt(<span class="number">4</span>, userInfo.getUserId());</span><br><span class="line">        <span class="keyword">int</span> influenceLines = preparedStatement.executeUpdate();</span><br><span class="line">        <span class="keyword">return</span> influenceLines;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试样例: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">JDBCDemo jdbcDemo = <span class="keyword">new</span> JDBCDemo();</span><br><span class="line">jdbcDemo.connection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/test?autoReconnect=true&amp;autoReconnectForPools=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&quot;</span>,</span><br><span class="line">        <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">UserInfo obama = <span class="keyword">new</span> UserInfo(<span class="number">0</span>, <span class="string">&quot;奥巴马&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="keyword">new</span> Timestamp(System.currentTimeMillis()));</span><br><span class="line">UserInfo cirali = <span class="keyword">new</span> UserInfo(<span class="number">0</span>, <span class="string">&quot;希拉里&quot;</span>, <span class="string">&quot;女&quot;</span>, <span class="keyword">new</span> Timestamp(System.currentTimeMillis()));</span><br><span class="line">UserInfo trappes = <span class="keyword">new</span> UserInfo(<span class="number">0</span>, <span class="string">&quot;特朗普&quot;</span>, <span class="string">&quot;女&quot;</span>, <span class="keyword">new</span> Timestamp(System.currentTimeMillis()));</span><br><span class="line">System.out.println(<span class="string">&quot;[添加 奥巴马]&quot;</span>);</span><br><span class="line">jdbcDemo.addUser(obama);</span><br><span class="line">System.out.println(<span class="string">&quot;[添加 希拉里]&quot;</span>);</span><br><span class="line"></span><br><span class="line">jdbcDemo.addUser(cirali);</span><br><span class="line">System.out.println(<span class="string">&quot;[添加 特朗普]&quot;</span>);</span><br><span class="line">jdbcDemo.addUser(trappes);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;\n 输出 所有用户信息：&quot;</span>);</span><br><span class="line">List&lt;UserInfo&gt; list = jdbcDemo.list(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (UserInfo userInfo : list) &#123;</span><br><span class="line">        System.out.println(userInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;根据姓名查询用户信息&quot;</span>);</span><br><span class="line">UserInfo tUserIndo = <span class="keyword">null</span>;</span><br><span class="line">List&lt;UserInfo&gt; resultList = jdbcDemo.findByName(<span class="string">&quot;特朗普&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (resultList != <span class="keyword">null</span>) &#123;</span><br><span class="line">    tUserIndo = resultList.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(tUserIndo);</span><br><span class="line"></span><br><span class="line">tUserIndo.setGender(<span class="string">&quot;男&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;[更新]&quot;</span>);</span><br><span class="line">jdbcDemo.update(tUserIndo);</span><br><span class="line"></span><br><span class="line">System.out.println(tUserIndo);</span><br><span class="line">System.out.println(<span class="string">&quot;\n 输出 所有用户信息：&quot;</span>);</span><br><span class="line">list = jdbcDemo.list(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (UserInfo userInfo : list) &#123;</span><br><span class="line">        System.out.println(userInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 释放资源 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rs </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> st </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">free</span><span class="params">(ResultSet rs,Statement st,Connection conn)</span></span>&#123;  </span><br><span class="line">  <span class="keyword">try</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(rs != <span class="keyword">null</span>)&#123;  </span><br><span class="line">      rs.close();  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;<span class="keyword">catch</span>(SQLException e)&#123;  </span><br><span class="line">    e.printStackTrace();  </span><br><span class="line">  &#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line">    <span class="keyword">try</span>&#123;  </span><br><span class="line">      <span class="keyword">if</span>(st != <span class="keyword">null</span>)&#123;  </span><br><span class="line">        st.close();  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;<span class="keyword">catch</span>(SQLException e)&#123;  </span><br><span class="line">      e.printStackTrace();  </span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line">      <span class="keyword">try</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;  </span><br><span class="line">          conn.close();  </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;<span class="keyword">catch</span>(SQLException e)&#123;  </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p>输出结果为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[添加 奥巴马]</span><br><span class="line">[添加 希拉里]</span><br><span class="line">[添加 特朗普]</span><br><span class="line"></span><br><span class="line"> 输出 所有用户信息：</span><br><span class="line">UserInfo&#123;userId&#x3D;10009, name&#x3D;&#39;奥巴马&#39;, gender&#x3D;男, birthday&#x3D;2016-11-27 10:03:00.0&#125;</span><br><span class="line">UserInfo&#123;userId&#x3D;10010, name&#x3D;&#39;希拉里&#39;, gender&#x3D;女, birthday&#x3D;2016-11-27 10:03:00.0&#125;</span><br><span class="line">UserInfo&#123;userId&#x3D;10011, name&#x3D;&#39;特朗普&#39;, gender&#x3D;女, birthday&#x3D;2016-11-27 10:03:00.0&#125;</span><br><span class="line">根据姓名查询用户信息</span><br><span class="line">UserInfo&#123;userId&#x3D;10011, name&#x3D;&#39;特朗普&#39;, gender&#x3D;女, birthday&#x3D;2016-11-27 10:03:00.0&#125;</span><br><span class="line">[更新]</span><br><span class="line">UserInfo&#123;userId&#x3D;10011, name&#x3D;&#39;特朗普&#39;, gender&#x3D;男, birthday&#x3D;2016-11-27 10:03:00.0&#125;</span><br><span class="line"></span><br><span class="line"> 输出 所有用户信息：</span><br><span class="line">UserInfo&#123;userId&#x3D;10009, name&#x3D;&#39;奥巴马&#39;, gender&#x3D;男, birthday&#x3D;2016-11-27 10:03:00.0&#125;</span><br><span class="line">UserInfo&#123;userId&#x3D;10010, name&#x3D;&#39;希拉里&#39;, gender&#x3D;女, birthday&#x3D;2016-11-27 10:03:00.0&#125;</span><br><span class="line">UserInfo&#123;userId&#x3D;10011, name&#x3D;&#39;特朗普&#39;, gender&#x3D;男, birthday&#x3D;2016-11-27 10:03:00.0&#125;</span><br></pre></td></tr></table></figure>


<p><strong>注意</strong></p>
<ol>
<li>使用prepareStatement预处理执行SQL语句时，<code>?</code>的索引是从<code>1</code>开始的</li>
</ol>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="JDBC中特殊数据类型的操作问题"><a href="#JDBC中特殊数据类型的操作问题" class="headerlink" title="JDBC中特殊数据类型的操作问题"></a>JDBC中特殊数据类型的操作问题</h1><h2 id="第一个是日期问题"><a href="#第一个是日期问题" class="headerlink" title="第一个是日期问题"></a>第一个是日期问题</h2><p>JDBC接收的时间类型是sql下的类型，与Java中的类型不同，通常需要转化。</p>
<p>如 java.sql.Date &lt;—&gt; java.util.Date</p>
<h2 id="第二个问题就是大文本数据的问题"><a href="#第二个问题就是大文本数据的问题" class="headerlink" title="第二个问题就是大文本数据的问题"></a>第二个问题就是大文本数据的问题</h2><p>读写大文本数据:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 插入大文本 </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;  </span><br><span class="line">  Connection conn = <span class="keyword">null</span>;  </span><br><span class="line">  PreparedStatement ps = <span class="keyword">null</span>;  </span><br><span class="line">  ResultSet rs = <span class="keyword">null</span>;  </span><br><span class="line">  <span class="keyword">try</span>&#123;  </span><br><span class="line">    conn = JdbcUtils.getConnection();  </span><br><span class="line">    String sql = <span class="string">&quot;insert into clob_test(bit_text) values(?)&quot;</span>;  </span><br><span class="line">    ps = conn.prepareStatement(sql);  </span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;src/com/weijia/type/ClubDemo.java&quot;</span>);  </span><br><span class="line">    Reader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));  </span><br><span class="line">    <span class="comment">//ps.setAsciiStream(1, new FileInputStream(file), (int)file.length());//英文的文档  </span></span><br><span class="line">    ps.setCharacterStream(<span class="number">1</span>, reader, (<span class="keyword">int</span>)file.length());  </span><br><span class="line">    ps.executeUpdate();  </span><br><span class="line">    reader.close();  </span><br><span class="line">  &#125;<span class="keyword">catch</span>(Exception e)&#123;  </span><br><span class="line">    e.printStackTrace();  </span><br><span class="line">  &#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line">    JdbcUtils.free(rs,ps,conn);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Clob clob = rs.getClob(<span class="number">1</span>);  </span><br><span class="line">InputStream is = clob.getAsciiStream();  </span><br></pre></td></tr></table></figure>


<h1 id="JDBC中事务的概念"><a href="#JDBC中事务的概念" class="headerlink" title="JDBC中事务的概念"></a>JDBC中事务的概念</h1><h1 id="JDBC中调用存储过程"><a href="#JDBC中调用存储过程" class="headerlink" title="JDBC中调用存储过程"></a>JDBC中调用存储过程</h1><h1 id="JDBC来实现批处理功能"><a href="#JDBC来实现批处理功能" class="headerlink" title="JDBC来实现批处理功能"></a>JDBC来实现批处理功能</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createBatch</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;  </span><br><span class="line">  <span class="comment">//建立一个连接的是很耗时间的  </span></span><br><span class="line">  <span class="comment">//执行一个sql语句也是很耗时间的  </span></span><br><span class="line">  <span class="comment">//优化的措施：批处理  </span></span><br><span class="line">  Connection conn = <span class="keyword">null</span>;  </span><br><span class="line">  PreparedStatement ps = <span class="keyword">null</span>;  </span><br><span class="line">  ResultSet rs = <span class="keyword">null</span>;  </span><br><span class="line">  <span class="keyword">try</span>&#123;  </span><br><span class="line">    conn = JdbcUtils.getConnection();  </span><br><span class="line">    String sql = <span class="string">&quot;insert user(name,birthday,money) values(?,?,?)&quot;</span>;  </span><br><span class="line">    ps = conn.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//打包的话容量也不是越大越好，因为可能会内存溢出的，同时网络传输的过程中也是会进行拆包传输的，这个包的大小是不一定的  </span></span><br><span class="line">    <span class="comment">//有时候打包的效率不一定就会高，这个和数据库的类型，版本都有关系的，所以我们在实践的过程中需要检验的  </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;  </span><br><span class="line">      ps.setString(<span class="number">1</span>,<span class="string">&quot;jiangwei&quot;</span>);  </span><br><span class="line">      ps.setDate(<span class="number">2</span>,<span class="keyword">new</span> Date(System.currentTimeMillis()));  </span><br><span class="line">      ps.setFloat(<span class="number">3</span>,<span class="number">400</span>);  </span><br><span class="line">      <span class="comment">//ps.addBatch(sql);  </span></span><br><span class="line">      ps.addBatch();  </span><br><span class="line">    &#125;  </span><br><span class="line">    ps.executeBatch();  </span><br><span class="line">  &#125;<span class="keyword">catch</span>(Exception e)&#123;  </span><br><span class="line">    e.printStackTrace();  </span><br><span class="line">  &#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line">    JdbcUtils.free(rs, ps, conn);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<h1 id="JDBC中的滚动结果集和分页技术"><a href="#JDBC中的滚动结果集和分页技术" class="headerlink" title="JDBC中的滚动结果集和分页技术"></a>JDBC中的滚动结果集和分页技术</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;  </span><br><span class="line">  Connection conn = <span class="keyword">null</span>;  </span><br><span class="line">  Statement st = <span class="keyword">null</span>;  </span><br><span class="line">  ResultSet rs = <span class="keyword">null</span>;  </span><br><span class="line">  <span class="keyword">try</span>&#123;  </span><br><span class="line">    conn = JdbcUtils.getConnection();  </span><br><span class="line">    <span class="comment">//结果集可滚动的  </span></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">             * 参数的含义： </span></span><br><span class="line"><span class="comment">             *  ResultSet.RTYPE_FORWORD_ONLY：这是缺省值，只可向前滚动；  </span></span><br><span class="line"><span class="comment">                ResultSet.TYPE_SCROLL_INSENSITIVE：双向滚动，但不及时更新，就是如果数据库里的数据修改过，并不在ResultSet中反应出来。  </span></span><br><span class="line"><span class="comment">                ResultSet.TYPE_SCROLL_SENSITIVE：双向滚动，并及时跟踪数据库的更新,以便更改ResultSet中的数据。 </span></span><br><span class="line"><span class="comment">                ResultSet.CONCUR_READ_ONLY：这是缺省值，指定不可以更新 ResultSet  </span></span><br><span class="line"><span class="comment">                ResultSet.CONCUR_UPDATABLE：指定可以更新 ResultSet </span></span><br><span class="line"><span class="comment">             */</span>  </span><br><span class="line">    st = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_READ_ONLY);  </span><br><span class="line">    rs = st.executeQuery(<span class="string">&quot;select id,name,money,birthday from user&quot;</span>);  </span><br><span class="line">    <span class="comment">//开始的时候这个游标的位置是第一条记录之前的一个位置  </span></span><br><span class="line">    <span class="comment">//当执行rs.next的时候这个游标的位置就到第一条记录了  </span></span><br><span class="line">    <span class="comment">/*while(rs.next())&#123; </span></span><br><span class="line"><span class="comment">                //print result </span></span><br><span class="line"><span class="comment">            &#125;*/</span>  </span><br><span class="line">    <span class="comment">//上面的代码执行之后，这个游标就到最后一条记录的下一个位置了  </span></span><br><span class="line">    <span class="comment">//所以这里在调用previous方法之后，这个游标就回到了最后一条记录中，所以打印了最后一条记录的值  </span></span><br><span class="line">    <span class="comment">/*if(rs.previous())&#123; </span></span><br><span class="line"><span class="comment">                System.out.println(&quot;id=&quot;+rs.getInt(&quot;id&quot;)+&quot;\tname=&quot;+rs.getString(&quot;name&quot;)+&quot;\tbirthday=&quot;+rs.getDate(&quot;birthday&quot;)+&quot;\tmoney=&quot;+rs.getFloat(&quot;money&quot;)); </span></span><br><span class="line"><span class="comment">            &#125;*/</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//绝对定位到第几行结果集  </span></span><br><span class="line">    <span class="comment">//这里传递的参数的下标是从1开始的，比如这里查询出来的记录有3条，那么这里的参数的范围是:1-3,如果传递的参数不在这个范围内就会报告异常的  </span></span><br><span class="line">    rs.absolute(<span class="number">2</span>);  </span><br><span class="line">    System.out.println(<span class="string">&quot;id=&quot;</span>+rs.getInt(<span class="string">&quot;id&quot;</span>)+<span class="string">&quot;\tname=&quot;</span>+rs.getString(<span class="string">&quot;name&quot;</span>)+<span class="string">&quot;\tbirthday=&quot;</span>+rs.getDate(<span class="string">&quot;birthday&quot;</span>)+<span class="string">&quot;\tmoney=&quot;</span>+rs.getFloat(<span class="string">&quot;money&quot;</span>));  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//滚到到第一行的前面(默认的就是这种情况)  </span></span><br><span class="line">    rs.beforeFirst();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//滚动到最后一行的后面  </span></span><br><span class="line">    rs.afterLast();  </span><br><span class="line"></span><br><span class="line">    rs.isFirst();<span class="comment">//判断是不是在第一行记录  </span></span><br><span class="line">    rs.isLast();<span class="comment">//判断是不是在最后一行记录  </span></span><br><span class="line">    rs.isAfterLast();<span class="comment">//判断是不是第一行前面的位置  </span></span><br><span class="line">    rs.isBeforeFirst();<span class="comment">//判断是不是最后一行的后面的位置  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//以上的api可以实现翻页的效果(这个效率很低的，因为是先把数据都查询到内存中，然后再进行分页显示的)  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//效率高的话是直接使用数据库中的分页查询语句：  </span></span><br><span class="line">    <span class="comment">//select * from user limit 150,10;  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//以上的api实现的分页功能是针对于那些本身不支持分页查询功能的数据库的，如果一个数据库支持分页功能，上面的代码就不能使用的，因为效率是很低的  </span></span><br><span class="line">  &#125;<span class="keyword">catch</span>(Exception e)&#123;  </span><br><span class="line">    e.printStackTrace();  </span><br><span class="line">  &#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line">    JdbcUtils.free(rs,st,conn);  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>


<h1 id="JDBC中的可更新以及对更新敏感的结果集操作"><a href="#JDBC中的可更新以及对更新敏感的结果集操作" class="headerlink" title="JDBC中的可更新以及对更新敏感的结果集操作"></a>JDBC中的可更新以及对更新敏感的结果集操作</h1><h1 id="元数据的相关知识"><a href="#元数据的相关知识" class="headerlink" title="元数据的相关知识"></a>元数据的相关知识</h1><h2 id="数据库的元数据信息"><a href="#数据库的元数据信息" class="headerlink" title="数据库的元数据信息"></a>数据库的元数据信息</h2><h2 id="查询参数的元数据信息"><a href="#查询参数的元数据信息" class="headerlink" title="查询参数的元数据信息"></a>查询参数的元数据信息</h2><h2 id="结果集中元数据信息"><a href="#结果集中元数据信息" class="headerlink" title="结果集中元数据信息"></a>结果集中元数据信息</h2><h1 id="JDBC中的数据源"><a href="#JDBC中的数据源" class="headerlink" title="JDBC中的数据源"></a>JDBC中的数据源</h1><h1 id="JDBC中CRUD的模板模式"><a href="#JDBC中CRUD的模板模式" class="headerlink" title="JDBC中CRUD的模板模式"></a>JDBC中CRUD的模板模式</h1><h1 id="Spring框架中的JdbcTemplate"><a href="#Spring框架中的JdbcTemplate" class="headerlink" title="Spring框架中的JdbcTemplate"></a>Spring框架中的JdbcTemplate</h1><h2 id="加强版的JdbcTemplate"><a href="#加强版的JdbcTemplate" class="headerlink" title="加强版的JdbcTemplate"></a>加强版的JdbcTemplate</h2><h3 id="NamedParameterJdbcTemplate"><a href="#NamedParameterJdbcTemplate" class="headerlink" title="NamedParameterJdbcTemplate"></a>NamedParameterJdbcTemplate</h3><h3 id="SimpleJdbcTemplate"><a href="#SimpleJdbcTemplate" class="headerlink" title="SimpleJdbcTemplate"></a>SimpleJdbcTemplate</h3><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h1 id="批量"><a href="#批量" class="headerlink" title="批量"></a>批量</h1><h1 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h1><ul>
<li><code>java.sql.SQLException: Incorrect string value: &#39;\xE3\x80\x90\xE9\x80\x9A...&#39; for column &#39;msg&#39; at row 1</code><br>编码问题： 检查数据库编码，数据表编码，列编码以及连接数据库使用的<code>characterEncoding</code></li>
</ul>
<h1 id="链接数据库"><a href="#链接数据库" class="headerlink" title="链接数据库"></a>链接数据库</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.seecen.stream;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJDBC</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 1、实例话驱动类</span></span><br><span class="line"><span class="comment">	 * 2、建立到数据库的连接</span></span><br><span class="line"><span class="comment">	 * 3、将数据发送到数据库中</span></span><br><span class="line"><span class="comment">	 * 4、执行语句（select语句）</span></span><br><span class="line"><span class="comment">	 * 5、关闭</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		  ResultSet rs = <span class="keyword">null</span>;  </span><br><span class="line">		  Statement stmt = <span class="keyword">null</span>;  </span><br><span class="line">		  Connection conn = <span class="keyword">null</span>;  </span><br><span class="line">		  <span class="keyword">try</span> &#123;  </span><br><span class="line">		   Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);  </span><br><span class="line">	conn = DriverManager.getConnection(<span class="string">&quot;jdbc:oracle:thin:@192.168.0.1:1521:yuewei&quot;</span>, <span class="string">&quot;scott&quot;</span>, <span class="string">&quot;tiger&quot;</span>);  </span><br><span class="line">		   stmt = conn.createStatement();  </span><br><span class="line">		   rs = stmt.executeQuery(<span class="string">&quot;select * from dept&quot;</span>);  </span><br><span class="line">		   <span class="keyword">while</span>(rs.next()) &#123;  </span><br><span class="line">		    System.out.println(rs.getString(<span class="string">&quot;deptno&quot;</span>));  </span><br><span class="line">		   &#125;  </span><br><span class="line">		  &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;  </span><br><span class="line">		   e.printStackTrace();  </span><br><span class="line">		  &#125; <span class="keyword">catch</span> (SQLException e) &#123;  </span><br><span class="line">		   e.printStackTrace();  </span><br><span class="line">		  &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">		   <span class="keyword">try</span> &#123;  </span><br><span class="line">		    <span class="keyword">if</span>(rs != <span class="keyword">null</span>) &#123;  </span><br><span class="line">		     rs.close();  </span><br><span class="line">		     rs = <span class="keyword">null</span>;  </span><br><span class="line">		    &#125;  </span><br><span class="line">		    <span class="keyword">if</span>(stmt != <span class="keyword">null</span>) &#123;  </span><br><span class="line">		     stmt.close();  </span><br><span class="line">		     stmt = <span class="keyword">null</span>;  </span><br><span class="line">		    &#125;  </span><br><span class="line">		    <span class="keyword">if</span>(conn != <span class="keyword">null</span>) &#123;  </span><br><span class="line">		     conn.close();  </span><br><span class="line">		     conn = <span class="keyword">null</span>;  </span><br><span class="line">		    &#125;  </span><br><span class="line">		   &#125; <span class="keyword">catch</span> (SQLException e) &#123;  </span><br><span class="line">		    e.printStackTrace();  </span><br><span class="line">		   &#125;  </span><br><span class="line">		  &#125;  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.huawei.interview.lym;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.CallableStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Types;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Connection cn = <span class="keyword">null</span>;</span><br><span class="line">		CallableStatement cstmt = <span class="keyword">null</span>;		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//这里最好不要这么干，因为驱动名写死在程序中了</span></span><br><span class="line">			Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">			<span class="comment">//实际项目中，这里应用DataSource数据，如果用框架，</span></span><br><span class="line">			<span class="comment">//这个数据源不需要我们编码创建，我们只需Datasource ds = context.lookup()</span></span><br><span class="line">			<span class="comment">//cn = ds.getConnection();			</span></span><br><span class="line">			cn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///test&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">			cstmt = cn.prepareCall(<span class="string">&quot;&#123;call insert_Student(?,?,?)&#125;&quot;</span>);</span><br><span class="line">			cstmt.registerOutParameter(<span class="number">3</span>,Types.INTEGER);</span><br><span class="line">			cstmt.setString(<span class="number">1</span>, <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">			cstmt.setInt(<span class="number">2</span>, <span class="number">25</span>);</span><br><span class="line">			cstmt.execute();</span><br><span class="line">			<span class="comment">//get第几个，不同的数据库不一样，建议不写</span></span><br><span class="line">			System.out.println(cstmt.getString(<span class="number">3</span>));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/*try&#123;cstmt.close();&#125;catch(Exception e)&#123;&#125;</span></span><br><span class="line"><span class="comment">			try&#123;cn.close();&#125;catch(Exception e)&#123;&#125;*/</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(cstmt != <span class="keyword">null</span>)</span><br><span class="line">					cstmt.close();</span><br><span class="line">				<span class="keyword">if</span>(cn != <span class="keyword">null</span>)				</span><br><span class="line">					cn.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="JDBC中的PreparedStatement相比Statement的好处"><a href="#JDBC中的PreparedStatement相比Statement的好处" class="headerlink" title="JDBC中的PreparedStatement相比Statement的好处"></a>JDBC中的PreparedStatement相比Statement的好处</h1><p>1）提高性能：在使用preparedStatement对象执行sql时候，命令被数据库编译和解析，然后被放到命令缓冲区，然后每当执行同一个preparedStatement时候，他就被再解析一次，但不会在编译，在缓冲区中可以发现预编译的命令，并且可以重新使用。<br>如果你要写Insert update delete 最好使用preparedStatement，在有大量用户的企业级应用软件中，经常会执行相同的sql,使用preparedStatement会增加整体的性能。<br>2）安全性：PreparedStatement 可以防止sql注入。</p>
<h1 id="JDBC原理"><a href="#JDBC原理" class="headerlink" title="JDBC原理"></a>JDBC原理</h1><p>调用Class.forName(“com.mysql.jdbc.Driver”);   加载mysql的驱动类进内存，那么就会在DriverManager中注册自己，注册的意思简单来说就是DriverManager中保持一个Driver引用指向了自己，但是具体的实现可能不同。</p>
<p>然后嗲用DriverManager.getConnection方法得到连接对象，  这里运用到了简单工厂方法，即根据传进去得参数来具体实例化哪个驱动类。</p>
<p>可能是mysql的驱动类， 也可能是Oracle的驱动类， 具体的由传进去的参数来决定。</p>
<p>当得到Connection对象后就没DriverManager和Driver类什么事了。</p>
<p>Connection一个接口，但是它指向了具体的Connection子类对象。</p>
<p>通过Connection中定义的接口，就能够访问数据库了。</p>
<p>所以总得来说，如果要改变当前使用的数据库，那么只需要改变两个地方，</p>
<p>Class.forName(具体的参数)</p>
<p>DriverManager.getConnection(具体的参数)</p>
<p>所以我们可以在配置文件中配置这两个参数，那么我们就可以在程序运行的时候动态地改变所使用的数据库，只需要更改配置文件就行了。</p>
<p>当然了，程序肯定要有数据库第三方jar包。</p>
<hr>
<p>参考文献：</p>
<ol>
<li>[J2EE学习篇之–JDBC详解 ][<a target="_blank" rel="noopener" href="http://blog.csdn.net/jiangwei0910410003/article/details/26164629]">http://blog.csdn.net/jiangwei0910410003/article/details/26164629]</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/innerClass/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/innerClass/" class="post-title-link" itemprop="url">Java内部类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-03-09 00:00:00" itemprop="dateCreated datePublished" datetime="2016-03-09T00:00:00+08:00">2016-03-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-04 09:10:28" itemprop="dateModified" datetime="2021-04-04T09:10:28+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是内部类？分为哪几种？"><a href="#什么是内部类？分为哪几种？" class="headerlink" title="什么是内部类？分为哪几种？"></a>什么是内部类？分为哪几种？</h1><p>内部类是指在一个外部类的内部再定义一个类。内部类作为外部类的一个成员，并且依附于外部类而存在的。内部类可为静态，可用protected和private修饰（而外部类只能使用public和缺省的包访问权限）。<br>内部类主要有以下几类：成员内部类、局部内部类、静态内部类、匿名内部类。</p>
<h1 id="为什么需要内部类？"><a href="#为什么需要内部类？" class="headerlink" title="为什么需要内部类？"></a>为什么需要内部类？</h1><p>典型的情况是，内部类继承自某个类或实现某个接口，内部类的代码操作创建其的外围类的对象。所以你可以认为内部类提供了某种进入其外围类的窗口。<br>使用内部类最吸引人的原因是：每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。如果没有内部类提供的可以继承多个具体的或抽象的类的能力，一些设计与编程问题就很难解决。从这个角度看，内部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。</p>
<h1 id="内部类可以引用它的包含类的成员吗？有没有什么限制？"><a href="#内部类可以引用它的包含类的成员吗？有没有什么限制？" class="headerlink" title="内部类可以引用它的包含类的成员吗？有没有什么限制？"></a>内部类可以引用它的包含类的成员吗？有没有什么限制？</h1><p>完全可以。如果不是静态内部类，那没有什么限制！<br>如果你把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员，例如，下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span></span><br><span class="line"><span class="class">	</span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			syso(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答题时，也要能察言观色，揣摩提问者的心思，显然人家希望你说的是静态内部类不能访问外部类的成员，但你一上来就顶牛，这不好，要先顺着人家，让人家满意，然后再说特殊情况，让人家吃惊。</p>
<h1 id="Anonymous-Inner-Class-匿名内部类-是否可以extends-继承-其它类，是否可以implements-实现-interface-接口"><a href="#Anonymous-Inner-Class-匿名内部类-是否可以extends-继承-其它类，是否可以implements-实现-interface-接口" class="headerlink" title="Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)?"></a>Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)?</h1><p>可以继承其他类或实现其他接口。不仅是可以，而是必须!</p>
<h1 id="如何调用内部类？"><a href="#如何调用内部类？" class="headerlink" title="如何调用内部类？"></a>如何调用内部类？</h1><hr>
<p>参考文献</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://www.codeceo.com/article/java-memory-model-volatile.html" title="Java内存模型与volatile关键字">Java内存模型与volatile关键字</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/memory/" class="post-title-link" itemprop="url">Java内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-03-04 00:00:00" itemprop="dateCreated datePublished" datetime="2016-03-04T00:00:00+08:00">2016-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-04 09:10:28" itemprop="dateModified" datetime="2021-04-04T09:10:28+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java内存管理原理"><a href="#Java内存管理原理" class="headerlink" title="Java内存管理原理"></a>Java内存管理原理</h1><p>在Java运行体系结构中，存在Java程序、虚拟机和操作系统三个层次，Java程序与虚拟机交互(即<a href="/java-jni/" title="JNI：Java native interface ">JNI</a>)，虚拟机与操作系统间交互！这就保证了Java程序的平台无关性。</p>
<p>程序运行前，JVM向操作系统申请一定的内存空间，称为初始内存空间。</p>
<p>程序运行过程中，Java程序一直向Java虚拟机申请内存，当超过初始内存空间时，Java虚拟机再次向操作系统申请。当虚拟机已申请的内存超过规定的最大内存空间再申请时，将会出现内存溢出错误。</p>
<h1 id="内存的分配"><a href="#内存的分配" class="headerlink" title="内存的分配"></a>内存的分配</h1><p>Java内存可以分为方法区、heap(堆)和stack(栈)。</p>
<ul>
<li>方法区，默认64M，Java虚拟机会将加载的类存入，保存类的结构，静态成员等。</li>
<li>heap(堆)，默认64M，存放对象持有的数据，<strong>保持对原类的引用</strong> 。对象的属性值保存在堆中，对象调用的方法保存在方法区。通过<code>new</code>创建的对象都在堆中。方法中的局部变量使用final修饰后，放在堆中。</li>
<li>stack(栈), 默认为1M。</li>
<li>基础类型保存在栈中</li>
<li>局部变量保存在栈中<br>程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。</li>
</ul>
<h2 id="在堆上分配内存与赋值异步性"><a href="#在堆上分配内存与赋值异步性" class="headerlink" title="在堆上分配内存与赋值异步性"></a>在堆上分配内存与赋值异步性</h2><p>在Java的指令中，创建对象和赋值操作是分开进行的，如<code>instance=new Singleton();</code>语句是分为两步进行的，但是JVM并不保证这两个操作的先后顺序，也就是有可能JVM会为Singleton实例分配空间， 然后直接赋值给 <code>instance</code>成员，然后再去初始化这个Singleton实例。这样就可能出错了，我们以A、B两个线程为例：</p>
<ol>
<li>A、B线程同时进入了第一个if判断</li>
<li>A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton();</li>
<li>由于JVM内部的优化机制，JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块。</li>
<li>B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序。</li>
<li>此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了。</li>
</ol>
<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">3</span>;</span><br><span class="line">a=<span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>编译器先处理<code>int a=3;</code>:<br>首先，在栈中创建一个变量为a的引用，然后查找有没有字面量为3的地址。没有，则开辟一个存放3这个字面量的地址，然后将a指向这个地址。</p>
</li>
<li><p>再处理<code>int b=3;</code>:<br>首先创建一个变量为b的引用，然后查找发现已经存在字面量为3的地址，将b指向这个地址。</p>
</li>
<li><p>如果此时，再<code>a=4;</code>:<br>那么，虚拟机存在是否存在4这个字面量，如果存在，直接将a指向这个地址；否则，创建4这个字面量，将a指向这个字面量的地址。</p>
</li>
</ul>
<p>因此改变了a的值，只是a重新指向别的地方，不会影响b的值。</p>
<h2 id="对象存储"><a href="#对象存储" class="headerlink" title="对象存储"></a>对象存储</h2><blockquote>
<p>方法的存储</p>
</blockquote>
<p>定义如下类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoxSet</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> width=<span class="number">100</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> hight=<span class="number">200</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BoxSet</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.width=x;</span><br><span class="line">    <span class="keyword">this</span>.hight=y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BoxSet boxSet; <span class="comment">// (1)</span></span><br><span class="line">boxSet=<span class="keyword">new</span> BoxSet(<span class="number">50</span>,<span class="number">50</span>); <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure>
<p>两条语句:</p>
<ol>
<li>声明变量boxSet：</li>
</ol>
<ul>
<li>在栈内存中，为对象的引用变量<code>boxSet</code>分配内存空间。但是<code>boxSet</code>的值为空，称<code>boxSet</code>为一个空对象。空对象不能使用，因为它没有引用任何“实体”。</li>
</ul>
<ol start="2">
<li>会做两件事：</li>
</ol>
<ul>
<li>在堆内存中，为类的成员变量<code>width</code>和<code>hight</code>分配内存，并赋值为各数据类型的默认值。</li>
<li>显式初始化: 类定义时的初始化值，即<code>width</code>赋值为100，<code>hight</code>赋值为200</li>
<li>调用构造方法: 为<code>width</code>和<code>hight</code>分别赋值为50和50</li>
<li>返回堆内存中对象的引用给引用变量<code>boxSet</code></li>
</ul>
<h2 id="方法存储"><a href="#方法存储" class="headerlink" title="方法存储"></a>方法存储</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  Collar c;</span><br><span class="line">  String name;</span><br><span class="line"><span class="comment">//1. main()方法位于栈上</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//2. 在栈上创建引用变量d,但Dog对象尚未存在</span></span><br><span class="line">    Dog d;</span><br><span class="line"><span class="comment">//3. 在堆上创建新的Dog对象，并将其赋予d引用变量</span></span><br><span class="line">    d = <span class="keyword">new</span> Dog();</span><br><span class="line"><span class="comment">//4. 将引用变量的一个副本传递给go()方法</span></span><br><span class="line">    d.go(d);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//5. 将go()方法置于栈上，并将dog参数作为局部变量(局部变量位于栈上)</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">go</span><span class="params">(Dog dog)</span></span>&#123;</span><br><span class="line"><span class="comment">//6. 在堆上创建新的Collar对象，并将其赋予Dog的实例变量</span></span><br><span class="line">    c =<span class="keyword">new</span> Collar();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//7.将setName()添加到栈上，并将dogName参数作为其局部变量</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(String dogName)</span></span>&#123;</span><br><span class="line"><span class="comment">//8. name的实例对象也引用String对象</span></span><br><span class="line">    name=dogName;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//9. 程序执行完成后，setName()将会完成并从栈中清除，</span></span><br><span class="line"><span class="comment">//此时，局部变量dogName也会消失，尽管它所引用的String仍在堆上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><blockquote>
<p>2.String StringBuffered 与 StringBuilder 区别</p>
</blockquote>
<p>Java中的基本变量都存在包装类，如下表：</p>
<table>
<thead>
<tr>
<th>0</th>
<th>基本变量</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>2</td>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>3</td>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>4</td>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>5</td>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>6</td>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>7</td>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>8</td>
<td>char</td>
<td>Character</td>
</tr>
</tbody></table>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>在栈内存中为对象的引用变量<code>s</code>分配内存</li>
<li>查找字面量<code>&quot;abc&quot;</code>，如果存在则将该地址赋值给s; 否则，新建字面量<code>&quot;abc&quot;</code>并将赋值给s。</li>
</ol>
<p>继续看下面的例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s=<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>); <span class="comment">//(2)</span></span><br></pre></td></tr></table></figure>
<p>方式2:</p>
<ol>
<li>在栈内存中为对象的引用变量<code>s</code>分配内存</li>
<li>在堆中新建String对象，并将地址赋值给栈中的s</li>
<li>在栈内存中，查找字面量”abc”, 如果存在则将字面量地址作为参数传递给赋值给栈中s指向的String对象；否则，新建字面量”abc”.<br>因此，在这个过程中共产生了两个对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str1==str2);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>　　注意，我们这里并不用<code>str1.equals(str2)；</code>的方式，因为这将比较两个字符串的值是否相等。<code>==</code>号，根据JDK的说明，只有在两个引用都指向了同一个对象时才返回真值。而我们在这里要看的是，str1与str2是否都指向了同一个对象。<br>结果说明，JVM创建了两个引用str1和str2，但只创建了一个对象，而且两个引用都指向了这个对象。</p>
<p>String可以用<code>String str = new String(&quot;abc&quot;);</code>的形式来创建，也可以用<code>String str = &quot;abc&quot;；</code>的形式来创建，这种表达式是可以的！前者是规范的类的创建过程，即在Java中，一切都是对象，而对象是类的实例，全部通过new()的形式来创建。那为什么在<code>String str = &quot;abc&quot;；</code>中，并没有通过<code>new()</code>来创建实例，是不是违反了上述原则？其实没有。</p>
<p>我们再来更进一步，将以上代码改成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">str1 = <span class="string">&quot;bcd&quot;</span>;</span><br><span class="line">System.out.println(str1==str2);   <span class="comment">//false</span></span><br><span class="line">System.out.println(str1 + <span class="string">&quot;,&quot;</span> + str2);   <span class="comment">//bcd, abc</span></span><br></pre></td></tr></table></figure>
<p>　　这就是说，赋值的变化导致了类对象引用的变化，str1指向了另外一个新对象！而str2仍旧指向原来的对象。上例中，当我们将str1的值改为”bcd”时，JVM发现在栈中没有存放该值的地址，便开辟了这个地址，并创建了一个新的对象，其字符串的值指向这个地址。<br>　　事实上，String类被设计成为不可改变(immutable)的类。如果你要改变其值，可以，但JVM在运行时根据新值悄悄创建了一个新对象，然后将这个对象的地址返回给原来类的引用。这个创建过程虽说是完全自动进行的，但它毕竟占用了更多的时间。在对时间要求比较敏感的环境中，会带有一定的不良影响。</p>
<p>　　再修改原来代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">　　String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">　　String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">　　str1 = <span class="string">&quot;bcd&quot;</span>;</span><br><span class="line"></span><br><span class="line">　　String str3 = str1;</span><br><span class="line">　　System.out.println(str3);   <span class="comment">//bcd</span></span><br><span class="line"></span><br><span class="line">　　String str4 = <span class="string">&quot;bcd&quot;</span>;</span><br><span class="line">　　System.out.println(str1 == str4);   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>　　str3 这个对象的引用直接指向str1所指向的对象(注意，str3并没有创建新对象)。当str1改完其值后，再创建一个String的引用str4，并指向因str1修改值而创建的新的对象。可以发现，这回str4也没有创建新的对象，从而再次实现栈中数据的共享。</p>
<p>　　我们再接着看以下的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">　　String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">　　System.out.println(str1==str2);   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>　　创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　String str1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">　　String str2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">　　System.out.println(str1==str2);   <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>　　创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。</p>
<p>　　以上两段代码说明，<strong>只要是用new()来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享。</strong></p>
<p>　　6). <strong>数据类型包装类的值不可修改</strong>。不仅仅是String类的值不可修改，所有的数据类型包装类都不能更改其内部的值。</p>
<h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>Volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p>
<p>首先, 应该明白计算机内部都做什么了。比如做了一个i++操作，计算机内部做了三次处理：读取－修改－写入。<br>同样，对于一个long型数据，做了个赋值操作，在32系统下需要经过两步才能完成，先修改低32位，然后修改高32位。<br>假想一下，当将以上的操作放到一个多线程环境下操作时候，有可能出现的问题，是这些步骤执行了一部分，而另外一个线程就已经引用了变量值，这样就导致了读取脏数据的问题。<br>通过这个设想，就不难理解volatile关键字了。</p>
<p>volatile可以用在任何变量前面，但不能用于final变量前面，因为final型的变量是禁止修改的。也不存在线程安全的问题。</p>
<h1 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h1><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾回收是一种动态存储管理技术，它自动地释放不再被程序引用的对象，按照特定的垃圾收集算法来实现资源自动回收的功能。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用，以免造成内存泄露。</p>
<p>一般是在CPU空闲或空间不足时自动进行垃圾回收，而程序员无法精确控制垃圾回收的时机和顺序等。<br>当没有任何获得线程能访问一个对象时，该对象就符合垃圾回收条件。<br> 垃圾回收器如发现一个对象不能被任何活线程访问时，他将认为该对象符合删除条件，就将其加入回收队列，但不是立即销毁对象，何时销毁并释放内存是无法预知的。垃圾回收不能强制执行，然而Java提供了一些方法（如：System.gc()方法），允许你请求JVM执行垃圾回收，而不是要求，虚拟机会尽其所能满足请求，但是不能保证JVM从内存中删除所有不用的对象。</p>
<h3 id="符合垃圾回收的条件"><a href="#符合垃圾回收的条件" class="headerlink" title="符合垃圾回收的条件"></a>符合垃圾回收的条件</h3><ol>
<li>空引用</li>
<li>重新为引用变量赋值：可以通过设置引用变量引用另一个对象来解除该引用变量与一个对象间的引用关系。</li>
<li>方法内创建的对象：所创建的局部变量仅在该方法的作用期间内存在。一旦该方法返回，在这个方法内创建的对象就符合垃圾收集条件。有一种明显的例外情况，就是方法的返回对象。</li>
<li>隔离引用：这种情况中，被回收的对象仍具有引用，这种情况称作隔离岛。若存在这两个实例，他们互相引用，并且这两个对象的所有其他引用都删除，其他任何线程无法访问这两个对象中的任意一个。也可以符合垃圾回收条件。</li>
</ol>
<h3 id="强制垃圾回收"><a href="#强制垃圾回收" class="headerlink" title="强制垃圾回收"></a>强制垃圾回收</h3><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>java提供了一种机制，使你能够在对象刚要被垃圾回收之前运行一些代码。这段代码位于名为finalize()的方法内，所有类从Object类继承这个方法。由于不能保证垃圾回收器会删除某个对象。因此放在finalize()中的代码无法保证运行。因此建议不要重写finalize();</p>
<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点:<br>首先，这些对象是有被引用的，即在有向树形图中，存在树枝通路可以与其相连；<br>其次，这些对象是无用的，即程序以后不会再使用这些对象。<br>如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Vector v = <span class="keyword">new</span> Vector(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Object o = <span class="keyword">new</span> Object();  </span><br><span class="line">v.add(o);  </span><br><span class="line">o = <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//此时，所有的Object对象都没有被释放，因为变量v引用这些对象。   实际上无用，而还被引用的对象，GC就无能为力了(事实上GC认为它还有用)，这一点是导致内存泄漏最重要的原因。</p>
<h1 id="优化编程"><a href="#优化编程" class="headerlink" title="优化编程"></a>优化编程</h1><h2 id="1-不要显式调用System-gc"><a href="#1-不要显式调用System-gc" class="headerlink" title="(1)不要显式调用System.gc()"></a>(1)不要显式调用System.gc()</h2><p>　　此函数建议JVM进行主GC,虽然只是建议而非一定,但很多情况下它会触发主GC,从而增加主GC的频率,也即增加了间歇性停顿的次数。</p>
<h2 id="2-尽量减少临时对象的使用"><a href="#2-尽量减少临时对象的使用" class="headerlink" title="(2)尽量减少临时对象的使用"></a>(2)尽量减少临时对象的使用</h2><p>　　临时对象在跳出函数调用后,会成为垃圾,少用临时变量就相当于减少了垃圾的产生,从而延长了出现上述第二个触发条件出现的时间,减少了主GC的机会。</p>
<h2 id="3-对象不用时最好显式置为Null"><a href="#3-对象不用时最好显式置为Null" class="headerlink" title="(3)对象不用时最好显式置为Null"></a>(3)对象不用时最好显式置为Null</h2><p>　　一般而言,为Null的对象都会被作为垃圾处理,所以将不用的对象显式地设为Null,有利于GC收集器判定垃圾,从而提高了GC的效率。</p>
<h2 id="4-尽量使用StringBuffer-而不用String来累加字符串"><a href="#4-尽量使用StringBuffer-而不用String来累加字符串" class="headerlink" title="(4)尽量使用StringBuffer,而不用String来累加字符串"></a>(4)尽量使用StringBuffer,而不用String来累加字符串</h2><p>   由于String是固定长的字符串对象,累加String对象时,并非在一个String对象中扩增,而是重新创建新的String对象,如Str5=Str1+Str2+Str3+Str4,这条语句执行过程中会产生多个垃圾对象,因为对次作“+”操作时都必须创建新的String对象,但这些过渡对象对系统来说是没有实际意义的,只会增加更多的垃圾。避免这种情况可以改用StringBuffer来累加字符串,因StringBuffer是可变长的,它在原有基础上进行扩增,不会产生中间对象。</p>
<h2 id="5-能用基本类型如Int-Long-就不用Integer-Long对象"><a href="#5-能用基本类型如Int-Long-就不用Integer-Long对象" class="headerlink" title="(5)能用基本类型如Int,Long,就不用Integer,Long对象"></a>(5)能用基本类型如Int,Long,就不用Integer,Long对象</h2><p>　　基本类型变量占用的内存资源比相应对象占用的少得多,如果没有必要,最好使用基本变量。</p>
<h2 id="6-尽量少用静态对象变量"><a href="#6-尽量少用静态对象变量" class="headerlink" title="(6)尽量少用静态对象变量"></a>(6)尽量少用静态对象变量</h2><p>　　静态变量属于全局变量,不会被GC回收,它们会一直占用内存。</p>
<h2 id="7-分散对象创建或删除的时间"><a href="#7-分散对象创建或删除的时间" class="headerlink" title="(7)分散对象创建或删除的时间"></a>(7)分散对象创建或删除的时间</h2><p>　集中在短时间内大量创建新对象,特别是大对象,会导致突然需要大量内存,JVM在面临这种情况时,只能进行主GC,以回收内存或整合内存碎片,从而增加主GC的频率。集中删除对象,道理也是一样的。它使得突然出现了大量的垃圾对象,空闲空间必然减少,从而大大增加了下一次创建新对象时强制主GC的机会。</p>
<hr>
<p>参考文献</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://www.codeceo.com/article/java-memory-model-volatile.html" title="Java内存模型与volatile关键字">Java内存模型与volatile关键字</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/generic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/generic/" class="post-title-link" itemprop="url">Java基础之泛型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-03-02 00:00:00" itemprop="dateCreated datePublished" datetime="2016-03-02T00:00:00+08:00">2016-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-04 09:10:28" itemprop="dateModified" datetime="2021-04-04T09:10:28+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="普通泛型"><a href="#普通泛型" class="headerlink" title="普通泛型"></a>普通泛型</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&lt;<span class="title">T</span>&gt;</span>&#123;       <span class="comment">// 此处可以随便写标识符号，T是type的名称参数</span></span><br><span class="line">   <span class="keyword">private</span> T <span class="keyword">var</span> ; <span class="comment">// var的类型由T指定，即：由外部指定</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>&#123;  <span class="comment">// 返回值的类型由外部决定</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">var</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;  <span class="comment">// 设置的类型也由外部决定</span></span><br><span class="line">       <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo06</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">       Point&lt;String&gt; p = <span class="keyword">new</span> Point&lt;String&gt;() ; <span class="comment">// 里面的var类型为String类型</span></span><br><span class="line">       p.setVar(<span class="string">&quot;it&quot;</span>) ;        <span class="comment">// 设置字符串</span></span><br><span class="line">       System.out.println(p.getVar().length()) ;   <span class="comment">// 取得字符串的长度</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> ----------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Notepad</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;       <span class="comment">// 此处指定了两个泛型类型</span></span><br><span class="line">     <span class="keyword">private</span> K key ;     <span class="comment">// 此变量的类型由外部决定</span></span><br><span class="line">     <span class="keyword">private</span> V value ;   <span class="comment">// 此变量的类型由外部决定</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.key ;</span><br><span class="line">     &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.value ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.key = key ;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(V value)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.value = value ;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo09</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">         Notepad&lt;String,Integer&gt; t = <span class="keyword">null</span> ;        <span class="comment">// 定义两个泛型类型的对象</span></span><br><span class="line">         t = <span class="keyword">new</span> Notepad&lt;String,Integer&gt;() ;       <span class="comment">// 里面的key为String，value为Integer</span></span><br><span class="line">        t.setKey(<span class="string">&quot;汤姆&quot;</span>) ;        <span class="comment">// 设置第一个内容</span></span><br><span class="line">         t.setValue(<span class="number">20</span>) ;            <span class="comment">// 设置第二个内容</span></span><br><span class="line">         System.out.print(<span class="string">&quot;姓名；&quot;</span> + t.getKey()) ;      <span class="comment">// 取得信息</span></span><br><span class="line">         System.out.print(<span class="string">&quot;，年龄；&quot;</span> + t.getValue()) ;       <span class="comment">// 取得信息</span></span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;     <span class="comment">// 定义泛型变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;   <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>.toString() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo14</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Info&lt;String&gt; i = <span class="keyword">new</span> Info&lt;String&gt;() ;       <span class="comment">// 使用String为泛型类型</span></span><br><span class="line">        i.setVar(<span class="string">&quot;it&quot;</span>) ;                            <span class="comment">// 设置内容</span></span><br><span class="line">        fun(i) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Info&lt;?&gt; temp)</span></span>&#123;     <span class="comment">// 可以接收任意的泛型对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;内容：&quot;</span> + temp) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="受限泛型"><a href="#受限泛型" class="headerlink" title="受限泛型"></a>受限泛型</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">private</span> T <span class="keyword">var</span> ;     <span class="comment">// 定义泛型变量</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;   <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>.toString() ;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo17</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Info&lt;Integer&gt; i1 = <span class="keyword">new</span> Info&lt;Integer&gt;() ;        <span class="comment">// 声明Integer的泛型对象</span></span><br><span class="line">         Info&lt;Float&gt; i2 = <span class="keyword">new</span> Info&lt;Float&gt;() ;            <span class="comment">// 声明Float的泛型对象</span></span><br><span class="line">         i1.setVar(<span class="number">30</span>) ;                                 <span class="comment">// 设置整数，自动装箱</span></span><br><span class="line">         i2.setVar(<span class="number">30.1f</span>) ;                              <span class="comment">// 设置小数，自动装箱</span></span><br><span class="line">         fun(i1) ;</span><br><span class="line">        fun(i2) ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Info&lt;? extends Number&gt; temp)</span></span>&#123;  <span class="comment">// 只能接收Number及其Number的子类</span></span><br><span class="line">         System.out.print(temp + <span class="string">&quot;、&quot;</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">private</span> T <span class="keyword">var</span> ;     <span class="comment">// 定义泛型变量</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;   <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>.toString() ;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo21</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Info&lt;String&gt; i1 = <span class="keyword">new</span> Info&lt;String&gt;() ;      <span class="comment">// 声明String的泛型对象</span></span><br><span class="line">         Info&lt;Object&gt; i2 = <span class="keyword">new</span> Info&lt;Object&gt;() ;      <span class="comment">// 声明Object的泛型对象</span></span><br><span class="line">         i1.setVar(<span class="string">&quot;hello&quot;</span>) ;</span><br><span class="line">         i2.setVar(<span class="keyword">new</span> Object()) ;</span><br><span class="line">         fun(i1) ;</span><br><span class="line">        fun(i2) ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Info&lt;? <span class="keyword">super</span> String&gt; temp)</span></span>&#123;    <span class="comment">// 只能接收String或Object类型的泛型</span></span><br><span class="line">         System.out.print(temp + <span class="string">&quot;、&quot;</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="泛型无法向上转型"><a href="#泛型无法向上转型" class="headerlink" title="泛型无法向上转型"></a>泛型无法向上转型</h1> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">private</span> T <span class="keyword">var</span> ;     <span class="comment">// 定义泛型变量</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;   <span class="comment">// 直接打印</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>.toString() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo23</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Info&lt;String&gt; i1 = <span class="keyword">new</span> Info&lt;String&gt;() ;      <span class="comment">// 泛型类型为String</span></span><br><span class="line">        Info&lt;Object&gt; i2 = <span class="keyword">null</span> ;</span><br><span class="line">        i2 = i1 ;                               <span class="comment">//这句会出错 incompatible types</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span>&#123;        <span class="comment">// 在接口上定义泛型</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span> </span>; <span class="comment">// 定义抽象方法，抽象方法的返回值就是泛型类型</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfoImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span>&#123;   <span class="comment">// 定义泛型接口的子类</span></span><br><span class="line">   <span class="keyword">private</span> T <span class="keyword">var</span> ;             <span class="comment">// 定义属性</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">InfoImpl</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;     <span class="comment">// 通过构造方法设置属性内容</span></span><br><span class="line">       <span class="keyword">this</span>.setVar(<span class="keyword">var</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span> ;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo24</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arsg[])</span></span>&#123;</span><br><span class="line">         Info&lt;String&gt; i = <span class="keyword">null</span>;        <span class="comment">// 声明接口对象</span></span><br><span class="line">         i = <span class="keyword">new</span> InfoImpl&lt;String&gt;(<span class="string">&quot;汤姆&quot;</span>) ;  <span class="comment">// 通过子类实例化对象</span></span><br><span class="line">         System.out.println(<span class="string">&quot;内容：&quot;</span> + i.getVar()) ;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> ----------------------------------------------------------</span><br><span class="line"> <span class="class"><span class="keyword">interface</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span>&#123;        <span class="comment">// 在接口上定义泛型</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span> </span>; <span class="comment">// 定义抽象方法，抽象方法的返回值就是泛型类型</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">InfoImpl</span> <span class="keyword">implements</span> <span class="title">Info</span>&lt;<span class="title">String</span>&gt;</span>&#123;   <span class="comment">// 定义泛型接口的子类</span></span><br><span class="line">     <span class="keyword">private</span> String <span class="keyword">var</span> ;                <span class="comment">// 定义属性</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">InfoImpl</span><span class="params">(String <span class="keyword">var</span>)</span></span>&#123;        <span class="comment">// 通过构造方法设置属性内容</span></span><br><span class="line">         <span class="keyword">this</span>.setVar(<span class="keyword">var</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(String <span class="keyword">var</span>)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getVar</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span> ;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo25</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arsg[])</span></span>&#123;</span><br><span class="line">         Info i = <span class="keyword">null</span>;      <span class="comment">// 声明接口对象</span></span><br><span class="line">         i = <span class="keyword">new</span> InfoImpl(<span class="string">&quot;汤姆&quot;</span>) ;    <span class="comment">// 通过子类实例化对象</span></span><br><span class="line">         System.out.println(<span class="string">&quot;内容：&quot;</span> + i.getVar()) ;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">fun</span><span class="params">(T t)</span></span>&#123;            <span class="comment">// 可以接收任意类型的数据</span></span><br><span class="line">        <span class="keyword">return</span> t ;                  <span class="comment">// 直接把参数返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo26</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Demo d = <span class="keyword">new</span> Demo() ;   <span class="comment">// 实例化Demo对象</span></span><br><span class="line">        String str = d.fun(<span class="string">&quot;汤姆&quot;</span>) ; <span class="comment">//   传递字符串</span></span><br><span class="line">        <span class="keyword">int</span> i = d.fun(<span class="number">30</span>) ;     <span class="comment">// 传递数字，自动装箱</span></span><br><span class="line">        System.out.println(str) ;   <span class="comment">// 输出内容</span></span><br><span class="line">        System.out.println(i) ;     <span class="comment">// 输出内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="通过泛型方法返回泛型类型实例"><a href="#通过泛型方法返回泛型类型实例" class="headerlink" title="通过泛型方法返回泛型类型实例"></a>通过泛型方法返回泛型类型实例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span>&#123; <span class="comment">// 指定上限，只能是数字类型</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;     <span class="comment">// 此类型由外部决定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;       <span class="comment">// 覆写Object类中的toString()方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>.toString() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo27</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Info&lt;Integer&gt; i = fun(<span class="number">30</span>) ;</span><br><span class="line">        System.out.println(i.getVar()) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Number&gt; <span class="function">Info&lt;T&gt; <span class="title">fun</span><span class="params">(T param)</span></span>&#123;<span class="comment">//方法中传入或返回的泛型类型由调用方法时所设置的参数类型决定</span></span><br><span class="line">        Info&lt;T&gt; temp = <span class="keyword">new</span> Info&lt;T&gt;() ;      <span class="comment">// 根据传入的数据类型实例化Info</span></span><br><span class="line">        temp.setVar(param) ;        <span class="comment">// 将传递的内容设置到Info对象的var属性之中</span></span><br><span class="line">        <span class="keyword">return</span> temp ;   <span class="comment">// 返回实例化对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="使用泛型统一传入的参数类型"><a href="#使用泛型统一传入的参数类型" class="headerlink" title="使用泛型统一传入的参数类型"></a>使用泛型统一传入的参数类型</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span>&lt;<span class="title">T</span>&gt;</span>&#123;    <span class="comment">// 指定上限，只能是数字类型</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;     <span class="comment">// 此类型由外部决定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;       <span class="comment">// 覆写Object类中的toString()方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span>.toString() ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo28</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Info&lt;String&gt; i1 = <span class="keyword">new</span> Info&lt;String&gt;() ;</span><br><span class="line">        Info&lt;String&gt; i2 = <span class="keyword">new</span> Info&lt;String&gt;() ;</span><br><span class="line">        i1.setVar(<span class="string">&quot;HELLO&quot;</span>) ;        <span class="comment">// 设置内容</span></span><br><span class="line">        i2.setVar(<span class="string">&quot;汤姆&quot;</span>) ;       <span class="comment">// 设置内容</span></span><br><span class="line">        add(i1,i2) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Info&lt;T&gt; i1,Info&lt;T&gt; i2)</span></span>&#123;</span><br><span class="line">        System.out.println(i1.getVar() + <span class="string">&quot; &quot;</span> + i2.getVar()) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo30</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Integer i[] = fun1(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>) ;   <span class="comment">// 返回泛型数组</span></span><br><span class="line">        fun2(i) ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] fun1(T...arg)&#123;  <span class="comment">// 接收可变参数</span></span><br><span class="line">      <span class="keyword">return</span> arg ;            <span class="comment">// 返回泛型数组</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">(T param[])</span></span>&#123;   <span class="comment">// 输出</span></span><br><span class="line">      System.out.print(<span class="string">&quot;接收泛型数组：&quot;</span>) ;</span><br><span class="line">        <span class="keyword">for</span>(T t:param)&#123;</span><br><span class="line">            System.out.print(t + <span class="string">&quot;、&quot;</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="泛型的嵌套设置"><a href="#泛型的嵌套设置" class="headerlink" title="泛型的嵌套设置"></a>泛型的嵌套设置</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span>&lt;<span class="title">T</span>,<span class="title">V</span>&gt;</span>&#123;      <span class="comment">// 接收两个泛型类型</span></span><br><span class="line">    <span class="keyword">private</span> T <span class="keyword">var</span> ;</span><br><span class="line">    <span class="keyword">private</span> V value ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(T <span class="keyword">var</span>,V value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setVar(<span class="keyword">var</span>) ;</span><br><span class="line">        <span class="keyword">this</span>.setValue(value) ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVar</span><span class="params">(T <span class="keyword">var</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">var</span> = <span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(V value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getVar</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">var</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&lt;<span class="title">S</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> S info ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(S info)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setInfo(info) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(S info)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.info = info ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> S <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.info ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsDemo31</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Demo&lt;Info&lt;String,Integer&gt;&gt; d = <span class="keyword">null</span> ;       <span class="comment">// 将Info作为Demo的泛型类型</span></span><br><span class="line">        Info&lt;String,Integer&gt; i = <span class="keyword">null</span> ;   <span class="comment">// Info指定两个泛型类型</span></span><br><span class="line">        i = <span class="keyword">new</span> Info&lt;String,Integer&gt;(<span class="string">&quot;汤姆&quot;</span>,<span class="number">30</span>) ;    <span class="comment">// 实例化Info对象</span></span><br><span class="line">        d = <span class="keyword">new</span> Demo&lt;Info&lt;String,Integer&gt;&gt;(i) ; <span class="comment">// 在Demo类中设置Info类的对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;内容一：&quot;</span> + d.getInfo().getVar()) ;</span><br><span class="line">        System.out.println(<span class="string">&quot;内容二：&quot;</span> + d.getInfo().getValue()) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 泛型方法不一定要通过参数来确定泛型准确类型，可以只通过返回值，比如：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">ArrayList&lt;E&gt; <span class="title">newArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;E&gt;();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;PrepaidHistory&gt; <span class="title">queryHistories</span><span class="params">(Long skyid,PrepaidHistoryType type, Date from, Date end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　　　。。。</span><br><span class="line">            <span class="keyword">return</span> Lists.newArrayList();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>这样<code>Lists.newArrayList()</code>;<br>智能的知道返回类型为<code>PrepaidHistory</code></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>//TODO 继承泛型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextFile</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/network/base/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/network/base/" class="post-title-link" itemprop="url">计算机网络基础知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-02-02 00:00:00" itemprop="dateCreated datePublished" datetime="2016-02-02T00:00:00+08:00">2016-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-04 09:10:28" itemprop="dateModified" datetime="2021-04-04T09:10:28+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="OSI七层模型-amp-常见五层模型"><a href="#OSI七层模型-amp-常见五层模型" class="headerlink" title="OSI七层模型 &amp; 常见五层模型"></a>OSI七层模型 &amp; 常见五层模型</h1><p>OSI（Open System Interconnection, 开放系统互连）七层网络模型称为开放式系统互联参考模型 , 是一个逻辑上的定义, 一个规范, 它把网络从逻辑上分为了7层. 每一层都有相关、相对应的物理设备, 比如路由器(网络层), 交换机(数据链路层). OSI 七层模型是一种框架性的设计方法 , 建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题, 其最主要的功能就是帮助不同类型的主机实现数据传输. 它的最大优点是将服务、接口和协议这三个概念明确地区分开来, 通过七个层次化的结构模型使不同的系统不同的网络之间实现可靠的通讯. </p>
<p><img src="/images/network/7.jpg"></p>
<table>
<thead>
<tr>
<th>应用层</th>
</tr>
</thead>
<tbody><tr>
<td>表示层</td>
</tr>
<tr>
<td>会话层</td>
</tr>
<tr>
<td>传输层：TCP/UDP</td>
</tr>
<tr>
<td>网络层: IP/ICMP</td>
</tr>
<tr>
<td>数据链路层: ARP/HDLC/PPP/SLIP</td>
</tr>
<tr>
<td>物理层</td>
</tr>
</tbody></table>
<p>图1 OSI七层模型</p>
<p>目前较为常用的5层模型, 模型分层如图2.</p>
<p><img src="/images/network/5.png"></p>
<table>
<thead>
<tr>
<th>应用层</th>
</tr>
</thead>
<tbody><tr>
<td>传输层</td>
</tr>
<tr>
<td>网络层</td>
</tr>
<tr>
<td>数据链路层</td>
</tr>
<tr>
<td>物理层</td>
</tr>
</tbody></table>
<h1 id="分层的好处"><a href="#分层的好处" class="headerlink" title="分层的好处"></a>分层的好处</h1><p>建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题. 它的最大优点是将服务、接口和协议这三个概念明确地区分开来：服务说明某一层为上一层提供一些什么功能, 接口说明上一层如何使用下层的服务, 而协议涉及如何实现本层的服务；这样各层之间具有很强的独立性, 互连网络中各实体采用什么样的协议是没有限制的, 只要向上提供相同的服务并且不改变相邻层的接口就可以了. 网络七层的划分也是为了使网络的不同功能模块（不同层次）分担起不同的职责, 从而带来如下好处：</p>
<ul>
<li>减轻问题的复杂程度, 一旦网络发生故障, 可迅速定位故障所处层次, 便于查找和纠错；</li>
<li>在各层分别定义标准接口, 使具备相同对等层的不同网络设备能实现互操作, 各层之间则相对独立, 一种高层协议可放在多种低层协议上运行；</li>
<li>能有效刺激网络技术革新, 因为每次更新都可以在小范围内进行, 不需对整个网络动大手术</li>
</ul>
<h1 id="各层功能说明"><a href="#各层功能说明" class="headerlink" title="各层功能说明"></a>各层功能说明</h1><ol>
<li><p>物理层</p>
<p>OSI 模型的最低层或第一层, 该层包括物理连网媒介, 如电缆连线连接器. 物理层的协议产生并检测电压以便发送和接收携带数据的信号. 在你的桌面PC 上插入网络接口卡, 你就建立了计算机连网的基础. 换言之, 你提供了一个物理层. 尽管物理层不提供纠错服务, 但它能够设定数据传输速率并监测数据出错率. 网络物理问题, 如电线断开, 将影响物理层. </p>
<p>用户要传递信息就要利用一些物理媒体, 如双绞线、同轴电缆等, 但具体的物理媒体并不在OSI的7层之内, 有人把物理媒体当做第0层, 物理层的任务就是为它的上一层提供一个物理连接, 以及它们的机械、电气、功能和过程特性. 如规定使用电缆和接头的类型、传送信号的电压等. 在这一层, 数据还没有被组织, 仅作为原始的位流或电气电压处理, 单位是bit比特. </p>
</li>
<li><p>数据链路层</p>
<p>OSI模型的第二层, 它控制网络层与物理层之间的通信. 它的主要功能是如何在不可靠的物理线路上进行数据的可靠传递. 为了保证传输, 从网络层接收到的数据被分割成特定的可被物理层传输的帧. 帧是用来移动数据的结构包, 它不仅包括原始数据, 还包括发送方和接收方的物理地址以及检错和控制信息. 其中的地址确定了帧将发送到何处, 而纠错和控制信息则确保帧无差错到达.  如果在传送数据时, 接收点检测到所传数据中有差错, 就要通知发送方重发这一帧. </p>
<p>数据链路层的功能独立于网络和它的节点和所采用的物理层类型, 它也不关心是否正在运行 Word 、Excel 或使用Internet. 有一些连接设备, 如交换机, 由于它们要对帧解码并使用帧信息将数据发送到正确的接收方, 所以它们是工作在数据链路层的. </p>
<p>在物理层提供比特流服务的基础上, 建立相邻结点之间的数据链路, 通过差错控制提供数据帧（Frame）在信道上无差错的传输, 并进行各电路上的动作系列. </p>
<p>数据链路层在不可靠的物理介质上提供可靠的传输. 该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等. </p>
<p>数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等. </p>
</li>
<li><p>网络层</p>
<p>OSI 模型的第三层, 其主要功能是决定如何将数据从发送方路由到接收方. </p>
<p>网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点A 到另一个网络中节点B 的最佳路径. 由于网络层处理, 并智能指导数据传送, 路由器连接网络各段, 所以路由器属于网络层. 在网络中, “路由”是基于编址方案、使用模式以及可达性来指引数据的发送. </p>
<p>网络层负责在源机器和目标机器之间建立它们所使用的路由. 这一层本身没有任何错误检测和修正机制, 因此, 网络层必须依赖于端端之间的由DLL提供的可靠传输服务. </p>
<p>网络层用于本地LAN网段之上的计算机系统建立通信, 它之所以可以这样做, 是因为它有自己的路由地址结构, 这种结构与第二层机器地址是分开的、独立的. 这种协议称为路由或可路由协议. 路由协议包括IP、Novell公司的IPX以及Apple Talk协议. </p>
<p>网络层是可选的, 它只用于当两个计算机系统处于不同的由路由器分割开的网段这种情况, 或者当通信应用要求某种网络层或传输层提供的服务、特性或者能力时. 例如, 当两台主机处于同一个LAN网段的直接相连这种情况, 它们之间的通信只使用LAN的通信机制就可以了(即OSI 参考模型的一二层). </p>
</li>
<li><p>传输层</p>
<p>传输协议同时进行流量控制或是基于接收方可接收数据的快慢程度规定适当的发送速率. 除此之外, 传输层按照网络能处理的最大尺寸将较长的数据包进行强制分割. 例如, 以太网无法接收大于1500字节的数据包. 发送方节点的传输层将数据分割成较小的数据片, 同时对每一数据片安排一序列号, 以便数据到达接收方节点的传输层时, 能以正确的顺序重组. 该过程即被称为排序. </p>
<p>工作在传输层的一种服务是 TCP/IP 协议套中的TCP （Transport Control Protocol, 传输控制协议）, UPD (User Packet Data, 用户数据报协议), 另一项传输层服务是IPX/SPX协议集的SPX（序列包交换）. </p>
</li>
</ol>
<h1 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h1><p><img src="/images/network/34.png"></p>
<h2 id="三次握手过程："><a href="#三次握手过程：" class="headerlink" title="三次握手过程："></a>三次握手过程：</h2><ul>
<li>第一次握手：host1发送一个TCP标志位SYN=1、ACK=0的数据包给host2, 并随机会产生一个Sequence number=3233.当host2接收到这个数据后, host2由SYN=1可知客户端是想要建立连接；</li>
<li>第二次握手：host2要对客户端的联机请求进行确认, 向host1发送应答号ACK=1、SYN=1、<br>确认号Acknowledge number=3234, 此值是host1的序列号加1, 还会产生一个随机的序列号Sequence number=36457, 这样就告诉host1可以进行连接；</li>
<li>第三次握手：host1收到数据后检查Acknowledge number是否是3233+1的值, 以及ACK的值是否为1, 若为1, host1会发送ACK=1、确认号码Acknowledge number=36457, 告诉host2,你的请求连接被确认, 连接可以建立. </li>
</ul>
<h2 id="四次挥手过程："><a href="#四次挥手过程：" class="headerlink" title="四次挥手过程："></a>四次挥手过程：</h2><ul>
<li>第一次挥手：当传输的数据到达尾部时, host1向host2发送FIN=1标志位；可理解成, host1向host2说, 我这边的数据传送完成了, 我准备断开了连接；</li>
<li>第二次挥手：因TCP的连接是全双工的双向连接, 关闭也是要从两边关闭；当host2收到host1发来的FIN=1的标志位后, host2不会立刻向host1发送FIND=1的请求关闭信息, 而是先向host1发送一个ACK=1的应答信息, 表示：你请求关闭的请求我已经收到, 但我可能还有数据没有完成传送, 你再等下, 等我数据传输完成了我就告诉你；</li>
<li>第三次挥手：host2数据传输完成, 向host1发送FIN=1, host1收到请求关闭连接的请求后, host1就明白host2的数据已传输完成, 现在可以断开连接了, </li>
<li>第四次挥手：host1收到FIND=1后, host1还是怕由于网络不稳定的原因, 怕host2不知道他要断开连接, 于是向host2发送ACK=1确认信息进行确认, 把自己设置成TIME_WAIT状态并启动定时器, 如果host2没有收到ACK, host2端TCP的定时器到达后, 会要求host1重新发送ACK, 当host2收到ACK后, host2就断开连接；当host1等待2MLS（2倍报文最大生存时间）后, 没有收到host2的重传请求后, 他就知道host2已收到了ACK, 所以host1此时才关闭自己的连接. </li>
</ul>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="HTTPS的工作原理"><a href="#HTTPS的工作原理" class="headerlink" title="HTTPS的工作原理"></a>HTTPS的工作原理</h2><p>HTTPS在传输数据之前需要客户端(浏览器)与服务端(网站)之间进行一次握手,  在握手过程中将确立双方加密传输数据的密码信息. TLS/SSL协议不仅仅是一套加密传输的协议, 更是一件经过艺术家精心设计的艺术品, TLS/SSL中使用了非对称加密, 对称加密以及HASH算法. 握手过程的具体描述如下：</p>
<ol>
<li>浏览器将自己支持的一套加密规则发送给网站.</li>
<li>网站从中选出一组加密算法与HASH算法, 并将自己的身份信息以证书的形式发回给浏览器. 证书里面包含了网站地址, 加密公钥, 以及证书的颁发机构等信息.</li>
<li>浏览器获得网站证书之后浏览器要做以下工作：</li>
</ol>
<ul>
<li> 验证证书的合法性(颁发证书的机构是否合法, 证书中包含的网站地址是否与正在访问的地址一致等), 如果证书受信任, 则浏览器栏里面会显示一个小锁头, 否则会给出证书不受信的提示.</li>
<li> 如果证书受信任, 或者是用户接受了不受信的证书, 浏览器会生成一串随机数的密码, 并用证书中提供的公钥加密.</li>
<li> 使用约定好的HASH算法计算握手消息, 并使用生成的随机数对消息进行加密, 最后将之前生成的所有信息发送给网站.</li>
</ul>
<ol start="4">
<li>网站接收浏览器发来的数据之后要做以下的操作：</li>
</ol>
<ul>
<li>使用自己的私钥将信息解密取出密码, 使用密码解密浏览器发来的握手消息, 并验证HASH是否与浏览器发来的一致.</li>
<li>使用密码加密一段握手消息, 发送给浏览器.</li>
</ul>
<ol start="5">
<li>浏览器解密并计算握手消息的HASH, 如果与服务端发来的HASH一致, 此时握手过程结束, 之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密.  这里浏览器与网站互相发送加密的握手消息并验证, 目的是为了保证双方都获得了一致的密码, 并且可以正常的加密解密数据, 为后续真正数据的传输做一次测试. 另外, HTTPS一般使用的加密与HASH算法如下：</li>
</ol>
<ul>
<li><p>非对称加密算法：RSA, DSA/DSS</p>
</li>
<li><p>对称加密算法：AES, RC4, 3DES</p>
</li>
<li><p>HASH算法：MD5, SHA1, SHA256 HTTPS对应的通信时序图如下：</p>
<p><img src="/images/network/https-process.png"></p>
</li>
</ul>
<hr>
<p>【参考文献】:</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://www.admin5.com/article/20150525/600230.shtml">HTTPS工作原理和TCP握手机制</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/network/HTTPS/optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/network/HTTPS/optimization/" class="post-title-link" itemprop="url">【转】基于协议和配置的优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-02-02 00:00:00" itemprop="dateCreated datePublished" datetime="2016-02-02T00:00:00+08:00">2016-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-04 09:10:28" itemprop="dateModified" datetime="2021-04-04T09:10:28+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>RTT(Round-Trip Time): 往返时延。表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。</p>
<h2 id="HTTPS-访问速度优化"><a href="#HTTPS-访问速度优化" class="headerlink" title="HTTPS 访问速度优化"></a>HTTPS 访问速度优化</h2><h3 id="Tcp-fast-open"><a href="#Tcp-fast-open" class="headerlink" title="Tcp fast open"></a>Tcp fast open</h3><p>HTTPS 和 HTTP 使用 TCP 协议进行传输，也就意味着必须通过三次握手建立 TCP 连接，但一个 RTT 的时间内只传输一个 syn 包是不是太浪费？能不能在 syn 包发出的同时捎上应用层的数据？其实是可以的，这也是 tcp fast open 的思路，简称 TFO。具体原理可以参考 rfc7413。</p>
<p>遗憾的是 TFO 需要高版本内核的支持，linux 从 3.7 以后支持 TFO，但是目前的 windows 系统还不支持 TFO，所以只能在公司内部服务器之间发挥作用。</p>
<h3 id="HSTS"><a href="#HSTS" class="headerlink" title="HSTS"></a>HSTS</h3><p>前面提到过将用户 HTTP 请求 302 跳转到 HTTPS，这会有两个影响：</p>
<blockquote>
<p>1、不安全，302 跳转不仅暴露了用户的访问站点，也很容易被中间者支持。</p>
<p>2、降低访问速度，302 跳转不仅需要一个 RTT，浏览器执行跳转也需要执行时间。</p>
</blockquote>
<p>由于 302 跳转事实上是由浏览器触发的，服务器无法完全控制，这个需求导致了 HSTS 的诞生：</p>
<p>HSTS(HTTP Strict Transport Security)。服务端返回一个 HSTS 的 http header，浏览器获取到 HSTS 头部之后，在一段时间内，不管用户输入<a target="_blank" rel="noopener" href="http://www.baidu.com还是http//www.baidu.com%EF%BC%8C%E9%83%BD%E4%BC%9A%E9%BB%98%E8%AE%A4%E5%B0%86%E8%AF%B7%E6%B1%82%E5%86%85%E9%83%A8%E8%B7%B3%E8%BD%AC%E6%88%90https://www.baidu.com%E3%80%82">www.baidu.com还是http://www.baidu.com，都会默认将请求内部跳转成https://www.baidu.com。</a></p>
<p>Chrome, firefox, ie 都支持了 HSTS（<a target="_blank" rel="noopener" href="http://caniuse.com/#feat=stricttransportsecurity%EF%BC%89%E3%80%82">http://caniuse.com/#feat=stricttransportsecurity）。</a></p>
<h3 id="Session-resume"><a href="#Session-resume" class="headerlink" title="Session resume"></a>Session resume</h3><p>Session resume 顾名思义就是复用 session，实现简化握手。复用 session 的好处有两个：</p>
<blockquote>
<p>1、减少了 CPU 消耗，因为不需要进行非对称密钥交换的计算。</p>
<p>2、提升访问速度，不需要进行完全握手阶段二，节省了一个 RTT 和计算耗时。</p>
</blockquote>
<p>TLS 协议目前提供两种机制实现 session resume，分别介绍一下。</p>
<h4 id="Session-cache"><a href="#Session-cache" class="headerlink" title="Session cache"></a>Session cache</h4><p>Session cache 的原理是使用 client hello 中的 session id 查询服务端的 session cache, 如果服务端有对应的缓存，则直接使用已有的 session 信息提前完成握手，称为简化握手。</p>
<p>Session cache 有两个缺点：</p>
<blockquote>
<p>1、需要消耗服务端内存来存储 session 内容。</p>
<p>2、目前的开源软件包括 nginx,apache 只支持单机多进程间共享缓存，不支持多机间分布式缓存，对于百度或者其他大型互联网公司而言，单机 session cache 几乎没有作用。</p>
</blockquote>
<p>Session cache 也有一个非常大的优点：</p>
<blockquote>
<p>session id 是 TLS 协议的标准字段，市面上的浏览器全部都支持 session cache。</p>
</blockquote>
<p>百度通过对 TLS 握手协议及服务器端实现的优化，已经支持全局的 session cache，能够明显提升用户的访问速度，节省服务器计算资源。</p>
<h4 id="Session-ticket"><a href="#Session-ticket" class="headerlink" title="Session ticket"></a>Session ticket</h4><p>上节提到了 session cache 的两个缺点，session ticket 能够弥补这些不足。</p>
<p>Session ticket 的原理参考 RFC4507。简述如下：</p>
<blockquote>
<p>server 将 session 信息加密成 ticket 发送给浏览器，浏览器后续握手请求时会发送 ticket，server 端如果能成功解密和处理 ticket，就能完成简化握手。</p>
</blockquote>
<p>显然，session ticket 的优点是不需要服务端消耗大量资源来存储 session 内容。</p>
<p>Session ticket 的缺点：</p>
<blockquote>
<p>1、session ticket 只是 TLS 协议的一个扩展特性，目前的支持率不是很广泛，只有 60% 左右。</p>
<p>2、session ticket 需要维护一个全局的 key 来加解密，需要考虑 KEY 的安全性和部署效率。</p>
</blockquote>
<p>总体来讲，session ticket 的功能特性明显优于 session cache。希望客户端实现优先支持 session ticket。</p>
<h3 id="OCSP-stapling"><a href="#OCSP-stapling" class="headerlink" title="OCSP stapling"></a>OCSP stapling</h3><p>OCSP 全称在线证书状态检查协议 (rfc6960)，用来向 CA 站点查询证书状态，比如是否撤销。通常情况下，浏览器使用 OCSP 协议发起查询请求，CA 返回证书状态内容，然后浏览器接受证书是否可信的状态。</p>
<p>这个过程非常消耗时间，因为 CA 站点有可能在国外，网络不稳定，RTT 也比较大。那有没有办法不直接向 CA 站点请求 OCSP 内容呢？ocsp stapling 就能实现这个功能。</p>
<p>详细介绍参考 RFC6066 第 8 节。简述原理就是浏览器发起 client hello 时会携带一个 certificate status request 的扩展，服务端看到这个扩展后将 OCSP 内容直接返回给浏览器，完成证书状态检查。</p>
<p>由于浏览器不需要直接向 CA 站点查询证书状态，这个功能对访问速度的提升非常明显。</p>
<p>Nginx 目前已经支持这个 ocsp stapling file，只需要配置 ocsp stapling file 的指令就能开启这个功能：</p>
<blockquote>
<ul>
<li>ssl_stapling on;ssl_stapling_file ocsp.staple;</li>
</ul>
</blockquote>
<h3 id="False-start"><a href="#False-start" class="headerlink" title="False start"></a>False start</h3><p>通常情况下，应用层数据必须等完全握手全部结束之后才能传输。这个其实比较浪费时间，那能不能类似 TFO 一样，在完全握手的第二个阶段将应用数据一起发出来呢？google 提出了 false start 来实现这个功能。详细介绍参考<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/draft-bmoeller-tls-falsestart-00%E3%80%82">https://tools.ietf.org/html/draft-bmoeller-tls-falsestart-00。</a></p>
<p>简单概括 False start 的原理就是在 client_key_exchange 发出时将应用层数据一起发出来，能够节省一个 RTT。</p>
<p>False start 依赖于 PFS（perfect forward secrecy 完美前向加密），而 PFS 又依赖于 DHE 密钥交换系列算法（DHE_RSA, ECDHE_RSA, DHE_DSS, ECDHE_ECDSA），所以尽量优先支持 ECDHE 密钥交换算法实现 false start。</p>
<h3 id="使用-SPDY-或者-HTTP2"><a href="#使用-SPDY-或者-HTTP2" class="headerlink" title="使用 SPDY 或者 HTTP2"></a>使用 SPDY 或者 HTTP2</h3><p>SPDY 是 google 推出的优化 HTTP 传输效率的协议（<a target="_blank" rel="noopener" href="https://www.chromium.org/spdy%EF%BC%89%EF%BC%8C%E5%AE%83%E5%9F%BA%E6%9C%AC%E4%B8%8A%E6%B2%BF%E7%94%A8%E4%BA%86">https://www.chromium.org/spdy），它基本上沿用了</a> HTTP 协议的语义, 但是通过使用帧控制实现了多个特性，显著提升了 HTTP 协议的传输效率。</p>
<p>SPDY 最大的特性就是多路复用，能将多个 HTTP 请求在同一个连接上一起发出去，不像目前的 HTTP 协议一样，只能串行地逐个发送请求。Pipeline 虽然支持多个请求一起发送，但是接收时依然得按照顺序接收，本质上无法解决并发的问题。</p>
<p>HTTP2 是 IETF 2015 年 2 月份通过的 HTTP 下一代协议，它以 SPDY 为原型，经过两年多的讨论和完善最终确定。</p>
<p>本文就不过多介绍 SPDY 和 HTTP2 的收益，需要说明两点：</p>
<blockquote>
<p>1、SPDY 和 HTTP2 目前的实现默认使用 HTTPS 协议。</p>
<p>2、SPDY 和 HTTP2 都支持现有的 HTTP 语义和 API，对 WEB 应用几乎是透明的。</p>
</blockquote>
<p>Google 宣布 chrome 浏览器 2016 年将放弃 SPDY 协议，全面支持 HTTP2，但是目前国内部分浏览器厂商进度非常慢，不仅不支持 HTTP2，连 SPDY 都没有支持过。</p>
<p>百度服务端和百度手机浏览器现在都已经支持 SPDY3.1 协议。</p>
<h2 id="HTTPS-计算性能优化"><a href="#HTTPS-计算性能优化" class="headerlink" title="HTTPS 计算性能优化"></a>HTTPS 计算性能优化</h2><h3 id="优先使用-ECC"><a href="#优先使用-ECC" class="headerlink" title="优先使用 ECC"></a>优先使用 ECC</h3><p>ECC 椭圆加密算术相比普通的离散对数计算速度性能要强很多。下表是 NIST 推荐的密钥长度对照表。</p>
<p><img src="http://upload.chinaz.com/2015/0505/1430805926143.png" alt="HTTPS HTTPS协议 https和http有什么区别 HTTPS证书申请"></p>
<p>表格 2 NIST 推荐使用的密钥长度</p>
<p>对于 RSA 算法来讲，目前至少使用 2048 位以上的密钥长度才能保证安全性。ECC 只需要使用 224 位长度的密钥就能实现 RSA2048 位长度的安全强度。在进行相同的模指数运算时速度显然要快很多。</p>
<h3 id="使用最新版的-openssl"><a href="#使用最新版的-openssl" class="headerlink" title="使用最新版的 openssl"></a>使用最新版的 openssl</h3><p>一般来讲，新版的 openssl 相比老版的计算速度和安全性都会有提升。比如 openssl1.0.2 采用了 intel 最新的优化成果，椭圆曲线 p256 的计算性能提升了 4 倍。(<a target="_blank" rel="noopener" href="https://eprint.iacr.org/2013/816.pdf">https://eprint.iacr.org/2013/816.pdf</a>)</p>
<p>Openssl 2014 年就升级了 5 次，基本都是为了修复实现上的 BUG 或者算法上的漏洞而升级的。所以尽量使用最新版本，避免安全上的风险。</p>
<h3 id="硬件加速方案"><a href="#硬件加速方案" class="headerlink" title="硬件加速方案"></a>硬件加速方案</h3><p>现在比较常用的 TLS 硬件加速方案主要有两种：</p>
<blockquote>
<p>1、SSL 专用加速卡。</p>
<p>2、GPU SSL 加速。</p>
</blockquote>
<p>上述两个方案的主流用法都是将硬件插入到服务器的 PCI 插槽中，由硬件完成最消耗性能的计算。但这样的方案有如下缺点：</p>
<p>1、支持算法有限。比如不支持 ECC，不支持 GCM 等。</p>
<p>2、升级成本高。</p>
<blockquote>
<p>a)  出现新的加密算法或者协议时，硬件加速方案无法及时升级。</p>
<p>b)  出现比较大的安全漏洞时，部分硬件方案在无法在短期内升级解决。比如 2014 年暴露的 heartbleed 漏洞。</p>
</blockquote>
<p>3、无法充分利用硬件加速性能。硬件加速程序一般都运行在内核态，计算结果传递到应用层需要 IO 和内存拷贝开销，即使硬件计算性能非常好，上层的同步等待和 IO 开销也会导致整体性能达不到预期，无法充分利用硬件加速卡的计算能力。</p>
<p>4、维护性差。硬件驱动及应用层 API 大部分是由安全厂家提供，出现问题后还需要厂家跟进。用户无法掌握核心代码，比较被动。不像开源的 openssl，不管算法还是协议，用户都能掌握。</p>
<h3 id="TLS-远程代理计算"><a href="#TLS-远程代理计算" class="headerlink" title="TLS 远程代理计算"></a>TLS 远程代理计算</h3><p>也正是因为上述原因，百度实现了专用的 SSL 硬件加速集群。基本思路是：</p>
<p>1、优化 TLS 协议栈，剥离最消耗 CPU 资源的计算，主要有如下部分：</p>
<blockquote>
<p>a)  RSA 中的加解密计算。</p>
<p>b)  ECC 算法中的公私钥生成。</p>
<p>c)  ECC 算法中的共享密钥生成。</p>
</blockquote>
<p>2、优化硬件计算部分。硬件计算不涉及协议及状态交互，只需要处理大数运算。</p>
<p>3、Web server 到 TLS 计算集群之间的任务是异步的。即 web server 将待计算内容发送给加速集群后，依然可以继续处理其他请求，整个过程是异步非阻塞的。</p>
<h2 id="HTTPS-安全配置"><a href="#HTTPS-安全配置" class="headerlink" title="HTTPS 安全配置"></a>HTTPS 安全配置</h2><h3 id="协议版本选择"><a href="#协议版本选择" class="headerlink" title="协议版本选择"></a>协议版本选择</h3><p>SSL2.0 早就被证明是不安全的协议了，统计发现目前已经没有客户端支持 SSL2.0，所以可以放心地在服务端禁用 SSL2.0 协议。</p>
<p>2014 年爆发了 POODLE 攻击，SSL3.0 因此被证明是不安全的。但是统计发现依然有 0.5% 的流量只支持 SSL3.0。所以只能有选择地支持 SSL3.0。</p>
<p>TLS1.1 及 1.2 目前为止没有发现安全漏洞，建议优先支持。</p>
<h3 id="加密套件选择"><a href="#加密套件选择" class="headerlink" title="加密套件选择"></a>加密套件选择</h3><p>加密套件包含四个部分：</p>
<blockquote>
<p>1、非对称密钥交换算法。建议优先使用 ECDHE，禁用 DHE，次优先选择 RSA。</p>
<p>2、证书签名算法。由于部分浏览器及操作系统不支持 ECDSA 签名，目前默认都是使用 RSA 签名，其中 SHA1 签名已经不再安全，chrome 及微软 2016 年开始不再支持 SHA1 签名的证书 (<a target="_blank" rel="noopener" href="http://googleonlinesecurity.blogspot.jp/2014/09/gradually-sunsetting-sha-1.html)%E3%80%82">http://googleonlinesecurity.blogspot.jp/2014/09/gradually-sunsetting-sha-1.html)。</a></p>
<p>3、对称加解密算法。优先使用 AES-GCM 算法，针对 1.0 以上协议禁用 RC4（ rfc7465）。</p>
<p>4、内容一致性校验算法。Md5 和 sha1 都已经不安全，建议使用 sha2 以上的安全哈希函数。</p>
</blockquote>
<h2 id="HTTPS-防攻击"><a href="#HTTPS-防攻击" class="headerlink" title="HTTPS 防攻击"></a>HTTPS 防攻击</h2><h3 id="防止协议降级攻击"><a href="#防止协议降级攻击" class="headerlink" title="防止协议降级攻击"></a>防止协议降级攻击</h3><p>降级攻击一般包括两种：加密套件降级攻击 (cipher suite rollback) 和协议降级攻击（version roll back）。降级攻击的原理就是攻击者伪造或者修改 client hello 消息，使得客户端和服务器之间使用比较弱的加密套件或者协议完成通信。</p>
<p>为了应对降级攻击，现在 server 端和浏览器之间都实现了 SCSV 功能，原理参考<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00%E3%80%82">https://tools.ietf.org/html/draft-ietf-tls-downgrade-scsv-00。</a></p>
<p>一句话解释就是如果客户端想要降级，必须发送 TLS_SCSV 的信号，服务器如果看到 TLS_SCSV，就不会接受比服务端最高协议版本低的协议。</p>
<h3 id="防止重新协商攻击"><a href="#防止重新协商攻击" class="headerlink" title="防止重新协商攻击"></a>防止重新协商攻击</h3><p>重新协商（tls renegotiation）分为两种：加密套件重协商 (cipher suite renegotiation) 和协议重协商（protocol renegotiation）。</p>
<p>重新协商会有两个隐患：</p>
<blockquote>
<p>1、重协商后使用弱的安全算法。这样的后果就是传输内容很容易泄露。</p>
<p>2、重协商过程中不断发起完全握手请求，触发服务端进行高强度计算并引发服务拒绝。</p>
</blockquote>
<p>对于重协商，最直接的保护手段就是禁止客户端主动重协商，当然出于特殊场景的需求，应该允许服务端主动发起重协商。</p>
<p><strong>结束语</strong></p>
<p>HTTPS 的实践和优化涉及到了非常多的知识点，由于篇幅关系，本文对很多优化策略只是简单介绍了一下. 如果想要了解协议背后的原理，还是需要详细阅读 TLS 协议及 PKI 知识。对于大型站点来说，如果希望做到极致，HTTPS 的部署需要结合产品和基础设施的架构来进行详细的考虑，比起部署支持 HTTPS 的接入和对它的优化，在产品和运维层面上花费的功夫会更多</p>
<hr>
<p>【参考文献】:</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/other/other-family-genealogy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/other/other-family-genealogy/" class="post-title-link" itemprop="url">张氏族谱辈分</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-01-20 00:00:00" itemprop="dateCreated datePublished" datetime="2016-01-20T00:00:00+08:00">2016-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-04 09:10:28" itemprop="dateModified" datetime="2021-04-04T09:10:28+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/wiki/" itemprop="url" rel="index"><span itemprop="name">wiki</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="问我故乡在何处，山西洪洞大槐树"><a href="#问我故乡在何处，山西洪洞大槐树" class="headerlink" title="问我故乡在何处，山西洪洞大槐树"></a>问我故乡在何处，山西洪洞大槐树</h1><p>据多方家谱记载，大约500年前，明朝靖难之役前后，明朝政府征调山西省洪洞县乡民迁往今河北、山东、河南、湖北、江西等地，史称“大槐树移民”。如今大槐树移民的后裔占这几个省的大部分。<br>移民是被明朝政府所迫，背井离乡，骨肉分离，是我们的祖先所经历的辛酸和苦楚。<br>每当本宗族黑白喜事，总要拿出族谱，勾起对祖先的思念和怜惜, 也让自己徐徐感觉到作为传承人的自豪。</p>
<h1 id="张氏族谱辈分"><a href="#张氏族谱辈分" class="headerlink" title="张氏族谱辈分"></a>张氏族谱辈分</h1><table>
<thead>
<tr>
<th>伟</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td>瑾</td>
<td>起</td>
<td>广</td>
</tr>
<tr>
<td>鼐</td>
<td>世</td>
<td>得</td>
<td>士</td>
<td>凤</td>
</tr>
<tr>
<td>国</td>
<td>云</td>
<td>锺</td>
<td>光</td>
<td>亦</td>
</tr>
<tr>
<td>方(思)</td>
<td>玉(欲)</td>
<td>再</td>
<td>显</td>
<td>传</td>
</tr>
<tr>
<td>兴</td>
<td>茂</td>
<td>恒</td>
<td>祚</td>
<td>延</td>
</tr>
<tr>
<td>庆</td>
<td>祥</td>
<td>恩</td>
<td>嘉</td>
<td>澍</td>
</tr>
<tr>
<td>令(零)</td>
<td>儒(罗)</td>
<td>肇(兆)</td>
<td>复(补)</td>
<td>天</td>
</tr>
<tr>
<td>立</td>
<td>志</td>
<td>新</td>
<td>法</td>
<td>邦</td>
</tr>
<tr>
<td>登</td>
<td>殿</td>
<td>瑞</td>
<td>义</td>
<td>祯</td>
</tr>
<tr>
<td>保</td>
<td>善</td>
<td>绪</td>
<td>洪</td>
<td>德</td>
</tr>
<tr>
<td>昌</td>
<td>凡</td>
<td>要</td>
<td>英</td>
<td>先</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/21/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><span class="page-number current">22</span><a class="page-number" href="/page/23/">23</a><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/23/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">aaronzhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">240</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">120</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aaronzhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
