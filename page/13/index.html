<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Guadazi">
<meta property="og:url" content="http://example.com/page/13/index.html">
<meta property="og:site_name" content="Guadazi">
<meta property="og:locale">
<meta property="article:author" content="aaronzhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Guadazi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Guadazi</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/bigdata/Flink/FlinkOutputTimely/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/bigdata/Flink/FlinkOutputTimely/" class="post-title-link" itemprop="url">Flink定时输出</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-12 00:00:00" itemprop="dateCreated datePublished" datetime="2018-08-12T00:00:00+08:00">2018-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-12 17:35:01" itemprop="dateModified" datetime="2021-04-12T17:35:01+08:00">2021-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="FlinkOutputTimely"><a href="#FlinkOutputTimely" class="headerlink" title="FlinkOutputTimely"></a>FlinkOutputTimely</h1><p>定时批量输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonSinkOperator</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractStreamOperator</span>&lt;<span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ProcessingTimeCallback</span>,</span></span><br><span class="line"><span class="class">        <span class="title">OneInputStreamOperator</span>&lt;<span class="title">T</span>, <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list;</span><br><span class="line">    <span class="keyword">private</span> ListState&lt;T&gt; listState;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bathSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> interval;</span><br><span class="line">    <span class="keyword">private</span> ProcessingTimeService processingTimeService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonSinkOperator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonSinkOperator</span><span class="params">(<span class="keyword">int</span> batchSize, <span class="keyword">long</span> interval)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.chainingStrategy = ChainingStrategy.ALWAYS;</span><br><span class="line">        <span class="keyword">this</span>.batchSize = batchSize;</span><br><span class="line">        <span class="keyword">this</span>.interval = interval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.open();</span><br><span class="line">        <span class="keyword">if</span> (interval &gt; <span class="number">0</span> &amp;&amp; batchSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            processingTimeService = getProcessingTimeService();</span><br><span class="line">            <span class="keyword">long</span> now = processingTimeService.getCurrentProcessingTime();</span><br><span class="line">            processingTimeService.registerTimer(now + interval, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializeState</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            StateInitializationContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.initializeState(context);</span><br><span class="line">        <span class="keyword">this</span>.list = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        listState = context.getOperatorStateStore()</span><br><span class="line"></span><br><span class="line">                .getSerializableListState(<span class="string">&quot;batch-interval-sink&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (context.isRestored()) &#123;</span><br><span class="line">            listState.get().forEach(x -&gt; &#123;</span><br><span class="line">                list.add(x);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            StreamRecord&lt;T&gt; element)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        list.add(element.getValue());</span><br><span class="line">        <span class="keyword">if</span> (list.size() &gt;= batchSize) &#123;</span><br><span class="line">            saveRecords(list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">snapshotState</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            StateSnapshotContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.snapshotState(context);</span><br><span class="line">        <span class="keyword">if</span> (list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            listState.clear();</span><br><span class="line">            listState.addAll(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProcessingTime</span><span class="params">(<span class="keyword">long</span> timestamp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            saveRecords(list);</span><br><span class="line">            list.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> now =processingTimeService.getCurrentProcessingTime();</span><br><span class="line">        processingTimeService.registerTimer(now + interval,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">saveRecords</span><span class="params">(List&lt;T&gt; datas)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/bigdata/Flink/Flink-timer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/bigdata/Flink/Flink-timer/" class="post-title-link" itemprop="url">Flink Timer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-12 00:00:00" itemprop="dateCreated datePublished" datetime="2018-08-12T00:00:00+08:00">2018-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-12 17:35:00" itemprop="dateModified" datetime="2021-04-12T17:35:00+08:00">2021-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><p>TimerService</p>
<h2 id="SystemProcessingTimeService"><a href="#SystemProcessingTimeService" class="headerlink" title="SystemProcessingTimeService"></a>SystemProcessingTimeService</h2><p>org.apache.flink.streaming.runtime.tasks.SystemProcessingTimeService</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/bigdata/tomcat/principle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/bigdata/tomcat/principle/" class="post-title-link" itemprop="url">Apache Tomcat 9 源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-07-30 12:26:00" itemprop="dateCreated datePublished" datetime="2018-07-30T12:26:00+08:00">2018-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-12 17:35:00" itemprop="dateModified" datetime="2021-04-12T17:35:00+08:00">2021-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Apache tomcat 目前是最常用的免费开源的Java web应用容器(没有之一)，本文旨在分析<a target="_blank" rel="noopener" href="https://tomcat.apache.org/download-90.cgi">Apache Tomcat 9 源码</a>，分析Tomcat高性能的原理</p>
<h2 id="Tomcat启动"><a href="#Tomcat启动" class="headerlink" title="Tomcat启动"></a>Tomcat启动</h2><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h2 id="快速数组扩容"><a href="#快速数组扩容" class="headerlink" title="快速数组扩容"></a>快速数组扩容</h2><h2 id="classLoader"><a href="#classLoader" class="headerlink" title="classLoader"></a>classLoader</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="[参考文献]"></a>[参考文献]</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/crazylqy/p/4706223.html">Tomcat服务器原理详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/">Tomcat 系统架构与设计模式，第1部分 工作原理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat2">Tomcat 系统架构与设计模式，第2部分 设计模式分析</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/bigdata/spider/webDriver_firefox_on_linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/bigdata/spider/webDriver_firefox_on_linux/" class="post-title-link" itemprop="url">搭建webDriver+firefox爬虫服务器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-02-04 19:57:00" itemprop="dateCreated datePublished" datetime="2018-02-04T19:57:00+08:00">2018-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-12 17:35:01" itemprop="dateModified" datetime="2021-04-12T17:35:01+08:00">2021-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Distributed/" itemprop="url" rel="index"><span itemprop="name">Distributed</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>基于Docker搭建的Centos 7平台<br>最新版的firefox 59, 新版的Chrome已经不再支持Linux, Opera半死不活</p>
</blockquote>
<p>Java + Selenium + GeckoDriver + firefox 版本太难兼容<br>本文的版本供参考(验证可用)</p>
<ul>
<li>Java 1.8.0 update 91</li>
<li>Selenium-Java 3.9.1</li>
<li>GeckoDriver 0.19.1</li>
<li>Firefox 59.0b8</li>
</ul>
<h1 id="安装-Java-8"><a href="#安装-Java-8" class="headerlink" title="安装 Java 8"></a>安装 Java 8</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install java-1.8.0-openjdk.x86_64</span><br></pre></td></tr></table></figure>
<h1 id="Selenium-Java"><a href="#Selenium-Java" class="headerlink" title="Selenium-Java"></a>Selenium-Java</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.seleniumhq.selenium<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>selenium-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="GeckoDriver"><a href="#GeckoDriver" class="headerlink" title="GeckoDriver"></a>GeckoDriver</h1><p>Gecko是Firefox的内核，顾名思义，<a target="_blank" rel="noopener" href="https://github.com/mozilla/geckodriver/releases">GeckoDriver</a>就是驱动<br>启动后监听6411端口， Selenium通过IPC调用，访问GeckoDriver</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/mozilla/geckodriver/releases/download/v0.19.1/geckodriver-v0.19.1-linux64.tar.gz</span><br><span class="line">tar -zxvf geckodriver-v0.19.1-linux64.tar.gz</span><br><span class="line">mv geckodriver /usr/local/bin/</span><br></pre></td></tr></table></figure>
<h1 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox"></a>Firefox</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://ftp.mozilla.org/pub/firefox/releases/59.0b8/linux-x86_64/zh-CN/firefox-59.0b8.tar.bz2</span><br><span class="line">tar -xvf firefox-59.0b8.tar.bz2</span><br><span class="line">mv firefox /usr/local/</span><br><span class="line">ln /usr/local/firefox/firefox /usr/bin/firefox</span><br></pre></td></tr></table></figure>
<h2 id="安装虚拟桌面"><a href="#安装虚拟桌面" class="headerlink" title="安装虚拟桌面"></a>安装虚拟桌面</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装Xvfb及其他依赖</span></span><br><span class="line">yum install xorg-x11-server-Xvfb bzip gtk3</span><br></pre></td></tr></table></figure>
<h2 id="安装字体，支持中文"><a href="#安装字体，支持中文" class="headerlink" title="安装字体，支持中文"></a>安装字体，支持中文</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall &quot;Fonts&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装后 重启</span></span><br></pre></td></tr></table></figure>
<h1 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;webdriver.gecko.driver&quot;</span>, <span class="string">&quot;/usr/local/bin/geckodriver&quot;</span>);</span><br><span class="line"></span><br><span class="line">FirefoxOptions firefoxOptions = <span class="keyword">new</span> FirefoxOptions();</span><br><span class="line">firefoxOptions.setHeadless(<span class="keyword">true</span>);</span><br><span class="line">firefoxOptions.setAcceptInsecureCerts(<span class="keyword">true</span>);</span><br><span class="line">firefoxOptions.addArguments(<span class="string">&quot;--disable-gpu&quot;</span>, <span class="string">&quot;--window-size=1920,1200&quot;</span>, <span class="string">&quot;--ignore-certificate-errors&quot;</span>);</span><br><span class="line">WebDriver driver = <span class="keyword">new</span> FirefoxDriver(firefoxOptions);</span><br><span class="line">System.out.println(<span class="string">&quot;init chromeDriver&quot;</span>);</span><br><span class="line">driver.get(<span class="string">&quot;https://www.coinone.com&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;open url&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;sleep over&quot;</span>);</span><br><span class="line"></span><br><span class="line">WebElement closeBtn = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        closeBtn = driver.findElement(By.id(<span class="string">&quot;close_btn&quot;</span>));</span><br><span class="line">            closeBtn.click();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    List&lt;WebElement&gt; elements = driver.findElements(By.cssSelector(<span class="string">&quot;.intro_chart_price table td&quot;</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.size(); i += <span class="number">2</span>) &#123;</span><br><span class="line">        String value = elements.get(i + <span class="number">1</span>).getText().trim();</span><br><span class="line">            System.out.println(<span class="string">&quot;empty value , try &quot;</span> + tryCount);</span><br><span class="line">        System.out.println(elements.get(i).getText().trim() + <span class="string">&quot;\t&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">driver.close();</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1518339710700	geckodriver	INFO	geckodriver 0.19.1</span><br><span class="line">1518339710706	geckodriver	INFO	Listening on 127.0.0.1:6411</span><br><span class="line">1518339711356	mozrunner::runner	INFO	Running command: &quot;&#x2F;usr&#x2F;local&#x2F;firefox&#x2F;firefox&quot; &quot;-marionette&quot; &quot;-headless&quot; &quot;--disable-gpu&quot; &quot;--window-size&#x3D;1920,1200&quot; &quot;--ignore-certificate-errors&quot; &quot;-profile&quot; &quot;&#x2F;tmp&#x2F;rust_mozprofile.1ZVD24PplvDp&quot;</span><br><span class="line">*** You are running in headless mode.</span><br><span class="line">1518339712100	Marionette	INFO	Enabled via --marionette</span><br><span class="line">1518339715188	Marionette	INFO	Listening on port 36443</span><br><span class="line">1518339715212	Marionette	WARN	TLS certificate errors will be ignored for this session</span><br><span class="line">Feb 11, 2018 9:01:55 AM org.openqa.selenium.remote.ProtocolHandshake createSession</span><br><span class="line">INFO: Detected dialect: W3C</span><br><span class="line">init chromeDriver</span><br><span class="line">open url</span><br><span class="line">sleep over</span><br><span class="line"></span><br><span class="line">BTC	8,918,000</span><br><span class="line">BCH	1,197,500</span><br><span class="line">ETH	814,200</span><br><span class="line">ETC	22,720</span><br><span class="line">XRP	1,056</span><br><span class="line">QTUM	29,710</span><br><span class="line">LTC	165,050</span><br><span class="line">IOTA	1,910</span><br><span class="line">BTG	370,350</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="[参考文献]"></a>[参考文献]</h2><p>太多</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/multithread/05.ThreadPool-principle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/multithread/05.ThreadPool-principle/" class="post-title-link" itemprop="url">Java中的线程池原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-10-25 00:00:00" itemprop="dateCreated datePublished" datetime="2017-10-25T00:00:00+08:00">2017-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-12 17:35:00" itemprop="dateModified" datetime="2021-04-12T17:35:00+08:00">2021-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="线程池的组成"><a href="#线程池的组成" class="headerlink" title="线程池的组成"></a>线程池的组成</h3><p><img src="/images/java/multithread/05.thread_pool/1.constructs.png" alt="1.constructs"></p>
<h3 id="提交Job的处理流程："><a href="#提交Job的处理流程：" class="headerlink" title="提交Job的处理流程："></a>提交Job的处理流程：</h3><p><img src="/images/java/multithread/05.thread_pool/2.new_task.png" alt="2.new_task"></p>
<p>核心代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (command == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="comment">// 如果线程数小于核心工作线程数, 则创建线程并执行当前任务</span></span><br><span class="line">  <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line">    <span class="comment">// 如线程数大于等于核心工作线程数或线程创建失败, 则将当前任务放到任务队列中.</span></span><br><span class="line">    <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>) ensureQueuedTaskHandled(command);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果线程池不处于运行中或任务无法放入队列, 并且当前线程数量小于最大工作线程数,</span></span><br><span class="line">    <span class="comment">// 则创建一个线程执行任务.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">      <span class="comment">// 抛出RejectedExecutionException异常</span></span><br><span class="line">      reject(command); <span class="comment">// is shutdown or saturated</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>工作线程worker</code>数量低于<code>核心工作线程数corePoolSize</code>时会优先创建一个<code>工作线程worker</code>处理<code>job</code>, 处理成功则返回.</li>
<li><code>工作线程worker</code>数量高于<code>核心工作线程数</code>时会优先把<code>job</code>放入到<code>任务队列</code>, 放入队列成功时处理结束.</li>
<li>入队失败会识别工作线程数是否还小于<code>最大工作线程数maximumPoolsize</code>, 小于的话也会新创建一个<code>工作线程worker</code>处理<code>job</code>.</li>
<li>饱和策略</li>
</ol>
<p>此外, 运行过程中, 更新核心工作线程数时, 若发现扩容, 会增加工作线程数.</p>
<p><strong>备注:</strong></p>
<ol>
<li>Java中的线程与操作系统的线程是一一对应的</li>
<li>添加新线程需要获得全局锁<br><code>private final ReentrantLock mainLock = new ReentrantLock();</code>, 因此, 当<code>工作线程work数量</code>大于<code>核心工作线程数corePoolSize</code>时, 优先放入<code>任务队列</code></li>
<li>只要工作线程达不到<code>corePoolSize</code>, 不管是否线程空闲, 都会创建新线程</li>
<li>调用<code>prestartAllCoreThreads</code>会初始化所有的核心线程, 没有预热期, 响应快, 但空载浪费资源</li>
<li>向<code>任务队列</code>添加任务, 不需要获取全局锁, 效率高</li>
<li>工作线程的复用: 执行完一个任务, 不断从<code>任务队列</code>取任务, 避免因创建和销毁操作系统线程带来的性能消耗</li>
<li>获取全局锁, 是性能性能瓶颈, <code>corePoolSize</code>是预热</li>
</ol>
<h3 id="工作线程的销毁"><a href="#工作线程的销毁" class="headerlink" title="工作线程的销毁"></a>工作线程的销毁</h3><p>满足下面条件会销毁:</p>
<ol>
<li>任务队列里没有<code>job</code>并且<code>工作线程worker</code>数量超过了<code>核心工作线程数corePoolSize</code>.</li>
<li>任务队列里没有<code>job</code>并且允许<code>工作线程数量</code>小于<code>核心工作线程</code>参数为<code>true</code>, 此场景会至少保留一个工作线程线程.</li>
</ol>
<p>工作线程空闲后, 最长等待<code>keepAliveTime</code></p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>
<p>用给定的初始参数和默认的线程工厂及饱和策略创建新的 <code>ThreadPoolExecutor</code>.<br>使用 <code>Executors</code> 工厂方法之一比使用此通用构造方法方便得多, 但是<a target="_blank" rel="noopener" href="https://yq.aliyun.com/attachment/download/?id=2023">阿里巴巴Java规约</a>不推荐使用, 见下文</p>
<ul>
<li>参数:<ul>
<li><code>corePoolSize</code> - 池中所保存的线程数, 包括空闲线程.</li>
<li><code>maximumPoolSize</code> - 池中允许的最大线程数.</li>
<li><code>keepAliveTime</code> - 当线程数大于核心时, 此为终止前多余的空闲线程等待新任务的最长时间.</li>
<li><code>unit</code> - <code>keepAliveTime</code> 参数的时间单位.</li>
<li><code>workQueue</code> - 执行前用于保持任务的队列. 此队列仅保持由 <code>execute</code> 方法提交的 <code>Runnable</code> 任务.</li>
</ul>
</li>
<li>抛出:<ul>
<li><code>IllegalArgumentException</code> - 如果 <code>corePoolSize</code> 或 <code>keepAliveTime</code> 小于零, 或者 <code>maximumPoolSize</code> 小于或等于零, 或者 <code>corePoolSize</code> 大于 <code>maximumPoolSize</code>.</li>
<li><code>NullPointerException</code> - 如果 <code>workQueue</code> 为 <code>null</code></li>
</ul>
</li>
</ul>
<h3 id="工作线程的存储"><a href="#工作线程的存储" class="headerlink" title="工作线程的存储"></a>工作线程的存储</h3><p>使用了<code>HashSet</code>来存储工作线程<code>worker</code>, 通过可重入锁<code>ReentrantLock</code>对其进行并发保护. 每个<code>worker</code>都是一个<code>Runnable</code>接口.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set containing all worker threads in pool. Accessed only when</span></span><br><span class="line"><span class="comment"> * holding mainLock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br></pre></td></tr></table></figure>



<h3 id="任务队列-runnableTaskQueue"><a href="#任务队列-runnableTaskQueue" class="headerlink" title="任务队列 runnableTaskQueue"></a>任务队列 runnableTaskQueue</h3><p>线程池中的队列采用的是<a href="/Java/multithread/06.BlockingQueue/"><code>BlockingQueue</code></a></p>
<ul>
<li><code>ArrayBlockingQueue</code>：是一个基于数组结构的有界阻塞队列, 此队列按 <code>FIFO（先进先出）</code>原则对元素进行排序.</li>
<li><code>LinkedBlockingQueue</code>：一个基于链表结构的阻塞队列, 此队列按FIFO排序元素, 吞吐量通常要高于<code>ArrayBlockingQueue</code>. 静态工厂方法<code>Executors.newFixedThreadPool()</code>使用了这个队列.</li>
<li><code>SynchronousQueue</code>：一个不存储元素的阻塞队列. 每个插入操作必须等到另一个线程调用移除操作, 否则插入操作一直处于阻塞状态, 吞吐量通常要高于<code>Linked-BlockingQueue</code>, 静态工厂方法<code>Executors.newCachedThreadPool</code>使用了这个队列.</li>
<li><code>PriorityBlockingQueue</code>：一个具有优先级的无限阻塞队列.</li>
</ul>
<h3 id="线程工厂-ThreadFactory"><a href="#线程工厂-ThreadFactory" class="headerlink" title="线程工厂 ThreadFactory"></a>线程工厂 ThreadFactory</h3><p>设置创建线程的工厂, 通过线程工厂给每个创建出来的线程设置更有意义的名字. 使用开源框架guava提供的<code>ThreadFactoryBuilder</code>可以快速给线程池里的线程设置有意义的名字, 代码如下.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newThreadFactoryBuilder().setNameFormat(<span class="string">&quot;XX-task-%d&quot;</span>).build();</span><br></pre></td></tr></table></figure>


<h3 id="RejectedExecutionHandler（饱和策略）"><a href="#RejectedExecutionHandler（饱和策略）" class="headerlink" title="RejectedExecutionHandler（饱和策略）"></a>RejectedExecutionHandler（饱和策略）</h3><p>当队列和线程池都满了, 说明线程池处于饱和状态, 那么必须采取一种策略处理提交的新任务. 这个策略默认情况下是 <code>AbortPolicy</code> , 表示无法 处理新任务时抛出异常. 在JDK 1.5中Java线程池框架提供了以下4种策略.</p>
<ul>
<li><p><code>AbortPolicy</code> ：直接抛出异常.</p>
</li>
<li><p><code>CallerRunsPolicy</code> ：只用调用者所在线程来运行任务.</p>
</li>
<li><p><code>DiscardOldestPolicy</code> ：丢弃队列里最近的一个任务, 并执行当前任务.</p>
</li>
<li><p><code>DiscardPolicy</code> ：不处理, 丢弃掉.</p>
</li>
</ul>
<p>当然, 也可以根据应用场景需要来实现<code>RejectedExecutionHandler</code>接口自定义策略. 如记录日志或持久化存储不能处理的任务.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池异常处理类:</span></span><br><span class="line"><span class="comment"> * 任务执行失败, 持久化到数据库</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  averyzhang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRejectedExecutionHandler</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable task, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Begin exception handler-----------&quot;</span>);</span><br><span class="line">    <span class="comment">//执行失败任务</span></span><br><span class="line">    CachingOnFirstOpenRunnable coor = (CachingOnFirstOpenJob)task;</span><br><span class="line">    List&lt;CachingEntity&gt; list = coor.getLastData();</span><br><span class="line">    CachingDaoUtils.save(list);</span><br><span class="line">    <span class="comment">//打印线程池的对象</span></span><br><span class="line">    System.out.println(<span class="string">&quot;The pool RejectedExecutionHandler = &quot;</span>+executor.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="提交任务-submit与execute"><a href="#提交任务-submit与execute" class="headerlink" title="提交任务: submit与execute"></a>提交任务: submit与execute</h3><p><code>execute</code> 没有返回值</p>
<p><code>submit</code> 可以通过 <code>Future</code> 接口, 获取任务执行的结果: 线程池会返回一个future类型的对象, 通过这个 future对象可以判断任务是否执行成功, 并且可以通过future的<code>get()</code>方法来获取返回值, <code>get()</code>方法会阻塞当前线程直到任务完成, 而使用<code>get(long timeout, TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回, 这时候有可能任务没有执行完.</p>
<h3 id="关闭-shutdown与shutdownNow"><a href="#关闭-shutdown与shutdownNow" class="headerlink" title="关闭: shutdown与shutdownNow"></a>关闭: shutdown与shutdownNow</h3><p>原理是遍历线程池中的工作线程, 然后逐个调用线程的<code>interrupt</code>方法来中断线程, 所以无法响应中断的任务可能永远无法终止.</p>
<ul>
<li><code>shutdownNow</code>首先将线程池的状态设置成 <code>STOP</code>, 然后尝试停止所有的正在执行或暂停任务的线程, 并返回等待执行任务的列表</li>
<li> <code>shutdown</code>只是将线程池的状态设置成<code>SHUTDOWN</code>状态, 然后中断所有没有正在执行任务的线程</li>
</ul>
<p>获取线程的关闭状态:</p>
<p>调用两个关闭方法, <code>isShutdown</code>方法就会返回<code>true</code>. 当所有的任务都已关闭后, 才表示线程池关闭成功, 这时调用<code>isTerminaed</code>方法会返回<code>true</code>.</p>
<p>至于应该调用哪一种方法来关闭线程池, 应该由提交到线程池的任务特性决定, 通常调用<code>shutdown</code>方法来关闭线程池, 如果任务不一定要执行完, 则可以调用<code>shutdownNow</code>方法.</p>
<h2 id="优化配置"><a href="#优化配置" class="headerlink" title="优化配置"></a>优化配置</h2><p>性质不同的任务可以用不同规模的线程池分开处理:</p>
<ul>
<li><code>CPU密集型任务</code>应配置尽可能小的线程, 如配置<code>Ncpu+1</code>个线程的线程池</li>
<li><code>IO密集型任务线程</code>并不是一直在执行任务, 则应配置尽可能多的线程, 如<code>2*Ncpu</code></li>
<li>混合型的任务, 如果可以拆分, 将其拆分成一个CPU密集型任务和一个IO密集型任务, 只要这两个任务执行的时间相差不是太大, 那么分解后执行的吞吐量将高于串行执行的吞吐量. 如果这两个任务执行时间相差太大, 则没必要进行分解.</li>
<li>可以通过 <code>Runtime.getRuntime().availableProcessors()</code>方法获得当前设备的CPU个数</li>
<li>如果任务很多, 并且每个任务执行的时间比较短, 可以调大<code>keepAliveTime</code>时间, 提高线程的利用率.</li>
<li>优先级不同的任务可以使用优先级队列<code>PriorityBlockingQueue</code>来处理. 它可以让优先级高的任务先执行.  优先级低的任务可能永远不能执行.</li>
<li>建议使用有界队列. 有界队列能增加系统的稳定性和预警能力, 可以根据需要设大一点：如果采用无解队列, 当任务无法处理引起堆积, 系统撑爆, 殃及其他业务</li>
</ul>
<p>通常基于几个维度进行：待处理工作job数、线程池定义的最大最小工作线程数、工作线程闲置时间.</p>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>通过线程池提供的参数进行监控, 在监控线程池的时候可以使用以下属性.</p>
<ul>
<li><p><code>taskCount</code>：线程池需要执行的任务数量.</p>
</li>
<li><p><code>completedTaskCount</code>：线程池在运行过程中已完成的任务数量, 小于或等于<code>taskCount</code>.</p>
</li>
<li><p><code>largestPoolSize</code>：线程池里曾经创建过的最大线程数量. 通过这个数据可以知道线程池是否曾经满过. 如该数值等于线程池的最大大小, 则表示线程池曾经满过.</p>
</li>
<li><p><code>getPoolSize</code>：线程池的线程数量. 如果线程池不销毁的话, 线程池里的线程不会自动销 毁, 所以这个大小只增不减.</p>
</li>
<li><p><code>getActiveCount</code>：获取活动的线程数.  通过扩展线程池进行监控.</p>
</li>
<li><p>通过继承线程池来自定义线程池, 重写线程池的 <code>beforeExecute</code>、<code>afterExecute</code>和<code>terminated</code>方法, 可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控. 例如, 监控任务的平均执行时间、最大执行时间和最小执行时间等. 这几个方法在线程池里是空方法.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t,Runnable r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sample</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyScheduledExecutorService</span> <span class="keyword">extends</span> <span class="title">ScheduledThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyScheduledExecutorService.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TableauScheduledExecutorService</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, threadFactory, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TableauScheduledExecutorService</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;############# before execute \n&quot;</span> + currentStatus());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;############# after execute \n&quot;</span> + currentStatus());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;############# terminated \n&quot;</span> + currentStatus());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">currentStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要执行的任务数目</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> taskCount = getTaskCount();</span><br><span class="line">        <span class="comment">// 执行完成的任务数目</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> completedTaskCount = getCompletedTaskCount();</span><br><span class="line">        <span class="comment">// 线程池最大线程数量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> largestPoolSize = getLargestPoolSize();</span><br><span class="line">        <span class="comment">// 线程池线程数量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> poolSize = getPoolSize();</span><br><span class="line">        <span class="comment">// 活动线程数量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> activeCount = getActiveCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[要执行任务:&quot;</span> + taskCount + <span class="string">&quot;,完成:&quot;</span> + completedTaskCount + <span class="string">&quot;,线程池最大数量:&quot;</span> + largestPoolSize +</span><br><span class="line">                <span class="string">&quot;,当前线程数量:&quot;</span> + poolSize + <span class="string">&quot;,活动线程数量:&quot;</span> + activeCount + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>TODO 等待关闭</p>
</blockquote>
<h2 id="Alibaba-Java-规约"><a href="#Alibaba-Java-规约" class="headerlink" title="Alibaba Java 规约"></a>Alibaba Java 规约</h2><p>线程池不允许使用Executors去创建, 而是通过ThreadPoolExecutor的方式, 这样的处理方式让写的同学更加明确线程池的运行规则, 规避资源耗尽的风险.  说明：Executors各个方法的弊端：<br>1）<code>newFixedThreadPool和newSingleThreadExecutor:</code><br>  主要问题是堆积的请求处理队列可能会耗费非常大的内存, 甚至OOM.<br>2）<code>newCachedThreadPool和newScheduledThreadPool:</code><br>  主要问题是线程数最大数是Integer.MAX_VALUE, 可能会创建数量非常多的线程, 甚至OOM.</p>
<p>Positive example 1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.commons.lang3.concurrent.BasicThreadFactory</span></span><br><span class="line">ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, <span class="keyword">new</span> BasicThreadFactory.Builder().namingPattern(<span class="string">&quot;example-schedule-pool-%d&quot;</span>).daemon(<span class="keyword">true</span>).build());</span><br></pre></td></tr></table></figure>

<p>Positive example 2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">.setNameFormat(<span class="string">&quot;demo-pool-%d&quot;</span>).build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Common Thread Pool</span></span><br><span class="line">ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">200</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">pool.execute(()-&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">pool.shutdown();<span class="comment">//gracefully shutdown</span></span><br></pre></td></tr></table></figure>

<p>Positive example 3：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userThreadPool&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;corePoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;queueCapacity&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2000&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;threadFactory&quot;</span> <span class="attr">value</span>= <span class="string">threadFactory</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;rejectedExecutionHandler&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">&quot;rejectedExecutionHandler&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in code</span></span><br><span class="line">    userThreadPool.execute(thread);</span><br></pre></td></tr></table></figure>
<p>线程池的关闭</p>
<p>等待关闭超时</p>
<h1 id="next…TODO"><a href="#next…TODO" class="headerlink" title="next…TODO"></a>next…TODO</h1><ol>
<li>Future接口</li>
<li>任务队列的实现</li>
<li><code>ArrayBlockingQueue</code></li>
<li><code>LinkedBlockingQueue</code></li>
<li><code>SynchronousQueue</code></li>
<li><code>PriorityBlockingQueue</code></li>
<li>线程池的底层实现</li>
<li>guava与线程工厂的使用</li>
<li>线程关闭与中断: 强制关闭与响应中断</li>
<li>Java获取设备参数的API</li>
<li>连接池</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/Java-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/Java-tips/" class="post-title-link" itemprop="url">Java编程tips</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-10-17 10:00:00" itemprop="dateCreated datePublished" datetime="2017-10-17T10:00:00+08:00">2017-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-12 17:35:00" itemprop="dateModified" datetime="2021-04-12T17:35:00+08:00">2021-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>Calendar<br>获取小时数 [2017-10-17 16:10:36 星期二]<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">// 获取12小时制的小时数</span></span><br><span class="line"><span class="keyword">int</span> hour12 = calendar.get(Calendar.HOUR);</span><br><span class="line"><span class="comment">// 获取24小时制的小时数</span></span><br><span class="line"><span class="keyword">int</span> hour24 = calendar.get(Calendar.HOUR_OF_DAY);</span><br></pre></td></tr></table></figure></li>
<li>读锁(共享锁)与写锁(独占锁)</li>
</ol>
<p>[2017-10-17 16:10:41 星期二]</p>
<p>虽然读锁可以允许多个线程读取，写锁会独占，但是当一个线程对资源加了读锁后，另一个线程要加独占锁也必须等待读锁释放。</p>
<ol start="3">
<li>Java web 获取 classes 目录</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String path = Thread.currentThread().getContextClassLoader().getResource(<span class="string">&quot;/&quot;</span>).toURI().getPath();</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/multithread/13.BlockingQueue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/multithread/13.BlockingQueue/" class="post-title-link" itemprop="url">Java BlockingQueue</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-08-12 00:00:00" itemprop="dateCreated datePublished" datetime="2017-08-12T00:00:00+08:00">2017-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-12 17:35:00" itemprop="dateModified" datetime="2021-04-12T17:35:00+08:00">2021-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-BlockingQueue-简介"><a href="#1-BlockingQueue-简介" class="headerlink" title="1. BlockingQueue 简介"></a>1. BlockingQueue 简介</h1><p>在实际编程中，会经常使用到 JDK 中 Collection 集合框架中的各种容器类如实现 List,Map,Queue 接口的容器类，但是这些容器类基本上不是线程安全的，除了使用 Collections 可以将其转换为线程安全的容器，Doug Lea 大师为我们都准备了对应的线程安全的容器，如实现 List 接口的 CopyOnWriteArrayList（<a target="_blank" rel="noopener" href="https://juejin.im/post/5aeeb55f5188256715478c21">关于 CopyOnWriteArrayList 可以看这篇文章</a>），实现 Map 接口的 ConcurrentHashMap（<a target="_blank" rel="noopener" href="https://juejin.im/post/5aeeaba8f265da0b9d781d16">关于 ConcurrentHashMap 可以看这篇文章</a>），实现 Queue 接口的 ConcurrentLinkedQueue（<a target="_blank" rel="noopener" href="https://juejin.im/post/5aeeae756fb9a07ab11112af">关于 ConcurrentLinkedQueue 可以看这篇文章</a>）。</p>
<p>最常用的”<strong>生产者-消费者</strong>“问题中，队列通常被视作线程间操作的数据容器，这样，可以对各个模块的业务功能进行解耦，生产者将“生产”出来的数据放置在数据容器中，而消费者仅仅只需要在“数据容器”中进行获取数据即可，这样生产者线程和消费者线程就能够进行解耦，只专注于自己的业务功能即可。阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是 BlockingQueue 提供了可阻塞的插入和移除的方法。<strong>当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</strong></p>
<h1 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2. 基本操作"></a>2. 基本操作</h1><p>BlockingQueue 基本操作总结如下（此图来源于 JAVA API 文档）：</p>
<table>
<thead>
<tr>
<th></th>
<th>Throws exception</th>
<th>Special value</th>
<th>Blocks</th>
<th>Times out</th>
</tr>
</thead>
<tbody><tr>
<td>Insert</td>
<td>add(e)</td>
<td>offser(e)</td>
<td>put(e)</td>
<td>offser(e,time,unit)</td>
</tr>
<tr>
<td>Remove</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time,unit)</td>
</tr>
<tr>
<td>Examine</td>
<td>element()</td>
<td>peek()</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>BlockingQueue 继承于 Queue 接口，因此，对数据元素的基本操作有：</p>
<blockquote>
<p>插入元素</p>
</blockquote>
<ol>
<li><code>add(E e)</code> ：往队列插入数据，当队列满时，插入元素时会抛出 <code>IllegalStateException</code> 异常；</li>
<li><code>offer(E e)</code>：当往队列插入数据时，插入成功返回<code>true</code>，否则则返回<code>false</code>。当队列满时不会抛出异常；</li>
</ol>
<blockquote>
<p>删除元素</p>
</blockquote>
<ol>
<li><code>remove(Object o)</code>：从队列中删除数据，成功则返回<code>true</code>，否则为<code>false</code></li>
<li><code>poll()</code>：删除数据，当队列为空时，返回 null；</li>
</ol>
<blockquote>
<p>查看元素</p>
</blockquote>
<ol>
<li><code>element()</code>：获取队头元素，如果队列为空时则抛出 <code>NoSuchElementException</code> 异常；</li>
<li><code>peek()</code>：获取队头元素，如果队列为空则抛出 <code>NoSuchElementException</code> 异常</li>
</ol>
<p>BlockingQueue 具有的特殊操作：</p>
<blockquote>
<p>插入数据：</p>
</blockquote>
<ol>
<li><code>put(E e)</code>：当阻塞队列容量已经满时，往阻塞队列插入数据的线程会被阻塞，直至阻塞队列已经有空余的容量可供使用；</li>
<li><code>offer(E e, long timeout, TimeUnit unit)</code>：若阻塞队列已经满时，同样会阻塞插入数据的线程，直至阻塞队列已经有空余的地方，与 <code>put</code> 方法不同的是，该方法会有一个超时时间，若超过当前给定的超时时间，插入数据的线程会退出；</li>
</ol>
<blockquote>
<p>删除数据</p>
</blockquote>
<ol>
<li><code>take()</code>：当阻塞队列为空时，获取队头数据的线程会被阻塞；</li>
<li><code>poll(long timeout, TimeUnit unit)</code>：当阻塞队列为空时，获取数据的线程会被阻塞，另外，如果被阻塞的线程超过了给定的时长，该线程会退出</li>
</ol>
<h1 id="3-常用的-BlockingQueue"><a href="#3-常用的-BlockingQueue" class="headerlink" title="3. 常用的 BlockingQueue"></a>3. 常用的 BlockingQueue</h1><p>实现 BlockingQueue 接口的有<code>ArrayBlockingQueue</code>, <code>DelayQueue</code>, <code>LinkedBlockingDeque</code>, <code>LinkedBlockingQueue</code>, <code>LinkedTransferQueue</code>, <code>PriorityBlockingQueue</code>, <code>SynchronousQueue</code>，而这几种常见的阻塞队列也是在实际编程中会常用的，下面对这几种常见的阻塞队列进行说明：</p>
<blockquote>
<p>1.<code>ArrayBlockingQueue</code></p>
</blockquote>
<p>**<code>ArrayBlockingQueue</code>**是由数组实现的有界阻塞队列。该队列命令元素 FIFO（先进先出）。因此，对头元素时队列中存在时间最长的数据元素，而对尾数据则是当前队列最新的数据元素。<code>ArrayBlockingQueue</code> 可作为“有界数据缓冲区”，生产者插入数据到队列容器中，并由消费者提取。<code>ArrayBlockingQueue</code> 一旦创建，容量不能改变。</p>
<p>当队列容量满时，尝试将元素放入队列将导致操作阻塞;尝试从一个空队列中取一个元素也会同样阻塞。</p>
<p><code>ArrayBlockingQueue</code> 默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到 <code>ArrayBlockingQueue</code>。而非公平性则是指访问 <code>ArrayBlockingQueue</code> 的顺序不是遵守严格的时间顺序，有可能存在，一旦 <code>ArrayBlockingQueue</code> 可以被访问时，长时间阻塞的线程依然无法访问到 <code>ArrayBlockingQueue</code>。<strong>如果保证公平性，通常会降低吞吐量</strong>。如果需要获得公平性的 <code>ArrayBlockingQueue</code>，可采用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">10</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>关于 <code>ArrayBlockingQueue</code> 的实现原理，可以<a target="_blank" rel="noopener" href="https://juejin.im/post/5aeebdb26fb9a07aa83ea17e">看这篇文章</a>。</p>
<blockquote>
<p>2.<code>LinkedBlockingQueue</code></p>
</blockquote>
<p><code>LinkedBlockingQueue</code> 是用链表实现的有界阻塞队列，同样满足 FIFO 的特性，与 <code>ArrayBlockingQueue</code> 相比起来具有更高的吞吐量，为了防止 <code>LinkedBlockingQueue</code> 容量迅速增，损耗大量内存。通常在创建 <code>LinkedBlockingQueue</code> 对象时，会指定其大小，如果未指定，容量等于 <code>Integer.MAX_VALUE</code></p>
<blockquote>
<p>3.<code>PriorityBlockingQueue</code></p>
</blockquote>
<p><code>PriorityBlockingQueue</code> 是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现 <code>compareTo()</code>方法来指定元素排序规则，或者初始化时通过构造器参数 <code>Comparator</code> 来指定排序规则。</p>
<blockquote>
<p>4.<code>SynchronousQueue</code></p>
</blockquote>
<p><code>SynchronousQueue</code> 每个插入操作必须等待另一个线程进行相应的删除操作，因此，<code>SynchronousQueue</code> 实际上没有存储任何数据元素，因为只有线程在删除数据时，其他线程才能插入数据，同样的，如果当前有线程在插入数据时，线程才能删除数据。<code>SynchronousQueue</code> 也可以通过构造器参数来为其指定公平性。</p>
<blockquote>
<p>5.<code>LinkedTransferQueue</code></p>
</blockquote>
<p><code>LinkedTransferQueue</code> 是一个由链表数据结构构成的无界阻塞队列，由于该队列实现了 <code>TransferQueue</code> 接口，与其他阻塞队列相比主要有以下不同的方法：</p>
<p><strong><code>transfer(E e)</code></strong> 如果当前有线程（消费者）正在调用 <code>take()</code>方法或者可延时的 <code>poll()</code>方法进行消费数据时，生产者线程可以调用 <code>transfer</code> 方法将数据传递给消费者线程。如果当前没有消费者线程的话，生产者线程就会将数据插入到队尾，直到有消费者能够进行消费才能退出；</p>
<p><strong><code>tryTransfer(E e)</code></strong> <code>tryTransfer</code> 方法如果当前有消费者线程（调用 <code>take</code> 方法或者具有超时特性的 <code>poll</code> 方法）正在消费数据的话，该方法可以将数据立即传送给消费者线程，如果当前没有消费者线程消费数据的话，就立即返回<code>false</code>。因此，与 <code>transfer</code> 方法相比，<code>transfer</code> 方法是必须等到有消费者线程消费数据时，生产者线程才能够返回。而 <code>tryTransfer</code> 方法能够立即返回结果退出。</p>
<p><strong><code>tryTransfer(E e,long timeout,imeUnit unit)</code></strong><br>与 <code>transfer</code> 基本功能一样，只是增加了超时特性，如果数据才规定的超时时间内没有消费者进行消费的话，就返回<code>false</code>。</p>
<blockquote>
<p>6.<code>LinkedBlockingDeque</code></p>
</blockquote>
<p><code>LinkedBlockingDeque</code> 是基于链表数据结构的有界阻塞双端队列，如果在创建对象时为指定大小时，其默认大小为 <code>Integer.MAX_VALUE</code>。与 <code>LinkedBlockingQueue</code> 相比，主要的不同点在于，<code>LinkedBlockingDeque</code> 具有双端队列的特性。<code>LinkedBlockingDeque</code> 基本操作如下图所示（来源于 java 文档）</p>
<p><img src="_v_images/20200721125024527_1529598628" alt="`LinkedBlockingDeque`的基本操作.png"></p>
<p><code>LinkedBlockingDeque</code>的基本操作.png</p>
<p>如上图所示，<code>LinkedBlockingDeque</code> 的基本操作可以分为四种类型：</p>
<p>1.特殊情况，抛出异常；<br>2.特殊情况，返回特殊值如 null 或者 false；<br>3.当线程不满足操作条件时，线程会被阻塞直至条件满足；<br>4. 操作具有超时特性。</p>
<p>另外，<code>LinkedBlockingDeque</code> 实现了 BlockingDueue 接口<br>而 <code>LinkedBlockingQueue</code> 实现的是 BlockingQueue，</p>
<p>这两个接口的主要区别如下图所示（来源于 java 文档）：</p>
<p><img src="_v_images/20200721125024023_871236957" alt="BlockingQueue和BlockingDeque的区别.png"></p>
<p>BlockingQueue和BlockingDeque的区别</p>
<p>从上图可以看出，两个接口的功能是可以等价使用的，比如 BlockingQueue 的 add 方法和 BlockingDeque 的 addLast 方法的功能是一样的。</p>
<blockquote>
<p>7.<code>DelayQueue</code></p>
</blockquote>
<p><code>DelayQueue</code> 是一个存放实现 <code>Delayed</code> 接口的数据的无界阻塞队列，只有当数据对象的延时时间达到时才能插入到队列进行存储。如果当前所有的数据都还没有达到创建时所指定的延时期，则队列没有队头，并且线程通过 <code>poll</code> 等方法获取数据元素则返回 <code>null</code>。所谓数据延时期满时，则是通过 <code>Delayed</code> 接口的<code>getDelay(TimeUnit.NANOSECONDS)</code>来进行判定，如果该方法返回的是小于等于 0 则说明该数据元素的延时期已满。</p>
<h1 id="ArrayBlockingQueue-实现原理"><a href="#ArrayBlockingQueue-实现原理" class="headerlink" title="ArrayBlockingQueue 实现原理"></a>ArrayBlockingQueue 实现原理</h1><p>阻塞队列最核心的功能是，能够可阻塞式的插入和删除队列元素。当前队列为空时，会阻塞消费数据的线程，直至队列非空时，通知被阻塞的线程；当队列满时，会阻塞插入数据的线程，直至队列未满时，通知插入数据的线程（生产者线程）。那么，多线程中消息通知机制最常用的是 lock 的 condition 机制，关于 condition 可以<a target="_blank" rel="noopener" href="https://juejin.im/post/5aeea5e951882506a36c67f0">看这篇文章的详细介绍</a>。那么 ArrayBlockingQueue 的实现是不是也会采用 Condition 的通知机制呢？下面来看看。</p>
<h2 id="2-1-ArrayBlockingQueue-的主要属性"><a href="#2-1-ArrayBlockingQueue-的主要属性" class="headerlink" title="2.1 ArrayBlockingQueue 的主要属性"></a><strong>2.1 ArrayBlockingQueue 的主要属性</strong></h2><p>ArrayBlockingQueue 的主要属性如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The queued items */</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"><span class="comment">/** items index for next take, poll, peek or remove */</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"><span class="comment">/** items index for next put, offer, or add */</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"><span class="comment">/** Number of elements in the queue */</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Concurrency control uses the classic two-condition algorithm</span></span><br><span class="line"><span class="comment">found in any textbook.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Main lock guarding all access */</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="comment">/** Condition for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从源码中可以看出 ArrayBlockingQueue 内部是采用数组进行数据存储的（<code>属性items</code>），为了保证线程安全，采用的是<code>ReentrantLock lock</code>，为了保证可阻塞式的插入删除数据利用的是 Condition，当获取数据的消费者线程被阻塞时会将该线程放置到 notEmpty 等待队列中，当插入数据的生产者线程被阻塞时，会将该线程放置到 notFull 等待队列中。而 notEmpty 和 notFull 等中要属性在构造方法中进行创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull =  lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来，主要看看可阻塞式的 put 和 take 方法是怎样实现的。</p>
<h2 id="2-2-put-方法详解"><a href="#2-2-put-方法详解" class="headerlink" title="2.2 put 方法详解"></a><strong>2.2 put 方法详解</strong></h2><p><code>put(E e)</code>方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//如果当前队列已满，将线程移入到notFull等待队列中</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">     <span class="comment">//满足插入数据的要求，直接进行入队操作</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>该方法的逻辑很简单，当队列已满时（<code>count == items.length</code>）将线程移入到 notFull 等待队列中，如果当前满足插入数据的条件，就可以直接调用<code>enqueue(e)</code>插入数据元素。enqueue 方法源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">   <span class="comment">//插入数据</span></span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">   <span class="comment">//通知消费者线程，当前队列中有数据可供消费</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enqueue 方法的逻辑同样也很简单，先完成插入数据，即往数组中添加数据（<code>items[putIndex] = x</code>），然后通知被阻塞的消费者线程，当前队列中有数据可供消费（<code>notEmpty.signal()</code>）。</p>
<h2 id="2-3-take-方法详解"><a href="#2-3-take-方法详解" class="headerlink" title="2.3 take 方法详解"></a><strong>2.3 take 方法详解</strong></h2><p>take 方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//如果队列为空，没有数据，将消费者线程移入等待队列中</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">		<span class="comment">//获取数据</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>take 方法也主要做了两步：1. 如果当前队列为空的话，则将获取数据的消费者线程移入到等待队列中；2. 若队列不为空则获取数据，即完成出队操作<code>dequeue</code>。dequeue 方法源码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="comment">//获取数据</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    <span class="comment">//通知被阻塞的生产者线程</span></span><br><span class="line">	notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dequeue 方法也主要做了两件事情：1. 获取队列中的数据，即获取数组中的数据元素（<code>(E) items[takeIndex]</code>）；2. 通知 notFull 等待队列中的线程，使其由等待队列移入到同步队列中，使其能够有机会获得 lock，并执行完成功退出。</p>
<p>从以上分析，可以看出 put 和 take 方法主要是通过 condition 的通知机制来完成可阻塞式的插入数据和获取数据。在理解 ArrayBlockingQueue 后再去理解 LinkedBlockingQueue 就很容易了。</p>
<h1 id="3-LinkedBlockingQueue-实现原理"><a href="#3-LinkedBlockingQueue-实现原理" class="headerlink" title="3. LinkedBlockingQueue 实现原理"></a>3. LinkedBlockingQueue 实现原理</h1><p>LinkedBlockingQueue 是用链表实现的有界阻塞队列，当构造对象时为指定队列大小时，队列默认大小为<code>Integer.MAX_VALUE</code>。从它的构造方法可以看出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-1-LinkedBlockingQueue-的主要属性"><a href="#3-1-LinkedBlockingQueue-的主要属性" class="headerlink" title="3.1 LinkedBlockingQueue 的主要属性"></a><strong>3.1 LinkedBlockingQueue 的主要属性</strong></h2><p>LinkedBlockingQueue 的主要属性有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Current number of elements */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Head of linked list.</span></span><br><span class="line"><span class="comment">Invariant: head.item == null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Tail of linked list.</span></span><br><span class="line"><span class="comment">Invariant: last.next == null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"><span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>可以看出与 ArrayBlockingQueue 主要的区别是，LinkedBlockingQueue 在插入数据和删除数据时分别是由两个不同的 lock（<code>takeLock</code>和<code>putLock</code>）来控制线程安全的，因此，也由这两个 lock 生成了两个对应的 condition（<code>notEmpty</code>和<code>notFull</code>）来实现可阻塞的插入和删除数据。并且，采用了链表的数据结构来实现队列，Node 结点的定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * One of:</span></span><br><span class="line"><span class="comment"> * - the real successor Node</span></span><br><span class="line"><span class="comment"> * - this Node, meaning the successor is head.next</span></span><br><span class="line"><span class="comment"> * - null, meaning there is no successor (this is the last node)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node&amp;lt;E&amp;gt; next;</span><br><span class="line"></span><br><span class="line">Node(E x) &#123; item = x; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来，我们也同样来看看 put 方法和 take 方法的实现。</p>
<h2 id="3-2-put-方法详解"><a href="#3-2-put-方法详解" class="headerlink" title="3.2 put 方法详解"></a><strong>3.2 put 方法详解</strong></h2><p>put 方法源码为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></span><br><span class="line">    <span class="comment">// holding count negative to indicate failure unless set.</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Note that count is used in wait guard even though it is</span></span><br><span class="line"><span class="comment">         * not protected by lock. This works because count can</span></span><br><span class="line"><span class="comment">         * only decrease at this point (all other puts are shut</span></span><br><span class="line"><span class="comment">         * out by lock), and we (or some other waiting put) are</span></span><br><span class="line"><span class="comment">         * signalled if it ever changes from capacity. Similarly</span></span><br><span class="line"><span class="comment">         * for all other uses of count in other wait guards.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		<span class="comment">//如果队列已满，则阻塞当前线程，将其移入等待队列</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//入队操作，插入数据</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">		<span class="comment">//若队列满足插入数据的条件，则通知被阻塞的生产者线程</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>put 方法的逻辑也同样很容易理解，可见注释。基本上和 ArrayBlockingQueue 的 put 方法一样。take 方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//当前队列为空，则阻塞当前线程，将其移入到等待队列中，直至满足条件</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//移除队头元素，获取数据</span></span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="comment">//如果当前满足移除元素的条件，则通知被阻塞的消费者线程</span></span><br><span class="line">		<span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>take 方法的主要逻辑请见于注释，也很容易理解。</p>
<h1 id="4-ArrayBlockingQueue-与-LinkedBlockingQueue-的比较"><a href="#4-ArrayBlockingQueue-与-LinkedBlockingQueue-的比较" class="headerlink" title="4. ArrayBlockingQueue 与 LinkedBlockingQueue 的比较"></a>4. ArrayBlockingQueue 与 LinkedBlockingQueue 的比较</h1><p><strong>相同点</strong>：ArrayBlockingQueue 和 LinkedBlockingQueue 都是通过 condition 通知机制来实现可阻塞式插入和删除元素，并满足线程安全的特性；</p>
<p><strong>不同点</strong>：1. ArrayBlockingQueue 底层是采用的数组进行实现，而 LinkedBlockingQueue 则是采用链表数据结构；</p>
<ol start="2">
<li>ArrayBlockingQueue 插入和删除数据，只采用了一个 lock，而 LinkedBlockingQueue 则是在插入和删除分别采用了<code>putLock</code>和<code>takeLock</code>，这样可以降低线程由于线程无法获取到 lock 而进入 WAITING 状态的可能性，从而提高了线程并发执行的效率。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/lib/Jpa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/lib/Jpa/" class="post-title-link" itemprop="url">Java JPA</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-08-12 00:00:00" itemprop="dateCreated datePublished" datetime="2017-08-12T00:00:00+08:00">2017-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-12 17:35:00" itemprop="dateModified" datetime="2021-04-12T17:35:00+08:00">2021-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Jpa"><a href="#Jpa" class="headerlink" title="Jpa"></a>Jpa</h1><h2 id="创建时间-更新时间"><a href="#创建时间-更新时间" class="headerlink" title="创建时间 更新时间"></a>创建时间 更新时间</h2><p>1.实体类加注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 创建时间</span><br><span class="line"> *&#x2F;</span><br><span class="line">@CreatedDate</span><br><span class="line">@Column(name &#x3D; &quot;create_time&quot;)</span><br><span class="line">private Date createTime;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 修改时间</span><br><span class="line"> *&#x2F;</span><br><span class="line">@LastModifiedDate</span><br><span class="line">@Column(name &#x3D; &quot;modify_time&quot;)</span><br><span class="line">private Date modifyTime;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.实体类头加注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@EntityListeners(AuditingEntityListener.class)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.SpringBoot启动类加注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@EnableJpaAuditing</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外数据库添加相应控制也可以：<br>createTime ： CURRENT_TIMESTAMP<br>modifyTime ： CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/metric/Java-%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/metric/Java-%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/" class="post-title-link" itemprop="url">Java微基准测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-08-12 00:00:00" itemprop="dateCreated datePublished" datetime="2017-08-12T00:00:00+08:00">2017-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-12 17:35:00" itemprop="dateModified" datetime="2021-04-12T17:35:00+08:00">2021-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Stalker</p>
<p><a target="_blank" rel="noopener" href="http://openjdk.java.net/projects/code-tools/jmh/">JMH</a> 是 Java Microbenchmark Harness（微基准测试</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/bigdata/transaction/distributed-transaction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/bigdata/transaction/distributed-transaction/" class="post-title-link" itemprop="url">分布式事务</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-07-23 00:00:00" itemprop="dateCreated datePublished" datetime="2017-07-23T00:00:00+08:00">2017-07-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-12 17:35:00" itemprop="dateModified" datetime="2021-04-12T17:35:00+08:00">2021-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Distributed/" itemprop="url" rel="index"><span itemprop="name">Distributed</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h1><p>事务的核心是锁和并发, 采用同步控制的方式保证并发的情况下性能尽可能高, 且容易理解. 这种方式的优势是方便理解; 它的劣势是性能比较低.</p>
<p>计算机可以简单的理解为一个标准的打字机, 尽管看起来计算机可以并行处理很多事情, 但实际上每个CPU单位时间内只能做一件事, 要么读取数据、要么计算数据、要么写入数据, 所有的任务都可以看成这三件事的集合. 计算机的这种特性引出了一个问题：当多个人去读、算、写操作时, 如果不加访问控制, 系统势必会产生冲突. 而事务相当于在读、算、写操作之外增加了同步的模块, 进而保证只有一个线程进入事务当中, 而其他线程不会进入.</p>
<h2 id="单个事务单元"><a href="#单个事务单元" class="headerlink" title="单个事务单元"></a>单个事务单元</h2><p>事务的四大特性分别是：原子型、一致性、隔离性和持久性.<br><code>原子性</code>指的是事务中包含的所有操作要么全做, 要么全不做;<br><code>一致性</code>是指在事务开始以前, 数据库处于一致性的状态, 事务结束后, 数据库也必须处于一致性的状态;<br><code>隔离性</code>要求系统必须保证事务不受其他并发执行的事务的影响;<br><code>持久性</code>是指一个事务一旦成功完成, 它对数据库的改变必须是永久的, 即使是在系统遇到故障的情况下也不会丢失, 数据的重要性决定了事务的持久性的重要.</p>
<p><img src="/images/distributed/distributedTransaction/01.png"></p>
<p>事务单元是通过<code>Begin-Traction</code>, 然后<code>Commit</code>(<code>Begin-Traction</code>、<code>Commit</code>和<code>Rollback</code>之间所有针对数据的写入、读取的操作都应该添加同步访问), <code>Begin</code>和<code>Commit</code>之间就是一个同步的事务单元. 例如, Bob给Smith 100块钱就是一个事务单元, 这个过程中有很多步操作, 具体如上图所示; 但对业务来说, 仅是一个转账的操作.</p>
<h2 id="事务之间的关系"><a href="#事务之间的关系" class="headerlink" title="事务之间的关系"></a>事务之间的关系</h2><p>事务单元之间的happens-before关系: 《事务管理》</p>
<ul>
<li>读写</li>
<li>写读</li>
<li>写写</li>
<li>读读</li>
</ul>
<p><code>amdahl定律</code>: 最快并行, 最慢串行</p>
<p>最快的速度并保证逻辑顺序</p>
<p>目标–提高系统的易用性而不损失系统的性能</p>
<p><strong>数据库使用多线程的原因</strong></p>
<p>事务问题的来源</p>
<p>慢速设备：硬盘和网路 I/O PS过低,吞吐量很高</p>
<p>快速设备：内存</p>
<p><strong>一组事务单元</strong></p>
<p><img src="/images/distributed/distributedTransaction/02.png"></p>
<p>当三个账户都在进行转账操作时, 每个操作都涉及Smith账户, 所有的事务都会排队, 各自形成一组事务单元.</p>
<p>事务单元之间的<code>Happen-Before</code>关系中的四种可能性：<code>读写</code>、<code>写读</code>、<code>读读</code>、<code>写写</code>.<br>所有事务之间的关系都可以抽象成这四种之一, 来对应现在所有的业务逻辑处理. 在此基础之上, 需要用最快的速度处理多个事务单元之间的关系, 同时还能保障这四种操作的逻辑顺序.</p>
<p><strong>单个事务单元的其他例子</strong></p>
<p>除了转账操作是事务单元外, 诸如商品要建立一个基于<code>GMT_Modified</code>的索引、从数据库中读取一行记录、向数据库中写入一行记录, 同时更新这行记录的所有索引、删除整张表等都是一个事务单元.</p>
<p>也是一个事务单元:</p>
<ol>
<li>添加索引</li>
<li>从数据库读一条数据</li>
<li>向数据库写一条记录, 并更新索引</li>
<li>删除整张表</li>
</ol>
<h2 id="事务单元的实现方式"><a href="#事务单元的实现方式" class="headerlink" title="事务单元的实现方式"></a>事务单元的实现方式</h2><p><img src="/images/distributed/distributedTransaction/03.png"></p>
<p>Two Phase Lock(2PL)是数据库中非常重要的一个概念.<br><strong>数据库操作<code>Insert</code>、<code>Update</code>、<code>Delete</code>都是先读再写的操作</strong>, 例如<code>Insert</code>操作是先读取数据, 读取之后判读数据是否存在, 如果不存在, 则写入该数据, 如果数据存在, 则返回错误.<br>假设在该场景下没有读操作, 只是单纯写入数据, 则数据本身并没有事务操作, <code>Delete</code>、<code>Update</code>操作与之类似.<br><strong>数据库利用这些操作的特性, 在每一次查询过程中, 只要查到数据, 就会在该数据上加锁.理论上, 所有被读取的数据都已加锁, 不会再被其他人读到, 也就是说对数据进行的中间操作状态对所有人都不可见, 当所有中间状态完成后, 提交操作时, 解开锁, 此时数据对所有系统可见</strong> , 例如在转账过程中, 所有人只能看到两种状态：开始时, A有钱, B没钱; 结束时, B有钱, A没钱, 而中间A减掉钱, B尚未加上钱的状态被锁隐藏掉了, 这个操作就是数据库中处理事务的最标准的方式. 如上图所示：事务中的Trx2(JoeLock)与其他事务不相关, 因此可以并行执行; Trx1需要Lock两个数据Boblock和Smithlock, 而Trx3同样需要Lock这两个数据, 因此Trx3必须等待, 且等待在Boblock上; Joe事务会先结束, Trx3会等到Trx1完成后才会开始.</p>
<p>两阶段提交协议(基础是2pl): 事务单元内, 从读数据开始, 将所读的行锁住, 直到事务提交才释放.</p>
<h2 id="处理事务的常见方法"><a href="#处理事务的常见方法" class="headerlink" title="处理事务的常见方法"></a>处理事务的常见方法</h2><p>处理事务的常见方法有<code>排队法</code>、<code>排他锁</code>、<code>读写锁</code>、<code>MVCC</code>等方式, 下面来一一解析.</p>
<h3 id="排队法"><a href="#排队法" class="headerlink" title="排队法"></a>排队法</h3><p><img src="/images/distributed/distributedTransaction/04.png"></p>
<p>事务处理中最重要也是最简单的方案是排队法, 单线程地处理一堆数据. 在Redis中, 如果数据全部在内存中, 则单线程处理所有<code>Put</code>、<code>Get</code>操作效率最高.<br>这是因为多线程本质是CPU模拟多个线程, 这种模拟是以上下文切换为代价, 而对于内存的数据库来说, 没有上下文切换时效率最高. 因此, 单个CPU绑定一块内存的数据, 针对这块数据做多次读写操作时都是在单个CPU上完成的, 单线程处理方式在内存的情况是效率是最优的.</p>
<p>那么什么时候事务需要用到多线程呢？这个问题的本质取决于下层所使用的存储, 如果是内存操作, 则可以动态地申请和销毁内存块; 而磁盘的IOPS很低, 但吞吐量很高. 如果一个场景涉及多次读写操作, 单线程可以很高的效率对于内存进行读写操作; 但是, 由于磁盘的IOPS仅为内存的几千分之一, 如果依旧用操作内存的方式操作磁盘, 那系统的整体性能将会很低, 这意味着必须将大量的读写操作聚合成一个<code>Batch</code>后再提交时才能达到较好的性能. 而将大量请求攒到一起的方式一是<code>异步</code>, 也就是请求本身和线程不绑定, 线程可以不Block(本质来说还是一种多线程的方式), 处理完一个线程后再处理其他线程. 这种做法的核心是将大量不同的请求提交到一个Buffer中, 再由该Buffer统一读取或者写入磁盘, 从而提高效率. 在慢速设备中, 多线程或异步非常常见, 在设计系统时, 面对磁盘、网络、SSD等慢速设备必须考虑使用多线程.</p>
<h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><p><img src="/images/distributed/distributedTransaction/05.png"></p>
<p>有些场景不适合用单线程操作, 可以利用排他锁的方式来快速隔离并发读写事务. 数据库中有一些事务单元是共享的, 如图中的事务单元1是共享的, 事务单元2/3共享数据; 针对事务单元2/3共享数据的所有读写Block住, 事务单元1单独用一个锁来控制, 用这种方式完成系统的访问控制.</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p><img src="/images/distributed/distributedTransaction/06.png"></p>
<p>如果是一个只读的事务, 例如只对数据进行查询操作, 在该过程中数据一定不被修改, 因此多个查询操作可以并行执行, 因此一种针对读读场景的优化自然而然产生——读写锁. 读写锁的核心是在多次读的操作中, 同时允许多个读者来访问共享资源, 提高并发性.</p>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p><img src="/images/distributed/distributedTransaction/07.png"></p>
<p>在最初的数据库事务实现中是不存在MVCC的, 它是Oracle在八十年代新加的功能, 本质是<code>Copy On Write</code>, 也就是每次写都是以重新开始一个新的版本的方式写入数据,<br>因此, 数据库中也就包含了之前的所有版本. 在数据读的过程中, 先申请一个版本号, 如果该版本号小于正在写入的版本号, 则数据一定可以查询到, 无需等到新版本完全写完即可返回查询结果. 这种方式可以在读读不阻塞的前提下, 实现读写/写读不阻塞, 尽可能保证所有的读操作并行, 而写操作串行.</p>
<h2 id="事务的调优原则"><a href="#事务的调优原则" class="headerlink" title="事务的调优原则"></a>事务的调优原则</h2><p>事务的调优的思路是在不影响业务应用的前提下：</p>
<p>第一. 尽可能减少锁的覆盖范围, 例如 <code>Myisam表锁</code>到<code>Innodb行锁</code>就是一个减少锁覆盖范围的过程; 对于<code>原位锁</code>(<code>排他锁</code>、<code>读写锁</code>等)可变为<code>MVCC</code>多版本(本质仍然是减少锁的范围).<br>第二. 增加锁上可并行的线程数, 例如读锁和写锁的分离, 允许并行读取数据.<br>第三. 选择正确锁类型, 其中悲观锁适合并发争抢比较严重的场景; 乐观锁适合并发争抢不太严重的场景.</p>
<ul>
<li><p><code>悲观锁</code> 适合并发争抢比较严重的场景<br><code>Collections.sychronizedList(new ArrayList());</code></p>
</li>
<li><p><code>乐观锁</code> 适合并发争抢不太严重的场景, 如<code>自旋锁</code></p>
</li>
</ul>
<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul>
<li>完整的事务支持<ul>
<li>像传统单机事务一样的操作方式</li>
<li>可按需无限扩展</li>
</ul>
</li>
</ul>
<p>容易理解的模型往往性能不好, 性能好的模型往往不容易理解—-这就是生活</p>
<h2 id="分布式事务带来的问题"><a href="#分布式事务带来的问题" class="headerlink" title="分布式事务带来的问题"></a>分布式事务带来的问题</h2><ul>
<li>网络带来的问题</li>
<li>基于锁的事务实现中遇到的问题<ul>
<li>从2PL到2PC</li>
<li>分布式事务的异常处理</li>
<li>分布式日志记录</li>
<li>分布式事务延迟变大的问题</li>
</ul>
</li>
<li>结合MVCC的事务实现中遇到的问题<ul>
<li>分布式顺序问题</li>
</ul>
</li>
</ul>
<p>并行与并发区别</p>
<h1 id="分布式事务-1"><a href="#分布式事务-1" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>分布式事务服务(Distributed Transaction Service，DTS)</p>
<p>由于在分布式系统中经常发生丢包、网络故障，分区容忍性是必须要满足的，同时为了兼顾高可用性，绝大部分系统都将强一致性需求转化成最终一致性的需求，并通过幂等机制保证了数据的最终一致性。</p>
<p><strong>理解2PC和3PC协议</strong></p>
<p>为了解决分布式一致性问题，前人在性能和数据一致性的反反复复权衡过程中总结了许多典型的协议和算法。其中比较著名的有二阶提交协议(2 Phase Commitment Protocol)，三阶提交协议(3 Phase Commitment Protocol)。</p>
<p><strong>2PC</strong></p>
<p>分布式事务最常用的解决方案就是二阶段提交。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有参与者节点的操作结果并最终指示这些节点是否要把操作结果进行真正的提交。</p>
<p>因此，二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p>
<p>所谓的两个阶段是指：第一阶段：准备阶段(投票阶段)和第二阶段：提交阶段(执行阶段)。</p>
<p><strong>第一阶段：投票阶段</strong></p>
<p>该阶段的主要目的在于打探数据库集群中的各个参与者是否能够正常的执行事务，具体步骤如下：</p>
<ol>
<li>协调者向所有的参与者发送事务执行请求，并等待参与者反馈事务执行结果。</li>
<li>事务参与者收到请求之后，执行事务，但不提交，并记录事务日志。</li>
<li>参与者将自己事务执行情况反馈给协调者，同时阻塞等待协调者的后续指令。</li>
</ol>
<p><strong>第二阶段：事务提交阶段</strong></p>
<p>在第一阶段协调者的询盘之后，各个参与者会回复自己事务的执行情况，这时候存在三种可能：</p>
<ol>
<li>所有的参与者回复能够正常执行事务。</li>
<li>一个或多个参与者回复事务执行失败。</li>
<li>协调者等待超时。</li>
</ol>
<p>对于第一种情况，协调者将向所有的参与者发出提交事务的通知，具体步骤如下：</p>
<ol>
<li>协调者向各个参与者发送commit通知，请求提交事务。</li>
<li>参与者收到事务提交通知之后，执行commit操作，然后释放占有的资源。</li>
<li>参与者向协调者返回事务commit结果信息。</li>
</ol>
<p><img src="/images/distributed/distributedTransaction/08.jpg"></p>
<p>对于第二、三种情况，协调者均认为参与者无法正常成功执行事务，为了整个集群数据的一致性，所以要向各个参与者发送事务回滚通知，具体步骤如下：</p>
<ol>
<li>协调者向各个参与者发送事务rollback通知，请求回滚事务。</li>
<li>参与者收到事务回滚通知之后，执行rollback操作，然后释放占有的资源。</li>
<li>参与者向协调者返回事务rollback结果信息。</li>
</ol>
<p><img src="/images/distributed/distributedTransaction/09.jpg"></p>
<p>两阶段提交协议解决的是分布式数据库数据强一致性问题，其原理简单，易于实现，但是缺点也是显而易见的，主要缺点如下：</p>
<ul>
<li>单点问题：协调者在整个两阶段提交过程中扮演着举足轻重的作用，一旦协调者所在服务器宕机，那么就会影响整个数据库集群的正常运行，比如在第二阶段中，如果协调者因为故障不能正常发送事务提交或回滚通知，那么参与者们将一直处于阻塞状态，整个数据库集群将无法提供服务。</li>
<li>同步阻塞：两阶段提交执行过程中，所有的参与者都需要听从协调者的统一调度，期间处于阻塞状态而不能从事其他操作，这样效率及其低下。</li>
<li>数据不一致性：两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</li>
</ul>
<p><strong>3PC</strong></p>
<p>针对两阶段提交存在的问题，三阶段提交协议通过引入一个“预询盘”阶段，以及超时策略来减少整个集群的阻塞时间，提升系统性能。三阶段提交的三个阶段分别为：can_commit，pre_commit，do_commit。</p>
<p><strong>第一阶段：can_commit</strong></p>
<p>该阶段协调者会去询问各个参与者是否能够正常执行事务，参与者根据自身情况回复一个预估值，相对于真正的执行事务，这个过程是轻量的，具体步骤如下：</p>
<ol>
<li>协调者向各个参与者发送事务询问通知，询问是否可以执行事务操作，并等待回复。</li>
<li>各个参与者依据自身状况回复一个预估值，如果预估自己能够正常执行事务就返回确定信息，并进入预备状态，否则返回否定信息。</li>
</ol>
<p><strong>第二阶段：pre_commit</strong></p>
<p>本阶段协调者会根据第一阶段的询盘结果采取相应操作，询盘结果主要有三种：</p>
<ol>
<li>所有的参与者都返回确定信息。</li>
<li>一个或多个参与者返回否定信息。</li>
<li>协调者等待超时。</li>
</ol>
<p>针对第一种情况，协调者会向所有参与者发送事务执行请求，具体步骤如下：</p>
<ol>
<li>协调者向所有的事务参与者发送事务执行通知。</li>
<li>参与者收到通知后，执行事务，但不提交。</li>
<li>参与者将事务执行情况返回给客户端。</li>
</ol>
<p>在上面的步骤中，如果参与者等待超时，则会中断事务。 针对第二、三种情况，协调者认为事务无法正常执行，于是向各个参与者发出abort通知，请求退出预备状态，具体步骤如下：</p>
<ol>
<li>协调者向所有事务参与者发送abort通知</li>
<li>参与者收到通知后，中断事务</li>
</ol>
<p><img src="/images/distributed/distributedTransaction/10.jpg"></p>
<p><strong>第三阶段：do_commit</strong></p>
<p>如果第二阶段事务未中断，那么本阶段协调者将会依据事务执行返回的结果来决定提交或回滚事务，分为三种情况：</p>
<ol>
<li>所有的参与者都能正常执行事务。</li>
<li>一个或多个参与者执行事务失败。</li>
<li>协调者等待超时。</li>
</ol>
<p>针对第一种情况，协调者向各个参与者发起事务提交请求，具体步骤如下：</p>
<ol>
<li>协调者向所有参与者发送事务commit通知。</li>
<li>所有参与者在收到通知之后执行commit操作，并释放占有的资源。</li>
<li>参与者向协调者反馈事务提交结果。</li>
</ol>
<p><img src="/images/distributed/distributedTransaction/11.jpg"></p>
<p>针对第二、三种情况，协调者认为事务无法正常执行，于是向各个参与者发送事务回滚请求，具体步骤如下：</p>
<ol>
<li>协调者向所有参与者发送事务rollback通知。</li>
<li>所有参与者在收到通知之后执行rollback操作，并释放占有的资源。</li>
<li>参与者向协调者反馈事务提交结果。</li>
</ol>
<p><img src="/images/distributed/distributedTransaction/12.jpg"></p>
<p>在本阶段如果因为协调者或网络问题，导致参与者迟迟不能收到来自协调者的commit或rollback请求，那么参与者将不会如两阶段提交中那样陷入阻塞，而是等待超时后继续commit。相对于两阶段提交虽然降低了同步阻塞，但仍然无法避免数据的不一致性。</p>
<p>高吞吐 高性能 和单机事务一样易用</p>
<p>ACID</p>
<p>spandex</p>
<p>xa</p>
<p>java 协调器</p>
<p>分布式日志记录</p>
<p>隔离级别 事务的传递性</p>
<p>幂等</p>
<hr>
<p>【相关文献】</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">aaronzhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">235</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">126</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aaronzhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
