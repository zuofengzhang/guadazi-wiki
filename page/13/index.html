<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Guadazi">
<meta property="og:url" content="http://example.com/page/13/index.html">
<meta property="og:site_name" content="Guadazi">
<meta property="og:locale">
<meta property="article:author" content="aaronzhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/13/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Guadazi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Guadazi</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/io/high-performance-network-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/io/high-performance-network-programming/" class="post-title-link" itemprop="url">高性能网络编程IO模型与线程模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-19 17:28:00" itemprop="dateCreated datePublished" datetime="2019-03-19T17:28:00+08:00">2019-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-04 09:24:03" itemprop="dateModified" datetime="2021-04-04T09:24:03+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="C10K问题"><a href="#C10K问题" class="headerlink" title="C10K问题"></a>C10K问题</h2><p><a target="_blank" rel="noopener" href="http://www.kegel.com/c10k.html">C10K问题</a>: 一万个客户端同时连接</p>
<h3 id="常识一：文件句柄限制"><a href="#常识一：文件句柄限制" class="headerlink" title="常识一：文件句柄限制"></a>常识一：文件句柄限制</h3><p>在linux下每一个tcp连接都要占一个文件描述符，一旦文件描述符使用完了，新的连接到来返回给我们的错误是“Socket/File:Can’t open so many files”。</p>
<p>操作系统可以打开的最大文件数的限制。</p>
<h4 id="1-进程限制"><a href="#1-进程限制" class="headerlink" title="1 进程限制"></a>1 进程限制</h4><p>执行 <code>ulimit -n</code> 输出 <code>1024</code>，说明对于一个进程而言最多只能打开1024个文件，所以采用此配置最多可以并发上千个TCP连接。<br>临时修改：ulimit -n 1000000，但是这种临时修改只对当前登录用户目前的使用环境有效，系统重启或用户退出后就会失效。</p>
<p>重启后失效的修改: （CentOS 6.5下测试，重启后未发现失效），编辑 <code>/etc/security/limits.conf</code> 文件， 修改后内容为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soft nofile 1000000</span><br><span class="line">hard nofile 1000000</span><br></pre></td></tr></table></figure>
<p>永久修改：编辑/etc/rc.local，在其后添加如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -SHn 1000000</span><br></pre></td></tr></table></figure>
<h4 id="2-全局限制"><a href="#2-全局限制" class="headerlink" title="2 全局限制"></a>2 全局限制</h4><p>执行<code>cat /proc/sys/fs/file-nr</code>输出<code>9344 0 592026</code>，分别为：</p>
<ol>
<li>已经分配的文件句柄数，</li>
<li>已经分配但没有使用的文件句柄数，</li>
<li>最大文件句柄数。</li>
</ol>
<p>但在kernel 2.6版本中第二项的值总为0，这并不是一个错误，它实际上意味着已经分配的文件描述符无一浪费的都已经被使用了。我们可以把这个数值改大些，用 root 权限修改 <code>/etc/sysctl.conf</code> 文件:</p>
<ul>
<li>fs.file-max = 1000000</li>
<li>net.ipv4.ip_conntrack_max = 1000000</li>
<li>net.ipv4.netfilter.ip_conntrack_max = 1000000</li>
</ul>
<h3 id="常识二：端口号范围限制？"><a href="#常识二：端口号范围限制？" class="headerlink" title="常识二：端口号范围限制？"></a>常识二：端口号范围限制？</h3><p>操作系统上端口号1024以下是系统保留的，从1024-65535是用户使用的。每个TCP连接都要占一个端口号, 但可以创建的最大并发连接不只60000个</p>
<h4 id="如何标识一个TCP连接："><a href="#如何标识一个TCP连接：" class="headerlink" title="如何标识一个TCP连接："></a>如何标识一个TCP连接：</h4><p>系统用一个4四元组来唯一标识一个TCP连接：<code>&#123;local ip, local port,remote ip,remote port&#125;</code>。</p>
<blockquote>
<p>《UNIX网络编程：卷一》第四章中对accept的讲解，第二个参数cliaddr代表了客户端的ip地址和端口号。而服务端实际只使用了bind时这一个端口，说明端口号65535并不是并发量的限制。</p>
</blockquote>
<h4 id="server最大tcp连接数："><a href="#server最大tcp连接数：" class="headerlink" title="server最大tcp连接数："></a>server最大tcp连接数：</h4><p>server通常固定在某个本地端口上监听，等待client的连接请求。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，即使server端有多个ip，本地监听端口也是独占的，因此server端tcp连接4元组中只有remote ip（也就是client ip）和remote port（客户端port）是可变的，因此最大tcp连接为<code>客户端ip数×客户端port数</code>，对IPV4，不考虑ip地址分类等因素，最大tcp连接数约为<code>2的32次方（ip数）×2的16次方（port数）</code>，也就是server端单机最大tcp连接数约为<code>2的48次方</code>。</p>
<h2 id="I-O-Model"><a href="#I-O-Model" class="headerlink" title="I/O Model"></a>I/O Model</h2><p>最初的服务器都是<strong>基于进程/线程模型</strong>的，一个TCP连接，就需要分配1个进程（或者线程）。而进程又是操作系统最昂贵的资源，一台机器无法创建很多进程。<br>如果是C10K就要创建1万个进程，那么单机而言操作系统是无法承受的（往往出现效率低下甚至完全瘫痪）。<br>如果是采用分布式系统，维持1亿用户在线需要10万台服务器，成本巨大，也只有Facebook、Google、雅虎等巨头才有财力购买如此多的服务器。</p>
<p>传统的同步阻塞I/O模型都是一样的，处理的方式都是requests per second，并发10K和100的区别关键在于CPU。<br>创建的进程线程多了，<strong>数据拷贝频繁（缓存I/O、内核将数据拷贝到用户进程空间、阻塞）， 进程/线程上下文切换消耗大</strong>， 导致操作系统崩溃，这就是C10K问题的本质！</p>
<h3 id="互联网服务端处理网络请求的原理"><a href="#互联网服务端处理网络请求的原理" class="headerlink" title="互联网服务端处理网络请求的原理"></a>互联网服务端处理网络请求的原理</h3><p>典型互联网服务端处理网络请求的典型过程：</p>
<p>  <img src="http://www.52im.net/data/attachment/forum/201809/05/211858pgsyanbk1yffennv.jpeg" alt="高性能网络编程(五)：一文读懂高性能网络编程中的I/O模型_1.jpeg">    </p>
<p>由上图可以看到，主要处理步骤包括： </p>
<p> 1）获取请求数据，客户端与服务器建立连接发出请求，服务器接受请求（1-3）；<br> 2）构建响应，当服务器接收完请求，并在用户空间处理客户端的请求，直到构建响应完成（4）；<br> 3）返回数据，服务器将已构建好的响应再通过内核空间的网络 I/O 发还给客户端（5-7）。</p>
<p>设计服务端并发模型时，主要有如下两个关键点： </p>
<p> 1）服务器如何管理连接，获取输入数据；<br> 2）服务器如何处理请求。</p>
<h3 id="“I-O-模型”的基本认识"><a href="#“I-O-模型”的基本认识" class="headerlink" title="“I/O 模型”的基本认识"></a>“I/O 模型”的基本认识</h3><h4 id="阻塞调用与非阻塞调用："><a href="#阻塞调用与非阻塞调用：" class="headerlink" title="阻塞调用与非阻塞调用："></a>阻塞调用与非阻塞调用：</h4><ul>
<li>阻塞调用是指调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回；</li>
<li>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</li>
</ul>
<p>两者的最大区别在于被调用方在收到请求到返回结果之前的这段时间内，调用方是否一直在等待。<strong>阻塞</strong>是指调用方一直在等待而且别的事情什么都不做；<strong>非阻塞</strong>是指调用方先去忙别的事情。</p>
<h4 id="同步处理与异步处理："><a href="#同步处理与异步处理：" class="headerlink" title="同步处理与异步处理："></a>同步处理与异步处理：</h4><p>同步处理是指被调用方得到最终结果之后才返回给调用方；异步处理是指被调用方先返回应答，然后再计算调用结果，计算完最终结果后再通知并返回给调用方。</p>
<p>阻塞、非阻塞和同步、异步的区别（阻塞、非阻塞和同步、异步其实针对的对象是不一样的）：</p>
<ul>
<li>1）阻塞、非阻塞的讨论对象是调用者；</li>
<li>2）同步、异步的讨论对象是被调用者。</li>
</ul>
<h4 id="recvfrom-函数："><a href="#recvfrom-函数：" class="headerlink" title="recvfrom 函数："></a>recvfrom 函数：</h4><p>// FIXME 究竟什么是Socket，操作系统套接字代表的是什么</p>
<p>recvfrom 函数(经 <code>Socket</code> 接收数据)，这里把它视为系统调用。</p>
<p>一个输入操作通常包括两个不同的阶段：</p>
<ul>
<li>1）等待数据准备好；</li>
<li>2）从内核向进程复制数据。</li>
</ul>
<p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>
<p>实际应用程序在系统调用完成上面的 2 步操作时，调用方式的阻塞、非阻塞，操作系统在处理应用程序请求时，处理方式的同步、异步处理的不同，可以分为 5 种 I/O 模型（下面的章节将逐个展开介绍）。（参考《UNIX网络编程卷1》）</p>
<h3 id="阻塞式-I-O-blocking-I-O）"><a href="#阻塞式-I-O-blocking-I-O）" class="headerlink" title="阻塞式 I/O(blocking I/O）"></a>阻塞式 I/O(blocking I/O）</h3><p>  <img src="http://www.52im.net/data/attachment/forum/201809/05/212717yp8iwt5z8j1niw8a.jpeg" alt="高性能网络编程(五)：一文读懂高性能网络编程中的I/O模型_2.jpeg">    </p>
<p> 在阻塞式 I/O 模型中，应用程序在从调用 recvfrom 开始到它返回有数据报准备好这段时间是阻塞的，recvfrom 返回成功后，应用进程开始处理数据报。</p>
<p><strong>比喻：</strong> 一个人在钓鱼，当没鱼上钩时，就坐在岸边一直等。</p>
<p><strong>优点：</strong> 程序简单，在阻塞等待数据期间进程/线程挂起，基本不会占用 CPU 资源。</p>
<p><strong>缺点：</strong> 每个连接需要独立的进程/线程单独处理，当并发请求量大时为了维护程序，内存、线程切换开销较大，这种模型在实际生产中很少使用。</p>
<h3 id="非阻塞式-I-O-non-blocking-I-O）"><a href="#非阻塞式-I-O-non-blocking-I-O）" class="headerlink" title="非阻塞式 I/O (non-blocking I/O）"></a>非阻塞式 I/O (non-blocking I/O）</h3><p>  <img src="http://www.52im.net/data/attachment/forum/201809/05/212910wn44nrr6zp5siiuo.jpeg" alt="高性能网络编程(五)：一文读懂高性能网络编程中的I/O模型_3.jpeg"></p>
<p> 应用程序把一个套接口设置为非阻塞，就是告诉内核，当所请求的 I/O 操作无法完成时，不要将进程睡眠。<br> 而是返回一个错误，应用程序基于 I/O 操作函数将不断的轮询数据是否已经准备好，如果没有准备好，继续轮询，直到数据准备好为止。</p>
<p><strong>比喻：</strong> 边钓鱼边玩手机，隔会再看看有没有鱼上钩，有的话就迅速拉杆。</p>
<p><strong>优点：</strong> 不会阻塞在内核的等待数据过程，每次发起的 I/O 请求可以立即返回，不用阻塞等待，实时性较好。</p>
<p><strong>缺点：</strong> 轮询将会不断地询问内核，这将占用大量的 CPU 时间，系统资源利用率较低，所以一般 Web 服务器不使用这种 I/O 模型。</p>
<h3 id="I-O-多路复用-I-O-multiplexing）"><a href="#I-O-多路复用-I-O-multiplexing）" class="headerlink" title="I/O 多路复用(I/O multiplexing）"></a>I/O 多路复用(I/O multiplexing）</h3><p><img src="http://www.52im.net/data/attachment/forum/201809/05/213041mtejdsoeojfjy7dd.jpeg" alt="高性能网络编程(五)：一文读懂高性能网络编程中的I/O模型_4.jpeg"></p>
<p> 在 I/O 复用模型中，会用到 Select 或 Poll 函数或 Epoll 函数(Linux 2.6 以后的内核开始支持)，这两个函数也会使进程阻塞，但是和阻塞 I/O 有所不同。</p>
<p> 这两个函数可以同时阻塞多个 I/O 操作，而且可以同时对多个读操作，多个写操作的 I/O 函数进行检测，直到有数据可读或可写时，才真正调用 I/O 操作函数。</p>
<p><strong>比喻：</strong> 放了一堆鱼竿，在岸边一直守着这堆鱼竿，没鱼上钩就玩手机。</p>
<p><strong>优点：</strong> 可以基于一个阻塞对象，同时在多个描述符上等待就绪，而不是使用多个线程(每个文件描述符一个线程)，这样可以大大节省系统资源。</p>
<p><strong>缺点：</strong> 当连接数较少时效率相比多线程+阻塞 I/O 模型效率较低，可能延迟更大，因为单个连接处理需要 2 次系统调用，占用时间会有增加。</p>
<p>众所周之，Nginx这样的高性能互联网反向代理服务器大获成功的关键就是得益于<code>Epoll</code>。</p>
<h3 id="信号驱动式-I-O-（signal-driven-I-O"><a href="#信号驱动式-I-O-（signal-driven-I-O" class="headerlink" title="信号驱动式 I/O （signal-driven I/O)"></a>信号驱动式 I/O （signal-driven I/O)</h3><p>  <img src="http://www.52im.net/data/attachment/forum/201809/05/213143a7n3mnxb38ybgxy3.jpeg" alt="高性能网络编程(五)：一文读懂高性能网络编程中的I/O模型_5.jpeg"></p>
<p> 在信号驱动式 I/O 模型中，应用程序使用套接口进行信号驱动 I/O，并安装一个信号处理函数，进程继续运行并不阻塞。<br> 当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I/O 操作函数处理数据。</p>
<p><strong>比喻：</strong> 鱼竿上系了个铃铛，当铃铛响，就知道鱼上钩，然后可以专心玩手机。</p>
<p><strong>优点：</strong> 线程并没有在等待数据时被阻塞，可以提高资源的利用率。</p>
<p><strong>缺点：</strong> 信号 I/O 在大量 IO 操作时可能会因为信号队列溢出导致没法通知。</p>
<p> 信号驱动 I/O 尽管对于处理 UDP 套接字来说有用，即这种信号通知意味着到达一个数据报，或者返回一个异步错误。</p>
<p> 但是，对于 TCP 而言，信号驱动的 I/O 方式近乎无用，因为导致这种通知的条件为数众多，每一个来进行判别会消耗很大资源，与前几种方式相比优势尽失。</p>
<h3 id="异步-I-O（即AIO，全称asynchronous-I-O）"><a href="#异步-I-O（即AIO，全称asynchronous-I-O）" class="headerlink" title="异步 I/O（即AIO，全称asynchronous I/O）"></a>异步 I/O（即AIO，全称asynchronous I/O）</h3><p><img src="http://www.52im.net/data/attachment/forum/201809/05/213218wbeovsvt6g7s4zsj.jpeg" alt="高性能网络编程(五)：一文读懂高性能网络编程中的I/O模型_6.jpeg"></p>
<p> 由 POSIX 规范定义，应用程序告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到应用程序的缓冲区）完成后通知应用程序。</p>
<p> 这种模型与信号驱动模型的主要区别在于：信号驱动 I/O 是由内核通知应用程序何时启动一个 I/O 操作，而异步 I/O 模型是由内核通知应用程序 I/O 操作何时完成。</p>
<p><strong>优点：</strong> 异步 I/O 能够充分利用 DMA 特性，让 I/O 操作与计算重叠。</p>
<p><strong>缺点：</strong> 要实现真正的异步 I/O，操作系统需要做大量的工作。目前 Windows 下通过 IOCP 实现了真正的异步 I/O。</p>
<p> 而在 Linux 系统下，Linux 2.6才引入，目前 AIO 并不完善，因此在 Linux 下实现高并发网络编程时都是以 IO 复用模型模式为主。</p>
<p> 关于AOI的介绍，请见：《Java新一代网络编程模型AIO原理及Linux系统AIO介绍》。</p>
<h3 id="5-种-I-O-模型总结"><a href="#5-种-I-O-模型总结" class="headerlink" title="5 种 I/O 模型总结"></a>5 种 I/O 模型总结</h3><p>  <img src="http://www.52im.net/data/attachment/forum/201809/05/213459mmmhohhgwom24uoj.jpeg" alt="高性能网络编程(五)：一文读懂高性能网络编程中的I/O模型_7.jpeg">    </p>
<p> 从上图中我们可以看出，越往后，阻塞越少，理论上效率也是最优。</p>
<p> 这五种 I/O 模型中，前四种属于同步 I/O，因为其中真正的 I/O 操作(recvfrom)将阻塞进程/线程，只有异步 I/O 模型才与 POSIX 定义的异步 I/O 相匹配。</p>
<h2 id="高性能网络编程中的线程模型"><a href="#高性能网络编程中的线程模型" class="headerlink" title="高性能网络编程中的线程模型"></a>高性能网络编程中的线程模型</h2><h3 id="传统阻塞-I-O-服务模型"><a href="#传统阻塞-I-O-服务模型" class="headerlink" title="传统阻塞 I/O 服务模型"></a>传统阻塞 I/O 服务模型</h3><p><img src="http://www.52im.net/data/attachment/forum/201809/06/195333v2cj2o6y92d2zp5z.jpeg" alt="高性能网络编程(六)：一文读懂高性能网络编程中的线程模型_1.jpeg">    </p>
<p><strong>特点：</strong></p>
<p>1）采用阻塞式 I/O 模型获取输入数据；<br>2）每个连接都需要独立的线程完成数据输入，业务处理，数据返回的完整操作。</p>
<p><strong>存在问题：</strong></p>
<p>1）当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大；<br>2）连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费。</p>
<h3 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>针对传统阻塞 I/O 服务模型的 2 个缺点，比较常见的有如下解决方案： </p>
<p> 1）基于 I/O 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理；<br> 2）基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。</p>
<p>I/O 复用结合线程池，这就是 Reactor 模式基本设计思想，如下图：</p>
<p><img src="http://www.52im.net/data/attachment/forum/201809/06/195839s5hi3te5pxueq5ze.jpeg" alt="高性能网络编程(六)：一文读懂高性能网络编程中的线程模型_2.jpeg"></p>
<p>Reactor 模式，是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。 </p>
<p>服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor 模式也叫 Dispatcher 模式。即 I/O 多了复用统一监听事件，收到事件后分发(Dispatch 给某进程)，是编写高性能网络服务器的必备技术之一。</p>
<p>Reactor 模式中有 2 个关键组成：</p>
<p>1）Reactor：Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO 事件做出反应。 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；<br>2）Handlers：处理程序执行 I/O 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor 通过调度适当的处理程序来响应 I/O 事件，处理程序执行非阻塞操作。</p>
<p>根据 Reactor 的数量和处理资源池线程的数量不同，有 3 种典型的实现：</p>
<p>1）单 Reactor 单线程；<br>2）单 Reactor 多线程；<br>3）主从 Reactor 多线程。</p>
<p>下面详细介绍这 3 种实现方式。</p>
<h4 id="单-Reactor-单线程"><a href="#单-Reactor-单线程" class="headerlink" title="单 Reactor 单线程"></a>单 Reactor 单线程</h4><p><img src="http://www.52im.net/data/attachment/forum/201809/06/200048bgll2l41w72174ot.jpeg" alt="高性能网络编程(六)：一文读懂高性能网络编程中的线程模型_3.jpeg">    </p>
<p>其中，Select 是前面 I/O 复用模型介绍的标准网络编程 API，可以实现应用程序通过一个阻塞对象监听多路连接请求，其他方案示意图类似。</p>
<p>方案说明：</p>
<p>1）Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发；<br>2）如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后的后续业务处理；<br>3）如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应；<br>4）Handler 会完成 Read→业务处理→Send 的完整业务流程。</p>
<p><strong>优点：</strong></p>
<p>模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成。</p>
<p>缺点：</p>
<p>性能问题，只有一个线程，无法完全发挥多核 CPU 的性能。Handler 在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈。</p>
<p> 可靠性问题，线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障。</p>
<p><strong>使用场景：</strong></p>
<p>客户端的数量有限，业务处理非常快速，比如 Redis，业务处理的时间复杂度 O(1)。</p>
<h4 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor 多线程"></a>单 Reactor 多线程</h4><p>  <img src="http://www.52im.net/data/attachment/forum/201809/06/200650wun9j9ghkgk7ngna.jpeg" alt="高性能网络编程(六)：一文读懂高性能网络编程中的线程模型_4.jpeg">    </p>
<p>方案说明：</p>
<ul>
<li>1）Reactor 对象通过 Select 监控客户端请求事件，收到事件后通过 Dispatch 进行分发；</li>
<li>2）如果是建立连接请求事件，则由 Acceptor 通过 Accept 处理连接请求，然后创建一个 Handler 对象处理连接完成后续的各种事件；</li>
<li>3）如果不是建立连接事件，则 Reactor 会分发调用连接对应的 Handler 来响应；</li>
<li>4）Handler 只负责响应事件，不做具体业务处理，通过 Read 读取数据后，会分发给后面的 Worker 线程池进行业务处理；</li>
<li>5）Worker 线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给 Handler 进行处理；</li>
<li>6）Handler 收到响应结果后通过 Send 将响应结果返回给 Client。</li>
</ul>
<p>优点：</p>
<p>可以充分利用多核 CPU 的处理能力。</p>
<p>缺点：</p>
<p>多线程数据共享和访问比较复杂；Reactor 承担所有事件的监听和响应，在单线程中运行，高并发场景下容易成为性能瓶颈。</p>
<h4 id="主从-Reactor-多线程"><a href="#主从-Reactor-多线程" class="headerlink" title="主从 Reactor 多线程"></a>主从 Reactor 多线程</h4><p>  <img src="http://www.52im.net/data/attachment/forum/201809/06/200759gg777fr7v7wzcr7r.jpeg" alt="高性能网络编程(六)：一文读懂高性能网络编程中的线程模型_5.jpeg">    </p>
<p> 针对单 Reactor 多线程模型中，Reactor 在单线程中运行，高并发场景下容易成为性能瓶颈，可以让 Reactor 在多线程中运行。</p>
<p>方案说明：</p>
<ul>
<li>1）Reactor 主线程 MainReactor 对象通过 Select 监控建立连接事件，收到事件后通过 Acceptor 接收，处理建立连接事件；</li>
<li>2）Acceptor 处理建立连接事件后，MainReactor 将连接分配 Reactor 子线程给 SubReactor 进行处理；</li>
<li>3）SubReactor 将连接加入连接队列进行监听，并创建一个 Handler 用于处理各种连接事件；</li>
<li>4）当有新的事件发生时，SubReactor 会调用连接对应的 Handler 进行响应；</li>
<li>5）Handler 通过 Read 读取数据后，会分发给后面的 Worker 线程池进行业务处理；</li>
<li>6）Worker 线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给 Handler 进行处理；</li>
<li>7）Handler 收到响应结果后通过 Send 将响应结果返回给 Client。</li>
</ul>
<p>优点：</p>
<p>父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</p>
<p> 父线程与子线程的数据交互简单，Reactor 主线程只需要把新连接传给子线程，子线程无需返回数据。</p>
<p> 这种模型在许多项目中广泛使用，包括 Nginx 主从 Reactor 多进程模型，Memcached 主从多线程，Netty 主从多线程模型的支持。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>3 种模式可以用个比喻来理解：</p>
<p>（餐厅常常雇佣接待员负责迎接顾客，当顾客入坐后，侍应生专门为这张桌子服务）</p>
<ul>
<li>1）单 Reactor 单线程，接待员和侍应生是同一个人，全程为顾客服务；</li>
<li>2）单 Reactor 多线程，1 个接待员，多个侍应生，接待员只负责接待；</li>
<li>3）主从 Reactor 多线程，多个接待员，多个侍应生。</li>
</ul>
<p>Reactor 模式具有如下的优点：</p>
<ul>
<li>1）响应快，不必为单个同步时间所阻塞，虽然 Reactor 本身依然是同步的；</li>
<li>2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；</li>
<li>3）可扩展性，可以方便的通过增加 Reactor 实例个数来充分利用 CPU 资源；</li>
<li>4）可复用性，Reactor 模型本身与具体事件处理逻辑无关，具有很高的复用性。</li>
</ul>
<h3 id="Proactor-模型"><a href="#Proactor-模型" class="headerlink" title="Proactor 模型"></a>Proactor 模型</h3><p> 在 Reactor 模式中，Reactor 等待某个事件或者可应用或者操作的状态发生（比如文件描述符可读写，或者是 Socket 可读写）。 然后把这个事件传给事先注册的 Handler（事件处理函数或者回调函数），由后者来做实际的读写操作。其中的读写操作都需要应用程序同步操作，所以 Reactor 是非阻塞同步网络模型。</p>
<p> 如果把 I/O 操作改为异步，即交给操作系统来完成就能进一步提升性能，这就是异步网络模型 Proactor。</p>
<p>  <img src="http://www.52im.net/data/attachment/forum/201809/06/201251i0om3mro9wtcxrty.jpeg" alt="高性能网络编程(六)：一文读懂高性能网络编程中的线程模型_1.jpeg">    </p>
<p>Proactor 是和异步 I/O 相关的，详细方案如下：</p>
<p>1）Proactor Initiator 创建 Proactor 和 Handler 对象，并将 Proactor 和 Handler 都通过 AsyOptProcessor（Asynchronous Operation Processor）注册到内核；<br>2）AsyOptProcessor 处理注册请求，并处理 I/O 操作；<br>3）AsyOptProcessor 完成 I/O 操作后通知 Proactor；<br>4）Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理；<br>5）Handler 完成业务处理。</p>
<p>可以看出 Proactor 和 Reactor 的区别：</p>
<p>1）Reactor 是在事件发生时就通知事先注册的事件（读写在应用程序线程中处理完成）；<br>2）Proactor 是在事件发生时基于异步 I/O 完成读写操作（由内核完成），待 I/O 操作完成后才回调应用程序的处理器来进行业务处理。</p>
<p>理论上 Proactor 比 Reactor 效率更高，异步 I/O 更加充分发挥 DMA(Direct Memory Access，直接内存存取)的优势。</p>
<p>但是Proactor有如下缺点：</p>
<p>1）编程复杂性，由于异步操作流程的事件的初始化和事件完成在时间和空间上都是相互分离的，因此开发异步应用程序更加复杂。应用程序还可能因为反向的流控而变得更加难以 Debug；<br>2）内存使用，缓冲区在读或写操作的时间段内必须保持住，可能造成持续的不确定性，并且每个并发操作都要求有独立的缓存，相比 Reactor 模式，在 Socket 已经准备好读或写前，是不要求开辟缓存的；<br>3）操作系统支持，Windows 下通过 IOCP 实现了真正的异步 I/O，而在 Linux 系统下，Linux 2.6 才引入，目前异步 I/O 还不完善。</p>
<p>因此在 Linux 下实现高并发网络编程都是以 Reactor 模型为主。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/metric/03_G1_GC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/metric/03_G1_GC/" class="post-title-link" itemprop="url">Java G1 GC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-12 00:00:00" itemprop="dateCreated datePublished" datetime="2018-08-12T00:00:00+08:00">2018-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-04 09:24:03" itemprop="dateModified" datetime="2021-04-04T09:24:03+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-03-G1-GC"><a href="#1-03-G1-GC" class="headerlink" title="1. 03_G1_GC"></a>1. 03_G1_GC</h1><h2 id="1-1-堆内存分配"><a href="#1-1-堆内存分配" class="headerlink" title="1.1. 堆内存分配"></a>1.1. 堆内存分配</h2><p>整个堆分为若干的region，region的大小可以通过参数设置；</p>
<p>Region可以分为Eden、Survivor、Old、Humongous(专门存储大对象的Region：单个对象超过Region大小的50%，就是大对象；</p>
<p>如果大对象超过一个Region，则会继续申请连续的空间，作为Humongous区)和Free(空闲Region: Region的内存被释放后的分区)；Free Region后续可以作为Eden、Survivor、Old或Humongous分区；</p>
<p>堆分为新生代+老年代；</p>
<h2 id="1-2-两个Set"><a href="#1-2-两个Set" class="headerlink" title="1.2. 两个Set"></a>1.2. 两个Set</h2><ol>
<li><p>CSet: collection set, 待回收的Region集合</p>
</li>
<li><p>RSet: remembered set,引用当前Region集合的其他集合</p>
<p>引用当前Region的其他Region集合，是points-in的，每个 Region 都有一个 RSet；在 <code>JDK10</code> 中，只有部分 Region 才存在 RSet。</p>
<ul>
<li><strong>young gc</strong>：指向「Eden」和「Survivor」Region 的 「Old」和「Humongous」Region 集合，避免全堆扫描</li>
<li><strong>mixed gc</strong>：确定「Old」Region 之间的相关引用，确定 Region 的回收价值</li>
</ul>
</li>
</ol>
<h2 id="1-3-垃圾回收过程"><a href="#1-3-垃圾回收过程" class="headerlink" title="1.3. 垃圾回收过程"></a>1.3. 垃圾回收过程</h2><ol>
<li>young gc：标记-复制<ol>
<li>「新生代」的垃圾回收</li>
<li>CSet 中，只包含 Eden、Survivor</li>
</ol>
</li>
<li>mixed gc：标记-复制<ol>
<li>「新生代」和「部分老年代」的垃圾回收</li>
<li>CSet 中，包含 Eden、Survivor、部分 Old、Humongous</li>
</ol>
</li>
<li>full gc：<ol>
<li>G1 gc 失败，退化为 Serial 方式</li>
<li>单线程全堆扫描，对整个 Heap 进行垃圾回收，涵盖所有的「新生代」和「老年代」</li>
</ol>
</li>
</ol>
<blockquote>
<p>G1 垃圾收集器，GC 都是针对 CSet 进行的</p>
</blockquote>
<h3 id="1-3-1-Young-GC"><a href="#1-3-1-Young-GC" class="headerlink" title="1.3.1. Young GC"></a>1.3.1. Young GC</h3><p>Young GC，关键细节：</p>
<ul>
<li>针对「<strong>年轻代</strong>」的 Eden、Survivor 分区，进行 GC</li>
<li><strong>存活的对象</strong>，放置在 「新的 Survivor 分区」或「Old 分区」</li>
<li><strong>触发的时机</strong>：Eden 分区空间不足，无法为普通对象分配存储空间（非大对象）</li>
</ul>
<p><strong>Young GC 的执行过程</strong>：就是「标记-复制」算法</p>
<ol>
<li><strong>根扫描</strong></li>
<li><strong>确定</strong>「老年代」对「新生代」的<strong>引用</strong>，避免全堆扫描：<ol>
<li>根据 card table，扫描 dirty 部分，更新 RSet</li>
<li>新生代中，根据 RSet，确定 Old 对 Eden 和 Survivor 对象的引用</li>
</ol>
</li>
<li><strong>标记复制</strong>：将存活对象，放入到 Survivor 区 或者 Old 区<ol>
<li>新的 Survivor 区：是 Free Region 升级来的</li>
<li>被释放的 Eden 和 Survivor 区：会标记为 Free Region 空白的可用分区</li>
</ol>
</li>
</ol>
<p>Tips：</p>
<ul>
<li>G1 在 Young GC 过程中，是串行？并行？并发？是否会暂停工作线程？<ul>
<li>Re：可以多线程，就看怎么设置了，会暂停工作线程，不是并发的。</li>
</ul>
</li>
</ul>
<h3 id="1-3-2-Mixed-GC"><a href="#1-3-2-Mixed-GC" class="headerlink" title="1.3.2. Mixed GC"></a>1.3.2. Mixed GC</h3><p>Mixed GC，关键细节：</p>
<ul>
<li>针对「<strong>年轻代</strong>」和「<strong>部分老年代</strong>」的 GC，具体 Eden、Survivor、Old、Humongous Region</li>
<li><strong>存活的对象</strong>，放置在「新的 Survivor 分区」或「Old 分区」</li>
<li><strong>触发的时机</strong>：「并发标记周期」中，完成了最后的「<strong>筛选回收</strong>」阶段后，标记出了 X 的 Old Region 分区</li>
</ul>
<p>Mixed GC 的执行过程：就是「标记-复制」算法</p>
<ol>
<li><strong>并发标记周期</strong>：针对 <code>Old 分区</code>，进行标记<ol>
<li><strong>初始标记</strong>：依赖 Young GC</li>
<li><strong>扫描根分区</strong>：如果有 Young GC，则，Young GC block 阻塞等待</li>
<li><strong>并发标记</strong>：<ol>
<li>可以并发进行 Young GC</li>
<li>结束后，并不会进入 Young GC 阶段</li>
</ol>
</li>
<li><strong>重新标记</strong>：不能进行 Young GC</li>
<li><strong>筛选回收</strong>：结束后，进入 mixed 阶段</li>
</ol>
</li>
<li><strong>Mixed GC</strong>，<strong>本质</strong>就是对 <strong>CSet</strong> 中 Region 的回收<ol>
<li><strong>CSet</strong>：在 mixed 模式下，其中涵盖了 Eden、Survivor、Old、Humongous Region</li>
<li><strong>筛选回收阶段</strong>：针对 Old 分区<ol>
<li><strong>完全可回收的 Region</strong>：不存在存活的对象，直接回收 Region，标记为 Free Region 可用分区</li>
<li>存在<strong>部分存活的对象的 Region</strong>：标记分数后，追加在 C-Set 中</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>实际上，可以认为是 2 条线：</p>
<ul>
<li><strong>Young GC</strong>：<ul>
<li>基于 C-Set，进行 Region 回收，本质上，只针对「年轻代」进行回收；</li>
<li>如果 C-Set 中，涵盖了标记为 X 的 Old Region，则，称为 Mixed GC，此时，既针对「年轻代」，也针对「部分老年代」Region 进行回收</li>
</ul>
</li>
<li><strong>并发标记周期</strong>：标记出 Old Region，哪些需要回收，标记为 X<ul>
<li>完成「并发标记阶段」后，Young GC，自动升级为 mixed 模式，即，Mixed GC</li>
<li>Mixed GC：基于 C-Set，进行 Region 回收，只不过，此时，C-Set 中，涵盖了一部分 Old Region</li>
</ul>
</li>
</ul>
<p><img src="_v_images/20200716205954650_1089567156.png"></p>
<p>1 个插图：并发标记周期的说明</p>
<ul>
<li><strong>并发标记周期</strong>：<ul>
<li>触发时机：「老年代」分区的占比，达到阈值</li>
<li>整个周期说明</li>
</ul>
</li>
<li><strong>Mixed GC</strong>：模式生效点、失效点<ul>
<li><strong>生效点</strong>：存在 X 状态的 Old Region，即，标记并发周期的「筛选回收」阶段结束后，再次触发的 GC，就是 Mixed GC</li>
<li><strong>失效点</strong>：完成所有的 X 状态 Old Region 的清理后，会进入 Young GC 状态</li>
</ul>
</li>
<li><strong>补充说明</strong>：<ul>
<li>部分 X 状态的 Old Region：每次 Mixed GC，只有部分 X 状态的 Old Region 会被放入 C-Set</li>
<li>完整 C-Set 都被回收：C-Set 中所有 Region，每次 GC 都会被回收</li>
</ul>
</li>
</ul>
<p><strong>特别说明</strong>：</p>
<blockquote>
<p>G1的收集都是STW的；</p>
<p>但「年轻代」和「老年代」的 GC <strong>界限模糊</strong>，采用了混合(<code>mixed</code>)收集的方式。</p>
<p><strong>Young GC</strong>，可能快速切换为 Mixed GC，只要 X 标记的 Old Region 存在和消失，就会自动升级 or 降级；</p>
<p>这样，即使堆内存很大时，也可以限制<strong>收集 Region 的范围</strong>，从而<strong>降低停顿</strong>，达到设置的「暂停时间的目标」。</p>
</blockquote>
<h3 id="1-3-3-其他"><a href="#1-3-3-其他" class="headerlink" title="1.3.3. 其他"></a>1.3.3. 其他</h3><h4 id="1-3-3-1-启发式算法"><a href="#1-3-3-1-启发式算法" class="headerlink" title="1.3.3.1. 启发式算法"></a>1.3.3.1. 启发式算法</h4><p><strong>启发式算法</strong>：根据执行状态，动态调整</p>
<ol>
<li>设置了「暂停时间的目标」（默认 200ms），G1 会自动调整「年轻代」的空间大小</li>
<li>如果显式设置「年轻代」的大小，则，用户设置的「暂停时间的目标」会自动失效</li>
</ol>
<h4 id="1-3-3-2-SATB，增量式的标记算法"><a href="#1-3-3-2-SATB，增量式的标记算法" class="headerlink" title="1.3.3.2. SATB，增量式的标记算法"></a>1.3.3.2. SATB，增量式的标记算法</h4><p>G1 垃圾收集器，采用了 <strong>SATB</strong>（Snapshot At The Beginning），初始快照，增量式的标记算法，具体：</p>
<ol>
<li><strong>标记开始时</strong>：Region 创建一个 Snapshot</li>
<li><strong>存量标记</strong>：只针对 Snapshot 中存活的对象，进行标记</li>
<li><strong>增量标记</strong>：Snapshot 之后，新生成的对象，都被标记为「存活对象」，此次不回收，下次标记再说</li>
</ol>
<h4 id="1-3-3-3-G1：适用场景"><a href="#1-3-3-3-G1：适用场景" class="headerlink" title="1.3.3.3. G1：适用场景"></a>1.3.3.3. G1：适用场景</h4><p>就目前而言、CMS还是默认首选的GC策略、可能在以下场景下G1更适合：</p>
<ol>
<li><strong>多核+大内存</strong>：服务端多核CPU、JVM内存占用较大的应用（至少大于4G）</li>
<li><strong>业务多碎片</strong>：应用在运行过程中会产生大量内存碎片、需要经常压缩空间</li>
<li><strong>防止高并发雪崩</strong>：想要更可控、可预期的GC停顿周期；防止高并发下应用雪崩现象</li>
</ol>
<h3 id="1-3-4-小结"><a href="#1-3-4-小结" class="headerlink" title="1.3.4. 小结"></a>1.3.4. 小结</h3><p>G1 垃圾收集器，围绕其 Young GC 和 Mixed GC，从整体宏观的角度上，跟之前所有的「串行」「并行」「并发」的垃圾收集器，存在本质的差异：</p>
<ol>
<li>之前的垃圾收集器，要实现 <strong>2 个基本步骤</strong>：<ol>
<li><strong>步骤1</strong>：找到需要回收的对象</li>
<li><strong>步骤2</strong>：回收</li>
<li><strong>Note</strong>：上面两个步骤「步骤2」依赖「步骤1」，并且串行进行</li>
</ol>
</li>
<li>G1 垃圾收集器，在「<strong>老年代</strong>」，把 2 个步骤「同时进行」：<ol>
<li><strong>找到需要回收的对象</strong>：<ol>
<li>在找到需要回收的 Old Region 过程中，仍然可以同时「回收对象」，即 GC</li>
<li>找到需要回收的 Old Region 过程，称为「<strong>并发标记周期</strong>」</li>
</ol>
</li>
<li><strong>回收对象</strong>：<ol>
<li>在「找需要回收的对象」<strong>过程中</strong>，可以持续并发的进行 GC，称为 <code>Young GC</code>，只会收「新生代」</li>
<li>「找需要回收的对象」<strong>过程结束后</strong>，再进行的 GC，称为 <code>Mixed GC</code>，会同时回收「新生代」和「部分老年代」</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>参考示意图：</p>
<p><img src="_v_images/20200716205954411_225227554.png"></p>
<p><img src="_v_images/20200716125557055_1896049925.png"></p>
<p>G1 回收过程如下。</p>
<ol>
<li>G1 的年轻代回收，采用复制算法，并行进行收集，收集过程会 STW。</li>
<li>G1 的老年代回收时也同时会对年轻代进行回收。主要分为四个阶段：<ol>
<li>依然是初始标记阶段完成对根对象的标记，这个过程是STW的；</li>
<li>并发标记阶段，这个阶段是和用户线程并行执行的；</li>
<li>最终标记阶段，完成三色标记周期；</li>
<li>复制/清除阶段，这个阶段会优先对可回收空间较大的 Region 进行回收，即 garbage first，这也是 G1 名称的由来。</li>
</ol>
</li>
</ol>
<p>【参考文献】</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zy1994hyq/article/details/102495471">GC算法之G1算法</a></li>
<li><a target="_blank" rel="noopener" href="https://ningg.top/jvm-series-jvm-practice-jvm-gc-g1/">JVM 实践：G1 垃圾收集器</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/bigdata/Flink/Flink-job-submit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/bigdata/Flink/Flink-job-submit/" class="post-title-link" itemprop="url">flink任务提交</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-12 00:00:00" itemprop="dateCreated datePublished" datetime="2018-08-12T00:00:00+08:00">2018-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-04 09:24:05" itemprop="dateModified" datetime="2021-04-04T09:24:05+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Flink-任务提交"><a href="#Flink-任务提交" class="headerlink" title="Flink-任务提交"></a>Flink-任务提交</h1><h2 id="flink-on-zeppelin"><a href="#flink-on-zeppelin" class="headerlink" title="flink on zeppelin"></a>flink on zeppelin</h2><p><code>org.apache.zeppelin.flink.FlinkScalaInterpreter</code></p>
<h2 id="flink-on-yarn"><a href="#flink-on-yarn" class="headerlink" title="flink on yarn"></a>flink on yarn</h2><p>命令行提交方式</p>
<p><img src="_v_images/20200713162403351_1965495978.png"></p>
<h3 id="yarn-per-job"><a href="#yarn-per-job" class="headerlink" title="yarn per-job"></a>yarn per-job</h3><h4 id="单任务Attach模式"><a href="#单任务Attach模式" class="headerlink" title="单任务Attach模式"></a>单任务Attach模式</h4><p>默认是 Attach 模式，即客户端会一直等待直到程序结束才会退出。</p>
<p>通过 -m yarn-cluster 指定 Yarn 模式</p>
<p>Yarn 上显示名字为 Flink session cluster，这个 Batch 的 Wordcount 任务运行完会 FINISHED。</p>
<h4 id="单任务Detached模式"><a href="#单任务Detached模式" class="headerlink" title="单任务Detached模式"></a>单任务Detached模式</h4><p>由于是 Detached 模式，客户端提交完任务就退出了</p>
<p>Yarn 上显示为 Flink per-job cluster</p>
<h3 id="yarn-session"><a href="#yarn-session" class="headerlink" title="yarn session"></a>yarn session</h3><p>也有attach和detached模式的区分</p>
<p>Flink run 方式提交（推荐模式）</p>
<p>yarn session需要先启动一个集群，然后在提交作业。<br>对于Flink run直接提交作业就相对比较简单，不需要额外的去启动一个集群，直接提交作业，即可完成Flink作业。<br>命令： bin/flink run -m yarn-cluster examples/batch/WordCount.jar，注意使用参数-m yarn-cluster提交到yarn集群。</p>
<h3 id="application-mode"><a href="#application-mode" class="headerlink" title="application mode"></a>application mode</h3><p>应用程序的main方法在jobManager上运行，创建仅仅在特定应用程序的作业之间共享的会话集群，在应用程序完成时终止。</p>
<h2 id="提交任务到yarn并监控任务运行情况"><a href="#提交任务到yarn并监控任务运行情况" class="headerlink" title="提交任务到yarn并监控任务运行情况"></a>提交任务到yarn并监控任务运行情况</h2><p>./flink run -m yarn-cluster -p 4 -yjm 1024m -ytm 1096m -ynm 1  ../examples/batch/WordCount.jar</p>
<p>./flink run-application -t yarn-application ../examples/batch/WordCount.jar</p>
<p>指定application name为1</p>
<p>然后通过yarn-rest-api拿取任务信息</p>
<p>【参考文献】</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/asker009/p/11327533.html">flink on yarn模式下两种提交job方式</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/bigdata/Flink/Flink-timer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/bigdata/Flink/Flink-timer/" class="post-title-link" itemprop="url">Flink Timer</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-12 00:00:00" itemprop="dateCreated datePublished" datetime="2018-08-12T00:00:00+08:00">2018-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-04 09:24:04" itemprop="dateModified" datetime="2021-04-04T09:24:04+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><p>TimerService</p>
<h2 id="SystemProcessingTimeService"><a href="#SystemProcessingTimeService" class="headerlink" title="SystemProcessingTimeService"></a>SystemProcessingTimeService</h2><p>org.apache.flink.streaming.runtime.tasks.SystemProcessingTimeService</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/bigdata/Flink/FlinkOutputTimely/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/bigdata/Flink/FlinkOutputTimely/" class="post-title-link" itemprop="url">Flink定时输出</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-08-12 00:00:00" itemprop="dateCreated datePublished" datetime="2018-08-12T00:00:00+08:00">2018-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-04 09:24:05" itemprop="dateModified" datetime="2021-04-04T09:24:05+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="FlinkOutputTimely"><a href="#FlinkOutputTimely" class="headerlink" title="FlinkOutputTimely"></a>FlinkOutputTimely</h1><p>定时批量输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonSinkOperator</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractStreamOperator</span>&lt;<span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ProcessingTimeCallback</span>,</span></span><br><span class="line"><span class="class">        <span class="title">OneInputStreamOperator</span>&lt;<span class="title">T</span>, <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list;</span><br><span class="line">    <span class="keyword">private</span> ListState&lt;T&gt; listState;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bathSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> interval;</span><br><span class="line">    <span class="keyword">private</span> ProcessingTimeService processingTimeService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonSinkOperator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonSinkOperator</span><span class="params">(<span class="keyword">int</span> batchSize, <span class="keyword">long</span> interval)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.chainingStrategy = ChainingStrategy.ALWAYS;</span><br><span class="line">        <span class="keyword">this</span>.batchSize = batchSize;</span><br><span class="line">        <span class="keyword">this</span>.interval = interval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.open();</span><br><span class="line">        <span class="keyword">if</span> (interval &gt; <span class="number">0</span> &amp;&amp; batchSize &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            processingTimeService = getProcessingTimeService();</span><br><span class="line">            <span class="keyword">long</span> now = processingTimeService.getCurrentProcessingTime();</span><br><span class="line">            processingTimeService.registerTimer(now + interval, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializeState</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            StateInitializationContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.initializeState(context);</span><br><span class="line">        <span class="keyword">this</span>.list = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        listState = context.getOperatorStateStore()</span><br><span class="line"></span><br><span class="line">                .getSerializableListState(<span class="string">&quot;batch-interval-sink&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (context.isRestored()) &#123;</span><br><span class="line">            listState.get().forEach(x -&gt; &#123;</span><br><span class="line">                list.add(x);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            StreamRecord&lt;T&gt; element)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        list.add(element.getValue());</span><br><span class="line">        <span class="keyword">if</span> (list.size() &gt;= batchSize) &#123;</span><br><span class="line">            saveRecords(list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">snapshotState</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">            StateSnapshotContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.snapshotState(context);</span><br><span class="line">        <span class="keyword">if</span> (list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            listState.clear();</span><br><span class="line">            listState.addAll(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProcessingTime</span><span class="params">(<span class="keyword">long</span> timestamp)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (list.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            saveRecords(list);</span><br><span class="line">            list.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> now =processingTimeService.getCurrentProcessingTime();</span><br><span class="line">        processingTimeService.registerTimer(now + interval,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">saveRecords</span><span class="params">(List&lt;T&gt; datas)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/bigdata/tomcat/principle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/bigdata/tomcat/principle/" class="post-title-link" itemprop="url">Apache Tomcat 9 源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-07-30 12:26:00" itemprop="dateCreated datePublished" datetime="2018-07-30T12:26:00+08:00">2018-07-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-04 09:24:04" itemprop="dateModified" datetime="2021-04-04T09:24:04+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Apache tomcat 目前是最常用的免费开源的Java web应用容器(没有之一)，本文旨在分析<a target="_blank" rel="noopener" href="https://tomcat.apache.org/download-90.cgi">Apache Tomcat 9 源码</a>，分析Tomcat高性能的原理</p>
<h2 id="Tomcat启动"><a href="#Tomcat启动" class="headerlink" title="Tomcat启动"></a>Tomcat启动</h2><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h2 id="快速数组扩容"><a href="#快速数组扩容" class="headerlink" title="快速数组扩容"></a>快速数组扩容</h2><h2 id="classLoader"><a href="#classLoader" class="headerlink" title="classLoader"></a>classLoader</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="[参考文献]"></a>[参考文献]</h2><ol>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/crazylqy/p/4706223.html">Tomcat服务器原理详解</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/">Tomcat 系统架构与设计模式，第1部分 工作原理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-tomcat2">Tomcat 系统架构与设计模式，第2部分 设计模式分析</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/bigdata/spider/webDriver_firefox_on_linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/bigdata/spider/webDriver_firefox_on_linux/" class="post-title-link" itemprop="url">搭建webDriver+firefox爬虫服务器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2018-02-04 19:57:00" itemprop="dateCreated datePublished" datetime="2018-02-04T19:57:00+08:00">2018-02-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-04 09:24:05" itemprop="dateModified" datetime="2021-04-04T09:24:05+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Distributed/" itemprop="url" rel="index"><span itemprop="name">Distributed</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>基于Docker搭建的Centos 7平台<br>最新版的firefox 59, 新版的Chrome已经不再支持Linux, Opera半死不活</p>
</blockquote>
<p>Java + Selenium + GeckoDriver + firefox 版本太难兼容<br>本文的版本供参考(验证可用)</p>
<ul>
<li>Java 1.8.0 update 91</li>
<li>Selenium-Java 3.9.1</li>
<li>GeckoDriver 0.19.1</li>
<li>Firefox 59.0b8</li>
</ul>
<h1 id="安装-Java-8"><a href="#安装-Java-8" class="headerlink" title="安装 Java 8"></a>安装 Java 8</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install java-1.8.0-openjdk.x86_64</span><br></pre></td></tr></table></figure>
<h1 id="Selenium-Java"><a href="#Selenium-Java" class="headerlink" title="Selenium-Java"></a>Selenium-Java</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.seleniumhq.selenium<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>selenium-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="GeckoDriver"><a href="#GeckoDriver" class="headerlink" title="GeckoDriver"></a>GeckoDriver</h1><p>Gecko是Firefox的内核，顾名思义，<a target="_blank" rel="noopener" href="https://github.com/mozilla/geckodriver/releases">GeckoDriver</a>就是驱动<br>启动后监听6411端口， Selenium通过IPC调用，访问GeckoDriver</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/mozilla/geckodriver/releases/download/v0.19.1/geckodriver-v0.19.1-linux64.tar.gz</span><br><span class="line">tar -zxvf geckodriver-v0.19.1-linux64.tar.gz</span><br><span class="line">mv geckodriver /usr/local/bin/</span><br></pre></td></tr></table></figure>
<h1 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox"></a>Firefox</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://ftp.mozilla.org/pub/firefox/releases/59.0b8/linux-x86_64/zh-CN/firefox-59.0b8.tar.bz2</span><br><span class="line">tar -xvf firefox-59.0b8.tar.bz2</span><br><span class="line">mv firefox /usr/local/</span><br><span class="line">ln /usr/local/firefox/firefox /usr/bin/firefox</span><br></pre></td></tr></table></figure>
<h2 id="安装虚拟桌面"><a href="#安装虚拟桌面" class="headerlink" title="安装虚拟桌面"></a>安装虚拟桌面</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装Xvfb及其他依赖</span></span><br><span class="line">yum install xorg-x11-server-Xvfb bzip gtk3</span><br></pre></td></tr></table></figure>
<h2 id="安装字体，支持中文"><a href="#安装字体，支持中文" class="headerlink" title="安装字体，支持中文"></a>安装字体，支持中文</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall &quot;Fonts&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装后 重启</span></span><br></pre></td></tr></table></figure>
<h1 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;webdriver.gecko.driver&quot;</span>, <span class="string">&quot;/usr/local/bin/geckodriver&quot;</span>);</span><br><span class="line"></span><br><span class="line">FirefoxOptions firefoxOptions = <span class="keyword">new</span> FirefoxOptions();</span><br><span class="line">firefoxOptions.setHeadless(<span class="keyword">true</span>);</span><br><span class="line">firefoxOptions.setAcceptInsecureCerts(<span class="keyword">true</span>);</span><br><span class="line">firefoxOptions.addArguments(<span class="string">&quot;--disable-gpu&quot;</span>, <span class="string">&quot;--window-size=1920,1200&quot;</span>, <span class="string">&quot;--ignore-certificate-errors&quot;</span>);</span><br><span class="line">WebDriver driver = <span class="keyword">new</span> FirefoxDriver(firefoxOptions);</span><br><span class="line">System.out.println(<span class="string">&quot;init chromeDriver&quot;</span>);</span><br><span class="line">driver.get(<span class="string">&quot;https://www.coinone.com&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;open url&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;sleep over&quot;</span>);</span><br><span class="line"></span><br><span class="line">WebElement closeBtn = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        closeBtn = driver.findElement(By.id(<span class="string">&quot;close_btn&quot;</span>));</span><br><span class="line">            closeBtn.click();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    List&lt;WebElement&gt; elements = driver.findElements(By.cssSelector(<span class="string">&quot;.intro_chart_price table td&quot;</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.size(); i += <span class="number">2</span>) &#123;</span><br><span class="line">        String value = elements.get(i + <span class="number">1</span>).getText().trim();</span><br><span class="line">            System.out.println(<span class="string">&quot;empty value , try &quot;</span> + tryCount);</span><br><span class="line">        System.out.println(elements.get(i).getText().trim() + <span class="string">&quot;\t&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">driver.close();</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1518339710700	geckodriver	INFO	geckodriver 0.19.1</span><br><span class="line">1518339710706	geckodriver	INFO	Listening on 127.0.0.1:6411</span><br><span class="line">1518339711356	mozrunner::runner	INFO	Running command: &quot;&#x2F;usr&#x2F;local&#x2F;firefox&#x2F;firefox&quot; &quot;-marionette&quot; &quot;-headless&quot; &quot;--disable-gpu&quot; &quot;--window-size&#x3D;1920,1200&quot; &quot;--ignore-certificate-errors&quot; &quot;-profile&quot; &quot;&#x2F;tmp&#x2F;rust_mozprofile.1ZVD24PplvDp&quot;</span><br><span class="line">*** You are running in headless mode.</span><br><span class="line">1518339712100	Marionette	INFO	Enabled via --marionette</span><br><span class="line">1518339715188	Marionette	INFO	Listening on port 36443</span><br><span class="line">1518339715212	Marionette	WARN	TLS certificate errors will be ignored for this session</span><br><span class="line">Feb 11, 2018 9:01:55 AM org.openqa.selenium.remote.ProtocolHandshake createSession</span><br><span class="line">INFO: Detected dialect: W3C</span><br><span class="line">init chromeDriver</span><br><span class="line">open url</span><br><span class="line">sleep over</span><br><span class="line"></span><br><span class="line">BTC	8,918,000</span><br><span class="line">BCH	1,197,500</span><br><span class="line">ETH	814,200</span><br><span class="line">ETC	22,720</span><br><span class="line">XRP	1,056</span><br><span class="line">QTUM	29,710</span><br><span class="line">LTC	165,050</span><br><span class="line">IOTA	1,910</span><br><span class="line">BTG	370,350</span><br></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="[参考文献]"></a>[参考文献]</h2><p>太多</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/multithread/05.ThreadPool-principle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/multithread/05.ThreadPool-principle/" class="post-title-link" itemprop="url">Java中的线程池原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-10-25 00:00:00" itemprop="dateCreated datePublished" datetime="2017-10-25T00:00:00+08:00">2017-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-04 09:24:03" itemprop="dateModified" datetime="2021-04-04T09:24:03+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>[TOC]</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="线程池的组成"><a href="#线程池的组成" class="headerlink" title="线程池的组成"></a>线程池的组成</h3><p><img src="/images/java/multithread/05.thread_pool/1.constructs.png" alt="1.constructs"></p>
<h3 id="提交Job的处理流程："><a href="#提交Job的处理流程：" class="headerlink" title="提交Job的处理流程："></a>提交Job的处理流程：</h3><p><img src="/images/java/multithread/05.thread_pool/2.new_task.png" alt="2.new_task"></p>
<p>核心代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (command == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  <span class="comment">// 如果线程数小于核心工作线程数, 则创建线程并执行当前任务</span></span><br><span class="line">  <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line">    <span class="comment">// 如线程数大于等于核心工作线程数或线程创建失败, 则将当前任务放到任务队列中.</span></span><br><span class="line">    <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>) ensureQueuedTaskHandled(command);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果线程池不处于运行中或任务无法放入队列, 并且当前线程数量小于最大工作线程数,</span></span><br><span class="line">    <span class="comment">// 则创建一个线程执行任务.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">      <span class="comment">// 抛出RejectedExecutionException异常</span></span><br><span class="line">      reject(command); <span class="comment">// is shutdown or saturated</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>工作线程worker</code>数量低于<code>核心工作线程数corePoolSize</code>时会优先创建一个<code>工作线程worker</code>处理<code>job</code>, 处理成功则返回.</li>
<li><code>工作线程worker</code>数量高于<code>核心工作线程数</code>时会优先把<code>job</code>放入到<code>任务队列</code>, 放入队列成功时处理结束.</li>
<li>入队失败会识别工作线程数是否还小于<code>最大工作线程数maximumPoolsize</code>, 小于的话也会新创建一个<code>工作线程worker</code>处理<code>job</code>.</li>
<li>饱和策略</li>
</ol>
<p>此外, 运行过程中, 更新核心工作线程数时, 若发现扩容, 会增加工作线程数.</p>
<p><strong>备注:</strong></p>
<ol>
<li>Java中的线程与操作系统的线程是一一对应的</li>
<li>添加新线程需要获得全局锁<br><code>private final ReentrantLock mainLock = new ReentrantLock();</code>, 因此, 当<code>工作线程work数量</code>大于<code>核心工作线程数corePoolSize</code>时, 优先放入<code>任务队列</code></li>
<li>只要工作线程达不到<code>corePoolSize</code>, 不管是否线程空闲, 都会创建新线程</li>
<li>调用<code>prestartAllCoreThreads</code>会初始化所有的核心线程, 没有预热期, 响应快, 但空载浪费资源</li>
<li>向<code>任务队列</code>添加任务, 不需要获取全局锁, 效率高</li>
<li>工作线程的复用: 执行完一个任务, 不断从<code>任务队列</code>取任务, 避免因创建和销毁操作系统线程带来的性能消耗</li>
<li>获取全局锁, 是性能性能瓶颈, <code>corePoolSize</code>是预热</li>
</ol>
<h3 id="工作线程的销毁"><a href="#工作线程的销毁" class="headerlink" title="工作线程的销毁"></a>工作线程的销毁</h3><p>满足下面条件会销毁:</p>
<ol>
<li>任务队列里没有<code>job</code>并且<code>工作线程worker</code>数量超过了<code>核心工作线程数corePoolSize</code>.</li>
<li>任务队列里没有<code>job</code>并且允许<code>工作线程数量</code>小于<code>核心工作线程</code>参数为<code>true</code>, 此场景会至少保留一个工作线程线程.</li>
</ol>
<p>工作线程空闲后, 最长等待<code>keepAliveTime</code></p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>
<p>用给定的初始参数和默认的线程工厂及饱和策略创建新的 <code>ThreadPoolExecutor</code>.<br>使用 <code>Executors</code> 工厂方法之一比使用此通用构造方法方便得多, 但是<a target="_blank" rel="noopener" href="https://yq.aliyun.com/attachment/download/?id=2023">阿里巴巴Java规约</a>不推荐使用, 见下文</p>
<ul>
<li>参数:<ul>
<li><code>corePoolSize</code> - 池中所保存的线程数, 包括空闲线程.</li>
<li><code>maximumPoolSize</code> - 池中允许的最大线程数.</li>
<li><code>keepAliveTime</code> - 当线程数大于核心时, 此为终止前多余的空闲线程等待新任务的最长时间.</li>
<li><code>unit</code> - <code>keepAliveTime</code> 参数的时间单位.</li>
<li><code>workQueue</code> - 执行前用于保持任务的队列. 此队列仅保持由 <code>execute</code> 方法提交的 <code>Runnable</code> 任务.</li>
</ul>
</li>
<li>抛出:<ul>
<li><code>IllegalArgumentException</code> - 如果 <code>corePoolSize</code> 或 <code>keepAliveTime</code> 小于零, 或者 <code>maximumPoolSize</code> 小于或等于零, 或者 <code>corePoolSize</code> 大于 <code>maximumPoolSize</code>.</li>
<li><code>NullPointerException</code> - 如果 <code>workQueue</code> 为 <code>null</code></li>
</ul>
</li>
</ul>
<h3 id="工作线程的存储"><a href="#工作线程的存储" class="headerlink" title="工作线程的存储"></a>工作线程的存储</h3><p>使用了<code>HashSet</code>来存储工作线程<code>worker</code>, 通过可重入锁<code>ReentrantLock</code>对其进行并发保护. 每个<code>worker</code>都是一个<code>Runnable</code>接口.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set containing all worker threads in pool. Accessed only when</span></span><br><span class="line"><span class="comment"> * holding mainLock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br></pre></td></tr></table></figure>



<h3 id="任务队列-runnableTaskQueue"><a href="#任务队列-runnableTaskQueue" class="headerlink" title="任务队列 runnableTaskQueue"></a>任务队列 runnableTaskQueue</h3><p>线程池中的队列采用的是<a href="/Java/multithread/06.BlockingQueue/"><code>BlockingQueue</code></a></p>
<ul>
<li><code>ArrayBlockingQueue</code>：是一个基于数组结构的有界阻塞队列, 此队列按 <code>FIFO（先进先出）</code>原则对元素进行排序.</li>
<li><code>LinkedBlockingQueue</code>：一个基于链表结构的阻塞队列, 此队列按FIFO排序元素, 吞吐量通常要高于<code>ArrayBlockingQueue</code>. 静态工厂方法<code>Executors.newFixedThreadPool()</code>使用了这个队列.</li>
<li><code>SynchronousQueue</code>：一个不存储元素的阻塞队列. 每个插入操作必须等到另一个线程调用移除操作, 否则插入操作一直处于阻塞状态, 吞吐量通常要高于<code>Linked-BlockingQueue</code>, 静态工厂方法<code>Executors.newCachedThreadPool</code>使用了这个队列.</li>
<li><code>PriorityBlockingQueue</code>：一个具有优先级的无限阻塞队列.</li>
</ul>
<h3 id="线程工厂-ThreadFactory"><a href="#线程工厂-ThreadFactory" class="headerlink" title="线程工厂 ThreadFactory"></a>线程工厂 ThreadFactory</h3><p>设置创建线程的工厂, 通过线程工厂给每个创建出来的线程设置更有意义的名字. 使用开源框架guava提供的<code>ThreadFactoryBuilder</code>可以快速给线程池里的线程设置有意义的名字, 代码如下.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newThreadFactoryBuilder().setNameFormat(<span class="string">&quot;XX-task-%d&quot;</span>).build();</span><br></pre></td></tr></table></figure>


<h3 id="RejectedExecutionHandler（饱和策略）"><a href="#RejectedExecutionHandler（饱和策略）" class="headerlink" title="RejectedExecutionHandler（饱和策略）"></a>RejectedExecutionHandler（饱和策略）</h3><p>当队列和线程池都满了, 说明线程池处于饱和状态, 那么必须采取一种策略处理提交的新任务. 这个策略默认情况下是 <code>AbortPolicy</code> , 表示无法 处理新任务时抛出异常. 在JDK 1.5中Java线程池框架提供了以下4种策略.</p>
<ul>
<li><p><code>AbortPolicy</code> ：直接抛出异常.</p>
</li>
<li><p><code>CallerRunsPolicy</code> ：只用调用者所在线程来运行任务.</p>
</li>
<li><p><code>DiscardOldestPolicy</code> ：丢弃队列里最近的一个任务, 并执行当前任务.</p>
</li>
<li><p><code>DiscardPolicy</code> ：不处理, 丢弃掉.</p>
</li>
</ul>
<p>当然, 也可以根据应用场景需要来实现<code>RejectedExecutionHandler</code>接口自定义策略. 如记录日志或持久化存储不能处理的任务.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池异常处理类:</span></span><br><span class="line"><span class="comment"> * 任务执行失败, 持久化到数据库</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  averyzhang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRejectedExecutionHandler</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable task, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Begin exception handler-----------&quot;</span>);</span><br><span class="line">    <span class="comment">//执行失败任务</span></span><br><span class="line">    CachingOnFirstOpenRunnable coor = (CachingOnFirstOpenJob)task;</span><br><span class="line">    List&lt;CachingEntity&gt; list = coor.getLastData();</span><br><span class="line">    CachingDaoUtils.save(list);</span><br><span class="line">    <span class="comment">//打印线程池的对象</span></span><br><span class="line">    System.out.println(<span class="string">&quot;The pool RejectedExecutionHandler = &quot;</span>+executor.toString());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="提交任务-submit与execute"><a href="#提交任务-submit与execute" class="headerlink" title="提交任务: submit与execute"></a>提交任务: submit与execute</h3><p><code>execute</code> 没有返回值</p>
<p><code>submit</code> 可以通过 <code>Future</code> 接口, 获取任务执行的结果: 线程池会返回一个future类型的对象, 通过这个 future对象可以判断任务是否执行成功, 并且可以通过future的<code>get()</code>方法来获取返回值, <code>get()</code>方法会阻塞当前线程直到任务完成, 而使用<code>get(long timeout, TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回, 这时候有可能任务没有执行完.</p>
<h3 id="关闭-shutdown与shutdownNow"><a href="#关闭-shutdown与shutdownNow" class="headerlink" title="关闭: shutdown与shutdownNow"></a>关闭: shutdown与shutdownNow</h3><p>原理是遍历线程池中的工作线程, 然后逐个调用线程的<code>interrupt</code>方法来中断线程, 所以无法响应中断的任务可能永远无法终止.</p>
<ul>
<li><code>shutdownNow</code>首先将线程池的状态设置成 <code>STOP</code>, 然后尝试停止所有的正在执行或暂停任务的线程, 并返回等待执行任务的列表</li>
<li> <code>shutdown</code>只是将线程池的状态设置成<code>SHUTDOWN</code>状态, 然后中断所有没有正在执行任务的线程</li>
</ul>
<p>获取线程的关闭状态:</p>
<p>调用两个关闭方法, <code>isShutdown</code>方法就会返回<code>true</code>. 当所有的任务都已关闭后, 才表示线程池关闭成功, 这时调用<code>isTerminaed</code>方法会返回<code>true</code>.</p>
<p>至于应该调用哪一种方法来关闭线程池, 应该由提交到线程池的任务特性决定, 通常调用<code>shutdown</code>方法来关闭线程池, 如果任务不一定要执行完, 则可以调用<code>shutdownNow</code>方法.</p>
<h2 id="优化配置"><a href="#优化配置" class="headerlink" title="优化配置"></a>优化配置</h2><p>性质不同的任务可以用不同规模的线程池分开处理:</p>
<ul>
<li><code>CPU密集型任务</code>应配置尽可能小的线程, 如配置<code>Ncpu+1</code>个线程的线程池</li>
<li><code>IO密集型任务线程</code>并不是一直在执行任务, 则应配置尽可能多的线程, 如<code>2*Ncpu</code></li>
<li>混合型的任务, 如果可以拆分, 将其拆分成一个CPU密集型任务和一个IO密集型任务, 只要这两个任务执行的时间相差不是太大, 那么分解后执行的吞吐量将高于串行执行的吞吐量. 如果这两个任务执行时间相差太大, 则没必要进行分解.</li>
<li>可以通过 <code>Runtime.getRuntime().availableProcessors()</code>方法获得当前设备的CPU个数</li>
<li>如果任务很多, 并且每个任务执行的时间比较短, 可以调大<code>keepAliveTime</code>时间, 提高线程的利用率.</li>
<li>优先级不同的任务可以使用优先级队列<code>PriorityBlockingQueue</code>来处理. 它可以让优先级高的任务先执行.  优先级低的任务可能永远不能执行.</li>
<li>建议使用有界队列. 有界队列能增加系统的稳定性和预警能力, 可以根据需要设大一点：如果采用无解队列, 当任务无法处理引起堆积, 系统撑爆, 殃及其他业务</li>
</ul>
<p>通常基于几个维度进行：待处理工作job数、线程池定义的最大最小工作线程数、工作线程闲置时间.</p>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>通过线程池提供的参数进行监控, 在监控线程池的时候可以使用以下属性.</p>
<ul>
<li><p><code>taskCount</code>：线程池需要执行的任务数量.</p>
</li>
<li><p><code>completedTaskCount</code>：线程池在运行过程中已完成的任务数量, 小于或等于<code>taskCount</code>.</p>
</li>
<li><p><code>largestPoolSize</code>：线程池里曾经创建过的最大线程数量. 通过这个数据可以知道线程池是否曾经满过. 如该数值等于线程池的最大大小, 则表示线程池曾经满过.</p>
</li>
<li><p><code>getPoolSize</code>：线程池的线程数量. 如果线程池不销毁的话, 线程池里的线程不会自动销 毁, 所以这个大小只增不减.</p>
</li>
<li><p><code>getActiveCount</code>：获取活动的线程数.  通过扩展线程池进行监控.</p>
</li>
<li><p>通过继承线程池来自定义线程池, 重写线程池的 <code>beforeExecute</code>、<code>afterExecute</code>和<code>terminated</code>方法, 可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控. 例如, 监控任务的平均执行时间、最大执行时间和最小执行时间等. 这几个方法在线程池里是空方法.</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t,Runnable r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sample</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyScheduledExecutorService</span> <span class="keyword">extends</span> <span class="title">ScheduledThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyScheduledExecutorService.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TableauScheduledExecutorService</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, threadFactory, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TableauScheduledExecutorService</span><span class="params">(<span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;############# before execute \n&quot;</span> + currentStatus());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;############# after execute \n&quot;</span> + currentStatus());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;############# terminated \n&quot;</span> + currentStatus());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">currentStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要执行的任务数目</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> taskCount = getTaskCount();</span><br><span class="line">        <span class="comment">// 执行完成的任务数目</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> completedTaskCount = getCompletedTaskCount();</span><br><span class="line">        <span class="comment">// 线程池最大线程数量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> largestPoolSize = getLargestPoolSize();</span><br><span class="line">        <span class="comment">// 线程池线程数量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> poolSize = getPoolSize();</span><br><span class="line">        <span class="comment">// 活动线程数量</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> activeCount = getActiveCount();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[要执行任务:&quot;</span> + taskCount + <span class="string">&quot;,完成:&quot;</span> + completedTaskCount + <span class="string">&quot;,线程池最大数量:&quot;</span> + largestPoolSize +</span><br><span class="line">                <span class="string">&quot;,当前线程数量:&quot;</span> + poolSize + <span class="string">&quot;,活动线程数量:&quot;</span> + activeCount + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>TODO 等待关闭</p>
</blockquote>
<h2 id="Alibaba-Java-规约"><a href="#Alibaba-Java-规约" class="headerlink" title="Alibaba Java 规约"></a>Alibaba Java 规约</h2><p>线程池不允许使用Executors去创建, 而是通过ThreadPoolExecutor的方式, 这样的处理方式让写的同学更加明确线程池的运行规则, 规避资源耗尽的风险.  说明：Executors各个方法的弊端：<br>1）<code>newFixedThreadPool和newSingleThreadExecutor:</code><br>  主要问题是堆积的请求处理队列可能会耗费非常大的内存, 甚至OOM.<br>2）<code>newCachedThreadPool和newScheduledThreadPool:</code><br>  主要问题是线程数最大数是Integer.MAX_VALUE, 可能会创建数量非常多的线程, 甚至OOM.</p>
<p>Positive example 1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.commons.lang3.concurrent.BasicThreadFactory</span></span><br><span class="line">ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>, <span class="keyword">new</span> BasicThreadFactory.Builder().namingPattern(<span class="string">&quot;example-schedule-pool-%d&quot;</span>).daemon(<span class="keyword">true</span>).build());</span><br></pre></td></tr></table></figure>

<p>Positive example 2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">.setNameFormat(<span class="string">&quot;demo-pool-%d&quot;</span>).build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Common Thread Pool</span></span><br><span class="line">ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">200</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">pool.execute(()-&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">pool.shutdown();<span class="comment">//gracefully shutdown</span></span><br></pre></td></tr></table></figure>

<p>Positive example 3：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userThreadPool&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;corePoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxPoolSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;queueCapacity&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2000&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;threadFactory&quot;</span> <span class="attr">value</span>= <span class="string">threadFactory</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;rejectedExecutionHandler&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ref</span> <span class="attr">local</span>=<span class="string">&quot;rejectedExecutionHandler&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in code</span></span><br><span class="line">    userThreadPool.execute(thread);</span><br></pre></td></tr></table></figure>
<p>线程池的关闭</p>
<p>等待关闭超时</p>
<h1 id="next…TODO"><a href="#next…TODO" class="headerlink" title="next…TODO"></a>next…TODO</h1><ol>
<li>Future接口</li>
<li>任务队列的实现</li>
<li><code>ArrayBlockingQueue</code></li>
<li><code>LinkedBlockingQueue</code></li>
<li><code>SynchronousQueue</code></li>
<li><code>PriorityBlockingQueue</code></li>
<li>线程池的底层实现</li>
<li>guava与线程工厂的使用</li>
<li>线程关闭与中断: 强制关闭与响应中断</li>
<li>Java获取设备参数的API</li>
<li>连接池</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/Java-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/Java-tips/" class="post-title-link" itemprop="url">Java编程tips</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-10-17 10:00:00" itemprop="dateCreated datePublished" datetime="2017-10-17T10:00:00+08:00">2017-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-04 09:24:03" itemprop="dateModified" datetime="2021-04-04T09:24:03+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>Calendar<br>获取小时数 [2017-10-17 16:10:36 星期二]<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">// 获取12小时制的小时数</span></span><br><span class="line"><span class="keyword">int</span> hour12 = calendar.get(Calendar.HOUR);</span><br><span class="line"><span class="comment">// 获取24小时制的小时数</span></span><br><span class="line"><span class="keyword">int</span> hour24 = calendar.get(Calendar.HOUR_OF_DAY);</span><br></pre></td></tr></table></figure></li>
<li>读锁(共享锁)与写锁(独占锁)</li>
</ol>
<p>[2017-10-17 16:10:41 星期二]</p>
<p>虽然读锁可以允许多个线程读取，写锁会独占，但是当一个线程对资源加了读锁后，另一个线程要加独占锁也必须等待读锁释放。</p>
<ol start="3">
<li>Java web 获取 classes 目录</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String path = Thread.currentThread().getContextClassLoader().getResource(<span class="string">&quot;/&quot;</span>).toURI().getPath();</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/lib/Jpa/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/lib/Jpa/" class="post-title-link" itemprop="url">Java JPA</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-08-12 00:00:00" itemprop="dateCreated datePublished" datetime="2017-08-12T00:00:00+08:00">2017-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-04 09:24:03" itemprop="dateModified" datetime="2021-04-04T09:24:03+08:00">2021-04-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Jpa"><a href="#Jpa" class="headerlink" title="Jpa"></a>Jpa</h1><h2 id="创建时间-更新时间"><a href="#创建时间-更新时间" class="headerlink" title="创建时间 更新时间"></a>创建时间 更新时间</h2><p>1.实体类加注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 创建时间</span><br><span class="line"> *&#x2F;</span><br><span class="line">@CreatedDate</span><br><span class="line">@Column(name &#x3D; &quot;create_time&quot;)</span><br><span class="line">private Date createTime;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 修改时间</span><br><span class="line"> *&#x2F;</span><br><span class="line">@LastModifiedDate</span><br><span class="line">@Column(name &#x3D; &quot;modify_time&quot;)</span><br><span class="line">private Date modifyTime;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.实体类头加注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@EntityListeners(AuditingEntityListener.class)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3.SpringBoot启动类加注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@EnableJpaAuditing</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外数据库添加相应控制也可以：<br>createTime ： CURRENT_TIMESTAMP<br>modifyTime ： CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/12/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/14/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">aaronzhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">240</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">120</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aaronzhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
