<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Guadazi">
<meta property="og:url" content="http://example.com/page/17/index.html">
<meta property="og:site_name" content="Guadazi">
<meta property="og:locale">
<meta property="article:author" content="aaronzhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/17/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Guadazi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Guadazi</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/database/MySQL/syntax_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/database/MySQL/syntax_1/" class="post-title-link" itemprop="url">【基础】MySQL语法基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-12-27 11:00:00" itemprop="dateCreated datePublished" datetime="2016-12-27T11:00:00+08:00">2016-12-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-23 13:04:00" itemprop="dateModified" datetime="2021-04-23T13:04:00+08:00">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DataBase/" itemprop="url" rel="index"><span itemprop="name">DataBase</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文主要介绍SQL语言以及部分MySQL的基础知识。</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>MySQL的默认的端口号是3306 超级用户是<code>root</code></p>
<p>MySql引擎</p>
<p><img src="/images/j2ee/MySQL/MySql-Engine.png"></p>
<h1 id="MySQL提示符-命令与语法规范"><a href="#MySQL提示符-命令与语法规范" class="headerlink" title="MySQL提示符 命令与语法规范"></a>MySQL提示符 命令与语法规范</h1><p>MySQL的所有的指令都是以结束符结束的, 回车提交命令. 默认的提示符是<code>;</code>号.</p>
<h2 id="修改提示符"><a href="#修改提示符" class="headerlink" title="修改提示符"></a>修改提示符</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prompt localhost;</span><br><span class="line">将提示符修改为localhost</span><br></pre></td></tr></table></figure>
<p>之后每一行的提示符由<code>mysql&gt;</code>变为<code>localhost&gt;</code>， 还可以使用通配符修改提示符。</p>
<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><p>通过<code>SELECT</code>执行内置函数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> VERSION(); <span class="operator">/</span><span class="operator">/</span>显示当前服务器版本</span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> VERSION()  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5.5</span><span class="number">.19</span><span class="operator">-</span>log <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> NOW(); <span class="operator">/</span><span class="operator">/</span>显示当前日期时间</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> NOW()               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2016</span><span class="number">-04</span><span class="number">-12</span> <span class="number">08</span>:<span class="number">51</span>:<span class="number">44</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>(); <span class="operator">/</span><span class="operator">/</span>显示当前用户</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">USER</span>()         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br><span class="line"><span class="operator">|</span> root<span class="variable">@localhost</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+</span></span><br></pre></td></tr></table></figure>
<h2 id="语法规范："><a href="#语法规范：" class="headerlink" title="语法规范："></a>语法规范：</h2><ul>
<li>关键字和函数名称必须全部大写</li>
<li>数据库名称 表名称 字段名称全部小写</li>
<li>SQL语句必须以分号结尾</li>
</ul>
<p>命名规则：</p>
<ul>
<li>可读性原则：驼峰提高可读性</li>
<li>表意性原则：对象的名字能反应对象的意义</li>
<li>长名原则：少用缩写</li>
</ul>
<h1 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h1><p>创建数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE &#123;DATABASE|SCHEMA&#125;[IF NOT EXISTS] db_name</span><br><span class="line">[<span class="keyword">DEFAULT</span>] <span class="type">CHARACTER</span> <span class="keyword">SET</span> [<span class="operator">=</span>] charset_name</span><br><span class="line"><span class="comment">--- MySQL中SCHEMA与DATABASE名称相同</span></span><br></pre></td></tr></table></figure>
<p>查看当前MySql服务器下的数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW &#123;DATABASES|SCHEMAS&#125;</span><br><span class="line">[<span class="keyword">LIKE</span> <span class="string">&#x27;pattern&#x27;</span><span class="operator">|</span><span class="keyword">WHERE</span> EXPR]</span><br></pre></td></tr></table></figure>
<p>修改数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER &#123;DATABASE|SCHEMA&#125;[db_name]</span><br><span class="line">[<span class="keyword">DEFAULT</span>]<span class="type">CHARACTER</span> <span class="keyword">SET</span> [<span class="operator">=</span>] charset_name</span><br></pre></td></tr></table></figure>
<p>删除数据库</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP &#123;DATABASE|SCHEMA&#125;[IF NOT EXISTS] db_name</span><br></pre></td></tr></table></figure>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>MySQL中的数据类型主要有整形 浮点型 字符型和日期时间型.<br>字段的类型影响着存储容量和数据查询性能。当可以选择多种类型时，优先选择数字类型，<br>其次是日期和二进制类型，最后是字符类型。相同级别的类型优先选择省空间的类型。</p>
<p><img src="/images/j2ee/MySQL/MySql-DataType.png"></p>
<p>对于上述原则主要从下面两个方面考虑：</p>
<ol>
<li>在对数据进行比较时(查询条件、JOIN条件及排序)操作时，<br><strong>同样的数据，字符处理往往比数字处理慢</strong></li>
<li>在数据库中，数据处理以页为单位，<strong>列的长度越小，利于性能提升</strong></li>
</ol>
<p>char与varchar选择:</p>
<ol>
<li>如果列中要存储的数据长度差不多是一致的，则应该考虑用char；否则应该用varchar。</li>
<li>如果列中的最大数据长度小于50Byte，则一般也考虑用char.(当然，如果这个列很少用，<br>则基于节省空间和较少I/O的考虑，还是可以选择用varchar)</li>
<li>一般不宜定义大于50Byte的char类型列。</li>
</ol>
<h2 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h2><p><img src="/images/j2ee/MySQL/MySql-DataType-Number.png"></p>
<h2 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h2><p><img src="/images/j2ee/MySQL/MySql-DataType-Float.png"></p>
<h2 id="日期时间型"><a href="#日期时间型" class="headerlink" title="日期时间型"></a>日期时间型</h2><p><img src="/images/j2ee/MySQL/MySql-DataType-DateTime.png"></p>
<h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><p><img src="/images/j2ee/MySQL/MySql-DataType-String.png"></p>
<h1 id="操作数据表"><a href="#操作数据表" class="headerlink" title="操作数据表"></a>操作数据表</h1><h2 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE db_name; <span class="operator">/</span><span class="operator">/</span>打开数据库</span><br></pre></td></tr></table></figure>
<h2 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] table_name(</span><br><span class="line">  column_name data_type,</span><br><span class="line">  ....</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>查看创建当前数据库的语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> provinces(</span><br><span class="line">    id <span class="type">SMALLINT</span> UNSIGNED <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">    pname <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">  );</span><br><span class="line">显示创建数据库的语句</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> provinces;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>     <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                                                                                                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> provinces <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `provinces` (</span><br><span class="line">  `id` <span class="type">smallint</span>(<span class="number">5</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `pname` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>latin1 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>以表格的形式显示列和列的属性</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> columns <span class="keyword">from</span> provinces;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+----------------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type                 <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+----------------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> <span class="type">smallint</span>(<span class="number">5</span>) unsigned <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> auto_increment <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> pname <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">20</span>)          <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+----------------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br><span class="line"><span class="keyword">desc</span> provinces;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+----------------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type                 <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+----------------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> <span class="type">smallint</span>(<span class="number">5</span>) unsigned <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> auto_increment <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> pname <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">20</span>)          <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+----------------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>


<h2 id="查看数据库中的数据表列表"><a href="#查看数据库中的数据表列表" class="headerlink" title="查看数据库中的数据表列表"></a>查看数据库中的数据表列表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES [<span class="keyword">FROM</span> db_name]</span><br><span class="line">[<span class="keyword">LIKE</span> <span class="string">&#x27;pattern&#x27;</span><span class="operator">|</span><span class="keyword">WHERE</span> expr]</span><br></pre></td></tr></table></figure>
<h2 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> [<span class="keyword">INTO</span>] table_name [(column_name,...)] <span class="keyword">VALUES</span>(var,...)</span><br></pre></td></tr></table></figure>
<h2 id="记录查找"><a href="#记录查找" class="headerlink" title="记录查找"></a>记录查找</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> expr,... <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<p>select 子句中可以包含子查询</p>
<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ol>
<li>约束保证数据的完整性和一致性</li>
<li>约束分为表级约束和列级约束</li>
<li>约束类型包括:<ul>
<li>NOT NULL 非空元素</li>
<li>PRIMARY KEY 主键约束</li>
<li>UNIQUE KEY 唯一约束</li>
<li>DEFAULT 默认约束</li>
<li>FOREIGN KEY 外键约束.</li>
</ul>
</li>
</ol>
<h3 id="自增长-AUTO-INCREMENT"><a href="#自增长-AUTO-INCREMENT" class="headerlink" title="自增长 AUTO_INCREMENT"></a>自增长 AUTO_INCREMENT</h3><ol>
<li>自动编号，且该字段必须是主键：<br>AUTO_INCREMENT必须是主键，主键不一定AUTO_INCREMENT</li>
<li>默认情况下，其实值是1，每次增量是1</li>
</ol>
<p>插入数据时可以使用<code>DEFAULT</code>或者<code>NULL</code>为自增长字段赋值，以生成自增长数据。</p>
<p>例如在上面的<code>provinces</code>表中, 插入数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> provinces <span class="keyword">values</span>(<span class="keyword">null</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.08</span> sec)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> provinces <span class="keyword">values</span>(<span class="keyword">DEFAULT</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.08</span> sec)</span><br><span class="line"> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> provinces;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> pname <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h3 id="主键约束-PRIMARY-KEY"><a href="#主键约束-PRIMARY-KEY" class="headerlink" title="主键约束 PRIMARY KEY"></a>主键约束 PRIMARY KEY</h3><ol>
<li>主键约束</li>
<li>每张数据表只能存在一个主键</li>
<li>主键保证记录的唯一性</li>
<li>主键自动为<code>NOT NULL</code></li>
</ol>
<h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><ol>
<li>保证记录的唯一性</li>
<li>字段可以为空值(NULL) 且可以多个为空</li>
<li>每张表可以有多个唯一约束</li>
</ol>
<h3 id="默认值约束-DEFAULT"><a href="#默认值约束-DEFAULT" class="headerlink" title="默认值约束 DEFAULT"></a>默认值约束 DEFAULT</h3><p>当插入记录时， 如果没有明确为字段赋值，则自动赋值为默认值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb6(</span><br><span class="line">    id <span class="type">SMALLINT</span> UNSIGNED AUTO_INCREMENT <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span> KEY,</span><br><span class="line">    sex ENUM(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>查看表格结构</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> COLUMNS <span class="keyword">FROM</span> tb6;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+----------------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="operator">|</span> Field    <span class="operator">|</span> Type                 <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+----------------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id       <span class="operator">|</span> <span class="type">smallint</span>(<span class="number">5</span>) unsigned <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> auto_increment <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> username <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">20</span>)          <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> UNI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sex      <span class="operator">|</span> enum(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)    <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="number">3</span>       <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+----------------------+------+-----+---------+----------------+</span></span><br></pre></td></tr></table></figure>
<p>使用默认值插入记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>使用<span class="keyword">DEFAULT</span>来生成AUTO_INCREMENT</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb6 <span class="keyword">VALUES</span>(<span class="keyword">Default</span>,&quot;李四&quot;,<span class="keyword">DEFAULT</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.08</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Select</span> <span class="operator">*</span>  <span class="keyword">from</span> tb6;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> username <span class="operator">|</span> sex  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 李四   <span class="operator">|</span> <span class="number">3</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>指定字段为枚举类型: 与Java中的枚举类型不同, sql中的枚举只是限制取值范围.</p>
<h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>要求</p>
<ol>
<li>父表和字表必须使用相同的存储引擎, 而且禁止使用临时表</li>
<li>数据表的引擎必须只能是InnoDB</li>
<li>外键列和参照列必须具有相似的数据类型, 其中数字的长度或是否有符号位必须相同;<br> 而字符的长度则可以不同.</li>
<li>外键列和参照列必须创建索引.如果外键列不存在索引, MySQL将自动创建索引.</li>
</ol>
<p>实例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> provinces(</span><br><span class="line">    id <span class="type">SMALLINT</span> UNSIGNED <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">    pname <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users(</span><br><span class="line">   id <span class="type">SMALLINT</span> UNSIGNED <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">   username <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   pid <span class="type">SMALLINT</span> UNSIGNED,</span><br><span class="line">   <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(pid) <span class="keyword">REFERENCES</span> provinces(id) );</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.08</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> INDEXES <span class="keyword">FROM</span> provinces\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">       <span class="keyword">Table</span>: provinces</span><br><span class="line">  Non_unique: <span class="number">0</span></span><br><span class="line">    Key_name: <span class="keyword">PRIMARY</span></span><br><span class="line">Seq_in_index: <span class="number">1</span></span><br><span class="line"> Column_name: id</span><br><span class="line">   <span class="keyword">Collation</span>: A</span><br><span class="line"> <span class="keyword">Cardinality</span>: <span class="number">0</span></span><br><span class="line">    Sub_part: <span class="keyword">NULL</span></span><br><span class="line">      Packed: <span class="keyword">NULL</span></span><br><span class="line">        <span class="keyword">Null</span>:</span><br><span class="line">  Index_type: BTREE</span><br><span class="line">     Comment:</span><br><span class="line">Index_comment:</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>外键约束的操作操作</p>
<ol>
<li>CASCADE: 从父表删除或更新且自动删除或更新子表中匹配的行</li>
<li>SET NULL: 从父表删除或更新行, 并设置子表中的外键列为NULL.  如果使用该选项, 必须保证子表列没有指定NOT NULL</li>
<li>RESTRICT: 拒绝对父表的删除或更新操作</li>
<li>NO ACTION: 标准SQL关键字, 在MySQL中与RESTRICT相同</li>
</ol>
<h3 id="表级约束与列级约束"><a href="#表级约束与列级约束" class="headerlink" title="表级约束与列级约束 ??"></a>表级约束与列级约束 ??</h3><p>对于一个数据列建立的约束, 称为列级约束.<br>对多个数据列建立的约束, 称为表级约束.<br>列级约束既可以在列定义时声明,也可以在列定义后声明.<br>表级约束只能在列级约束后声明.</p>
<h2 id="修改数据表"><a href="#修改数据表" class="headerlink" title="修改数据表"></a>修改数据表</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">COLUMN</span>] column_name</span><br><span class="line">  column_definition [<span class="keyword">FIRST</span><span class="operator">|</span>AFTER column_name]</span><br><span class="line">添加多列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">COLUMN</span>]</span><br><span class="line">  (column_name column_definition, ....)</span><br><span class="line">删除列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> [<span class="keyword">COLUMN</span>] column_name</span><br><span class="line">添加主键约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">CONSTRAINT</span> [symbol]]</span><br><span class="line">  <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> [Index_type](index_column_name,...)</span><br><span class="line">添加唯一约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">CONSTRAINT</span> [symbol]]</span><br><span class="line">  <span class="keyword">UNIQUE</span> [INDEX<span class="operator">|</span>KEY][index_name][index_type]</span><br><span class="line">  (index_column_name,...)</span><br><span class="line">添加<span class="operator">/</span>删除默认约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ALTER</span> [<span class="keyword">COLUMN</span>] column_name</span><br><span class="line">&#123;SET DEFAULT litera&#125;</span><br><span class="line">如:</span><br><span class="line">  <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> users2 <span class="keyword">ALTER</span> age <span class="keyword">DROP</span> <span class="keyword">DEFAULT</span>;</span><br><span class="line">删除主键约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> <span class="keyword">Key</span></span><br><span class="line">删除唯一约束</span><br><span class="line">ALTER TABLE table_name DROP &#123;INDEX|KEY&#125; index_name</span><br><span class="line">删除外键约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> fk_symbol</span><br><span class="line">修改列定义</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name MODIFY [<span class="keyword">COLUMN</span>] column_name</span><br><span class="line">  column_definition [<span class="keyword">FIRST</span><span class="operator">|</span>AFTER column_name]</span><br><span class="line">修改列名称</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name CHANGE [<span class="keyword">COLUMN</span>] old_column_name</span><br><span class="line">  new_column_name column_definition [<span class="keyword">FIRST</span><span class="operator">|</span>AFTER column_name]</span><br><span class="line">数据表更名</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name RENAME [<span class="keyword">TO</span><span class="operator">|</span><span class="keyword">AS</span>] new_table_name</span><br><span class="line">或</span><br><span class="line">RENAME <span class="keyword">TABLE</span> table_name <span class="keyword">TO</span> new_table_name</span><br><span class="line">  [, table_name2 <span class="keyword">TO</span> new_table_name2] ...</span><br></pre></td></tr></table></figure>
<h1 id="操作数据表中的记录"><a href="#操作数据表中的记录" class="headerlink" title="操作数据表中的记录"></a>操作数据表中的记录</h1><h2 id="插入记录-1"><a href="#插入记录-1" class="headerlink" title="插入记录"></a>插入记录</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">INSERT [INTO] table_name [(column_name,....)] &#123;VALUES|VALUE&#125;</span><br><span class="line">(&#123;expr|DEFAULT&#125;,...),(...),...</span><br><span class="line"></span><br><span class="line">INSERT [INTO] table_name SET column_name=&#123;expr|DEFAULT&#125;,...</span><br><span class="line">此方法可以使用子查询</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> [<span class="keyword">INTO</span>] table_name [(column_name,...)] <span class="keyword">SELECT</span> ...</span><br></pre></td></tr></table></figure>
<h2 id="单表更新"><a href="#单表更新" class="headerlink" title="单表更新"></a>单表更新</h2><p>单表更新，可以根据字段的当前值，进行判断。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将user_info表中，user_id&gt;1000的信息状态置反。</span></span><br><span class="line"><span class="keyword">UPDATE</span> user_info</span><br><span class="line"><span class="keyword">SET</span> `status`<span class="operator">=</span> (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="string">&#x27;status&#x27;</span><span class="operator">=</span><span class="number">1</span> <span class="keyword">THEN</span> <span class="number">0</span> <span class="keyword">WHEN</span> `status`<span class="operator">=</span><span class="number">0</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">END</span>)</span><br><span class="line"><span class="keyword">WHERE</span> `user_id` <span class="operator">&gt;</span> <span class="number">1000</span> ;</span><br><span class="line"><span class="comment">-- 将user_info表中的real_name去掉空格</span></span><br><span class="line"><span class="keyword">UPDATE</span> user_info</span><br><span class="line"><span class="keyword">SET</span> real_name<span class="operator">=</span><span class="built_in">TRIM</span>(real_name);</span><br></pre></td></tr></table></figure>




<h2 id="单表删除"><a href="#单表删除" class="headerlink" title="单表删除"></a>单表删除</h2><h2 id="查询表达式解析"><a href="#查询表达式解析" class="headerlink" title="查询表达式解析"></a>查询表达式解析</h2><h2 id="where语句进行条件查询"><a href="#where语句进行条件查询" class="headerlink" title="where语句进行条件查询"></a>where语句进行条件查询</h2><h2 id="group-by语句对查询结果分组"><a href="#group-by语句对查询结果分组" class="headerlink" title="group by语句对查询结果分组"></a>group by语句对查询结果分组</h2><h2 id="having语句设置分组条件"><a href="#having语句设置分组条件" class="headerlink" title="having语句设置分组条件"></a>having语句设置分组条件</h2><h2 id="order-by语句对查询结果排序"><a href="#order-by语句对查询结果排序" class="headerlink" title="order by语句对查询结果排序"></a>order by语句对查询结果排序</h2><h2 id="limit语句限制查询数量"><a href="#limit语句限制查询数量" class="headerlink" title="limit语句限制查询数量"></a>limit语句限制查询数量</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--语法：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> LIMIT [<span class="keyword">offset</span>,] <span class="keyword">rows</span> <span class="operator">|</span> <span class="keyword">rows</span> <span class="keyword">OFFSET</span> <span class="keyword">offset</span></span><br><span class="line"><span class="comment">--举例：</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> limit <span class="number">5</span>; <span class="comment">--返回前5行</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> limit <span class="number">0</span>,<span class="number">5</span>; <span class="comment">--同上，返回前5行</span></span><br><span class="line"><span class="comment">---为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> LIMIT <span class="number">95</span>,<span class="number">-1</span>; <span class="comment">--- 检索记录行 96-last.</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> limit <span class="number">5</span>,<span class="number">10</span>; <span class="comment">--返回6-15行</span></span><br></pre></td></tr></table></figure>
<p>当一个查询语句偏移量offset很大的时候，如<code>select * from table limit 10000,10 </code>,<br>最好不要直接使用limit，而是先获取到offset的id后，再直接使用limit size来获取数据。<br>效果会好很多。** 想办法减少offset **</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">From</span> customers <span class="keyword">Where</span> customer_id <span class="operator">&gt;=</span>(</span><br><span class="line">  <span class="comment">--- 查找第1000条记录对应的id, id是索引, 检索速度快</span></span><br><span class="line">  <span class="keyword">select</span> customer_id <span class="keyword">From</span> customers <span class="keyword">Order</span> <span class="keyword">By</span> customer_id limit <span class="number">10000</span>,<span class="number">1</span></span><br><span class="line">) limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>** 通过将查询条件(即where子句)的字段加索引,可以大大提高查询速度. **</p>
<h1 id="子查询与连接"><a href="#子查询与连接" class="headerlink" title="子查询与连接"></a>子查询与连接</h1><h2 id="内连接-join从句"><a href="#内连接-join从句" class="headerlink" title="内连接 join从句"></a>内连接 join从句</h2><p>SQL标准中有5种连接：</p>
<ul>
<li>内连接 inner</li>
<li>全外连接 full outer</li>
<li>左外连接 left outer</li>
<li>右外连接 right outer</li>
<li>交叉连接 cross</li>
</ul>
<h3 id="内连接-inner-join"><a href="#内连接-inner-join" class="headerlink" title="内连接 inner join"></a>内连接 inner join</h3><p>取两个表的交集， 即公共部分</p>
<p><img src="/images/j2ee/MySQL/inner-join.png"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.`column1`, a.`column2`, b.`column3`</span><br><span class="line"><span class="keyword">FROM</span> `table_name1` <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> `table_name2` <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> a.`column4`<span class="operator">=</span>b.`column5`;</span><br></pre></td></tr></table></figure>
<h3 id="左外连接-left-outer-join"><a href="#左外连接-left-outer-join" class="headerlink" title="左外连接 left outer join"></a>左外连接 left outer join</h3><p><img src="/images/j2ee/MySQL/left-outer-join.png"></p>
<p>右图中的部分， 可以用于替换<code>NOT IN</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.`column1`, a.`column2`, b.`column3`</span><br><span class="line"><span class="keyword">FROM</span> `table_name1` <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> `table_name2` <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> a.`column4`<span class="operator">=</span>b.`column5`</span><br><span class="line"><span class="keyword">WHERE</span> b.`column3` <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<h3 id="右外连接-right-outer-join"><a href="#右外连接-right-outer-join" class="headerlink" title="右外连接 right outer join"></a>右外连接 right outer join</h3><p><img src="/images/j2ee/MySQL/right-outer-join.png"></p>
<p>右图中的部分， 可以用于替换<code>NOT IN</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.`column1`, a.`column2`, b.`column3`</span><br><span class="line"><span class="keyword">FROM</span> `table_name1` <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> `table_name2` <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> a.`column4`<span class="operator">=</span>b.`column5`</span><br><span class="line"><span class="keyword">WHERE</span> a.`column3` <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<h3 id="全外连接-FULL-OUTER-JOIN"><a href="#全外连接-FULL-OUTER-JOIN" class="headerlink" title="全外连接 FULL OUTER JOIN"></a>全外连接 FULL OUTER JOIN</h3><p><img src="/images/j2ee/MySQL/full-outer-join.png"></p>
<p>MySQL 中默认是不包含全外连接查询的， 可以通过其他方式实现同样的效果。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.`column1`, a.`column2`, b.`column3`</span><br><span class="line"><span class="keyword">FROM</span> `table_name1` <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> `table_name2` <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> a.`column4`<span class="operator">=</span>b.`column5`</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> a.`column1`, a.`column2`, b.`column3`</span><br><span class="line"><span class="keyword">FROM</span> `table_name1` <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> `table_name2` <span class="keyword">AS</span> b</span><br><span class="line"><span class="keyword">ON</span> a.`column4`<span class="operator">=</span>b.`column5`</span><br></pre></td></tr></table></figure>
<h3 id="交叉连接-CROSS-JOIN"><a href="#交叉连接-CROSS-JOIN" class="headerlink" title="交叉连接 CROSS JOIN"></a>交叉连接 CROSS JOIN</h3><p>笛卡尔积<br>A表中的每一条记录和B表中的每一条记录组合: 结果的长度为A的长度×B的长度.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.`column1`, a.`column2`, b.`column3`</span><br><span class="line"><span class="keyword">FROM</span> `table_name1` <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">CROSS</span> <span class="keyword">JOIN</span> `table_name2` <span class="keyword">AS</span> b</span><br></pre></td></tr></table></figure>


<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数主要分为字符函数 数值函数 日期时间函数 加密函数</p>
<h2 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h2><p><img src="/images/j2ee/MySQL/MySQL-function-String01.png"><br><img src="/images/j2ee/MySQL/MySQL-function-String02.png"></p>
<p>对特殊字符的Escape</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> first_name <span class="keyword">LIKE</span> <span class="string">&#x27;%1%%&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;1&#x27;</span></span><br><span class="line">表示<span class="number">1</span>后面的<span class="operator">%</span>是真实的字符而不是转意字符</span><br></pre></td></tr></table></figure>
<h3 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h3><p><code>SUBSTR (str, pos)</code></p>
<p>由 <str> 中，选出所有从第 <pos> 位置开始的字元。请注意，这个语法不适用于 SQL Server 上。</p>
<p><code>SUBSTR (str, pos, len)</code></p>
<p>由 <str> 中的第 <pos> 位置开始，选出接下去的 <len> 个字元。</p>
<h2 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h2><p><img src="/images/j2ee/MySQL/MySQL-function-Number01.png"></p>
<h2 id="比较运算符和函数"><a href="#比较运算符和函数" class="headerlink" title="比较运算符和函数"></a>比较运算符和函数</h2><p><img src="/images/j2ee/MySQL/MySQL-function-Compare01.png"></p>
<h2 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数"></a>日期时间函数</h2><p><img src="/images/j2ee/MySQL/MySQL-function-DateTime01.png"></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/zeroone/archive/2010/05/05/1727659.html">详细请看</a></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="string">&#x27;2016-04-12&#x27;</span>, <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">YEAR</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> DATE_ADD(<span class="string">&#x27;2016-04-12&#x27;</span>, <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">YEAR</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2017</span><span class="number">-04</span><span class="number">-12</span>                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> DATE_ADD(<span class="string">&#x27;2016-04-12&#x27;</span>, <span class="type">INTERVAL</span> <span class="number">3</span> WEEK);</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> DATE_ADD(<span class="string">&#x27;2016-04-12&#x27;</span>, <span class="type">INTERVAL</span> <span class="number">3</span> WEEK) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2016</span><span class="number">-05</span><span class="number">-03</span>                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(<span class="string">&#x27;2016-3-2&#x27;</span>,<span class="string">&#x27;%m/%d/%Y&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> DATE_FORMAT(<span class="string">&#x27;2016-3-2&#x27;</span>,<span class="string">&#x27;%m/%d/%Y&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">03</span><span class="operator">/</span><span class="number">02</span><span class="operator">/</span><span class="number">2016</span>                         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------------+</span></span><br></pre></td></tr></table></figure>


<h3 id="时间与时间戳的转换"><a href="#时间与时间戳的转换" class="headerlink" title="时间与时间戳的转换"></a>时间与时间戳的转换</h3><ol>
<li><p>unix_timestamp</p>
<p>将时间转化为时间戳。（date 类型数据转换成 timestamp 形式整数）</p>
<p>没传时间参数则取当前时间的时间戳</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MySQL<span class="operator">&gt;</span> <span class="keyword">select</span> unix_timestamp();</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span> unix_timestamp() <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">1361586358</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> unix_timestamp(<span class="string">&#x27;2013-01-01 10:10:10&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> unix_timestamp(<span class="string">&#x27;2013-01-01 10:10:10&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>                            <span class="number">1357006210</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li><p>from_unixtime</p>
<p>将timestamp 形式整数 转化为 date类型</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">select</span> from_unixtime(<span class="number">1355272360</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> from_unixtime(<span class="number">1355272360</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2012</span><span class="number">-12</span><span class="number">-12</span> <span class="number">08</span>:<span class="number">32</span>:<span class="number">40</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>当然也可以指定输出的时间格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">select</span> from_unixtime(<span class="number">1355272360</span>,<span class="string">&#x27;%Y%m%d&#x27;</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> from_unixtime(<span class="number">1355272360</span>,<span class="string">&#x27;%Y%m%d&#x27;</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">20121212</span>                           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------------------------------------+</span></span><br></pre></td></tr></table></figure></li>
<li><p>关于mysql 时间戳的限制</p>
<p>  目前timestamp 所能表示的范围在 1970年  -  2038年之间 。</p>
<p>  超过这个范围 得到的时间将会溢出 得到的时间是null.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span>  <span class="keyword">select</span> from_unixtime(<span class="number">0</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> from_unixtime(<span class="number">0</span>)    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1970</span><span class="number">-01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------+</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> from_unixtime(<span class="number">2147483647</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> from_unixtime(<span class="number">2147483647</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2038</span><span class="number">-01</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">07</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li>
<li><p>SQL中的timestamp与Java中的转换</p>
<p>SQL中的时间戳是从1970年1月1日 8:00:00 开始的毫秒数</p>
<table>
<thead>
<tr>
<th>SQL中的时间戳</th>
<th>1970-1-1 8:00:00 开始的毫秒数</th>
</tr>
</thead>
<tbody><tr>
<td>java.util.Date()</td>
<td>内置时间 getYear()是从1900年开始的</td>
</tr>
<tr>
<td>java.util.Date().getTime()</td>
<td>从1970-1-1 8:00:00 开始的微妙数</td>
</tr>
<tr>
<td>java.sql.Timestamp()</td>
<td>与java.util.Date()相同</td>
</tr>
<tr>
<td>java.sql.Date</td>
<td>只保存年月日，没有时分秒</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ol>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Timestamp是一个与 java.util.Date 类有关的瘦包装器 (thin wrapper)，它允许 JDBC API 将该类标识为 SQL TIMESTAMP 值。它添加保存 SQL TIMESTAMP 毫微秒值和提供支持时间戳值的 JDBC 转义语法的格式化和解析操作的能力。</span><br></pre></td></tr></table></figure>
<p>   因此，在SQL中的时间戳与Java中传递进来的long型时间比较时，需要乘以1000.</p>
<h2 id="信息函数"><a href="#信息函数" class="headerlink" title="信息函数"></a>信息函数</h2><p><img src="/images/j2ee/MySQL/MySQL-function-Information01.png"></p>
<h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p><img src="/images/j2ee/MySQL/MySQL-function-Aggregate01.png"></p>
<h2 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h2><p><img src="/images/j2ee/MySQL/MySQL-function-Encryption01.png"></p>
<p>password函数只适用于设置MySQL的密码</p>
<h2 id="XML支持"><a href="#XML支持" class="headerlink" title="XML支持"></a>XML支持</h2><p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.5/en/xml-functions.html">xml支持</a> :xml的函数主要有两个 ExtractValue 和  UpdateXML</p>
<h3 id="ExtractValue"><a href="#ExtractValue" class="headerlink" title="ExtractValue"></a>ExtractValue</h3><p>​```sql<br>mysql&gt; SELECT<br>    -&gt;   ExtractValue(‘<a>ccc<b>ddd</b></a>‘, ‘/a’) AS val1,<br>    -&gt;   ExtractValue(‘<a>ccc<b>ddd</b></a>‘, ‘/a/b’) AS val2,<br>    -&gt;   ExtractValue(‘<a>ccc<b>ddd</b></a>‘, ‘//b’) AS val3,<br>    -&gt;   ExtractValue(‘<a>ccc<b>ddd</b></a>‘, ‘/b’) AS val4,<br>    -&gt;   ExtractValue(‘<a>ccc<b>ddd</b><b>eee</b></a>‘, ‘//b’) AS val5;</p>
<p>+——+——+——+——+———+<br>| val1 | val2 | val3 | val4 | val5    |<br>+——+——+——+——+———+<br>| ccc  | ddd  | ddd  |      | ddd eee |<br>+——+——+——+——+———+<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### UpdateXML</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;sql</span><br><span class="line">mysql&gt; SELECT</span><br><span class="line">    -&gt;   UpdateXML(&#39;&lt;a&gt;&lt;b&gt;ccc&lt;&#x2F;b&gt;&lt;d&gt;&lt;&#x2F;d&gt;&lt;&#x2F;a&gt;&#39;, &#39;&#x2F;a&#39;, &#39;&lt;e&gt;fff&lt;&#x2F;e&gt;&#39;) AS val1,</span><br><span class="line">    -&gt;   UpdateXML(&#39;&lt;a&gt;&lt;b&gt;ccc&lt;&#x2F;b&gt;&lt;d&gt;&lt;&#x2F;d&gt;&lt;&#x2F;a&gt;&#39;, &#39;&#x2F;b&#39;, &#39;&lt;e&gt;fff&lt;&#x2F;e&gt;&#39;) AS val2,</span><br><span class="line">    -&gt;   UpdateXML(&#39;&lt;a&gt;&lt;b&gt;ccc&lt;&#x2F;b&gt;&lt;d&gt;&lt;&#x2F;d&gt;&lt;&#x2F;a&gt;&#39;, &#39;&#x2F;&#x2F;b&#39;, &#39;&lt;e&gt;fff&lt;&#x2F;e&gt;&#39;) AS val3,</span><br><span class="line">    -&gt;   UpdateXML(&#39;&lt;a&gt;&lt;b&gt;ccc&lt;&#x2F;b&gt;&lt;d&gt;&lt;&#x2F;d&gt;&lt;&#x2F;a&gt;&#39;, &#39;&#x2F;a&#x2F;d&#39;, &#39;&lt;e&gt;fff&lt;&#x2F;e&gt;&#39;) AS val4,</span><br><span class="line">    -&gt;   UpdateXML(&#39;&lt;a&gt;&lt;d&gt;&lt;&#x2F;d&gt;&lt;b&gt;ccc&lt;&#x2F;b&gt;&lt;d&gt;&lt;&#x2F;d&gt;&lt;&#x2F;a&gt;&#39;, &#39;&#x2F;a&#x2F;d&#39;, &#39;&lt;e&gt;fff&lt;&#x2F;e&gt;&#39;) AS val5</span><br><span class="line">    -&gt; \G</span><br><span class="line"></span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">val1: &lt;e&gt;fff&lt;&#x2F;e&gt;</span><br><span class="line">val2: &lt;a&gt;&lt;b&gt;ccc&lt;&#x2F;b&gt;&lt;d&gt;&lt;&#x2F;d&gt;&lt;&#x2F;a&gt;</span><br><span class="line">val3: &lt;a&gt;&lt;e&gt;fff&lt;&#x2F;e&gt;&lt;d&gt;&lt;&#x2F;d&gt;&lt;&#x2F;a&gt;</span><br><span class="line">val4: &lt;a&gt;&lt;b&gt;ccc&lt;&#x2F;b&gt;&lt;e&gt;fff&lt;&#x2F;e&gt;&lt;&#x2F;a&gt;</span><br><span class="line">val5: &lt;a&gt;&lt;d&gt;&lt;&#x2F;d&gt;&lt;b&gt;ccc&lt;&#x2F;b&gt;&lt;d&gt;&lt;&#x2F;d&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h1><p>自定义函数(user-defined function,UDF)是一种对MySQL扩展的途径,<br>其用法与内置函数相同. 自定义函数的两个必要条件:<br><code>参数</code>和<code>返回值</code>. 函数可以返回任意类型的值, 同样也可以接受这些类型的参数</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> function_name</span><br><span class="line">RETURNS &#123;STRING|INTEGER|REAL|DECIMAL&#125;</span><br><span class="line">routine_body</span><br></pre></td></tr></table></figure>
<p>函数体</p>
<ol>
<li>由合法SQL语句构成</li>
<li>可以是简单的SELECT或INSERT语句</li>
<li>如果是复合结构,必须使用<code>BEGIN</code>…<code>END</code>语句</li>
<li>复合结构可以包括声明,循环,控制结构</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> f1()</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">30</span>)</span><br><span class="line"><span class="keyword">RETURN</span> DATE_FORMAT(NOW(),<span class="string">&#x27;%Y年%m月%d日 %H点%i分%s秒&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> f1();</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+</span></span><br><span class="line"><span class="operator">|</span> f1()                           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2016</span>年<span class="number">04</span>月<span class="number">12</span>日 <span class="number">10</span>点<span class="number">51</span>分<span class="number">24</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> f2(num1 <span class="type">SMALLINT</span> UNSIGNED, num2 <span class="type">SMALLINT</span> UNSIGNED)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">FLOAT</span>(<span class="number">10</span>,<span class="number">2</span>) UNSIGNED</span><br><span class="line"><span class="keyword">RETURN</span> (num1<span class="operator">+</span>num2)<span class="operator">/</span><span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> f2(<span class="number">35</span>,<span class="number">46</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> f2(<span class="number">35</span>,<span class="number">46</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">40.50</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"></span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> adduser(username <span class="type">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INT</span> UNSIGNED</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">INSERT</span> test(username) <span class="keyword">VALUES</span>(username);</span><br><span class="line"><span class="keyword">RETURN</span> LAST_INSERT_ID();</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>SQL命令的执行过程</p>
<p><img src="/images/j2ee/MySQL/MySQL-execute.png"></p>
<p>存储过程是SQL语句和控制语句的预编译集合, 以一个名称存储并作为一个单元处理. 其优点有:</p>
<ol>
<li>增强SQL语句的功能和灵活性</li>
<li>实现较快的执行速度</li>
<li>减少网络流量</li>
</ol>
<p>语法格式为:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span></span><br><span class="line">[DEFINER=&#123;USER|CURRENT_USER&#125;]</span><br><span class="line"><span class="keyword">PROCEDURE</span> sp_name ([proc_parameter[,...]])</span><br><span class="line">[characteristic ...] routine_body</span><br><span class="line"></span><br><span class="line">proc_parameter:</span><br><span class="line">[<span class="keyword">IN</span><span class="operator">|</span><span class="keyword">OUT</span><span class="operator">|</span><span class="keyword">INOUT</span>]parameter_name type</span><br><span class="line"></span><br><span class="line">调用</span><br><span class="line"><span class="keyword">CALL</span> sp_name([<span class="keyword">parameter</span>[,...]])</span><br><span class="line"><span class="keyword">CALL</span> sp_name[()]</span><br></pre></td></tr></table></figure>
<p>参数</p>
<ul>
<li>IN 表示该参数的值必须在调用存储过程时指定</li>
<li>OUT 表示该参数的值可以被存储过程改变, 并且可以返回</li>
<li>INOUT 表示该参数的调用时指定,并且可以被改变和返回</li>
</ul>
<p>过程体</p>
<ul>
<li>过程体由合法的SQL语句构成</li>
<li>过程体可以是任意SQL语句</li>
<li>过程体如果为复合结构则使用BEGIN…END语句</li>
<li>复合结构可以包含声明,循环,控制结果</li>
</ul>
<p>实例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> removeUserById(<span class="keyword">IN</span> ppid <span class="type">INT</span> UNSIGNED)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">BEGIN</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id<span class="operator">=</span>ppid;</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">END</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> DELIMITER ;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> removeUserAndReturnUserNums(<span class="keyword">in</span> pid <span class="type">int</span> unsigned,<span class="keyword">out</span> useNums <span class="type">int</span> unsigned)</span><br><span class="line">	<span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id<span class="operator">=</span>pid;</span><br><span class="line">	<span class="keyword">select</span> <span class="built_in">count</span>(id) <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">into</span> useNums;</span><br><span class="line">	<span class="keyword">end</span></span><br><span class="line">	<span class="operator">/</span><span class="operator">/</span></span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">调用</span><br><span class="line"><span class="keyword">call</span> removeUserAndReturnUserNums(<span class="number">27</span>,<span class="variable">@nums</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@nums</span>;</span><br><span class="line">通过<span class="keyword">declare</span>语句声明的变量是局部变量, 作用域只能在<span class="keyword">begin</span>和<span class="keyword">end</span>之间.</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@nums</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@num</span><span class="operator">=</span><span class="number">7</span>;</span><br><span class="line">这种声明方式声明的变量成为用户变量. 作用域是客户端,只在当前的客户端有效.</span><br></pre></td></tr></table></figure>
<p>获取插入 删除 更新的记录总数.<br>select row_count();</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">delimiter <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> removeUserAndReturnInfos(<span class="keyword">in</span> p_age <span class="type">smallint</span> unsigned,</span><br><span class="line">    <span class="keyword">out</span> deleteUsers <span class="type">smallint</span> unsigned, <span class="keyword">out</span> userCounts <span class="type">smallint</span> unsigned)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age<span class="operator">=</span>p_age;</span><br><span class="line"><span class="keyword">select</span> row_count() <span class="keyword">into</span> deleteUsers;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(id) <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">into</span> userCounts;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span></span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> removeUserAndReturnInfos(<span class="number">20</span>,<span class="variable">@rm</span>,<span class="variable">@rl</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@rm</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@rl</span>;</span><br></pre></td></tr></table></figure>
<p>删除存储过程</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> [IF <span class="keyword">EXISTS</span>] sp_name</span><br></pre></td></tr></table></figure>
<p>存储过程与自定义函数的区别</p>
<ol>
<li>存储过程实现的功能更复杂一些 而函数的针对性更强</li>
<li>存储过程可以返回多个值;函数只能有一个返回值</li>
<li>存储过程一般独立的执行;而函数可以作为其他SQL语句的组成部分来出现.</li>
</ol>
<p>创建存储过程或者自定义函数时需要通过<code>delimiter</code>语句修改定界符.</p>
<h1 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h1><p>在 MySQL5.7 中 user 表的 password 已换成了authentication_string。<br>注意：在注意需要执行 FLUSH PRIVILEGES 语句。 这个命令执行后会重新载入授权表。<br>如果你不使用该命令，你就无法使用新创建的用户来连接mysql服务器，除非你重启mysql服务器。<br>你可以在创建用户时，为用户指定权限，在对应的权限列中，在插入语句中设置为 ‘Y’ 即可，用户权限列表如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Select_priv</span><br><span class="line">Insert_priv</span><br><span class="line">Update_priv</span><br><span class="line">Delete_priv</span><br><span class="line">Create_priv</span><br><span class="line">Drop_priv</span><br><span class="line">Reload_priv</span><br><span class="line">Shutdown_priv</span><br><span class="line">Process_priv</span><br><span class="line">File_priv</span><br><span class="line">Grant_priv</span><br><span class="line">References_priv</span><br><span class="line">Index_priv</span><br><span class="line">Alter_priv</span><br></pre></td></tr></table></figure>
<p>  除非你使用 LIKE 来比较字符串，否则MySQL的WHERE子句的字符串比较是不区分大小写的。 你可以使用 BINARY 关键字来设定WHERE子句的字符串比较是区分大小写的。<br>如下实例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">root@host#</span><span class="bash"> mysql -u root -p password;</span></span><br><span class="line">Enter password:*******</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> use RUNOOB;</span></span><br><span class="line">Database changed</span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * from runoob_tbl \</span></span><br><span class="line"><span class="bash">          WHERE BINARY runoob_author=<span class="string">&#x27;sanjay&#x27;</span>;</span></span><br><span class="line">Empty set (0.02 sec)</span><br></pre></td></tr></table></figure>
<p>为了处理这种情况，MySQL提供了三大运算符:</p>
<ul>
<li>IS NULL: 当列的值是NULL,此运算符返回true。</li>
<li>IS NOT NULL: 当列的值不为NULL, 运算符返回true。</li>
<li>&lt;=&gt;: 比较操作符（不同于=运算符），当比较的的两个值为NULL时返回true。<br>关于 NULL 的条件比较运算是比较特殊的。你不能使用 = NULL 或 != NULL 在列中查找 NULL 值 。<br>在MySQL中，NULL值与任何其它值的比较（即使是NULL）永远返回false，即 NULL = NULL 返回false 。<br>MySQL中处理NULL使用IS NULL和IS NOT NULL运算符。</li>
</ul>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><a target="_blank" rel="noopener" href="http://www.runoob.com/mysql/mysql-regexp.html">http://www.runoob.com/mysql/mysql-regexp.html</a></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> person_tbl <span class="keyword">WHERE</span> name REGEXP <span class="string">&#x27;^st&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索包含多个列。<br>创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。<br>实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。<br>上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。<br>建立索引会占用磁盘空间的索引文件。</p>
<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><p>有四种方式来添加数据表的索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (column_list):</span><br><span class="line"></span><br><span class="line">该语句添加一个主键，这意味着索引值必须是唯一的，且不能为<span class="keyword">NULL</span>。</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> index_name (column_list): 这条语句创建索引的值必须是唯一的（除了<span class="keyword">NULL</span>外，<span class="keyword">NULL</span>可能会出现多次）。</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> INDEX index_name (column_list): 添加普通索引，索引值可出现多次。</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">ADD</span> FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ，用于全文索引。</span><br></pre></td></tr></table></figure>
<h2 id="创建临时表"><a href="#创建临时表" class="headerlink" title="创建临时表"></a>创建临时表</h2><p>如果你退出当前MySQL会话，再使用 SELECT命令来读取原先创建的临时表数据，那你会发现数据库中没有该表的存在，因为在你退出时该临时表已经被销毁了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TEMPORARY <span class="keyword">TABLE</span> SalesSummary (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> product_name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> , total_sales <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0.00</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> , avg_unit_price <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0.00</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> , total_units_sold <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h1 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> runoob_tbl \G;</span><br></pre></td></tr></table></figure>
<p>修改数据表名，执行SQL语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> clone_tbl (runoob_id,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>                        runoob_title,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>                        runoob_author,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>                        submission_date)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> runoob_id,runoob_title,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>        runoob_author,submission_date</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> runoob_tbl;</span><br></pre></td></tr></table></figure>
<h1 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h1><p>查询结果信息  数据库和数据表的信息 服务器信息</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> VERSION( ) 服务器版本信息</span><br><span class="line"><span class="keyword">SELECT</span> DATABASE( )  当前数据库名 (或者返回空)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>( )  当前用户名</span><br><span class="line"><span class="keyword">SHOW</span> STATUS 服务器状态</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES  服务器配置变量</span><br><span class="line"><span class="keyword">show</span> processList; 连接MySQL的所有线程的信息</span><br><span class="line"><span class="keyword">SHOW</span>  <span class="keyword">OPEN</span> TABLES  <span class="keyword">WHERE</span> In_use<span class="operator">&gt;</span><span class="number">0</span> 所有打开的数据表</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="自增序列"><a href="#自增序列" class="headerlink" title="自增序列"></a>自增序列</h1><p>在MySQL的客户端中你可以使用 SQL中的LAST_INSERT_ID( ) 函数来获取最后的插入表中的自增列的值 Java如何获取</p>
<h2 id="重置序列"><a href="#重置序列" class="headerlink" title="重置序列"></a>重置序列</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> ALTER TABLE insect DROP id;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> ALTER TABLE insect</span></span><br><span class="line">    -&gt; ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT FIRST,</span><br><span class="line">    -&gt; ADD PRIMARY KEY (id);</span><br></pre></td></tr></table></figure>
<h2 id="设置序列的开始值"><a href="#设置序列的开始值" class="headerlink" title="设置序列的开始值"></a>设置序列的开始值</h2><p>一般情况下序列的开始值为1，但如果你需要指定一个开始值100，那我们可以通过以下语句来实现：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> insect</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="operator">=</span> <span class="number">100</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (id),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> name <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, # type <span class="keyword">of</span> insect</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="type">date</span> <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>, # <span class="type">date</span> collected</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> origin <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> # <span class="keyword">where</span> collected</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>或者你也可以在表创建成功后，通过以下语句来实现：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t AUTO_INCREMENT <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>


<h1 id="防止数据重复"><a href="#防止数据重复" class="headerlink" title="防止数据重复"></a>防止数据重复</h1><p>设置字段为primary key或者unique索引</p>
<h2 id="INSERT-IGNORE"><a href="#INSERT-IGNORE" class="headerlink" title="INSERT IGNORE"></a>INSERT IGNORE</h2><p>INTO当插入数据时，在设置了记录的唯一性后，如果插入重复数据，将不返回错误，只以警告形式返回。 而REPLACE INTO into如果存在primary 或 unique相同的记录，则先删除掉。再插入新记录。</p>
<h2 id="添加一个UNIQUE索引，如下所示："><a href="#添加一个UNIQUE索引，如下所示：" class="headerlink" title="添加一个UNIQUE索引，如下所示："></a>添加一个UNIQUE索引，如下所示：</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_tbl</span><br><span class="line">(</span><br><span class="line">   first_name <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   last_name <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   sex <span class="type">CHAR</span>(<span class="number">10</span>)</span><br><span class="line">   <span class="keyword">UNIQUE</span> (last_name, first_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<h1 id="统计重复数据"><a href="#统计重复数据" class="headerlink" title="统计重复数据"></a>统计重复数据</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">as</span> repetitions, last_name, first_name <span class="keyword">FROM</span> person_tbl <span class="keyword">GROUP</span> <span class="keyword">BY</span> last_name, first_name <span class="keyword">HAVING</span> repetitions <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h1 id="过滤重复数据"><a href="#过滤重复数据" class="headerlink" title="过滤重复数据"></a>过滤重复数据</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> last_name, first_name</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> person_tbl</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> last_name;</span><br></pre></td></tr></table></figure>
<p>你也可以使用 GROUP BY 来读取数据表中不重复的数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> last_name, first_name</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> person_tbl</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> (last_name, first_name);</span><br></pre></td></tr></table></figure>
<h2 id="删除重复数据"><a href="#删除重复数据" class="headerlink" title="删除重复数据"></a>删除重复数据</h2><p>如果你想删除数据表中的重复数据，你可以使用以下的SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tmp <span class="keyword">SELECT</span> last_name, first_name, sex</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>                  <span class="keyword">FROM</span> person_tbl;</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>                  <span class="keyword">GROUP</span> <span class="keyword">BY</span> (last_name, first_name);</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DROP</span> <span class="keyword">TABLE</span> person_tbl;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tmp RENAME <span class="keyword">TO</span> person_tbl;</span><br></pre></td></tr></table></figure>
<p>当然你也可以在数据表中添加 INDEX（索引） 和 PRIMAY KEY（主键）这种简单的方法来删除表中的重复记录。方法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> IGNORE <span class="keyword">TABLE</span> person_tbl</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (last_name, first_name);</span><br></pre></td></tr></table></figure>



<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p>防止SQL注入，我们需要注意以下几个要点：</p>
<ol>
<li>永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和 双”-“进行转换等。</li>
<li>永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。</li>
<li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</li>
<li>不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。</li>
<li>应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装</li>
<li>sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。</li>
</ol>
<h2 id="SQL-like语句注入"><a href="#SQL-like语句注入" class="headerlink" title="SQL like语句注入"></a>SQL like语句注入</h2><p>like查询时，如果用户输入的值有”<em>“和”%”，则会出现这种情况：用户本来只是想查询”abcd</em>“，查询结果中却有”abcd_”、”abcde”、”abcdf”等等；用户要查询”30%”（注：百分之三十）时也会出现问题。</p>
<h1 id="备份与导入"><a href="#备份与导入" class="headerlink" title="备份与导入"></a>备份与导入</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>u <span class="operator">&lt;</span>USER_HOME<span class="operator">&gt;</span> <span class="operator">-</span>p <span class="operator">&lt;</span>DATABASE_NAME <span class="operator">&gt;</span> news.sql   <span class="comment">-- 输入后会让你输入进入MySQL的密码</span></span><br><span class="line"><span class="comment">-- 登陆</span></span><br><span class="line">mysql<span class="operator">&gt;</span> use <span class="operator">&lt;</span>DATABASE_NAME<span class="operator">&gt;</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> source news.sql;</span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line">mysql <span class="operator">-</span>u <span class="operator">&lt;</span>USER_HOME<span class="operator">&gt;</span> <span class="operator">-</span>p <span class="operator">&lt;</span>DATABASE_NAME<span class="operator">&gt;</span> <span class="operator">&lt;</span> news.sql</span><br><span class="line"><span class="comment">-- 输入密码即可</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>更新记录：</p>
<ol>
<li>创建 2016-04-11</li>
<li>添加 时间戳与Java中时间的区别  2016-12-27</li>
</ol>
</blockquote>
<hr>
<p>[参考文献]:</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/zeroone/archive/2010/05/05/1727659.html">MySQL日期时间函数大全</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/database/Redis/the-little-Redis-book/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/database/Redis/the-little-Redis-book/" class="post-title-link" itemprop="url">The Little Redis Book</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-12-20 08:44:00" itemprop="dateCreated datePublished" datetime="2016-12-20T08:44:00+08:00">2016-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-23 13:04:00" itemprop="dateModified" datetime="2021-04-23T13:04:00+08:00">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NOSQL/" itemprop="url" rel="index"><span itemprop="name">NOSQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/NOSQL/Redis/title.png"></p>
<h2 id="关于此书"><a href="#关于此书" class="headerlink" title="关于此书"></a>关于此书</h2><h3 id="最新版本"><a href="#最新版本" class="headerlink" title="最新版本"></a>最新版本</h3><p>此书的最新有效资源在：<br><a target="_blank" rel="noopener" href="http://github.com/karlseguin/the-little-redis-book">http://github.com/karlseguin/the-little-redis-book</a></p>
<p>中文版是英文版的一个分支，最新的中文版本在：<br><a target="_blank" rel="noopener" href="https://github.com/JasonLai256/the-little-redis-book">https://github.com/JasonLai256/the-little-redis-book</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近几年来，关于持久化和数据查询的相关技术，其需求已经增长到了让人惊讶的程度。可以断言，关系型数据库再也不是放之四海皆准。换一句话说，围绕数据的解决方案不可能再只有唯一一种。</p>
<p>对于我来说，在众多新出现的解决方案和工具里，最让人兴奋的，无疑是Redis。为什么？首先是因为其让人不可思议的容易学习，只需要简短的几个小时学习时间，就能对Redis有个大概的认识。还有，Redis在处理一组特定的问题集的同时能保持相当的通用性。更准确地说就是，Redis不会尝试去解决关于数据的所有事情。在你足够了解Redis后，事情就会变得越来越清晰，什么是可行的，什么是不应该由Redis来处理的。作为一名开发人员，如此的经验当是相当的美妙。</p>
<p>当你能仅使用Redis去构建一个完整系统时，我想大多数人将会发现，Redis能使得他们的许多数据方案变得更为通用，不论是一个传统的关系型数据库，一个面向文档的系统，或是其它更多的东西。这是一种用来实现某些特定特性的解决方法。就类似于一个索引引擎，你不会在 Lucene 上构建整个程序，但当你需要足够好的搜索，为什么不使用它呢？这对你和你的用户都有好处。当然，关于Redis和索引引擎之间相似性的讨论到此为止。</p>
<p>本书的目的是向读者传授掌握Redis所需要的基本知识。我们将会注重于学习Redis的5种数据结构，并研究各种数据建模方法。我们还会接触到一些主要的管理细节和调试技巧。</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>每个人的学习方式都不一样，有的人喜欢亲自实践学习，有的喜欢观看教学视频，还有的喜欢通过阅读来学习。对于Redis，没有什么比亲自实践学习来得效果更好的了。Redis的安装非常简单。而且通过随之安装的一个简单的命令解析程序，就能处理我们想做的一切事情。让我们先花几分钟的时间把Redis安装到我们的机器上。</p>
<h3 id="Windows平台"><a href="#Windows平台" class="headerlink" title="Windows平台"></a>Windows平台</h3><p>Redis并没有官方支持Windows平台，但还是可供选择。你不会想在这里配置实际的生产环境，不过在我过往的开发经历里并没有感到有什么限制。</p>
<p>首先进入<a target="_blank" rel="noopener" href="https://github.com/dmajkic/redis/downloads">https://github.com/dmajkic/redis/downloads</a>，然后下载最新的版本（应该会在列表的最上方）。</p>
<p>获取zip文件，然后根据你的系统架构，打开<code>64bit</code>或<code>32bit</code>文件夹。</p>
<h3 id="nix和MacOSX平台"><a href="#nix和MacOSX平台" class="headerlink" title="*nix和MacOSX平台"></a><code>*nix和MacOSX平台</code></h3><p>对于*nix和MacOSX平台的用户，从源文件来安装是你的最佳选择。通过最新的版本号来选择，有效地址于<a target="_blank" rel="noopener" href="http://redis.io/download">http://redis.io/download</a>。在编写此书的时候，最新的版本是2.4.6，我们可以运行下面的命令来安装该版本：</p>
<pre><code>wget http://redis.googlecode.com/files/redis-2.4.6.tar.gz
tar xzf redis-2.4.6.tar.gz
cd redis-2.4.6
make</code></pre>
<p>（当然，Redis同样可以通过套件管理程序来安装。例如，使用Homebrew的MaxOSX用户可以只键入<code>brew install redis</code>即可。）</p>
<p>如果你是通过源文件来安装，二进制可执行文件会被放置在<code>src</code>目录里。通过运行<code>cd src</code>可跳转到<code>src</code>目录。</p>
<h3 id="运行和连接Redis"><a href="#运行和连接Redis" class="headerlink" title="运行和连接Redis"></a>运行和连接Redis</h3><p>如果一切都工作正常，那Redis的二进制文件应该已经可以曼妙地跳跃于你的指尖之下。Redis只有少量的可执行文件，我们将着重于Redis的服务器和命令行界面（一个类DOS的客户端）。首先，让我们来运行服务器。在Windows平台，双击<code>redis-server</code>，在*nix/MacOSX平台则运行<code>./redis-server</code>.</p>
<p>如果你仔细看了启动信息，你会看到一个警告，指没能找到<code>redis.conf</code>文件。Redis将会采用内置的默认设置，这对于我们将要做的已经足够了。</p>
<p>然后，通过双击<code>redis-cli</code>（Windows平台）或者运行<code>./redis-cli</code>（<code>*nix/MacOSX</code>平台），启动Redis的控制台。控制台将会通过默认的端口（6379）来连接本地运行的服务器。</p>
<p>可以在命令行界面键入<code>info</code>命令来查看一切是不是都运行正常。你会很乐意看到这么一大组关键字-值（key-value）对的显示，这为我们查看服务器的状态提供了大量有效信息。</p>
<p>如果在上面的启动步骤里遇到什么问题，我建议你到<a target="_blank" rel="noopener" href="https://groups.google.com/forum/#!forum/redis-db">Redis的官方支持组</a>里获取帮助。</p>
<h2 id="驱动Redis"><a href="#驱动Redis" class="headerlink" title="驱动Redis"></a>驱动Redis</h2><p>很快你就会发现，Redis的API就如一组定义明确的函数那般容易理解。Redis具有让人难以置信的简单性，其操作过程也同样如此。这意味着，无论你是使用命令行程序，或是使用你喜欢的语言来驱动，整体的感觉都不会相差多少。因此，相对于命令行程序，如果你更愿意通过一种编程语言去驱动Redis，你不会感觉到有任何适应的问题。如果真想如此，可以到Redis的<a target="_blank" rel="noopener" href="http://redis.io/clients">客户端推荐页面</a>下载适合的Redis载体。</p>
<h2 id="第1章-基础知识"><a href="#第1章-基础知识" class="headerlink" title="第1章 - 基础知识"></a>第1章 - 基础知识</h2><p>是什么使Redis显得这么特别？Redis具体能解决什么类型的问题？要实际应用Redis，开发者必须储备什么知识？在我们能回答这么一些问题之前，我们需要明白Redis到底是什么。</p>
<p>Redis通常被人们认为是一种持久化的存储器关键字-值型存储（in-memory persistent key-value store）。我认为这种对Redis的描述并不太准确。Redis的确是将所有的数据存放于存储器（更多是是按位存储），而且也确实通过将数据写入磁盘来实现持久化，但是<strong>Redis的实际意义比单纯的关键字-值型存储要来得深远</strong>。纠正脑海里的这种误解观点非常关键，否则你对于Redis之道以及其应用的洞察力就会变得越发狭义。</p>
<p>事实是，Redis引入了5种不同的数据结构，只有一个是典型的关键字-值型结构。理解Redis的关键就在于搞清楚这5种数据结构，其工作的原理都是如何，有什么关联方法以及你能怎样应用这些数据结构去构建模型。首先，让我们来弄明白这些数据结构的实际意义。</p>
<p>应用上面提及的数据结构概念到我们熟悉的关系型数据库里，我们可以认为其引入了一个单独的数据结构——表格。表格既复杂又灵活，基于表格的存储和管理，没有多少东西是你不能进行建模的。然而，这种通用性并不是没有缺点。具体来说就是，事情并不是总能达到假设中的简单或者快速。相对于这种普遍适用（one-size-fits-all）的结构体系，我们可以使用更为专门化的结构体系。当然，因此可能有些事情我们会完成不了(至少，达不到很好的程度）。但话说回来，这样做就能确定我们可以获得想象中的简单性和速度吗？</p>
<p>针对特定类型的问题使用特定的数据结构？我们不就是这样进行编程的吗？你不会使用一个散列表去存储每份数据，也不会使用一个标量变量去存储。对我来说，这正是Redis的做法。如果你需要处理标量、列表、散列或者集合，为什么不直接就用标量、列表、散列和集合去存储他们？为什么不是直接调用<code>exists(key)</code>去检测一个已存在的值，而是要调用其他比O(1)（常量时间查找，不会因为待处理元素的增长而变慢）慢的操作？</p>
<h3 id="数据库（Databases）"><a href="#数据库（Databases）" class="headerlink" title="数据库（Databases）"></a>数据库（Databases）</h3><p>与你熟悉的关系型数据库一致，Redis有着相同的数据库基本概念，即一个数据库包含一组数据。典型的数据库应用案例是，将一个程序的所有数据组织起来，使之与另一个程序的数据保持独立。</p>
<p>在Redis里，数据库简单的使用一个数字编号来进行辨认，默认数据库的数字编号是<code>0</code>。如果你想切换到一个不同的数据库，你可以使用<code>select</code>命令来实现。在命令行界面里键入<code>select 1</code>，Redis应该会回复一条<code>OK</code>的信息，然后命令行界面里的提示符会变成类似<code>redis 127.0.0.1:6379[1]&gt;</code>这样。如果你想切换回默认数据库，只要在命令行界面键入<code>select 0</code>即可。</p>
<h3 id="命令、关键字和值（Commands-Keys-and-Values）"><a href="#命令、关键字和值（Commands-Keys-and-Values）" class="headerlink" title="命令、关键字和值（Commands, Keys and Values）"></a>命令、关键字和值（Commands, Keys and Values）</h3><p>Redis不仅仅是一种简单的关键字-值型存储，从其核心概念来看，Redis的5种数据结构中的每一个都至少有一个关键字和一个值。在转入其它关于Redis的有用信息之前，我们必须理解关键字和值的概念。</p>
<p>关键字（Keys）是用来标识数据块。我们将会经常跟关键字打交道，不过在现在，明白关键字就是类似于<code>users:leto</code>这样的表述就足够了。一般都能很好地理解到，这样关键字包含的信息是一个名为<code>leto</code>的用户。这个关键字里的冒号没有任何特殊含义，对于Redis而言，使用分隔符来组织关键字是很常见的方法。</p>
<p>值（Values）是关联于关键字的实际值，可以是任何东西。有时候你会存储字符串，有时候是整数，还有时候你会存储序列化对象（使用JSON、XML或其他格式）。在大多数情况下，Redis会把值看做是一个字节序列，而不会关注它们实质上是什么。要注意，不同的Redis载体处理序列化会有所不同（一些会让你自己决定）。因此，在这本书里，我们将仅讨论字符串、整数和JSON。</p>
<p>现在让我们活动一下手指吧。在命令行界面键入下面的命令：</p>
<pre><code>set users:leto &quot;&#123;name: leto, planet: dune, likes: [spice]&#125;&quot;</code></pre>
<p>这就是Redis命令的基本构成。首先我们要有一个确定的命令，在上面的语句里就是<code>set</code>。然后就是相应的参数，<code>set</code>命令接受两个参数，包括要设置的关键字，以及相应要设置的值。很多的情况是，命令接受一个关键字（当这种情况出现，其经常是第一个参数）。你能想到如何去获取这个值吗？我想你会说（当然一时拿不准也没什么）：</p>
<pre><code>get users:leto</code></pre>
<p>关键字和值的是Redis的基本概念，而<code>get</code>和<code>set</code>命令是对此最简单的使用。你可以创建更多的用户，去尝试不同类型的关键字以及不同的值，看看一些不同的组合。</p>
<h3 id="查询（Querying）"><a href="#查询（Querying）" class="headerlink" title="查询（Querying）"></a>查询（Querying）</h3><p>随着学习的持续深入，两件事情将变得清晰起来。对于Redis而言, <code>key</code>就是一切，而值是没有任何意义。更通俗来看就是，Redis不允许你通过值来进行查询。回到上面的例子，我们就不能查询生活在<code>dune</code>行星上的用户。</p>
<p>对许多人来说，这会引起一些担忧。在我们生活的世界里，数据查询是如此的灵活和强大，而Redis的方式看起来是这么的原始和不高效。不要让这些扰乱你太久。要记住，Redis不是一种普遍使用（one-size-fits-all）的解决方案，确实存在这么一些事情是不应该由Redis来解决的（因为其查询的限制）。事实上，在考虑了这些情况后，你会找到新的方法去构建你的数据。</p>
<p>很快，我们就能看到更多实际的用例。很重要的一点是，我们要明白关于Redis的这些基本事实。这能帮助我们弄清楚: 为什么<code>value</code>可以是任何东西，因为Redis从来不需要去读取或理解它们。而且，这也可以帮助我们理清思路，然后去思考如何在这个新世界里建立模型。</p>
<h3 id="存储器和持久化（Memory-and-Persistence）"><a href="#存储器和持久化（Memory-and-Persistence）" class="headerlink" title="存储器和持久化（Memory and Persistence）"></a>存储器和持久化（Memory and Persistence）</h3><p>我们之前提及过，Redis是一种持久化的存储器内存储（in-memory persistent store）。对于持久化，默认情况下，Redis会根据已变更的关键字数量来进行判断，然后在磁盘里创建数据库的快照（snapshot）。你可以对此进行设置，如果X个关键字已变更，那么每隔Y秒存储数据库一次。默认情况下，如果1000个或更多的关键字已变更，Redis会每隔60秒存储数据库；而如果9个或更少的关键字已变更，Redis会每隔15分钟存储数据库。</p>
<p>除了创建磁盘快照外，Redis可以在附加模式下运行。任何时候，如果有一个关键字变更，一个单一附加（append-only）的文件会在磁盘里进行更新。在一些情况里，虽然硬件或软件可能发生错误，但用那60秒有效数据存储去换取更好性能是可以接受的。而在另一些情况里，这种损失就难以让人接受，Redis为你提供了选择。在第5章里，我们将会看到第三种选择，其将持久化任务减荷到一个从属数据库里。</p>
<p>至于存储器，Redis会将所有数据都保留在存储器中。显而易见，运行Redis具有不低的成本：因为RAM仍然是最昂贵的服务器硬件部件。</p>
<p>我很清楚有一些开发者对即使是一点点的数据空间都是那么的敏感。一本《威廉·莎士比亚全集》需要近5.5MB的存储空间。对于缩放的需求，其它的解决方案趋向于IO-bound或者CPU-bound。这些限制（RAM或者IO）将会需要你去理解更多机器实际依赖的数据类型，以及应该如何去进行存储和查询。除非你是存储大容量的多媒体文件到Redis中，否则存储器内存储应该不会是一个问题。如果这对于一个程序是个问题，你就很可能不会用IO-bound的解决方案。</p>
<p>Redis有虚拟存储器的支持。然而，这个功能已经被认为是失败的了（通过Redis的开发者），而且它的使用已经被废弃了。</p>
<p>（从另一个角度来看，一本5.5MB的《威廉·莎士比亚全集》可以通过压缩减小到近2MB。当然，Redis不会自动对值进行压缩，但是因为其将所有值都看作是字节，没有什么限制让你不能对数据进行压缩/解压，通过牺牲处理时间来换取存储空间。）</p>
<h3 id="整体来看（Putting-It-Together）"><a href="#整体来看（Putting-It-Together）" class="headerlink" title="整体来看（Putting It Together）"></a>整体来看（Putting It Together）</h3><p>我们已经接触了好几个高层次的主题。在继续深入Redis之前，我想做的最后一件事情是将这些主题整合起来。这些主题包括，查询的限制，数据结构以及Redis在存储器内存储数据的方法。</p>
<p>当你将这3个主题整合起来，你最终会得出一个绝妙的结论：速度。一些人可能会想，当然Redis会很快速，要知道所有的东西都在存储器里。但这仅仅是其中的一部分，让Redis闪耀的真正原因是其不同于其它解决方案的特殊数据结构。</p>
<p>能有多快速？这依赖于很多东西，包括你正在使用着哪个命令，数据的类型等等。但Redis的性能测试是趋向于数万或数十万次操作<strong>每秒</strong>。你可以通过运行<code>redis-benchmark</code>（就在<code>redis-server</code>和<code>redis-cli</code>的同一个文件夹里）来进行测试。</p>
<p>我曾经试过将一组使用传统模型的代码转向使用Redis。在传统模型里，运行一个我写的载入测试，需要超过5分钟的时间来完成。而在Redis里，只需要150毫秒就完成了。你不会总能得到这么好的收获，但希望这能让你对我们所谈的东西有更清晰的理解。</p>
<p>理解Redis的这个特性很重要，因为这将影响到你如何去与Redis进行交互。拥有SQL背景的程序员通常会致力于让数据库的数据往返次数减至最小。这对于任何系统都是个好建议，包括Redis。然而，考虑到我们是在处理比较简单的数据结构，有时候我们还是需要与Redis服务器频繁交互，以达到我们的目的。刚开始的时候，可能会对这种数据访问模式感到不太自然。实际上，相对于我们通过Redis获得的高性能而言，这仅仅是微不足道的损失。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>虽然我们只接触和摆弄了Redis的冰山一角，但我们讨论的主题已然覆盖了很大范围内的东西。如果觉得有些事情还是不太清楚（例如查询），不用为此而担心，在下一章我们将会继续深入探讨，希望你的问题都能得到解答。</p>
<p>这一章的要点包括：</p>
<ul>
<li><p>关键字（Keys）是用于标识一段数据的一个字符串</p>
</li>
<li><p>值（Values）是一段任意的字节序列，Redis不会关注它们实质上是什么</p>
</li>
<li><p>Redis展示了（也实现了）5种专门的数据结构</p>
</li>
<li><p>上面的几点使得Redis快速而且容易使用，但要知道Redis并不适用于所有的应用场景</p>
</li>
</ul>
<h2 id="第2章-数据结构"><a href="#第2章-数据结构" class="headerlink" title="第2章 - 数据结构"></a>第2章 - 数据结构</h2><p>现在开始将探究Redis的5种数据结构，我们会解释每种数据结构都是什么，包含了什么有效的方法（Method），以及你能用这些数据结构处理哪些类型的特性和数据。</p>
<p>目前为止，我们所知道的Redis构成仅包括命令、关键字和值，还没有接触到关于数据结构的具体概念。当我们使用<code>set</code>命令时，Redis是怎么知道我们是在使用哪个数据结构？其解决方法是，每个命令都相对应于一种特定的数据结构。例如，当你使用<code>set</code>命令，你就是将值存储到一个字符串数据结构里。而当你使用<code>hset</code>命令，你就是将值存储到一个散列数据结构里。考虑到Redis的关键字集很小，这样的机制具有相当的可管理性。</p>
<p><strong><a target="_blank" rel="noopener" href="http://redis.io/commands">Redis的网站</a>里有着非常优秀的参考文档，没有任何理由去重造轮子。但为了搞清楚这些数据结构的作用，我们将会覆盖那些必须知道的重要命令。</strong></p>
<p>没有什么事情比高兴的玩和试验有趣的东西来得更重要的了。在任何时候，你都能通过键入<code>flushdb</code>命令将你数据库里的所有值清除掉，因此，不要再那么害羞了，去尝试做些疯狂的事情吧！</p>
<h3 id="字符串（Strings"><a href="#字符串（Strings" class="headerlink" title="字符串（Strings)"></a>字符串（Strings)</h3><p>在Redis里，字符串是最基本的数据结构。当你在思索着关键字-值对时，你就是在思索着字符串数据结构。不要被名字给搞混了，如之前说过的，你的值可以是任何东西。我更喜欢将他们称作“标量”（Scalars），但也许只有我才这样想。</p>
<p>我们已经看到了一个常见的字符串使用案例，即通过关键字存储对象的实例。有时候，你会频繁地用到这类操作：</p>
<pre><code>set users:leto &quot;&#123;name: leto, planet: dune, likes: [spice]&#125;&quot;</code></pre>
<p>除了这些外，Redis还有一些常用的操作。例如，<code>strlen &lt;key&gt;</code>能用来获取一个关键字对应值的长度；<code>getrange &lt;key&gt; &lt;start&gt; &lt;end&gt;</code>将返回指定范围内的关键字对应值；<code>append &lt;key&gt; &lt;value&gt;</code>会将value附加到已存在的关键字对应值中（如果该关键字并不存在，则会创建一个新的关键字-值对）。不要犹豫，去试试看这些命令吧。下面是我得到的：</p>
<pre><code>&gt; strlen users:leto
(integer) 42

&gt; getrange users:leto 27 40
&quot;likes: [spice]&quot;

&gt; append users:leto &quot; OVER 9000!!&quot;
(integer) 54</code></pre>
<p>现在你可能会想，这很好，但似乎没有什么意义。你不能有效地提取出一段范围内的JSON文件，或者为其附加一些值。你是对的，这里的经验是，一些命令，尤其是关于字符串数据结构的，只有在给定了明确的数据类型后，才会有实际意义。</p>
<p>之前我们知道了，Redis不会去关注你的值是什么东西。通常情况下，这没有错。然而，一些字符串命令是专门为一些类型或值的结构而设计的。作为一个有些含糊的用例，我们可以看到，对于一些自定义的空间效率很高的（space-efficient）串行化对象，<code>append</code>和<code>getrange</code>命令将会很有用。对于一个更为具体的用例，我们可以再看一下<code>incr</code>、<code>incrby</code>、<code>decr</code>和<code>decrby</code>命令。这些命令会增长或者缩减一个字符串数据结构的值：</p>
<pre><code>&gt; incr stats:page:about
(integer) 1
&gt; incr stats:page:about
(integer) 2

&gt; incrby ratings:video:12333 5
(integer) 5
&gt; incrby ratings:video:12333 3
(integer) 8</code></pre>
<p>由此你可以想象到，Redis的字符串数据结构能很好地用于分析用途。你还可以去尝试增长<code>users:leto</code>（一个不是整数的值），然后看看会发生什么（应该会得到一个错误）。</p>
<p>更为进阶的用例是<code>setbit</code>和<code>getbit</code>命令。“今天我们有多少个独立用户访问”是个在Web应用里常见的问题，有一篇<a target="_blank" rel="noopener" href="http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps/">精彩的博文</a>，在里面可以看到Spool是如何使用这两个命令有效地解决此问题。对于1.28亿个用户，一部笔记本电脑在不到50毫秒的时间里就给出了答复，而且只用了16MB的存储空间。</p>
<p>最重要的事情不是在于你是否明白位图（Bitmaps)的工作原理，或者Spool是如何去使用这些命令，而是应该要清楚Redis的字符串数据结构比你当初所想的要有用许多。然而，最常见的应用案例还是上面我们给出的：存储对象（简单或复杂）和计数。同时，由于通过关键字来获取一个值是如此之快，字符串数据结构很常被用来缓存数据。</p>
<h3 id="散列（Hashes）"><a href="#散列（Hashes）" class="headerlink" title="散列（Hashes）"></a>散列（Hashes）</h3><p>我们已经知道把Redis称为一种关键字-值型存储是不太准确的，散列数据结构是一个很好的例证。你会看到，在很多方面里，散列数据结构很像字符串数据结构。两者显著的区别在于，散列数据结构提供了一个额外的间接层：一个域（Field）。因此，散列数据结构中的<code>set</code>和<code>get</code>是：</p>
<pre><code>hset users:goku powerlevel 9000
hget users:goku powerlevel</code></pre>
<p>相关的操作还包括在同一时间设置多个域、同一时间获取多个域、获取所有的域和值、列出所有的域或者删除指定的一个域：</p>
<pre><code>hmset users:goku race saiyan age 737
hmget users:goku race powerlevel
hgetall users:goku
hkeys users:goku
hdel users:goku age</code></pre>
<p>如你所见，散列数据结构比普通的字符串数据结构具有更多的可操作性。我们可以使用一个散列数据结构去获得更精确的描述，是存储一个用户，而不是一个序列化对象。从而得到的好处是能够提取、更新和删除具体的数据片段，而不必去获取或写入整个值。</p>
<p>对于散列数据结构，可以从一个经过明确定义的对象的角度来考虑，例如一个用户，关键之处在于要理解他们是如何工作的。从性能上的原因来看，这是正确的，更具粒度化的控制可能会相当有用。在下一章我们将会看到，如何用散列数据结构去组织你的数据，使查询变得更为实效。在我看来，这是散列真正耀眼的地方。</p>
<h3 id="列表（Lists）"><a href="#列表（Lists）" class="headerlink" title="列表（Lists）"></a>列表（Lists）</h3><p>对于一个给定的关键字，列表数据结构让你可以存储和处理一组值。你可以添加一个值到列表里、获取列表的第一个值或最后一个值以及用给定的索引来处理值。列表数据结构维护了值的顺序，提供了基于索引的高效操作。为了跟踪在网站里注册的最新用户，我们可以维护一个<code>newusers</code>的列表：</p>
<pre><code>lpush newusers goku
ltrim newusers 0 50</code></pre>
<p><strong>（译注：<code>ltrim</code>命令的具体构成是<code>LTRIM Key start stop</code>。要理解<code>ltrim</code>命令，首先要明白Key所存储的值是一个列表，理论上列表可以存放任意个值。对于指定的列表，根据所提供的两个范围参数start和stop，<code>ltrim</code>命令会将指定范围外的值都删除掉，只留下范围内的值。）</strong></p>
<p>首先，我们将一个新用户推入到列表的前端，然后对列表进行调整，使得该列表只包含50个最近被推入的用户。这是一种常见的模式。<code>ltrim</code>是一个具有O(N)时间复杂度的操作，N是被删除的值的数量。从上面的例子来看，我们总是在插入了一个用户后再进行列表调整，实际上，其将具有O(1)的时间复杂度（因为N将永远等于1）的常数性能。</p>
<p>这是我们第一次看到一个关键字的对应值索引另一个值。如果我们想要获取最近的10个用户的详细资料，我们可以运行下面的组合操作：</p>
<pre><code>keys = redis.lrange(&#39;newusers&#39;, 0, 10)
redis.mget(*keys.map &#123;|u| &quot;users:#&#123;u&#125;&quot;&#125;)</code></pre>
<p>我们之前谈论过关于多次往返数据的模式，上面的两行Ruby代码为我们进行了很好的演示。</p>
<p>当然，对于存储和索引关键字的功能，并不是只有列表数据结构这种方式。值可以是任意的东西，你可以使用列表数据结构去存储日志，也可以用来跟踪用户浏览网站时的路径。如果你过往曾构建过游戏，你可能会使用列表数据结构去跟踪用户的排队活动。</p>
<h3 id="集合（Sets）"><a href="#集合（Sets）" class="headerlink" title="集合（Sets）"></a>集合（Sets）</h3><p>集合数据结构常常被用来存储只能唯一存在的值，并提供了许多的基于集合的操作，例如并集。集合数据结构没有对值进行排序，但是其提供了高效的基于值的操作。使用集合数据结构的典型用例是朋友名单的实现：</p>
<pre><code>sadd friends:leto ghanima paul chani jessica
sadd friends:duncan paul jessica alia</code></pre>
<p>不管一个用户有多少个朋友，我们都能高效地（O(1)时间复杂度）识别出用户X是不是用户Y的朋友：</p>
<pre><code>sismember friends:leto jessica
sismember friends:leto vladimir</code></pre>
<p>而且，我们可以查看两个或更多的人是不是有共同的朋友：</p>
<pre><code>sinter friends:leto friends:duncan</code></pre>
<p>甚至可以在一个新的关键字里存储结果：</p>
<pre><code>sinterstore friends:leto_duncan friends:leto friends:duncan</code></pre>
<p>有时候需要对值的属性进行标记和跟踪处理，但不能通过简单的复制操作完成，集合数据结构是解决此类问题的最好方法之一。当然，对于那些需要运用集合操作的地方（例如交集和并集），集合数据结构就是最好的选择。</p>
<h3 id="分类集合（Sorted-Sets）"><a href="#分类集合（Sorted-Sets）" class="headerlink" title="分类集合（Sorted Sets）"></a>分类集合（Sorted Sets）</h3><p>最后也是最强大的数据结构是分类集合数据结构。如果说散列数据结构类似于字符串数据结构，主要区分是域（field）的概念；那么分类集合数据结构就类似于集合数据结构，主要区分是标记（score）的概念。标记提供了排序（sorting）和秩划分（ranking）的功能。如果我们想要一个秩分类的朋友名单，可以这样做：</p>
<pre><code>zadd friends:duncan 70 ghanima 95 paul 95 chani 75 jessica 1 vladimir</code></pre>
<p>对于<code>duncan</code>的朋友，要怎样计算出标记（score）为90或更高的人数？</p>
<pre><code>zcount friends:duncan 90 100</code></pre>
<p>如何获取<code>chani</code>在名单里的秩（rank）？</p>
<pre><code>zrevrank friends:duncan chani</code></pre>
<p><strong>（译注：<code>zrank</code>命令的具体构成是<code>ZRANK Key menber</code>，要知道Key存储的Sorted Set默认是根据Score对各个menber进行升序的排列，该命令就是用来获取menber在该排列里的次序，这就是所谓的秩。）</strong></p>
<p>我们使用了<code>zrevrank</code>命令而不是<code>zrank</code>命令，这是因为Redis的默认排序是从低到高，但是在这个例子里我们的秩划分是从高到低。对于分类集合数据结构，最常见的应用案例是用来实现排行榜系统。事实上，对于一些基于整数排序，且能以标记（score）来进行有效操作的东西，使用分类集合数据结构来处理应该都是不错的选择。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>对于Redis的5种数据结构，我们进行了高层次的概述。一件有趣的事情是，相对于最初构建时的想法，你经常能用Redis创造出一些更具实效的事情。对于字符串数据结构和分类集合数据结构的使用，很有可能存在一些构建方法是还没有人想到的。当你理解了那些常用的应用案例后，你将发现Redis对于许多类型的问题，都是很理想的选择。还有，不要因为Redis展示了5种数据结构和相应的各种方法，就认为你必须要把所有的东西都用上。只使用一些命令去构建一个特性是很常见的。</p>
<h2 id="第3章-使用数据结构"><a href="#第3章-使用数据结构" class="headerlink" title="第3章 - 使用数据结构"></a>第3章 - 使用数据结构</h2><p>在上一章里，我们谈论了Redis的5种数据结构，对于一些可能的用途也给出了用例。现在是时候来看看一些更高级，但依然很常见的主题和设计模式。</p>
<h3 id="大O表示法（Big-O-Notation）"><a href="#大O表示法（Big-O-Notation）" class="headerlink" title="大O表示法（Big O Notation）"></a>大O表示法（Big O Notation）</h3><p>在本书中，我们之前就已经看到过大O表示法，包括O(1)和O(N)的表示。大O表示法的惯常用途是，描述一些用于处理一定数量元素的行为的综合表现。在Redis里，对于一个要处理一定数量元素的命令，大O表示法让我们能了解该命令的大概运行速度。</p>
<p>在Redis的文档里，每一个命令的时间复杂度都用大O表示法进行了描述，还能知道各命令的具体性能会受什么因素影响。让我们来看看一些用例。</p>
<p>常数时间复杂度O(1)被认为是最快速的，无论我们是在处理5个元素还是5百万个元素，最终都能得到相同的性能。对于<code>sismember</code>命令，其作用是告诉我们一个值是否属于一个集合，时间复杂度为O(1)。<code>sismember</code>命令很强大，很大部分的原因是其高效的性能特征。许多Redis命令都具有O(1)的时间复杂度。</p>
<p>对数时间复杂度O(log(N))被认为是第二快速的，其通过使需扫描的区间不断皱缩来快速完成处理。使用这种“分而治之”的方式，大量的元素能在几个迭代过程里被快速分解完整。<code>zadd</code>命令的时间复杂度就是O(log(N))，其中N是在分类集合中的元素数量。</p>
<p>再下来就是线性时间复杂度O(N)，在一个表格的非索引列里进行查找就需要O(N)次操作。<code>ltrim</code>命令具有O(N)的时间复杂度，但是，在<code>ltrim</code>命令里，N不是列表所拥有的元素数量，而是被删除的元素数量。从一个具有百万元素的列表里用<code>ltrim</code>命令删除1个元素，要比从一个具有一千个元素的列表里用<code>ltrim</code>命令删除10个元素来的快速（实际上，两者很可能会是一样快，因为两个时间都非常的小）。</p>
<p>根据给定的最小和最大的值的标记，<code>zremrangebyscore</code>命令会在一个分类集合里进行删除元素操作，其时间复杂度是O(log(N)+M)。这看起来似乎有点儿杂乱，通过阅读文档可以知道，这里的N指的是在分类集合里的总元素数量，而M则是被删除的元素数量。可以看出，对于性能而言，被删除的元素数量很可能会比分类集合里的总元素数量更为重要。</p>
<p><strong>（译注：<code>zremrangebyscore</code>命令的具体构成是<code>ZREMRANGEBYSCORE Key max mix</code>。）</strong></p>
<p>对于<code>sort</code>命令，其时间复杂度为O(N+M*log(M))，我们将会在下一章谈论更多的相关细节。从<code>sort</code>命令的性能特征来看，可以说这是Redis里最复杂的一个命令。</p>
<p>还存在其他的时间复杂度描述，包括O(N^2)和O(C^N)。随着N的增大，其性能将急速下降。在Redis里，没有任何一个命令具有这些类型的时间复杂度。</p>
<p>值得指出的一点是，在Redis里，当我们发现一些操作具有O(N)的时间复杂度时，我们可能可以找到更为好的方法去处理。</p>
<p><strong>（译注：对于Big O Notation，相信大家都非常的熟悉，虽然原文仅仅是对该表示法进行简单的介绍，但限于个人的算法知识和文笔水平实在有限，此小节的翻译让我头痛颇久，最终成果也确实难以让人满意，望见谅。）</strong></p>
<h3 id="仿多关键字查询（Pseudo-Multi-Key-Queries）"><a href="#仿多关键字查询（Pseudo-Multi-Key-Queries）" class="headerlink" title="仿多关键字查询（Pseudo Multi Key Queries）"></a>仿多关键字查询（Pseudo Multi Key Queries）</h3><p>时常，你会想通过不同的关键字去查询相同的值。例如，你会想通过电子邮件（当用户开始登录时）去获取用户的具体信息，或者通过用户id（在用户登录后）去获取。有一种很不实效的解决方法，其将用户对象分别放置到两个字符串值里去：</p>
<pre><code>set users:leto@dune.gov &quot;&#123;id: 9001, email: &#39;leto@dune.gov&#39;, ...&#125;&quot;
set users:9001 &quot;&#123;id: 9001, email: &#39;leto@dune.gov&#39;, ...&#125;&quot;</code></pre>
<p>这种方法很糟糕，如此不但会产生两倍数量的内存，而且这将会成为数据管理的恶梦。</p>
<p>如果Redis允许你将一个关键字链接到另一个的话，可能情况会好很多，可惜Redis并没有提供这样的功能（而且很可能永远都不会提供）。Redis发展到现在，其开发的首要目的是要保持代码和API的整洁简单，关键字链接功能的内部实现并不符合这个前提（对于关键字，我们还有很多相关方法没有谈论到）。其实，Redis已经提供了解决的方法：散列。</p>
<p>使用散列数据结构，我们可以摆脱重复的缠绕：</p>
<pre><code>set users:9001 &quot;&#123;id: 9001, email: leto@dune.gov, ...&#125;&quot;
hset users:lookup:email leto@dune.gov 9001</code></pre>
<p>我们所做的是，使用域来作为一个二级索引，然后去引用单个用户对象。要通过id来获取用户信息，我们可以使用一个普通的<code>get</code>命令：</p>
<pre><code>get users:9001</code></pre>
<p>而如果想通过电子邮箱来获取用户信息，我们可以使用<code>hget</code>命令再配合使用<code>get</code>命令（Ruby代码）：</p>
<pre><code>id = redis.hget(&#39;users:lookup:email&#39;, &#39;leto@dune.gov&#39;)
user = redis.get(&quot;users:#&#123;id&#125;&quot;)</code></pre>
<p>你很可能将会经常使用这类用法。在我看来，这就是散列真正耀眼的地方。在你了解这类用法之前，这可能不是一个明显的用例。</p>
<h3 id="引用和索引（References-and-Indexes）"><a href="#引用和索引（References-and-Indexes）" class="headerlink" title="引用和索引（References and Indexes）"></a>引用和索引（References and Indexes）</h3><blockquote>
<p> Redis必须手动的管理索引和引用</p>
</blockquote>
<p>我们已经看过几个关于值引用的用例，包括介绍列表数据结构时的用例，以及在上面使用散列数据结构来使查询更灵活一些。进行归纳后会发现，对于那些值与值间的索引和引用，我们都必须手动的去管理。诚实来讲，这确实会让人有点沮丧，尤其是当你想到那些引用相关的操作，如管理、更新和删除等，都必须手动的进行时。在Redis里，这个问题还没有很好的解决方法。</p>
<p>我们已经看到，集合数据结构常常被用来实现这类索引：</p>
<pre><code>sadd friends:leto ghanima paul chani jessica</code></pre>
<p>这个集合里的每一个成员都是一个Redis字符串数据结构的引用，而每一个引用的值则包含着用户对象的具体信息。那么如果<code>chani</code>改变了她的名字，或者删除了她的帐号，应该如何处理？从整个朋友圈的关系结构来看可能会更好理解，我们知道，<code>chani</code>也有她的朋友：</p>
<pre><code>sadd friends_of:chani leto paul</code></pre>
<p>如果你有什么待处理情况像上面那样，那在维护成本之外，还会有对于额外索引值的处理和存储空间的成本。这可能会令你感到有点退缩。在下一小节里，我们将会谈论减少使用额外数据交互的性能成本的一些方法（在第1章我们粗略地讨论了下）。</p>
<blockquote>
<p>在上一节实现引用的技巧中，当一个集合的每个成员都对应一个引用时，如果这个成员的名称发生变化时，需要手动的更新索引对应的值，这需要额外的工作</p>
</blockquote>
<blockquote>
<p>即使是在传统的关系型数据库中，也需要维护索引，不过这些工作是由数据库自身维护的</p>
</blockquote>
<p>如果你确实在担忧着这些情况，其实，关系型数据库也有同样的开销。索引需要一定的存储空间，必须通过扫描或查找，然后才能找到相应的记录。其开销也是存在的，当然他们对此做了很多的优化工作，使之变得更为有效。</p>
<p>再次说明，需要在Redis里手动地管理引用确实是颇为棘手。但是，对于你关心的那些问题，包括性能或存储空间等，应该在经过测试后，才会有真正的理解。我想你会发现这不会是一个大问题。</p>
<h3 id="数据交互和流水线（Round-Trips-and-Pipelining）"><a href="#数据交互和流水线（Round-Trips-and-Pipelining）" class="headerlink" title="数据交互和流水线（Round Trips and Pipelining）"></a>数据交互和流水线（Round Trips and Pipelining）</h3><p>我们已经提到过，与服务器频繁交互是Redis的一种常见模式。这类情况可能很常出现，为了使我们能获益更多，值得仔细去看看我们能利用哪些特性。</p>
<p>许多命令能接受一个或更多的参数，也有一种关联命令（sister-command）可以接受多个参数。例如早前我们看到过<code>mget</code>命令，接受多个关键字，然后返回值：</p>
<pre><code>keys = redis.lrange(&#39;newusers&#39;, 0, 10)
redis.mget(*keys.map &#123;|u| &quot;users:#&#123;u&#125;&quot;&#125;)</code></pre>
<p>或者是<code>sadd</code>命令，能添加一个或多个成员到集合里：</p>
<pre><code>sadd friends:vladimir piter
sadd friends:paul jessica leto &quot;leto II&quot; chani</code></pre>
<p>Redis还支持流水线功能。通常情况下，当一个客户端发送请求到Redis后，在发送下一个请求之前必须等待Redis的答复。使用流水线功能，你可以发送多个请求，而不需要等待Redis响应。这不但减少了网络开销，还能获得性能上的显著提高。</p>
<p>值得一提的是，Redis会使用存储器去排列命令，因此批量执行命令是一个好主意。至于具体要多大的批量，将取决于你要使用什么命令（更明确来说，该参数有多大）。另一方面来看，如果你要执行的命令需要差不多50个字符的关键字，你大概可以对此进行数千或数万的批量操作。</p>
<p>对于不同的Redis载体，在流水线里运行命令的方式会有所差异。在Ruby里，你传递一个代码块到<code>pipelined</code>方法：</p>
<pre><code>redis.pipelined do
  9001.times do
    redis.incr(&#39;powerlevel&#39;)
  end
end</code></pre>
<p>正如你可能猜想到的，流水线功能可以实际地加速一连串命令的处理。</p>
<h3 id="事务（Transactions）"><a href="#事务（Transactions）" class="headerlink" title="事务（Transactions）"></a>事务（Transactions）</h3><p>每一个Redis命令都具有原子性，包括那些一次处理多项事情的命令。此外，对于使用多个命令，Redis支持事务功能。</p>
<p>你可能不知道，但Redis实际上是单线程运行的，这就是为什么每一个Redis命令都能够保证具有原子性。当一个命令在执行时，没有其他命令会运行（我们会在往后的章节里简略谈论一下Scaling）。在你考虑到一些命令去做多项事情时，这会特别的有用。例如：</p>
<p><code>incr</code>命令实际上就是一个<code>get</code>命令然后紧随一个<code>set</code>命令。</p>
<p><code>getset</code>命令设置一个新的值然后返回原始值。</p>
<p><code>setnx</code>命令首先测试关键字是否存在，只有当关键字不存在时才设置值</p>
<p>虽然这些都很有用，但在实际开发时，往往会需要运行具有原子性的一组命令。若要这样做，首先要执行<code>multi</code>命令，紧随其后的是所有你想要执行的命令（作为事务的一部分），最后执行<code>exec</code>命令去实际执行命令，或者使用<code>discard</code>命令放弃执行命令。Redis的事务功能保证了什么？</p>
<ul>
<li><p>事务中的命令将会按顺序地被执行</p>
</li>
<li><p>事务中的命令将会如单个原子操作般被执行（没有其它的客户端命令会在中途被执行）</p>
</li>
<li><p>事务中的命令要么全部被执行，要么不会执行</p>
</li>
</ul>
<p>你可以（也应该）在命令行界面对事务功能进行一下测试。还有一点要注意到，没有什么理由不能结合流水线功能和事务功能。</p>
<pre><code>multi
hincrby groups:1percent balance -9000000000
hincrby groups:99percent balance 9000000000
exec</code></pre>
<p>最后，Redis能让你指定一个关键字（或多个关键字），当关键字有改变时，可以查看或者有条件地应用一个事务。这是用于当你需要获取值，且待运行的命令基于那些值时，所有都在一个事务里。对于上面展示的代码，我们不能去实现自己的<code>incr</code>命令，因为一旦<code>exec</code>命令被调用，他们会全部被执行在一块。我们不能这么做：</p>
<pre><code>redis.multi()
current = redis.get(&#39;powerlevel&#39;)
redis.set(&#39;powerlevel&#39;, current + 1)
redis.exec()</code></pre>
<p><strong>（译注：虽然Redis是单线程运行的，但是我们可以同时运行多个Redis客户端进程，常见的并发问题还是会出现。像上面的代码，在<code>get</code>运行之后，<code>set</code>运行之前，<code>powerlevel</code>的值可能会被另一个Redis客户端给改变，从而造成错误。）</strong></p>
<p>这些不是Redis的事务功能的工作。但是，如果我们增加一个<code>watch</code>到<code>powerlevel</code>，我们可以这样做：</p>
<pre><code>redis.watch(&#39;powerlevel&#39;)
current = redis.get(&#39;powerlevel&#39;)
redis.multi()
redis.set(&#39;powerlevel&#39;, current + 1)
redis.exec()</code></pre>
<p>在我们调用<code>watch</code>后，如果另一个客户端改变了<code>powerlevel</code>的值，我们的事务将会运行失败。如果没有客户端改变<code>powerlevel</code>的值，那么事务会继续工作。我们可以在一个循环里运行这些代码，直到其能正常工作。</p>
<h3 id="关键字反模式（Keys-Anti-Pattern）"><a href="#关键字反模式（Keys-Anti-Pattern）" class="headerlink" title="关键字反模式（Keys Anti-Pattern）"></a>关键字反模式（Keys Anti-Pattern）</h3><p>在下一章中，我们将会谈论那些没有确切关联到数据结构的命令，其中的一些是管理或调试工具。然而有一个命令我想特别地在这里进行谈论：<code>keys</code>命令。这个命令需要一个模式，然后查找所有匹配的关键字。这个命令看起来很适合一些任务，但这不应该用在实际的产品代码里。为什么？因为这个命令通过线性扫描所有的关键字来进行匹配。或者，简单地说，这个命令太慢了。</p>
<p>人们会如此去使用这个命令？一般会用来构建一个本地的Bug追踪服务。每一个帐号都有一个<code>id</code>，你可能会通过一个看起来像<code>bug:account_id:bug_id</code>的关键字，把每一个Bug存储到一个字符串数据结构值中去。如果你在任何时候需要查询一个帐号的Bug（显示它们，或者当用户删除了帐号时删除掉这些Bugs），你可能会尝试去使用<code>keys</code>命令：</p>
<pre><code>keys bug:1233:*</code></pre>
<p>更好的解决方法应该使用一个散列数据结构，就像我们可以使用散列数据结构来提供一种方法去展示二级索引，因此我们可以使用域来组织数据：</p>
<pre><code>hset bugs:1233 1 &quot;&#123;id:1, account: 1233, subject: &#39;...&#39;&#125;&quot;
hset bugs:1233 2 &quot;&#123;id:2, account: 1233, subject: &#39;...&#39;&#125;&quot;</code></pre>
<p>从一个帐号里获取所有的Bug标识，可以简单地调用<code>hkeys bugs:1233</code>。去删除一个指定的Bug，可以调用<code>hdel bugs:1233 2</code>。如果要删除了一个帐号，可以通过<code>del bugs:1233</code>把关键字删除掉。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>结合这一章以及前一章，希望能让你得到一些洞察力，了解如何使用Redis去支持（Power）实际项目。还有其他的模式可以让你去构建各种类型的东西，但真正的关键是要理解基本的数据结构。你将能领悟到，这些数据结构是如何能够实现你最初视角之外的东西。</p>
<h2 id="第4章-超越数据结构"><a href="#第4章-超越数据结构" class="headerlink" title="第4章 超越数据结构"></a>第4章 超越数据结构</h2><p>5种数据结构组成了Redis的基础，其他没有关联特定数据结构的命令也有很多。我们已经看过一些这样的命令：<code>info</code>, <code>select</code>, <code>flushdb</code>, <code>multi</code>, <code>exec</code>, <code>discard</code>, <code>watch</code>和<code>keys </code>。这一章将看看其他的一些重要命令。</p>
<h3 id="使用期限（Expiration）"><a href="#使用期限（Expiration）" class="headerlink" title="使用期限（Expiration）"></a>使用期限（Expiration）</h3><p>Redis允许你标记一个关键字的使用期限。你可以给予一个Unix时间戳形式（自1970年1月1日起）的绝对时间，或者一个基于秒的存活时间。这是一个基于关键字的命令，因此其不在乎关键字表示的是哪种类型的数据结构。</p>
<pre><code>expire pages:about 30
expireat pages:about 1356933600</code></pre>
<p>第一个命令将会在30秒后删除掉关键字（包括其关联的值）。第二个命令则会在2012年12月31日上午12点删除掉关键字。</p>
<p>这让Redis能成为一个理想的缓冲引擎。通过<code>ttl</code>命令，你可以知道一个关键字还能够存活多久。而通过<code>persist</code>命令，你可以把一个关键字的使用期限删除掉。</p>
<pre><code>ttl pages:about
persist pages:about</code></pre>
<p>最后，有个特殊的字符串命令，<code>setex</code>命令让你可以在一个单独的原子命令里设置一个字符串值，同时里指定一个生存期（这比任何事情都要方便）。</p>
<pre><code>setex pages:about 30 &#39;&lt;h1&gt;about us&lt;/h1&gt;....&#39;</code></pre>
<h3 id="发布和订阅（Publication-and-Subscriptions）"><a href="#发布和订阅（Publication-and-Subscriptions）" class="headerlink" title="发布和订阅（Publication and Subscriptions）"></a>发布和订阅（Publication and Subscriptions）</h3><p>Redis的列表数据结构有<code>blpop</code>和<code>brpop</code>命令，能从列表里返回且删除第一个（或最后一个）元素，或者被堵塞，直到有一个元素可供操作。这可以用来实现一个简单的队列。</p>
<p><strong>（译注：对于<code>blpop</code>和<code>brpop</code>命令，如果列表里没有关键字可供操作，连接将被堵塞，直到有另外的Redis客户端使用<code>lpush</code>或<code>rpush</code>命令推入关键字为止。）</strong></p>
<p>此外，Redis对于消息发布和频道订阅有着一流的支持。你可以打开第二个<code>redis-cli</code>窗口，去尝试一下这些功能。在第一个窗口里订阅一个频道（我们会称它为<code>warnings</code>）：</p>
<pre><code>subscribe warnings</code></pre>
<p>其将会答复你订阅的信息。现在，在另一个窗口，发布一条消息到<code>warnings</code>频道：</p>
<pre><code>publish warnings &quot;it&#39;s over 9000!&quot;</code></pre>
<p>如果你回到第一个窗口，你应该已经接收到<code>warnings</code>频道发来的消息。</p>
<p>你可以订阅多个频道（<code>subscribe channel1 channel2 ...</code>），订阅一组基于模式的频道（<code>psubscribe warnings:*</code>），以及使用<code>unsubscribe</code>和<code>punsubscribe</code>命令停止监听一个或多个频道，或一个频道模式。</p>
<p>最后，可以注意到<code>publish</code>命令的返回值是1，这指出了接收到消息的客户端数量。</p>
<h3 id="监控和延迟日志（Monitor-and-Slow-Log）"><a href="#监控和延迟日志（Monitor-and-Slow-Log）" class="headerlink" title="监控和延迟日志（Monitor and Slow Log）"></a>监控和延迟日志（Monitor and Slow Log）</h3><p><code>monitor</code>命令可以让你查看Redis正在做什么。这是一个优秀的调试工具，能让你了解你的程序如何与Redis进行交互。在两个<code>redis-cli</code>窗口中选一个（如果其中一个还处于订阅状态，你可以使用<code>unsubscribe</code>命令退订，或者直接关掉窗口再重新打开一个新窗口）键入<code>monitor</code>命令。在另一个窗口，执行任何其他类型的命令（例如<code>get</code>或<code>set</code>命令）。在第一个窗口里，你应该可以看到这些命令，包括他们的参数。</p>
<p>在实际生产环境里，你应该谨慎运行<code>monitor</code>命令，这真的仅仅就是一个很有用的调试和开发工具。除此之外，没有更多要说的了。</p>
<p>随同<code>monitor</code>命令一起，Redis拥有一个<code>slowlog</code>命令，这是一个优秀的性能剖析工具。其会记录执行时间超过一定数量<strong>微秒</strong>的命令。在下一章节，我们会简略地涉及如何配置Redis，现在你可以按下面的输入配置Redis去记录所有的命令：</p>
<pre><code>config set slowlog-log-slower-than 0</code></pre>
<p>然后，执行一些命令。最后，你可以检索到所有日志，或者检索最近的那些日志：</p>
<pre><code>slowlog get
slowlog get 10</code></pre>
<p>通过键入<code>slowlog len</code>，你可以获取延迟日志里的日志数量。</p>
<p>对于每个被你键入的命令，你应该查看4个参数：</p>
<ul>
<li><p>一个自动递增的id</p>
</li>
<li><p>一个Unix时间戳，表示命令开始运行的时间</p>
</li>
<li><p>一个微妙级的时间，显示命令运行的总时间</p>
</li>
<li><p>该命令以及所带参数</p>
</li>
</ul>
<p>延迟日志保存在存储器中，因此在生产环境中运行（即使有一个低阀值）也应该不是一个问题。默认情况下，它将会追踪最近的1024个日志。</p>
<h3 id="排序（Sort）"><a href="#排序（Sort）" class="headerlink" title="排序（Sort）"></a>排序（Sort）</h3><p><code>sort</code>命令是Redis最强大的命令之一。它让你可以在一个列表、集合或者分类集合里对值进行排序（分类集合是通过标记来进行排序，而不是集合里的成员）。下面是一个<code>sort</code>命令的简单用例：</p>
<pre><code>rpush users:leto:guesses 5 9 10 2 4 10 19 2
sort users:leto:guesses</code></pre>
<p>这将返回进行升序排序后的值。这里有一个更高级的例子：</p>
<pre><code>sadd friends:ghanima leto paul chani jessica alia duncan
sort friends:ghanima limit 0 3 desc alpha</code></pre>
<p>上面的命令向我们展示了，如何对已排序的记录进行分页（通过<code>limit</code>），如何返回降序排序的结果（通过<code>desc</code>），以及如何用字典序排序代替数值序排序（通过<code>alpha</code>）。</p>
<p><code>sort</code>命令的真正力量是其基于引用对象来进行排序的能力。早先的时候，我们说明了列表、集合和分类集合很常被用于引用其他的Redis对象，<code>sort</code>命令能够解引用这些关系，而且通过潜在值来进行排序。例如，假设我们有一个Bug追踪器能让用户看到各类已存在问题。我们可能使用一个集合数据结构去追踪正在被监视的问题：</p>
<pre><code>sadd watch:leto 12339 1382 338 9338</code></pre>
<p>你可能会有强烈的感觉，想要通过id来排序这些问题（默认的排序就是这样的），但是，我们更可能是通过问题的严重性来对这些问题进行排序。为此，我们要告诉Redis将使用什么模式来进行排序。首先，为了可以看到一个有意义的结果，让我们添加多一点数据：</p>
<pre><code>set severity:12339 3
set severity:1382 2
set severity:338 5
set severity:9338 4</code></pre>
<p>要通过问题的严重性来降序排序这些Bug，你可以这样做：</p>
<pre><code>sort watch:leto by severity:* desc</code></pre>
<p>Redis将会用存储在列表（集合或分类集合）中的值去替代模式中的<code>*</code>（通过<code>by</code>）。这会创建出关键字名字，Redis将通过查询其实际值来排序。</p>
<p>在Redis里，虽然你可以有成千上万个关键字，类似上面展示的关系还是会引起一些混乱。幸好，<code>sort</code>命令也可以工作在散列数据结构及其相关域里。相对于拥有大量的高层次关键字，你可以利用散列：</p>
<pre><code>hset bug:12339 severity 3
hset bug:12339 priority 1
hset bug:12339 details &quot;&#123;id: 12339, ....&#125;&quot;

hset bug:1382 severity 2
hset bug:1382 priority 2
hset bug:1382 details &quot;&#123;id: 1382, ....&#125;&quot;

hset bug:338 severity 5
hset bug:338 priority 3
hset bug:338 details &quot;&#123;id: 338, ....&#125;&quot;

hset bug:9338 severity 4
hset bug:9338 priority 2
hset bug:9338 details &quot;&#123;id: 9338, ....&#125;&quot;</code></pre>
<p>所有的事情不仅变得更为容易管理，而且我们能通过<code>severity</code>或<code>priority</code>来进行排序，还可以告诉<code>sort</code>命令具体要检索出哪一个域的数据：</p>
<pre><code>sort watch:leto by bug:*-&gt;priority get bug:*-&gt;details</code></pre>
<p>相同的值替代出现了，但Redis还能识别<code>-&gt;</code>符号，用它来查看散列中指定的域。里面还包括了<code>get</code>参数，这里也会进行值替代和域查看，从而检索出Bug的细节（details域的数据）。</p>
<p>对于太大的集合，<code>sort</code>命令的执行可能会变得很慢。好消息是，<code>sort</code>命令的输出可以被存储起来：</p>
<pre><code>sort watch:leto by bug:*-&gt;priority get bug:*-&gt;details store watch_by_priority:leto</code></pre>
<p>使用我们已经看过的<code>expiration</code>命令，再结合<code>sort</code>命令的<code>store</code>能力，这是一个美妙的组合。</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>这一章主要关注那些非特定数据结构关联的命令。和其他事情一样，它们的使用依情况而定。构建一个程序或特性时，可能不会用到使用期限、发布和订阅或者排序等功能。但知道这些功能的存在是很好的。而且，我们也只接触到了一些命令。还有更多的命令，当你消化理解完这本书后，非常值得去浏览一下<a target="_blank" rel="noopener" href="http://redis.io/commands">完整的命令列表</a>。</p>
<h2 id="第5章-管理"><a href="#第5章-管理" class="headerlink" title="第5章 - 管理"></a>第5章 - 管理</h2><p>在最后一章里，我们将集中谈论Redis运行中的一些管理方面内容。这是一个不完整的Redis管理指南，我们将会回答一些基本的问题，初接触Redis的新用户可能会很感兴趣。</p>
<h3 id="配置（Configuration）"><a href="#配置（Configuration）" class="headerlink" title="配置（Configuration）"></a>配置（Configuration）</h3><p>当你第一次运行Redis的服务器，它会向你显示一个警告，指<code>redis.conf</code>文件没有被找到。这个文件可以被用来配置Redis的各个方面。一个充分定义（well-documented）的<code>redis.conf</code>文件对各个版本的Redis都有效。范例文件包含了默认的配置选项，因此，对于想要了解设置在干什么，或默认设置是什么，都会很有用。你可以在<a target="_blank" rel="noopener" href="https://github.com/antirez/redis/raw/2.4.6/redis.conf">https://github.com/antirez/redis/raw/2.4.6/redis.conf</a>找到这个文件。</p>
<p><strong>这个配置文件针对的是Redis 2.4.6，你应该用你的版本号替代上面URL里的”2.4.6”。运行<code>info</code>命令，其显示的第一个值就是Redis的版本号。</strong></p>
<p>因为这个文件已经是充分定义（well-documented），我们就不去再进行设置了。</p>
<p>除了通过<code>redis.conf</code>文件来配置Redis，<code>config set</code>命令可以用来对个别值进行设置。实际上，在将<code>slowlog-log-slower-than</code>设置为0时，我们就已经使用过这个命令了。</p>
<p>还有一个<code>config get</code>命令能显示一个设置值。这个命令支持模式匹配，因此如果我们想要显示关联于日志（logging）的所有设置，我们可以这样做：</p>
<pre><code>config get *log*</code></pre>
<h3 id="验证（Authentication）"><a href="#验证（Authentication）" class="headerlink" title="验证（Authentication）"></a>验证（Authentication）</h3><p>通过设置<code>requirepass</code>（使用<code>config set</code>命令或<code>redis.conf</code>文件），可以让Redis需要一个密码验证。当<code>requirepass</code>被设置了一个值（就是待用的密码），客户端将需要执行一个<code>auth password</code>命令。</p>
<p>一旦一个客户端通过了验证，就可以在任意数据库里执行任何一条命令，包括<code>flushall</code>命令，这将会清除掉每一个数据库里的所有关键字。通过配置，你可以重命名一些重要命令为混乱的字符串，从而获得一些安全性。</p>
<pre><code>rename-command CONFIG 5ec4db169f9d4dddacbfb0c26ea7e5ef
rename-command FLUSHALL 1041285018a942a4922cbf76623b741e</code></pre>
<p>或者，你可以将新名字设置为一个空字符串，从而禁用掉一个命令。</p>
<h3 id="大小限制（Size-Limitations）"><a href="#大小限制（Size-Limitations）" class="headerlink" title="大小限制（Size Limitations）"></a>大小限制（Size Limitations）</h3><p>当你开始使用Redis，你可能会想知道，我能使用多少个关键字？还可能想知道，一个散列数据结构能有多少个域（尤其是当你用它来组织数据时），或者是，一个列表数据结构或集合数据结构能有多少个元素？对于每一个实例，实际限制都能达到亿万级别（hundreds of millions）。</p>
<h3 id="复制（Replication）"><a href="#复制（Replication）" class="headerlink" title="复制（Replication）"></a>复制（Replication）</h3><p>Redis支持复制功能，这意味着当你向一个Redis实例（Master）进行写入时，一个或多个其他实例（Slaves）能通过Master实例来保持更新。可以在配置文件里设置<code>slaveof</code>，或使用<code>slaveof</code>命令来配置一个Slave实例。对于那些没有进行这些设置的Redis实例，就可能一个Master实例。</p>
<p>为了更好保护你的数据，复制功能拷贝数据到不同的服务器。复制功能还能用于改善性能，因为读取请求可以被发送到Slave实例。他们可能会返回一些稍微滞后的数据，但对于大多数程序来说，这是一个值得做的折衷。</p>
<p>遗憾的是，Redis的复制功能还没有提供自动故障恢复。如果Master实例崩溃了，一个Slave实例需要手动的进行升级。如果你想使用Redis去达到某种高可用性，对于使用心跳监控（heartbeat monitoring）和脚本自动开关（scripts to automate the switch）的传统高可用性工具来说，现在还是一个棘手的难题。</p>
<h3 id="备份文件（Backups）"><a href="#备份文件（Backups）" class="headerlink" title="备份文件（Backups）"></a>备份文件（Backups）</h3><p>备份Redis非常简单，你可以将Redis的快照（snapshot）拷贝到任何地方，包括S3、FTP等。默认情况下，Redis会把快照存储为一个名为<code>dump.rdb</code>的文件。在任何时候，你都可以对这个文件执行<code>scp</code>、<code>ftp</code>或<code>cp</code>等常用命令。</p>
<p>有一种常见情况，在Master实例上会停用快照以及单一附加文件（aof），然后让一个Slave实例去处理备份事宜。这可以帮助减少Master实例的载荷。在不损害整体系统响应性的情况下，你还可以在Slave实例上设置更多主动存储的参数。</p>
<h3 id="缩放和Redis集群（Scaling-and-Redis-Cluster）"><a href="#缩放和Redis集群（Scaling-and-Redis-Cluster）" class="headerlink" title="缩放和Redis集群（Scaling and Redis Cluster）"></a>缩放和Redis集群（Scaling and Redis Cluster）</h3><p>复制功能（Replication）是一个成长中的网站可以利用的第一个工具。有一些命令会比另外一些来的昂贵（例如<code>sort</code>命令），将这些运行载荷转移到一个Slave实例里，可以保持整体系统对于查询的快速响应。</p>
<p>此外，通过分发你的关键字到多个Redis实例里，可以达到真正的缩放Redis（记住，Redis是单线程的，这些可以运行在同一个逻辑框里）。随着时间的推移，你将需要特别注意这些事情（尽管许多的Redis载体都提供了consistent-hashing算法）。对于数据水平分布（horizontal distribution）的考虑不在这本书所讨论的范围内。这些东西你也很可能不需要去担心，但是，无论你使用哪一种解决方案，有一些事情你还是必须意识到。</p>
<p>好消息是，这些工作都可在Redis集群下进行。不仅提供水平缩放（包括均衡），为了高可用性，还提供了自动故障恢复。</p>
<p>高可用性和缩放是可以达到的，只要你愿意为此付出时间和精力，Redis集群也使事情变得简单多了。</p>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>在过去的一段时间里，已经有许多的计划和网站使用了Redis，毫无疑问，Redis已经可以应用于实际生产中了。然而，一些工具还是不够成熟，尤其是一些安全性和可用性相关的工具。对于Redis集群，我们希望很快就能看到其实现，这应该能为一些现有的管理挑战提供处理帮忙。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在许多方面，Redis体现了一种简易的数据处理方式，其剥离掉了大部分的复杂性和抽象，并可有效的在不同系统里运行。不少情况下，选择Redis不是最佳的选择。在另一些情况里，Redis就像是为你的数据提供了特别定制的解决方案。</p>
<p>最终，回到我最开始所说的：Redis很容易学习。现在有许多的新技术，很难弄清楚哪些才真正值得我们花时间去学习。如果你从实际好处来考虑，Redis提供了他的简单性。我坚信，对于你和你的团队，学习Redis是最好的技术投资之一。</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/HttpClient/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/HttpClient/" class="post-title-link" itemprop="url">HttpClient</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-12-12 12:26:00" itemprop="dateCreated datePublished" datetime="2016-12-12T12:26:00+08:00">2016-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-23 13:04:00" itemprop="dateModified" datetime="2021-04-23T13:04:00+08:00">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HttpClient-2-3-6中-使用-SSL-3"><a href="#HttpClient-2-3-6中-使用-SSL-3" class="headerlink" title="HttpClient 2.3.6中 使用 SSL 3"></a>HttpClient 2.3.6中 使用 SSL 3</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">httpPost</span><span class="params">(String strUrl, List&lt;NameValuePair&gt; params)</span> </span>&#123;</span><br><span class="line">    RequestConfig.Builder bld = RequestConfig.custom();</span><br><span class="line">    bld.setConnectTimeout(<span class="number">60000</span>);</span><br><span class="line">    bld.setConnectionRequestTimeout(<span class="number">60000</span>);</span><br><span class="line">    bld.setSocketTimeout(<span class="number">60000</span>);</span><br><span class="line"></span><br><span class="line">    RequestConfig config = bld.build();</span><br><span class="line">    CloseableHttpClient closeableHttpClient = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SSLContext sslcontext = SSLContexts.custom()</span><br><span class="line">                .loadTrustMaterial(<span class="keyword">null</span>, <span class="keyword">new</span> TrustSelfSignedStrategy())</span><br><span class="line">                .loadKeyMaterial(<span class="keyword">null</span>, <span class="keyword">null</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        SSLConnectionSocketFactory sslsf = <span class="keyword">new</span> SSLConnectionSocketFactory(</span><br><span class="line">                sslcontext, <span class="keyword">new</span> String[]&#123;<span class="string">&quot;SSLv3&quot;</span>, <span class="string">&quot;TLSv1&quot;</span>&#125;, <span class="keyword">null</span>,</span><br><span class="line">                SSLConnectionSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (closeableHttpClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">            closeableHttpClient = HttpClients.custom()</span><br><span class="line">                    .setSSLSocketFactory(sslsf).build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    String result = <span class="keyword">null</span>;</span><br><span class="line">    CloseableHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HttpPost post = <span class="keyword">new</span> HttpPost(strUrl);</span><br><span class="line">        post.setEntity(<span class="keyword">new</span> UrlEncodedFormEntity(params, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        response = closeableHttpClient.execute(post);</span><br><span class="line">        <span class="keyword">int</span> code = response.getStatusLine().getStatusCode();</span><br><span class="line">        System.out.println(<span class="string">&quot;请求返回结果: Code:&quot;</span> + code);</span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">200</span>) &#123;</span><br><span class="line">            result = EntityUtils.toString(response.getEntity(), <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求返回值为:=&gt; &quot;</span> + result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (closeableHttpClient != <span class="keyword">null</span>) &#123;</span><br><span class="line">                closeableHttpClient.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/multithread/04.thread-synchronization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/multithread/04.thread-synchronization/" class="post-title-link" itemprop="url">Java多线程4: 同步锁与Java线程同步方法比较</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-12-09 00:00:00" itemprop="dateCreated datePublished" datetime="2016-12-09T00:00:00+08:00">2016-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-23 13:04:00" itemprop="dateModified" datetime="2021-04-23T13:04:00+08:00">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="/Java/advanced-engineer-outline/">&lt;Java高级软件工程师知识结构</a></p>
<pre><code>Java多线程是Java基础的重要的一部分，支持多线程是Java的重要特性之一. 主要包括如下内容:</code></pre>
<blockquote>
<ol>
<li><a href="/Java/multithread/01.base/">Java多线程1: 线程生命周期和多线程基础</a></li>
<li><a href="/Java/multithread/02.Lock-Semaphore-Atomic/">Java多线程2: Lock、信号量、原子量与队列</a></li>
<li><a href="/Java/multithread/03.volatile/">Java多线程3: volatile</a></li>
<li><a href="/Java/multithread/04.thread-synchronization/">Java多线程4: 同步锁与Java线程同步方法比较</a></li>
<li><a href="/Java/multithread/05.ThreadPool/">Java多线程5: 线程池</a></li>
<li><a href="/Java/multithread/06.BlockingQueue/">Java多线程6: Java阻塞队列与生产者消费者模式</a></li>
</ol>
</blockquote>
<ol>
<li>Atomic Class 依赖寄存器 CAS</li>
<li>volatile 共享变量</li>
<li>ThreadLocal CopyOnWrite 只读或近似只读</li>
<li>Synchronized CAS级别</li>
<li>Lock condition readAndWriteLock 并发级别</li>
<li>CountdownLatch</li>
<li>Semaphore</li>
</ol>
<hr>
<p>【参考文献】:</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/database/sql-lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/database/sql-lock/" class="post-title-link" itemprop="url">数据库锁的基本原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-12-01 00:00:00" itemprop="dateCreated datePublished" datetime="2016-12-01T00:00:00+08:00">2016-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-23 13:04:00" itemprop="dateModified" datetime="2021-04-23T13:04:00+08:00">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DataBase/" itemprop="url" rel="index"><span itemprop="name">DataBase</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="数据库锁的基本原理"><a href="#数据库锁的基本原理" class="headerlink" title="数据库锁的基本原理"></a>数据库锁的基本原理</h1><h2 id="为什么要锁"><a href="#为什么要锁" class="headerlink" title="为什么要锁"></a>为什么要锁</h2><p>数据库通常有大量的用户在同时操作，所以并发的情况下需要控制对临界资源的操作，数据库通过锁来控制对临界资源的访问，从而保证数据的一致性。例如对于同一个账户，操作之前账户余额为1000，同时开始2个事务，一个事务取款100，一个事务往账户中汇入100，那么2个事务结束后，账户的余额必须还是1000，否则要么银行不干，要么个人不干。 </p>
<h2 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h2><h3 id="共享锁-读锁"><a href="#共享锁-读锁" class="headerlink" title="共享锁(读锁)"></a>共享锁(读锁)</h3><p>读锁是共享的，互相不阻塞，也就是可以多个客户同时读取同一资源，而不互相干扰。</p>
<p>加锁条件：当执行select时，数据库为这个事务分配一把共享锁，来锁定被查询的数据。 </p>
<p>解锁条件：默认情况下，数据被读取之后，数据库立即解锁。例如select * from table中，先锁定第一行，读取后，立即解锁第一行，然后再锁定第二行，这样大大降低锁争用程度。在repeatable read和serializable 这两种事务隔离级别下，共享锁是在事务结束时释放的，serializable对表加锁。 </p>
<h3 id="排它锁-独占锁-写锁"><a href="#排它锁-独占锁-写锁" class="headerlink" title="排它锁(独占锁)(写锁)"></a>排它锁(独占锁)(写锁)</h3><p>写锁是排他的，一个写锁会阻塞其他的读锁和写锁，只有这样才能保证同一时刻，只有一个用户能够写入，并阻止其他用户读取正在写入的同一资源。如果要锁定的数据资源，已经放置了其他的锁，则不能再放置排它锁。<br>加锁条件：当执行insert update 和delete语句时，数据库会对操纵的资源使用排它锁。<br>解锁条件：事务结束时解锁。 </p>
<h2 id="锁原理"><a href="#锁原理" class="headerlink" title="锁原理"></a>锁原理</h2><p>锁的基本原理如下：</p>
<p>1.当第一个事务访问数据库资源时，如果执行select语句，则必须先获得共享锁，如果执行insert update和delete时，必须获得排它锁<br>2.当第二个事务也要访问相同的资源时，如果执行select语句，也必须先获得共享锁，如果执行insert update或者delete，也必须获得共享锁。根据已经放置在资源上的锁类型，来决定第二个事务是应该等待第一个事务释放锁，还是立即获得锁。 </p>
<table>
<thead>
<tr>
<th>资源上的锁</th>
<th>第二个事务进行读</th>
<th>第二个事务进行写</th>
</tr>
</thead>
<tbody><tr>
<td>无</td>
<td>立即获得共享锁</td>
<td>立即获得排他锁</td>
</tr>
<tr>
<td>共享锁</td>
<td>立即获得共享锁</td>
<td>等待第一个事务释放锁</td>
</tr>
<tr>
<td>排他锁</td>
<td>等待第一个事务释放锁</td>
<td>等待第一个事务释放锁</td>
</tr>
</tbody></table>
<h2 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h2><p>常见的锁有表锁、 行锁、 页锁、外键锁等。 </p>
<p>锁有一定的消耗，主要有：获得锁，检查锁是否已经解除，释放锁等，这些操作都会增加系统的开销。<br>表锁开销比较小，但是并发性能也较差，行锁并发性能高，但是需要更多锁，数据库系统一般都支持锁的自动升级，例如一个事务中的锁过多的时候，可能会将行锁升级到表锁。</p>
<p>mysql的各个存储引擎根据不同的应用场景采用不同的锁机制，MyISAM存储引擎采用表锁，InnoDB使用行锁。如果执行alert table之类的操作，服务器也会采用表锁，而忽略存储引擎的锁机制。<br>页锁，某些数据库支持页锁，页锁粒度介于行锁和表锁之间，用于锁定存放数据的页，1页通常含有n个数据行。 </p>
<p>外键锁：外键会产生高级别的锁，后面介绍死锁的时候会提到。 </p>
<h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><p>悲观锁：假设如果不加锁就一定会出现问题。<br>乐观锁：先假定不会出现并发问题，出现问题后再采取相应的措施。<br>悲观锁通过<code>select * from tbl for update</code>实现。<br>乐观锁可以在表中加一个version字段，每次更新的时候都+1，这样如果出现并发，第二次更新的时候version的值已经不再匹配，可以在这时采取相应的措施。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁是如何产生的"><a href="#死锁是如何产生的" class="headerlink" title="死锁是如何产生的"></a>死锁是如何产生的</h3><p>同java的死锁一样，都是互相等待对方释放锁，造成了相互阻塞，造成的死锁。<br>请看下面的表格： </p>
<p><img src="/images/database/lock/concept-02.gif"></p>
<h3 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h3><p>1.修改操作表的顺序<br>从上面的示例中可以看出，如果调整一下操作表的顺序就可以避免死锁。<br>2.外键<br>如果向子表写记录，那么外键约束会检查父表的记录，并锁住父表的记录，来保证这条记录不会在这个事务完成之时就被删除了。<br>产生高级别的锁，会阻止其他事务操作或者其他DML操作，如果是因为外键产生的死锁，可以去掉外键约束，由应用来保证数据的完整性，通常生产环境都不建议加外键约束。<br>3.短事务<br>缩短事务的执行时间，可以减少锁的持有时间，可以降低死锁的风险。 </p>
<h2 id="锁可能出现的问题"><a href="#锁可能出现的问题" class="headerlink" title="锁可能出现的问题"></a>锁可能出现的问题</h2><p>上锁是有开销的，即使不是给数据行而是给数据页上锁，也是有一定的时间的，如果第一个事务update一张大表，这时候第二个事务update这张大表比较靠后的位置的数据，这时候就可能会出现，第一个事务还没来得及给相应的数据上锁，第二个事务已经上了锁，所以出现第一个事务要等待第二个事务提交后释放锁，才能继续执行的情况。 </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/database/MySQL/best_practices/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/database/MySQL/best_practices/" class="post-title-link" itemprop="url">MySQL数据库设计总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-12-01 00:00:00" itemprop="dateCreated datePublished" datetime="2016-12-01T00:00:00+08:00">2016-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-23 13:04:00" itemprop="dateModified" datetime="2021-04-23T13:04:00+08:00">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DataBase/" itemprop="url" rel="index"><span itemprop="name">DataBase</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MySQL数据库设计总结"><a href="#MySQL数据库设计总结" class="headerlink" title="MySQL数据库设计总结"></a>MySQL数据库设计总结</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.qcloud.com/community/article/119">参考文献: MySQL数据库设计总结</a></p>
</blockquote>
<h2 id="常用规则"><a href="#常用规则" class="headerlink" title="常用规则"></a>常用规则</h2><p><strong>规则1</strong>：一般情况可以选择<code>MyISAM</code>存储引擎，如果需要事务支持必须使用<code>InnoDB</code>存储引擎。</p>
<p>注意：<code>MyISAM</code>存储引擎 <code>B-tree索引</code>有一个很大的限制：参与一个<strong>索引的所有字段的长度之和不能超过1000字节</strong>。另外<strong>MyISAM数据和索引是分开</strong>，而<code>InnoDB</code>的数据存储是按<strong>聚簇(cluster)索引有序排列</strong>的，主键是默认的<strong>聚簇(cluster)索引</strong>，因此<code>MyISAM</code>虽然在一般情况下，查询性能比<code>InnoDB</code>高，但<code>InnoDB</code>的以主键为条件的查询性能是非常高的。</p>
<p><strong>规则2</strong>：命名规则。</p>
<ol>
<li>数据库和表名应尽可能和所服务的业务模块名一致</li>
<li>服务与同一个子模块的一类表应尽量以子模块名(或部分单词)为前缀或后缀</li>
<li>表名应尽量包含与所存放数据对应的单词</li>
<li>字段名称也应尽量保持和实际数据相对应</li>
<li>联合索引名称应尽量包含所有索引键字段名或缩写，且各字段名在索引名中的顺序应与索引键在索引中的索引顺序一致，并尽量包含一个类似idx的前缀或后缀，以表明期对象类型是索引。</li>
<li>约束等其他对象也应该尽可能包含所属表或其他对象的名称，以表明各自的关系</li>
</ol>
<p><strong>规则3</strong>：数据库字段类型定义</p>
<ol>
<li>经常需要计算和排序等消耗CPU的字段,应该尽量选择更为迅速的字段，如用<code>TIMESTAMP</code>(4个字节，最小值<code>1970-01-01 00:00:00</code>)代替<code>Datetime</code>（8个字节，最小值<code>1001-01-01 00:00:00</code>）,通过整型替代浮点型和字符型</li>
<li>变长字段使用<code>varchar</code>，不要使用<code>char</code></li>
<li>对于二进制多媒体数据，流水队列数据(如日志)，超大文本数据不要放在数据库字段中</li>
</ol>
<p><strong>规则4</strong>：业务逻辑执行过程必须读到的表中必须要有初始的值。避免业务读出为负或无穷大的值导致程序失败</p>
<p><strong>规则5</strong>：并不需要一定遵守范式理论，适度的冗余，让Query尽量减少Join</p>
<p><strong>规则6</strong>：访问频率较低的大字段拆分出数据表。有些大字段占用空间多，访问频率较其他字段明显要少很多，这种情况进行拆分，频繁的查询中就不需要读取大字段，造成IO资源的浪费。</p>
<p><strong>规则7</strong>：大表可以考虑水平拆分。大表影响查询效率，根据业务特性有很多拆分方式，像根据时间递增的数据，可以根据时间来分。以id划分的数据，可根据id%数据库个数的方式来拆分。</p>
<h2 id="一-数据库索引"><a href="#一-数据库索引" class="headerlink" title="一.数据库索引"></a>一.数据库索引</h2><p><strong>规则8</strong>：业务需要的相关索引是根据实际的设计所构造sql语句的**<em>where条件**</em>来确定的，<br>业务不需要的字段不要建索引，不允许在联合索引（或主键）中存在多余的字段。特别是该字段根本不会在条件语句中出现。</p>
<p><strong>规则9</strong>：唯一确定一条记录的一个字段或多个字段要建立主键或者唯一索引，不能唯一确定一条记录，为了提高查询效率建普通索引</p>
<p><strong>规则10</strong>：业务使用的表，有些记录数很少，甚至只有一条记录，为了<strong>约束</strong>的需要，也要建立索引或者设置主键。</p>
<p><strong>规则11</strong>：对于取值不能重复，经常作为查询条件的字段，应该建唯一索引(主键默认唯一索引)，并且将查询条件中该字段的条件置于第一个位置。没有必要再建立与该字段有关的联合索引。</p>
<p><strong>规则12</strong>：对于经常查询的字段，其<strong>值不唯一</strong>，也应该考虑建立<strong>普通索引</strong>，查询语句中该字段条件置于第一个位置，对联合索引处理的方法同样。</p>
<p><strong>规则13</strong>：业务通过不唯一索引访问数据时，需要考虑通过该索引值返回的记录稠密度，原则上可能的<strong>稠密度最大不能高于0.2</strong>，如果稠密度太大，则不合适建立索引了。</p>
<blockquote>
<p>当通过这个索引查找得到的数据量占到表内所有数据的20%以上时，则需要考虑建立该索引的代价，同时由于索引扫描产生的都是随机I/O，生成效率比全表顺序扫描的顺序I/O低很多。数据库系统优化query的时候有可能不会用到这个索引。</p>
</blockquote>
<p><strong>规则14</strong>：需要联合索引(或联合主键)的数据库要注意索引的顺序。SQL语句中的匹配条件也要跟索引的顺序保持一致。</p>
<p>注意：索引的顺势不正确也可能导致严重的后果。</p>
<p><strong>规则15</strong>：表中的多个字段查询作为查询条件，不含有其他索引，并且字段联合值不重复，可以在这多个字段上建唯一的联合索引，假设索引字段为 (a1,a2,…an),则查询条件<code>(a1 op val1,a2 op val2,...am op valm)m&lt;=n</code>,可以用到索引，查询条件中字段的位置与索引中的字段位置是一致的。</p>
<p><strong>规则16</strong>：联合索引的建立原则(以下均假设在数据库表的字段a,b,c上建立联合索引(<code>a,b,c</code>))</p>
<ol>
<li>联合索引中的字段应尽量满足过滤数据从多到少的顺序，也就是说差异最大的字段应该放在第一个字段</li>
<li>建立索引尽量与SQL语句的条件顺序一致，使SQL语句尽量以整个索引为条件，尽量避免以索引的一部分(特别是首个条件与索引的首个字段不一致时)作为查询的条件</li>
<li><code>Where a=1</code>, <code>where a&gt;=12 and a&lt;15</code>, <code>where a=1 and b&lt;5</code> , <code>where a=1 and b=7 and c&gt;=40</code>为条件可以用到此联合索引；而这些语句<code>where b=10</code>, <code>where c=221</code>, <code>where b&gt;=12 and c=2</code>则无法用到这个联合索引。</li>
<li>当需要查询的数据库字段全部在索引中体现时，数据库可以直接查询索引得到查询信息无须对整个表进行扫描(这就是所谓的key-only)，能大大的提高查询效率。<br>当a，ab，abc与其他表字段关联查询时可以用到索引</li>
<li>当a，ab，abc顺序而不是b，c，bc，ac为顺序执行Order by或者group不要时可以用到索引</li>
<li>以下情况时，进行表扫描然后排序可能比使用联合索引更加有效<ul>
<li>a. 表已经按照索引组织好了</li>
<li>b. 被查询的数据占所有数据的很多比例。</li>
</ul>
</li>
</ol>
<p><strong>规则17</strong>：重要业务访问数据表时。但不能通过索引访问数据时，应该确保顺序访问的记录数目是有限的，原则上不得多于10.</p>
<h2 id="二-Query语句与应用系统优化"><a href="#二-Query语句与应用系统优化" class="headerlink" title="二. Query语句与应用系统优化"></a>二. Query语句与应用系统优化</h2><p><strong>规则18</strong>：合理构造Query语句</p>
<ol>
<li><p>Insert语句中，根据测试，批量一次插入1000条时效率最高，多于1000条时，要拆分，多次进行同样的插入，应该合并批量进行。注意query语句的长度要小于mysqld的参数 max_allowed_packet</p>
</li>
<li><p>查询条件中各种逻辑操作符性能顺序是and,or,in,因此在查询条件中应该尽量避免使用在大集合中使用in</p>
</li>
<li><p>永远用小结果集驱动大记录集，因为在mysql中，只有Nested Join一种Join方式，就是说mysql的join是通过嵌套循环来实现的。通过小结果集驱动大记录集这个原则来减少嵌套循环的循环次数，以减少IO总量及CPU运算次数</p>
</li>
<li><p>尽量优化Nested Join内层循环。</p>
</li>
<li><p>只取需要的columns，尽量不要使用<code>select *</code></p>
</li>
<li><p>仅仅使用最有效的过滤字段，where 字句中的过滤条件少为好</p>
</li>
<li><p>尽量避免复杂的Join和子查询</p>
<p>Mysql在并发这块做得并不是太好，当并发量太高的时候，整体性能会急剧下降，这主要与Mysql内部资源的争用锁定控制有关，<code>MyIsam</code>用表锁，<code>InnoDB</code>好一些用行锁。</p>
</li>
</ol>
<p><strong>规则19</strong>：应用系统的优化</p>
<ol>
<li>合理使用<code>cache</code>，对于变化较少的部分活跃数据通过应用层的<code>cache</code>缓存到内存中，对性能的提升是成数量级的。</li>
<li>对重复执行相同的query进行合并，减少IO次数。</li>
<li>事务相关性最小原则</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/database/mongodb/the-little-mongodb-book/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/database/mongodb/the-little-mongodb-book/" class="post-title-link" itemprop="url">The Little MongoDB Book</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-11-27 08:44:00" itemprop="dateCreated datePublished" datetime="2016-11-27T08:44:00+08:00">2016-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-23 13:04:00" itemprop="dateModified" datetime="2021-04-23T13:04:00+08:00">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NOSQL/" itemprop="url" rel="index"><span itemprop="name">NOSQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/NOSQL/mongodb/mongodb-the-little-mongodb-book.png"></p>
<h1 id="关于本书"><a href="#关于本书" class="headerlink" title="关于本书"></a>关于本书</h1><h2 id="许可"><a href="#许可" class="headerlink" title="许可"></a>许可</h2><p>本书《 The Little MongoDB Book 》基于 Attribution-NonCommercial 3.0 Unported license. <strong>你无须为本书付款。</strong></p>
<p>你可以自由的复制，分发，修改和传阅本书。但请认可该书属于作者 Karl Seguin，并请勿将本书用于任何商业目的。</p>
<p>你可以在以下链接查看完整的许可文档:</p>
<p><a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/3.0/legalcode">http://creativecommons.org/licenses/by-nc/3.0/legalcode</a></p>
<h2 id="关于作者"><a href="#关于作者" class="headerlink" title="关于作者"></a>关于作者</h2><p>Karl Seguin 在多领域有着丰富经验，他是 .NET 和 Ruby 的开发专家。他也参与贡献 OSS 项目, 还是技术文档撰写人而且偶尔做做演讲。MongoDB 方面，他是 C# MongoDB 库 NoRM 的核心开发者，写有互动入门教程 <a target="_blank" rel="noopener" href="http://openmymind.net/mongly/">mongly</a> 和 <a target="_blank" rel="noopener" href="https://github.com/karlseguin/Mongo-Web-Admin">Mongo Web Admin</a>。他用 MongoDB，为休闲游戏开发者写了一个免费服务, <a target="_blank" rel="noopener" href="http://mogade.com/">mogade.com</a>。</p>
<p>Karl 还编写了 <a target="_blank" rel="noopener" href="http://openmymind.net/2012/1/23/The-Little-Redis-Book/">The Little Redis Book</a> <em>1</em></p>
<p>你可以在 <a target="_blank" rel="noopener" href="http://openmymind.net/">http://openmymind.net</a> 找到他的 Blog，或者通过 <a target="_blank" rel="noopener" href="http://twitter.com/karlseguin">@karlseguin</a> 在 Twitter 上关注他。</p>
<h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>特别感谢 <a target="_blank" rel="noopener" href="http://twitter.com/perryneal">Perry Neal</a>, 赐予我你的视野，精神，和热情。你赐予了我无尽的力量。感恩。</p>
<h2 id="最新版本"><a href="#最新版本" class="headerlink" title="最新版本"></a>最新版本</h2><p>最新的版本由 Asya Kamsky 更新到了 MongoDB 2.6 。本书最新代码可以在这里获得:</p>
<p><a target="_blank" rel="noopener" href="http://github.com/karlseguin/the-little-mongodb-book">http://github.com/karlseguin/the-little-mongodb-book</a>.</p>
<h3 id="中文版本"><a href="#中文版本" class="headerlink" title="中文版本"></a>中文版本</h3><p>Karl 在 <a target="_blank" rel="noopener" href="https://github.com/karlseguin/the-little-mongodb-book">the-little-mongodb-book</a> 的 Github 链接中给出了 <a target="_blank" rel="noopener" href="https://github.com/justinyhuang">justinyhuang</a> 的 <a target="_blank" rel="noopener" href="https://github.com/justinyhuang/the-little-mongodb-book-cn">the-little-mongodb-book-cn</a> 链接。但貌似 justinyhuang 并没有同步更新到 MongoDB 2.6 。内容上也和原文稍微有点出入，并且由于本人水平有限，无法提交自信正确的内容。因此重开一项目。如果你被搜索引擎引导到本工程，在此向你致歉，并希望有能力者且有时间者一同完善和同步本工程。你可以通过我的 邮箱 <a href="mailto:&#x67;&#101;&#x6d;&#x69;&#110;&#x69;&#x79;&#101;&#108;&#x6c;&#111;&#119;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;">&#x67;&#101;&#x6d;&#x69;&#110;&#x69;&#x79;&#101;&#108;&#x6c;&#111;&#119;&#64;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;</a> 来联系我，或者通过 <a target="_blank" rel="noopener" href="https://twitter.com/geminiyellow">@geminiyellow</a> 在 Twitter 上关注我。</p>
<p>最新中文版本基于 <a target="_blank" rel="noopener" href="https://github.com/asya999">asya999</a> 在 May 29, 2014 提交的 <a target="_blank" rel="noopener" href="https://github.com/karlseguin/the-little-mongodb-book/pull/38">#38</a> SHA 是：6d4dce8ead6a767e1e8de1b59f714510d36d366f</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>这章那么短不是我的错，MongoDB 就真的很易学。</p>
</blockquote>
<p>都说技术在飞速发展。确实，有接连不断的新技术新方法出现。但是，我一直认为，程序员用到的基础技术的发展却是相当缓慢的。你可以好几年不学习但还能混得下去。令人惊讶的其实是成熟技术的被替换速度。就像在一夜之间，那些长期稳定成熟的技术发现它们不再被开发者关注。</p>
<p>最好的例子就是 NoSQL 技术的发展，以及它对稳定的关系型数据库市场的蚕食。看起来就像，昨天网络还是由 RDBMS 们来驱动的，而今天，就冒出五种左右的 NoSQL 解决案已经证明了它们都是值得拥有的。</p>
<p>虽然这些转变看起来都是一夜之间发生的，实际上他们他们可能花了数年的时间来取得公众的认可。最开始是由一小波开发者和公司在推动。解决方案被不断细化，吸取教训，然后一个新技术就这样诞生了，慢慢的后来者也开始了尝试。再次重申，NoSQL 的许多解决方案并不是为了取代传统的存储方案，而是解决一些特殊需求，填补了传统解决方案的一些空白。</p>
<p>说了那么多，我们第一件应该解决的事情是解释一下什么是 NoSQL。它是一个宽松的概念，不同的人有不同的见解。就个人而言，我通常认为它是数据存储系统的一部分。换而言之，NoSQL (重申, 就我而言)，的好处是让你的持久层不需要一个独立的系统。历史上，传统的关系数据库厂商尝试把他们的产品当作一揽子解决方案，NoSQL 倾向于扮演，在特定的工作中充当最好的工具这种角色。因此，你的 NoSQL 架构中还是可以用到关系型数据库，比如说 MySQL，但是可以也可以用 Redis 作为系统中某部分的持久层，或者是用到 Hadoop 来处理大数据。简而言之，NoSQL 就是需要用开放的可代替的意识，使用现有的或者未来的方式和工具来管理你的数据。</p>
<p>你会想知道，MongoDB 是不是适用于这一切。作为一个面向文档数据库，MongoDB 是最通用的 NoSQL 解决案。它可以看成是关系型数据库的代替方案。和关系型数据库一样，它也可以和其他的 NoSQL 解决案搭配在一起更好的工作。MongoDB 有优点也有缺点，我们将会在本书后面的章节中介绍。</p>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>本书大部分内容将会专注于 MongoDB 的核心功能。我们会用到 MongoDB 的 shell。因为 shell 不但有助于学习，而且还是个很有用的管理工具。实际代码中你需要用到 MongoDB 驱动。</p>
<p>这也引出了关于 MongoDB 你所需要知道的第一件事: 它的驱动。MongoDB 有各种语言的 <a target="_blank" rel="noopener" href="http://docs.mongodb.org/ecosystem/drivers/">官方驱动</a>。这些驱动可以认为是和你所熟悉的各种数据库驱动一样的东西。基于这些驱动，开发社区又创建了更多的语言/框架相关库。比如说，<a target="_blank" rel="noopener" href="https://github.com/atheken/NoRM">NoRM</a> 是一个 C# 语言库，用 LINQ 实现,而 <a target="_blank" rel="noopener" href="https://github.com/jnunemaker/mongomapper">MongoMapper</a> 是一个 Ruby 库，ActiveRecord-friendly。你可以选择直接对 MongoDB 核心进行开发，或选择高级库。之所以要指出，是因为许多新手都觉得迷惑，为什么这里有官方版本和社区版本 - 前者通常关心和 MongoDB 核心的通讯/连接，而后者有更多的语言和框架的实现。</p>
<p>说到这，我希望你可以在 MongoDB 环境中尝试一下我的例子，并且在尝试解决可能遇到的问题。MongoDB 很容易安装和运行，所以让我们花几分钟把所有的东西运行起来。</p>
<ol>
<li><p>先打开 <a target="_blank" rel="noopener" href="http://www.mongodb.org/downloads">官方下载页面</a> ，从你选择的操作系统下面的第一行(推荐稳定版本)下载二进制文件。根据开发实际，你可以选择 32位 或者 64位。</p>
</li>
<li><p>解压缩文件 (随便你放哪) 然后进入 <code>bin</code> 子目录。现在还不要执行任何命令，只要记住 <code>mongod</code> 用来打开服务进程，<code>mongo</code> 打开客户端 shell - 大部分时间我们将要使用这两个命令。</p>
</li>
<li><p>在 <code>bin</code> 子目录下创建一个文本文件，命名为 <code>mongodb.config</code>。</p>
</li>
<li><p>在 mongodb.config 中添加一行: <code>dbpath=PATH_TO_WHERE_YOU_WANT_TO_STORE_YOUR_DATABASE_FILES</code>。比如，在 Windows 你可以写 <code>dbpath=c:\mongodb\data</code> ，在 Linux 可能是 <code>dbpath=/var/lib/mongodb/data</code>。</p>
</li>
<li><p>确保你指定的 <code>dbpath</code> 确实存在。</p>
</li>
<li><p>执行 mongod ，带上参数 <code>--config /path/to/your/mongodb.config</code> 。</p>
</li>
</ol>
<p>以 Windows 用户为例，如果你解压下载文档到 <code>c:\mongodb\</code> ，并且你创建了 <code>c:\mongodb\data\</code> ,那么在 <code>c:\mongodb\bin\mongodb.config</code> 你要指定 <code>dbpath=c:\mongodb\data\</code>。 然后你可以在 CMD 执行 <code>mongod</code> 如下命令行 <code>c:\mongodb\bin\mongod --config c:\mongodb\bin\mongodb.config</code>。</p>
<p>为省心你可以把 <code>bin</code> 文件夹路径添加到环境变量 PATH 中，可以简化命令。MacOSX 和 Linux 用户方法几乎一样。唯一需要改变的是路径。</p>
<p>希望你现在已经可以启动 MongoDB 了。如果出现异常，仔细阅读一下异常信息 - 服务器对异常的解释做得非常好。</p>
<p>现在你可以执行 <code>mongo</code> (没有 <em>d</em>) ，链接 shell 到你的服务器上了。尝试输入 <code>db.version()</code> 来确认所有都正确执行了。你应该能拿到一个已安装的版本号。</p>
<h1 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 - 基础知识"></a>第一章 - 基础知识</h1><p>我们通过学习 MongoDB 的基本工作原理，开始我们的 MongoDB 之旅。当然，这是学习 MongoDB 的核心，它也能帮助我们回答诸如，MongoDB 适用于哪些场景这些更高层次的问题。</p>
<p>开始之前，这有六个简单的概念我们需要了解一下。</p>
<ol>
<li><p>MongoDB中的 <code>database</code> 有着和你熟知的”数据库”一样的概念 (对 Oracle 来说就是 schema)。一个 MongoDB 实例中，可以有零个或多个数据库，每个都作为一个高等容器，用于存储数据。</p>
</li>
<li><p>数据库中可以有零个或多个 <code>collections</code> (集合)。集合和传统意义上的 <code>table</code> 基本一致，你可以简单的把两者看成是一样的东西。</p>
</li>
<li><p>集合是由零个或多个 <code>documents</code> (文档)组成。同样，一个文档可以看成是一 <code>row</code>。</p>
</li>
<li><p>文档是由零个或多个 <code>fields</code> (字段)组成。, 没错，它就是 <code>columns</code>。</p>
</li>
<li><p><code>Indexes</code> (索引)在 MongoDB 中扮演着和它们在 RDBMS 中一样的角色。</p>
</li>
<li><p><code>Cursors</code> (游标)和上面的五个概念都不一样，但是它非常重要，并且经常被忽视，因此我觉得它们值得单独讨论一下。其中最重要的你要理解的一点是，游标是，当你问 MongoDB 拿数据的时候，它会给你返回一个结果集的指针而不是真正的数据，这个指针我们叫它游标，我们可以拿游标做我们想做的任何事情，比如说计数或者跨行之类的，而无需把真正的数据拖下来，在真正的数据上操作。</p>
</li>
</ol>
<p>综上，MongoDB 是由包含 <code>collections</code> 的 <code>databases</code> 组成的。而 <code>collection</code> 是由 <code>documents</code>组成。每个 <code>document</code> 是由 <code>fields</code> 组成。 <code>Collections</code> 可以被 <code>indexed</code>，以便提高查找和排序的性能。最后，当我们从 MongoDB 获取数据的时候，我们通过 <code>cursor</code> 来操作，读操作会被延迟到需要实际数据的时候才会执行。</p>
<p>那为什么我们需要新的术语(collection vs. table, document vs. row and field vs. column)？为了让看起来更复杂点？事实上，虽然这些概念和关系型数据中的概念类似，但是还是有差异的。核心差异在于，关系型数据库是在 <code>table</code> 上定义的 <code>columns</code>，而面向文档数据库是在 <code>document</code> 上定义的 <code>fields</code>。也就是说，在 <code>collection</code> 中的每个 <code>document</code> 都可以有它自己独立的 <code>fields</code>。因此，对于 <code>collection</code> 来说是个简化了的 <code>table</code> ，但是一个 <code>document</code> 却比一 <code>row</code> 有更多的信息。</p>
<p>虽然这些概念很重要，但是如果现在搞不明白也不要紧。多插几条数据就明白上面说的到底是什么意思了。反正，要点就是，集合不对存储内容严格限制 (所谓的无模式(schema-less))。字段由每个独立的文档进行跟踪处理。这样做的优点和缺点将在下面章节一一讨论。</p>
<p>好了我们开始吧。如果你还没有运行 MongoDB，那么快去运行 <code>mongod</code> 服务和开启 mongo shell。shell 用的是 JavaScript。你可以试试一些全局命令，比如 <code>help</code> 或者 <code>exit</code>。如果要操作当前数据库，用 <code>db</code> ，比如 <code>db.help()</code> 或者 <code>db.stats()</code>。如果要操作指定集合，大多数情况下我们会操作集合而不是数据库，用 <code>db.COLLECTION_NAME</code> ，比如 <code>db.unicorns.help()</code> 或者 <code>db.unicorns.count()</code>。</p>
<p>我们继续，输入 <code>db.help()</code>，就能拿到一个对 <code>db</code> 能执行的所有的命令的列表。</p>
<p>顺便说一句:因为这是一个 JavaScript shell，如果你输入的命令漏了 <code>()</code>，你会看到这个命令的源码，而不是执行这个命令。我提一下，是为了避免你执行漏了括号的命令，拿到一个以 <code>function (...)&#123;</code> 开头的返回的时候，觉得神奇不可思议。比如说，如果你输入 <code>db.help</code> (不带括号), 你会看到 <code>help</code> 方法的内部实现。</p>
<p>首先我们用全局的 <code>use</code> 来切换数据库，继续，输入 <code>use learn</code>。这个数据库实际存在与否完全没有关系。我们在里面生成集合的时候， <code>learn</code> 数据库会自动建起来。现在，我们在一个数据库里面了，你可以开始尝试一下数据库命令，比如 <code>db.getCollectionNames()</code>。执行之后，你会得到一个空数组 (<code>[ ]</code>)。因为集合是无模式的，我们不需要特地去配置它。我们可以简单的插入一个文档到一个新的集合。像这样，我们用 <code>insert</code> 命令，在文档中插入:</p>
<pre><code>db.unicorns.insert(&#123;name: &#39;Aurora&#39;,
    gender: &#39;f&#39;, weight: 450&#125;)</code></pre>
<p>这行命令对集合 <code>unicorns</code> 执行了 <code>insert</code> 命令，并传入一个参数。MongoDB 内部用二进制序列化 JSON 格式，称为 BSON。外部，也就是说我们多数情况应该用 JSON，就像上面的参数一样。然后我们执行 <code>db.getCollectionNames()</code> ，我们将能拿到两个集合: <code>unicorns</code> 和 <code>system.indexes</code>。在每个数据库中都会有一个 <code>system.indexes</code> 集合，用来保存我们数据的的索引信息。</p>
<p>你现在可以对用 <code>unicorns</code> 执行 <code>find</code> 命令，然后返回文档列表:</p>
<pre><code>db.unicorns.find()</code></pre>
<p>请注意，除你指定的字段之外，会多出一个 <code>_id</code> 字段。每个文档都会有一个唯一 <code>_id</code> 字段。你可以自己生成一个，或者让 MongoDB 帮你生成一个 <code>ObjectId</code> 类型的。多数情况下，你会乐意让 MongoDB 帮你生成的。默认的 <code>_id</code> 字段是已被索引的 - 这就说明了为什么会有 <code>system.indexes</code> 集合。你可以看看 <code>system.indexes</code>:</p>
<pre><code>db.system.indexes.find()</code></pre>
<p>你可以看到索引的名字，被索引的数据库和集合，以及在索引中的字段。</p>
<p>现在，回到我们关于数组无模式的讨论中来。往 <code>unicorns</code> 插入一个完全不同的文档，比如:</p>
<pre><code>db.unicorns.insert(&#123;name: &#39;Leto&#39;,
    gender: &#39;m&#39;,
    home: &#39;Arrakeen&#39;,
    worm: false&#125;)</code></pre>
<p>然后，再用 <code>find</code> 列出文档。等我们理解再深入一点的时候，将会讨论一下 MongoDB 的有趣行为。到这里，我希望你开始理解，为什么那些传统的术语在这里不适用了。</p>
<h2 id="掌握选择器-Selector"><a href="#掌握选择器-Selector" class="headerlink" title="掌握选择器(Selector)"></a>掌握选择器(Selector)</h2><p>除了我们介绍过的六个概念，在开始讨论更深入的话题之前，MongoDB 还有一个应该掌握的实用概念:查询选择器。MongoDB 的查询选择器就像 SQL 语句里面的 <code>where</code> 一样。因此，你会在对集合的文档做查找，计数，更新，删除的时候用到它。选择器是一个 JSON 对象，最简单的是就是用 <code>&#123;&#125;</code> 匹配所有的文档。如果我们想找出所有母独角兽，我们可以用 <code>&#123;gender:&#39;f&#39;&#125;</code>。</p>
<p>开始深入学习选择器之前，让我们先做些准备。首先，把刚才我们插入 <code>unicorns</code> 集合的数据删除，通过: <code>db.unicorns.remove(&#123;&#125;)</code>。现在，再插入一些用来演示的数据 (你不会手打吧):</p>
<pre><code>db.unicorns.insert(&#123;name: &#39;Horny&#39;,
    dob: new Date(1992,2,13,7,47),
    loves: [&#39;carrot&#39;,&#39;papaya&#39;],
    weight: 600,
    gender: &#39;m&#39;,
    vampires: 63&#125;);
db.unicorns.insert(&#123;name: &#39;Aurora&#39;,
    dob: new Date(1991, 0, 24, 13, 0),
    loves: [&#39;carrot&#39;, &#39;grape&#39;],
    weight: 450,
    gender: &#39;f&#39;,
    vampires: 43&#125;);
db.unicorns.insert(&#123;name: &#39;Unicrom&#39;,
    dob: new Date(1973, 1, 9, 22, 10),
    loves: [&#39;energon&#39;, &#39;redbull&#39;],
    weight: 984,
    gender: &#39;m&#39;,
    vampires: 182&#125;);
db.unicorns.insert(&#123;name: &#39;Roooooodles&#39;,
    dob: new Date(1979, 7, 18, 18, 44),
    loves: [&#39;apple&#39;],
    weight: 575,
    gender: &#39;m&#39;,
    vampires: 99&#125;);
db.unicorns.insert(&#123;name: &#39;Solnara&#39;,
    dob: new Date(1985, 6, 4, 2, 1),
    loves:[&#39;apple&#39;, &#39;carrot&#39;,
        &#39;chocolate&#39;],
    weight:550,
    gender:&#39;f&#39;,
    vampires:80&#125;);
db.unicorns.insert(&#123;name:&#39;Ayna&#39;,
    dob: new Date(1998, 2, 7, 8, 30),
    loves: [&#39;strawberry&#39;, &#39;lemon&#39;],
    weight: 733,
    gender: &#39;f&#39;,
    vampires: 40&#125;);
db.unicorns.insert(&#123;name:&#39;Kenny&#39;,
    dob: new Date(1997, 6, 1, 10, 42),
    loves: [&#39;grape&#39;, &#39;lemon&#39;],
    weight: 690,
    gender: &#39;m&#39;,
    vampires: 39&#125;);
db.unicorns.insert(&#123;name: &#39;Raleigh&#39;,
    dob: new Date(2005, 4, 3, 0, 57),
    loves: [&#39;apple&#39;, &#39;sugar&#39;],
    weight: 421,
    gender: &#39;m&#39;,
    vampires: 2&#125;);
db.unicorns.insert(&#123;name: &#39;Leia&#39;,
    dob: new Date(2001, 9, 8, 14, 53),
    loves: [&#39;apple&#39;, &#39;watermelon&#39;],
    weight: 601,
    gender: &#39;f&#39;,
    vampires: 33&#125;);
db.unicorns.insert(&#123;name: &#39;Pilot&#39;,
    dob: new Date(1997, 2, 1, 5, 3),
    loves: [&#39;apple&#39;, &#39;watermelon&#39;],
    weight: 650,
    gender: &#39;m&#39;,
    vampires: 54&#125;);
db.unicorns.insert(&#123;name: &#39;Nimue&#39;,
    dob: new Date(1999, 11, 20, 16, 15),
    loves: [&#39;grape&#39;, &#39;carrot&#39;],
    weight: 540,
    gender: &#39;f&#39;&#125;);
db.unicorns.insert(&#123;name: &#39;Dunx&#39;,
    dob: new Date(1976, 6, 18, 18, 18),
    loves: [&#39;grape&#39;, &#39;watermelon&#39;],
    weight: 704,
    gender: &#39;m&#39;,
    vampires: 165&#125;);</code></pre>
<p>现在我们有数据了，我们可以开始来学习掌握选择器了。<code>&#123;field: value&#125;</code> 用来查找那些 <code>field</code> 的值等于 <code>value</code> 的文档。 <code>&#123;field1: value1, field2: value2&#125;</code> 相当于 <code>and</code> 查询。还有 <code>$lt</code>, <code>$lte</code>, <code>$gt</code>, <code>$gte</code> 和 <code>$ne</code> 被用来处理 小于，小于等于，大于，大于等于，和不等于操作。比如，获取所有体重大于700磅的公独角兽，我们可以这样:</p>
<pre><code>db.unicorns.find(&#123;gender: &#39;m&#39;,
    weight: &#123;$gt: 700&#125;&#125;)
//or (not quite the same thing, but for
//demonstration purposes)
db.unicorns.find(&#123;gender: &#123;$ne: &#39;f&#39;&#125;,
    weight: &#123;$gte: 701&#125;&#125;)</code></pre>
<p><code>$exists</code> 用来匹配字段是否存在，比如:</p>
<pre><code>db.unicorns.find(&#123;
    vampires: &#123;$exists: false&#125;&#125;)</code></pre>
<p>会返回一条文档。’$in’ 被用来匹配查询文档在我们传入的数组参数中是否存在匹配值，比如:</p>
<pre><code>db.unicorns.find(&#123;
    loves: &#123;$in:[&#39;apple&#39;,&#39;orange&#39;]&#125;&#125;)</code></pre>
<p>会返回那些喜欢 <code>apple</code> 或者 <code>orange</code> 的独角兽。</p>
<p>如果我们想要 OR 而不是 AND 来处理选择条件的话，我们可以用 <code>$or</code> 操作符，再给它一个我们要匹配的数组:</p>
<pre><code>db.unicorns.find(&#123;gender: &#39;f&#39;,
    $or: [&#123;loves: &#39;apple&#39;&#125;,
          &#123;weight: &#123;$lt: 500&#125;&#125;]&#125;)</code></pre>
<p>上面的查询会返回那些喜欢 <code>apples</code> 或者 <code>weigh</code> 小于500磅的母独角兽。</p>
<p>在我们最后两个例子里面有个非常赞的特性。你应该已经注意到了，<code>loves</code> 字段是个数组。MongoDB 允许数组作为基本对象(first class objects)处理。这是个令人难以置信的超赞特性。一旦你开始用它，你都不知道没了它你怎么活下去了。最有趣的是，基于数组的查询变得非常简单: <code>&#123;loves: &#39;watermelon&#39;&#125;</code> 会把文档中 <code>loves</code> 中有 <code>watermelon</code> 的值全部查询出来。</p>
<p>除了我们介绍的这些，还有更多可用的操作。所有这些都记载在 MongoDB 手册上的 <a target="_blank" rel="noopener" href="http://docs.mongodb.org/manual/reference/operator/query/#query-selectors">Query Selectors</a> 这一章。我们介绍的仅仅是那些你学习时所需要用到的，同时也是你最经常用到的操作。</p>
<p>我们已经学习了选择器是如何配合 <code>find</code> 命令使用的了。还大致介绍了一下如何配合 <code>remove</code> 命令使用，<code>count</code> 命令虽然没介绍，不过你肯定知道应该怎么做，而 <code>update</code> 命令，之后我们会花多点时间来详细学习它。</p>
<p>MongoDB 为我们的 <code>_id</code> 字段生成的 <code>ObjectId</code> 可以这样查询:</p>
<pre><code>db.unicorns.find(
    &#123;_id: ObjectId(&quot;TheObjectId&quot;)&#125;)</code></pre>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们还没有看到 <code>update</code> , 或是能拿来做更华丽事情的 <code>find</code>。不过，我们已经安装好 MongoDB 并运行起来了, 简略的介绍了一下 <code>insert</code> 和 <code>remove</code> 命令 (完整版也没比我们介绍的多什么)。 我们还介绍了 <code>find</code> 以及了解了 MongoDB <code>selectors</code> 是怎么一回事。 我们起了个很好的头，并为以后的学习奠定了坚实基础。 信不信由你，其实你已经掌握了学习 MongoDB 所必须的大多数知识 - 它真的是易学易用。 我强烈建议你在继续学习之前在本机上多试试多玩玩。 插入不同的文档，可以试试看在不同的集合中，习惯一下使用不同的选择器。试试 <code>find</code>, <code>count</code> 和 <code>remove</code>。 多试几次之后，你会发现原来看起来那么格格不入的东西，用起来居然水到渠成。</p>
<h1 id="第二章-更新"><a href="#第二章-更新" class="headerlink" title="第二章 - 更新"></a>第二章 - 更新</h1><p>在第一章，我们介绍了 CRUD 的四分之三(create, read, update 和 delete) 操作。这章，我们来专门来讨论我们跳过的那个操作: <code>update</code>。 <code>Update</code> 有些独特的行为，这是为什么我们把它独立成章。</p>
<h2 id="Update-覆盖还是-set"><a href="#Update-覆盖还是-set" class="headerlink" title="Update: 覆盖还是 $set"></a>Update: 覆盖还是 $set</h2><p>最简单的情况， <code>update</code> 有两个参数: 选择器 (<code>where</code>) 和需要更新字段的内容。假设 Roooooodles 长胖了，你会希望我们这样操作:</p>
<pre><code>db.unicorns.update(&#123;name: &#39;Roooooodles&#39;&#125;,
    &#123;weight: 590&#125;)</code></pre>
<p>(如果你已经把 <code>unicorns</code> 集合玩坏了，它已经不是原来的数据了的话，再执行一次 <code>remove</code> 删除所有数据，然后重新插入第一章中所有的代码。)</p>
<p>现在，如果你查一下被更新了的记录:</p>
<pre><code>db.unicorns.find(&#123;name: &#39;Roooooodles&#39;&#125;)</code></pre>
<p>你会发现 <code>update</code> 的第一个惊喜，没找到任何文档。因为我们指定的第二个参数没有使用任何的更新选项，因此，它 <strong>replace</strong> 了原始文档。也就是说， <code>update</code> 先根据 <code>name</code> 找到一个文档，然后用新文档(第二个参数)覆盖替换了整个文档。这和 SQL 的 <code>update</code> 命令的完全不一样。在某些情况下，这非常理想，可以用于某些完全动态更新上。但是，如果你只希望改变一个或者几个字段的值的时候，你应该用 MongoDB 的 <code>$set</code> 操作。继续，让我们来更新重置这个丢失的数据:</p>
<pre><code>db.unicorns.update(&#123;weight: 590&#125;, &#123;$set: &#123;
    name: &#39;Roooooodles&#39;,
    dob: new Date(1979, 7, 18, 18, 44),
    loves: [&#39;apple&#39;],
    gender: &#39;m&#39;,
    vampires: 99&#125;&#125;)</code></pre>
<p>这里不会覆盖新字段 <code>weight</code> 因为我们没有指定它。现在让我们来执行:</p>
<pre><code>db.unicorns.find(&#123;name: &#39;Roooooodles&#39;&#125;)</code></pre>
<p>我们拿到了期待的结果。因此，在最开始的时候，我们正确的更新 weight 的方式应该是:</p>
<pre><code>db.unicorns.update(&#123;name: &#39;Roooooodles&#39;&#125;,
    &#123;$set: &#123;weight: 590&#125;&#125;)</code></pre>
<h2 id="Update-操作符"><a href="#Update-操作符" class="headerlink" title="Update 操作符"></a>Update 操作符</h2><p>除了 <code>$set</code>，我们还可以用其他的更新操作符做些有意思的事情。所有的更新操作都是对字段起作用 - 所以你不用担心整个文档被删掉。比如，<code>$inc</code> 可以用来给一个字段增加一个正/负值。假设说 Pilot 获得了非法的两个 vampire kills 点，我们可以这样修正它:</p>
<pre><code>db.unicorns.update(&#123;name: &#39;Pilot&#39;&#125;,
    &#123;$inc: &#123;vampires: -2&#125;&#125;)</code></pre>
<p>假设 Aurora 忽然长牙了，我们可以给她的 <code>loves</code> 字段加一个值，通过 <code>$push</code> 操作:</p>
<pre><code>db.unicorns.update(&#123;name: &#39;Aurora&#39;&#125;,
    &#123;$push: &#123;loves: &#39;sugar&#39;&#125;&#125;)</code></pre>
<p>MongoDB 手册的 <a target="_blank" rel="noopener" href="http://docs.mongodb.org/manual/reference/operator/update/#update-operators">Update Operators</a> 这章，可以查到更多可用的更新操作符的信息。</p>
<h2 id="Upserts"><a href="#Upserts" class="headerlink" title="Upserts"></a>Upserts</h2><p>用 <code>update</code> 还有一个最大的惊喜，就是它完全支持 <code>upserts</code>。所谓 <code>upsert</code> 更新，即在文档中找到匹配值时更新它，无匹配时向文档插入新值，你可以这样理解。要使用 upsert 我们需要向 update 写入第三个参数 <code>&#123;upsert:true&#125;</code>。</p>
<p>一个最常见的例子是网站点击计数器。如果我们想保存一个实时点击总数，我们得先看看是否在页面上已经有点击记录，然后基于此再决定执行更新或者插入操作。如果省略 upsert 选项(或者设为 false)，执行下面的操作不会带来任何变化:</p>
<pre><code>db.hits.update(&#123;page: &#39;unicorns&#39;&#125;,
    &#123;$inc: &#123;hits: 1&#125;&#125;);
db.hits.find();</code></pre>
<p>但是，如果我们加上 upsert 选项，结果会大不同:</p>
<pre><code>db.hits.update(&#123;page: &#39;unicorns&#39;&#125;,
    &#123;$inc: &#123;hits: 1&#125;&#125;, &#123;upsert:true&#125;);
db.hits.find();</code></pre>
<p>由于没有找到字段 <code>page</code> 值为 <code>unicorns</code>的文档，一个新的文档被生成插入。当我们第二次执行这句命令的时候，这个既存的文档将会被更新，且 <code>hits</code> 会被增加到 2。</p>
<pre><code>db.hits.update(&#123;page: &#39;unicorns&#39;&#125;,
    &#123;$inc: &#123;hits: 1&#125;&#125;, &#123;upsert:true&#125;);
db.hits.find();</code></pre>
<h2 id="批量-Updates"><a href="#批量-Updates" class="headerlink" title="批量 Updates"></a>批量 Updates</h2><p>关于 <code>update</code> 的最后一个惊喜，默认的，它只更新单个文档。到目前为止，我们的所有例子，看起来都挺符合逻辑的。但是，如果你执行一些像这样的操作的时候:</p>
<pre><code>db.unicorns.update(&#123;&#125;,
    &#123;$set: &#123;vaccinated: true &#125;&#125;);
db.unicorns.find(&#123;vaccinated: true&#125;);</code></pre>
<p>你肯定会希望，你所有的宝贝独角兽都被接种疫苗了。为了达到这个目的， <code>multi</code> 选项需要设为 true:</p>
<pre><code>db.unicorns.update(&#123;&#125;,
    &#123;$set: &#123;vaccinated: true &#125;&#125;,
    &#123;multi:true&#125;);
db.unicorns.find(&#123;vaccinated: true&#125;);</code></pre>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>本章中我们介绍了集合的基本 CRUD 操作。我们详细讲解了 <code>update</code> 及它的三个有趣的行为。 首先，如果你传 MongoDB 一个文档但是不带更新操作, MongoDB 的 <code>update</code> 会默认替换现有文档。因此，你通常要用到 <code>$set</code> 操作 (或者其他各种可用的用于修改文档的操作)。 其次， <code>update</code> 支持 <code>upsert</code> 操作，当你不知道文档是否存在的时候，非常有用。 最后，默认情况下， <code>update</code> 只更新第一个匹配文档，因此当你希望更新所有匹配文档时，你要用 <code>multi</code> 。</p>
<h1 id="第三章-掌握查询"><a href="#第三章-掌握查询" class="headerlink" title="第三章 - 掌握查询"></a>第三章 - 掌握查询</h1><p>在第一章中我们对 <code>find</code> 命令做了一个初步的了解。除了 <code>selectors</code> 以外 <code>find</code> 还有更丰富的功能。我们已经说过，<code>find</code> 返回的结果是一个 <code>cursor</code>。我们将进一步看看它到底是什么意思。</p>
<h2 id="字段选择"><a href="#字段选择" class="headerlink" title="字段选择"></a>字段选择</h2><p>在开始 <code>cursors</code> 的话题之前，你应该知道 <code>find</code> 有第二个可选参数，叫做 “projection”。这个参数是我们要检索或者排除字段的列表。比如，我们可以仅查询返回独角兽的名字而不带别的字段:</p>
<pre><code>db.unicorns.find(&#123;&#125;, &#123;name: 1&#125;);</code></pre>
<p>默认的，<code>_id</code> 字段总是会返回的。我们可以通过这样显式的把它从返回结果中排除 <code>&#123;name:1, _id: 0&#125;</code>。</p>
<p>除了 <code>_id</code> 字段，你不能把检索和排除混合使用。仔细想想，这是有道理的。你只能显式的检索或者排除某些字段。</p>
<h2 id="排序-Ordering"><a href="#排序-Ordering" class="headerlink" title="排序(Ordering)"></a>排序(Ordering)</h2><p>到目前位置我已经提到好多次， <code>find</code> 返回的是一个游标，它只有在需要的时候才会执行。但是，你在 shell 中看确实到的是 <code>find</code> 被立刻执行了。这只是 shell 的行为。 我们可以通过一个 <code>find</code> 的链式方法，观察到 <code>cursors</code> 的真正行为。我们来看看 <code>sort</code>。我们指定我们希望排序的字段，以 JSON 方式，其中 1 表示升序 -1 表示降序。比如:</p>
<pre><code>//heaviest unicorns first
db.unicorns.find().sort(&#123;weight: -1&#125;)

//by unicorn name then vampire kills:
db.unicorns.find().sort(&#123;name: 1,
    vampires: -1&#125;)</code></pre>
<p>就像关系型数据库那样，MongoDB 允许对索引进行排序。我们再稍后将详细讨论索引。那，你应该知道的是，MongoDB 对未经索引的字段进行排序是有大小限制的。就是说，如果你试图对一个非常大的没有经过索引的结果集进行排序的话，你会得到个异常。有些人认为这是一个缺点。说实话，我是多希望更多的数据库可以有这种能力去拒绝未经优化的查询。(我不是把每个 MongoDB 的缺点硬说成优点，但是我已经看够了那些缺乏优化的数据库了，我真心希望他们能有一个 strict-mode。)</p>
<h2 id="分页-Paging"><a href="#分页-Paging" class="headerlink" title="分页(Paging)"></a>分页(Paging)</h2><p>对结果分页可以通过 <code>limit</code> 和 <code>skip</code> 游标方法来实现。比如要获取第二和第三重的独角兽，我们可以这样:</p>
<pre><code>db.unicorns.find()
    .sort(&#123;weight: -1&#125;)
    .limit(2)
    .skip(1)</code></pre>
<p>通过 <code>limit</code> 和 <code>sort</code> 的配合，可以在对非索引字段进行排序时避免引起问题。</p>
<h2 id="计数-Count"><a href="#计数-Count" class="headerlink" title="计数(Count)"></a>计数(Count)</h2><p>shell 中可以直接对一个集合执行 <code>count</code> ，像这样:</p>
<pre><code>db.unicorns.count(&#123;vampires: &#123;$gt: 50&#125;&#125;)</code></pre>
<p>实际上，<code>count</code> 是一个 <code>cursor</code> 的方法，shell 只是简单的提供了一个快捷方式。以不提供快捷方式的方法来执行的时候需要这样(在 shell 中同样可以执行):</p>
<pre><code>db.unicorns.find(&#123;vampires: &#123;$gt: 50&#125;&#125;)
    .count()</code></pre>
<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><p>使用 <code>find</code> 和 <code>cursors</code> 非常简单。还讲了一些我们后面章节会用到的或是非常特殊情况才用的命令，不过不管怎样，现在，你应该已经非常熟练使用 mongo shell 以及理解 MongoDB 的基本原则了。</p>
<h1 id="第四章-数据建模"><a href="#第四章-数据建模" class="headerlink" title="第四章 - 数据建模"></a>第四章 - 数据建模</h1><p>让我们换换思维，对 MongoDB 进行一个更抽象的理解。介绍一些新的术语和一些新的语法是非常容易的。而要接受一个以新的范式来建模，是相当不简单的。事实是，当用新技术进行建模的时候，我们中的许多人还在找什么可用的什么不可用。在这里我们只是开始新的开端，而最终你需要去在实战中练习和学习。</p>
<p>与大多数 NoSQL 数据库相比，面向文档型数据库和关系型数据库很相似 - 至少，在建模上是这样的。但是，不同点非常重要。</p>
<h2 id="No-Joins"><a href="#No-Joins" class="headerlink" title="No Joins"></a>No Joins</h2><p>你需要适应的第一个，也是最根本的区别就是 mongoDB 没有链接(join) 。我不知道 MongoDB 中不支持链接的具体原因，但是我知道链接基本上意味着不可扩展。就是说，一旦你把数据水平扩展，无论如何你都要放弃在客户端(应用服务器)使用链接。事实就是，数据 <em>有</em> 关系, 但 MongoDB 不支持链接。</p>
<p>没别的办法，为了在无连接的世界生存下去，我们只能在我们的应用代码中自己实现链接。我们需要进行二次查询 <code>find</code> ，把相关数据保存到另一个集合中。我们设置数据和在关系型数据中声明一个外键没什么区别。先不管我们那美丽的 <code>unicorns</code> 了，让我们来看看我们的 <code>employees</code>。 首先我们来创建一个雇主 (我提供了一个明确的 <code>_id</code> ，这样我们就可以和例子作成一样)</p>
<pre><code>db.employees.insert(&#123;_id: ObjectId(
    &quot;4d85c7039ab0fd70a117d730&quot;),
    name: &#39;Leto&#39;&#125;)</code></pre>
<p>然后让我们加几个工人，把他们的管理者设置为 <code>Leto</code>:</p>
<pre><code>db.employees.insert(&#123;_id: ObjectId(
    &quot;4d85c7039ab0fd70a117d731&quot;),
    name: &#39;Duncan&#39;,
    manager: ObjectId(
    &quot;4d85c7039ab0fd70a117d730&quot;)&#125;);
db.employees.insert(&#123;_id: ObjectId(
    &quot;4d85c7039ab0fd70a117d732&quot;),
    name: &#39;Moneo&#39;,
    manager: ObjectId(
    &quot;4d85c7039ab0fd70a117d730&quot;)&#125;);</code></pre>
<p>(有必要再重复一次， <code>_id</code> 可以是任何形式的唯一值。因为你很可能在实际中使用 <code>ObjectId</code> ，我们也在这里用它。)</p>
<p>当然，要找出 Leto 的所有工人，只需要执行:</p>
<pre><code>db.employees.find(&#123;manager: ObjectId(
    &quot;4d85c7039ab0fd70a117d730&quot;)&#125;)</code></pre>
<p>这没什么神奇的。在最坏的情况下，大多数的时间，为弥补无链接所做的仅仅是增加一个额外的查询(可能是被索引的)。</p>
<h2 id="数组和内嵌文档"><a href="#数组和内嵌文档" class="headerlink" title="数组和内嵌文档"></a>数组和内嵌文档</h2><p>MongoDB 不支持链接不意味着它没优势。还记得我们说过 MongoDB 支持数组作为文档中的基本对象吗？这在处理多对一(many-to-one)或者多对多(many-to-many)的关系的时候非常方便。举个简单的例子，如果一个工人有两个管理者，我们只需要像这样存一下数组:</p>
<pre><code>db.employees.insert(&#123;_id: ObjectId(
    &quot;4d85c7039ab0fd70a117d733&quot;),
    name: &#39;Siona&#39;,
    manager: [ObjectId(
    &quot;4d85c7039ab0fd70a117d730&quot;),
    ObjectId(
    &quot;4d85c7039ab0fd70a117d732&quot;)] &#125;)</code></pre>
<p>有趣的是，对于某些文档，<code>manager</code> 可以是单个不同的值，而另外一些可以是数组。而我们原来的 <code>find</code> 查询依旧可用:</p>
<pre><code>db.employees.find(&#123;manager: ObjectId(
    &quot;4d85c7039ab0fd70a117d730&quot;)&#125;)</code></pre>
<p>你会很快就发现，数组中的值比多对多链接表(many-to-many join-tables)要容易处理得多。</p>
<p>数组之外，MongoDB 还支持内嵌文档。来试试看向文档插入一个内嵌文档，像这样:</p>
<pre><code>db.employees.insert(&#123;_id: ObjectId(
    &quot;4d85c7039ab0fd70a117d734&quot;),
    name: &#39;Ghanima&#39;,
    family: &#123;mother: &#39;Chani&#39;,
        father: &#39;Paul&#39;,
        brother: ObjectId(
    &quot;4d85c7039ab0fd70a117d730&quot;)&#125;&#125;)</code></pre>
<p>像你猜的那样，内嵌文档可以用 dot-notation 查询:</p>
<pre><code>db.employees.find(&#123;
    &#39;family.mother&#39;: &#39;Chani&#39;&#125;)</code></pre>
<p>我们只简单的介绍一下内嵌文档适用情况，以及你怎么使用它们。</p>
<p>结合两个概念，我们甚至可以内嵌文档数组:</p>
<pre><code>db.employees.insert(&#123;_id: ObjectId(
    &quot;4d85c7039ab0fd70a117d735&quot;),
    name: &#39;Chani&#39;,
    family: [ &#123;relation:&#39;mother&#39;,name: &#39;Chani&#39;&#125;,
        &#123;relation:&#39;father&#39;,name: &#39;Paul&#39;&#125;,
        &#123;relation:&#39;brother&#39;, name: &#39;Duncan&#39;&#125;]&#125;)</code></pre>
<h2 id="反规范化-Denormalization"><a href="#反规范化-Denormalization" class="headerlink" title="反规范化(Denormalization)"></a>反规范化(Denormalization)</h2><p>另外一个代替链接的方案是对你的数据做反规范化处理(denormalization)。从历史角度看，反规范化处理是为了解决那些对性能敏感的问题，或是需要做快照的数据(比如说审计日志)。但是，随着日益增长的普及的 NoSQL，对链接的支持的日益丧失，反规范化作为规范化建模的一部分变得越来越普遍了。这不意味着，应该对你文档里的每条数据都做冗余处理。而是说，与其对冗余数据心存恐惧，让它影响你的设计决策，不如在建模的时候考虑什么信息应当属于什么文档。</p>
<p>比如说，假设你要写一个论坛应用。传统的方式是通过 <code>posts</code> 中的 <code>userid</code> 列，来关联一个特定的 <code>user</code> 和一篇 <code>post</code> 。这样的建模，你没法在显示 <code>posts</code> 的时候不查询 (链接到) <code>users</code>。一个代替案是简单的在每篇 <code>post</code> 中把 <code>name</code> 和 <code>userid</code> 一起保存。你可能要用到内嵌文档，比如 <code>user: &#123;id: ObjectId(&#39;Something&#39;), name: &#39;Leto&#39;&#125;</code>。是的，如果你让用户可以更新他们的名字，那么你得对所有的文档都进行更新(一个多重更新)。</p>
<p>适应这种方法不是对任何人都那么简单的。很多情况下这样做甚至是无意义的。不过不要害怕去尝试。它只是在某些情况下不适用而已，但在某些情况下是最好的解决方法。</p>
<h2 id="你的选择是？"><a href="#你的选择是？" class="headerlink" title="你的选择是？"></a>你的选择是？</h2><p>在处理一对多(one-to-many)或者多对多(many-to-many)场景的时候，id 数组通常是一个正确的选择。但通常，新人开发者在面对内嵌文档和 “手工” 引用时，左右为难。</p>
<p>首先，你应该知道的是，一个独立文档的大小当前被限制在 16MB 。知道了文档的大小限制，挺宽裕的，对你考虑怎么用它多少有些影响。在这点上，看起来大多数开发者都愿意手工维护数据引用关系。内嵌文档经常被用到，大多数情况下多是很小的数据块，那些总是被和父节点一起拉取的数据块。现实的例子是为每个用户保存一个 <code>addresses</code> ，看起来像这样:</p>
<pre><code>db.users.insert(&#123;name: &#39;leto&#39;,
    email: &#39;leto@dune.gov&#39;,
    addresses: [&#123;street: &quot;229 W. 43rd St&quot;,
                city: &quot;New York&quot;, state:&quot;NY&quot;,zip:&quot;10036&quot;&#125;,
               &#123;street: &quot;555 University&quot;,
                city: &quot;Palo Alto&quot;, state:&quot;CA&quot;,zip:&quot;94107&quot;&#125;]&#125;)</code></pre>
<p>这并不意味着你要低估内嵌文档的能力，或者仅仅把他们当成小技巧。把你的数据模型直接映射到你的对象，这会使得问题更简单，并且通常也不需要用到链接了。尤其是，当你考虑到 MongoDB 允许你对内嵌文档和数组的字段进行查询和索引时，效果特别明显。</p>
<h2 id="大而全还是小而专的集合？"><a href="#大而全还是小而专的集合？" class="headerlink" title="大而全还是小而专的集合？"></a>大而全还是小而专的集合？</h2><p>由于对集合没做任何的强制要求，完全可以在系统中用一个混合了各种文档的集合，但这绝对是个非常烂的主意。大多数 MongoDB 系统都采用了和关系型数据库类似的结构，分成几个集合。换而言之，如果在关系型数据库中是一个表，那么在 MongoDB 中会被作成一个集合 (many-to-many join tables being an important exception as well as tables that exist only to enable one to many relationships with simple entities)。</p>
<p>当你把内嵌文档考虑进来的时候，这个话题会变的更有趣。常见的例子就是博客。你是应该分成一个 <code>posts</code> 集合和一个 <code>comments</code> 集合呢，还是应该每个 <code>post</code> 下面嵌入一个 <code>comments</code> 数组？ 先不考虑那个 16MB 文档大小限制 ( <em>哈姆雷特</em> 全文也没超过 200KB，所以你的博客是有多人气？)，许多开发者都喜欢把东西划分开来。这样更简洁更明确，给你更好的性能。MongoDB 的灵活架构允许你把这两种方式结合起来，你可以把评论放在独立的集合中，同时在博客帖子下嵌入一小部分评论 (比如说最新评论) ，以便和帖子一同显示。这遵守以下的规则，就是你到想在一次查询中获取到什么内容。</p>
<p>这没有硬性规定(好吧，除了16MB限制)。尝试用不同的方法解决问题，你会知道什么能用什么不能用。</p>
<h2 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h2><p>本章目标是提供一些对你在 MongoDB 中数据建模有帮助的指导, 一个新起点，如果愿意你可以这样认为。在一个面向文档系统中建模，和在面向关系世界中建模，是不一样的，但也没多少不同。你能得到更多的灵活性并且只有一个约束，而对于新系统，一切都很完美。你唯一会做错的就是你不去尝试。</p>
<h1 id="第五章-MongoDB-适用场景"><a href="#第五章-MongoDB-适用场景" class="headerlink" title="第五章 - MongoDB 适用场景"></a>第五章 - MongoDB 适用场景</h1><p>现在你应该有感觉，何时何地把 MongoDB 融入你现有的系统是最棒的了。这有超多的新的类似的存储技术，肯定会让你在选择的时候晕头转向。</p>
<p>对我来说，最重要的教训，跟 MongoDB 无关，是说你不用再依赖单一的解决案来处理你的数据了。毫无疑问，一个单一的解决案有明显的优势，对于许多项目来说 - 或者说大多数 - 单一解决案是一个明智的选择。意思不是说你 <em>必须</em> 使用不同的技术，而是说你 <em>可以</em>。 只有你自己才知道，引进新技术是否利大于弊。</p>
<p>说了那么多，我希望你到目前为止学到知识让你觉得 MongoDB 是一个通用的解决案。我们已经提到很多次了，面向文档的数据库和关系型数据库有很多方面类似。因此，与其绕开这些相同点，不如我们可以简单的这样认为， MongoDB 是关系型数据库的一个代替案。比如说用 Lucene 作为关系型数据库的全文检索索引的加强，或者用 Redis 作为持久型 key-value 存储，MongoDB 就是用来保存你的数据的。</p>
<p>注意，我没有说用 MongoDB <em>取代</em> 关系型数据库，而是 <em>代替</em> 案。它能做的有很多工具也能做。有些事情 MongoDB 可以做的更好，另外一些 MongoDB 做得差点。我们来进一步来讨论一下。</p>
<h2 id="无模式-Flexible-Schema"><a href="#无模式-Flexible-Schema" class="headerlink" title="无模式(Flexible Schema)"></a>无模式(Flexible Schema)</h2><p>面向文档数据库经常吹嘘的一个好处就是，它不需要一个固定的模式。这使得他们比传统的数据库表要灵活得多。我同意无模式是一个很不错的特性，但不是大多数人说的那样。</p>
<p>人们讲到无模式的时候，好像你就会把一堆乱七八糟的数据统统存起来一样。确实有些领域有些数据用关系型数据库来建模很痛苦，不过我觉得这些都是不常见的特例。无模式是酷，可是大多数情况下你的数据结构还是应当好好设计的。真正需要处理混乱时是不错，比如当你添加一个新功能的时候，不过事实是，大多数情况下，一个空列基本可以解决问题。</p>
<p>对我来说，动态模式的真正好处在于无需很多设置以及可以降低在 OOP 中使用的阻力。这在你使用静态语言的时候尤其明显。我在 C# 和 Ruby 中用过 MongoDB ，差异非常明显。Ruby 的动态特性以及它的流行的 ActiveRecord 实现，已经大幅降低面向对象/关系开发之间差异所带来的阻力。这不是说 MongoDB 和 Ruby 不配，而是是说它们太配了。真的，我觉得许多 Ruby 开发者眼中的的 MongoDB 只是有些许改进而已，而在 C# 或者 Java 开发者眼中，MongoDB 带来的是处理数据交互方式的翻天覆地变化。</p>
<p>假设从驱动开发者角度来看这个问题。你想保存一个对象？把它串行化成 JSON (严格来说是 BSON, 不过差不多) 然后把它传给 MongoDB。不需要做任何属性映射或者类型映射。这种简单性的好处就这样传递给了你，终端开发者。</p>
<h2 id="写操作-Writes"><a href="#写操作-Writes" class="headerlink" title="写操作(Writes)"></a>写操作(Writes)</h2><p>MongoDB 可以胜任的一个特殊角色是在日志领域。有两点使得 MongoDB 的写操作非常快。首先，你可以选择发送了写操作命令之后立刻返回，而无须等到操作完成。其次，你可以控制数据持久性的写行为。这些设置，加上，可以定义一个成功的提交，需要在多少台服务器上成功拿到你的数据之后才算成功，并且每个写操作都是可设置, 这就给予你很高的权限用以控制写性能和数据持久性。</p>
<p>除了这些性能因素，日志数据还是这样一种数据集，用无模式集合更有优势。最后，MongoDB 还提供了 <a target="_blank" rel="noopener" href="http://docs.mongodb.org/manual/core/capped-collections/">受限集合(capped collection)</a>。到目前为止，所有我们默认创建的集合都是普通集合。我们可以通过 <code>db.createCollection</code> 命令来创建一个受限集合并标记它的限制:</p>
<pre><code>//limit our capped collection to 1 megabyte
db.createCollection(&#39;logs&#39;, &#123;capped: true,
    size: 1048576&#125;)</code></pre>
<p>当我们的受限集合到达 1MB 上限的时候，旧文档会被自动清除。另外一种限制可以基于文档个数，而不是大小，用 <code>max</code> 标记。受限集合有一些非常有趣的属性。比如说，你可以更新文档但是你不能改变它的大小。插入顺序是被设置好了的，因此不需要另外提供一个索引来获取基于时间的排序，你可以 “tail” 一个受限集合，就和你在 Unix 中通过 <code>tail -f &lt;filename&gt;</code> 来处理文件一样，获取最新的数据，如果存在数据的话，而不需要重新查询它。</p>
<p>如果想让你的数据 “过期” ，基于时间而不是整个集合的大小，你可以用 <a target="_blank" rel="noopener" href="http://docs.mongodb.org/manual/tutorial/expire-data/">TTL 索引</a> ，所谓 TTL 是 “time-to-live” 的缩写。</p>
<h2 id="持久性-Durability"><a href="#持久性-Durability" class="headerlink" title="持久性(Durability)"></a>持久性(Durability)</h2><p>在 1.8 之前的版本，MongoDB 不支持单服务器持久性。就是说，如果一个服务器崩溃了，可能会导致数据的丢失或者损坏。解决案是在多服务器上运行 MongoDB 副本 (MongoDB 支持复制)。日志(Journaling)是 1.8 版追加的一个非常重要的功能。从 2.0 版的 MongoDB 开始，日志是默认启动的，该功能允许快速恢复服务器，比如遭遇到了服务器崩溃或者停电的情况。</p>
<p>持久性在这里只是提一下，因为围绕 MongoDB 过去缺乏单服务器持久的问题，人们取得了众多成果。这个话题在以后的 Google 检索中也许还会继续出现。但是关于缺少日志功能这一缺点的信息，都是过时了的。</p>
<h2 id="全文检索-Full-Text-Search"><a href="#全文检索-Full-Text-Search" class="headerlink" title="全文检索(Full Text Search)"></a>全文检索(Full Text Search)</h2><p>真正的全文检索是在最近加入到 MongoDB 中的。它支持十五国语言，支持词形变化(stemming)和干扰字(stop words)。除了原生的 MongoDB 的全文检索支持，如果你需要一个更强大更全面的全文检索引擎的话，你需要另找方案。</p>
<h2 id="事务-Transactions"><a href="#事务-Transactions" class="headerlink" title="事务(Transactions)"></a>事务(Transactions)</h2><p>MongoDB 不支持事务。这有两个代替案，一个很好用但有限制，另外一个比较麻烦但灵活。</p>
<p>第一个方案，就是各种原子更新操作。只要能解决你的问题，都挺不错。我们已经看过几个简单的了，比如 <code>$inc</code> 和 <code>$set</code>。还有像 <code>findAndModify</code> 命令，可以更新或删除文档之后，自动返回修改过的文档。</p>
<p>第二个方案，当原子操作不能满足的时候，回到两段提交上来。对于事务，两段提交就好像给链接手工解引用。这是一个和存储无关的解决方案。两段提交实际上在关系型数据库世界中非常常用，用来实现多数据库之间的事务。 MongoDB 网站 <a target="_blank" rel="noopener" href="http://docs.mongodb.org/manual/tutorial/perform-two-phase-commits/">有个例子</a> 演示了最典型的场合 (资金转账)。通常的想法是，把事务的状态保存到实际的原子更新的文档中，然后手工的进行 init-pending-commit/rollback 处理。</p>
<p>MongoDB 支持内嵌文档以及它灵活的 schema 设计，让两步提交没那么痛苦，但是它仍然不是一个好处理，特别是当你刚开始接触它的时候。</p>
<h2 id="数据处理-Data-Processing"><a href="#数据处理-Data-Processing" class="headerlink" title="数据处理(Data Processing)"></a>数据处理(Data Processing)</h2><p>在2.2 版本之前的 MongoDB 依赖 MapReduce 来解决大部分数据处理工作。在 2.2 版本，它追加了一个强力的功能，叫做 <a target="_blank" rel="noopener" href="http://docs.mongodb.org/manual/core/aggregation-pipeline/">aggregation framework or pipeline</a>，因此你只要对那些尚未支持管道的，需要使用复杂方法的，不常见的聚合使用 MapReduce。下一章我们将看看聚合管道和 MapReduce 的细节。现在，你可以把他们想象成功能强大的，用不同方法实现的 <code>group by</code> (打个比方)。对于非常大的数据的处理，你可能要用到其他的工具，比如 Hadoop。值得庆幸的是，这两个系统是相辅相成的，这里有个 <a target="_blank" rel="noopener" href="http://docs.mongodb.org/ecosystem/tools/hadoop/">MongoDB connector for Hadoop</a>。</p>
<p>当然，关系型数据库也不擅长并行数据处理。MongoDB 有计划在未来的版本中，改善增加处理大数据集的能力。</p>
<h2 id="地理空间查询-Geospatial"><a href="#地理空间查询-Geospatial" class="headerlink" title="地理空间查询(Geospatial)"></a>地理空间查询(Geospatial)</h2><p>一个很强大的功能就是 MongoDB 支持 <a target="_blank" rel="noopener" href="http://docs.mongodb.org/manual/applications/geospatial-indexes/">geospatial 索引</a>。这允许你保存 geoJSON 或者 x 和 y 坐标到文档，并查询文档，用如 <code>$near</code> 来获取坐标集，或者 <code>$within</code> 来获取一个矩形或圆中的点。这个特性最好通过一些可视化例子来演示，所以如果你想学更多的话，可以试试看 <a target="_blank" rel="noopener" href="http://mongly.openmymind.net/geo/index">5 minute geospatial interactive tutorial</a>。</p>
<h2 id="工具和成熟度"><a href="#工具和成熟度" class="headerlink" title="工具和成熟度"></a>工具和成熟度</h2><p>你应该已经知道这个问题的答案了，MongoDB 确实比大多数的关系型数据要年轻很多。这个问题确实是你应当考虑的，但是到底有多重要，这取决于你要做什么，怎么做。不管怎么说，一个好的评估，不可能忽略 MongoDB 年轻这一事实，而可用的工具也不是很好 (虽然成熟的关系型数据库工具有些也非常渣!)。举个例子，它缺乏对十进制浮点数的支持，在处理货币的系统来说，明显是一个问题 (尽管也不是致命的) 。</p>
<p>积极的一方面，它为大多数语言提供了驱动，协议现代而简约，开发速度相当快。MongoDB 被众多公司用到了生产环境中，虽然有所担心，但经过验证后，担心很快就变成了过去。</p>
<h2 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h2><p>本章要说的是，MongoDB，大多数情况下，可以取代关系型数据库。它更简单更直接；更快速并且通常对应用开发者的约束更少。不过缺乏事务支持也许值得慎重考虑。当人们说起 <em>MongoDB 在新的数据库阵营中到底处在什么位置？</em> 时，答案很简单: <strong>中庸</strong>(<em>2</em>)。</p>
<h1 id="第六章-数据聚合"><a href="#第六章-数据聚合" class="headerlink" title="第六章 - 数据聚合"></a>第六章 - 数据聚合</h1><h2 id="聚合管道-Aggregation-Pipeline"><a href="#聚合管道-Aggregation-Pipeline" class="headerlink" title="聚合管道(Aggregation Pipeline)"></a>聚合管道(Aggregation Pipeline)</h2><p>聚合管道提供了一种方法用于转换整合文档到集合。你可以通过管道来传递文档，就像 Unix 的 “pipe” 一样，将一个命令的输出传递到另第二个，第三个，等等。</p>
<p>最简单的聚合，应该是你在 SQL 中早已熟悉的 <code>group by</code> 操作。我们已经看过 <code>count()</code> 方法，那么假设我们怎么才能知道有多少匹公独角兽，有多少匹母独角兽呢？</p>
<pre><code>db.unicorns.aggregate([&#123;$group:&#123;_id:&#39;$gender&#39;,
    total: &#123;$sum:1&#125;&#125;&#125;])</code></pre>
<p>在 shell 中，我们有 <code>aggregate</code> 辅助类，用来执行数组的管道操作。对于简单的对某物进行分组计数，我们只需要简单的调用 <code>$group</code>。这和 SQL 中的 <code>GROUP BY</code> 完全一致，我们用来创建一个新的文档，以 <code>_id</code> 字段表示我们以什么来分组(在这里是以 <code>gender</code>) ，另外的字段通常被分配为聚合的结果，在这里，我们对匹配某一性别的各文档使用了 <code>$sum</code> 1 。你应该注意到了 <code>_id</code> 字段被分配为 <code>&#39;$gender&#39;</code> 而不是 <code>&#39;gender&#39;</code> - 字段前面的 <code>&#39;$&#39;</code> 表示，该字段将会被输入的文档中的有同样名字的值所代替，一个占位符。</p>
<p>我们还可以用其他什么管道操作呢？在 <code>$group</code> 之前(之后也很常用)的一个是 <code>$match</code> - 这和 <code>find</code> 方法完全一样，允许我们获取文档中某个匹配的子集，或者在我们的结果中对文档进行筛选。</p>
<pre><code>db.unicorns.aggregate([&#123;$match: &#123;weight:&#123;$lt:600&#125;&#125;&#125;,
    &#123;$group: &#123;_id:&#39;$gender&#39;,  total:&#123;$sum:1&#125;,
      avgVamp:&#123;$avg:&#39;$vampires&#39;&#125;&#125;&#125;,
    &#123;$sort:&#123;avgVamp:-1&#125;&#125; ])</code></pre>
<p>这里我们介绍另外一个管道操作 <code>$sort</code> ，作用和你想的完全一致，还有和它一起用的 <code>$skip</code> 和 <code>$limit</code>。以及用 <code>$group</code> 操作 <code>$avg</code>。</p>
<p>MongoDB 数组非常强大，并且他们不会阻止我们往保存中的数组中写入内容。我们需要可以 “flatten” 他们以便对所有的东西进行计数:</p>
<pre><code>db.unicorns.aggregate([&#123;$unwind:&#39;$loves&#39;&#125;,
     &#123;$group: &#123;_id:&#39;$loves&#39;,  total:&#123;$sum:1&#125;,
     unicorns:&#123;$addToSet:&#39;$name&#39;&#125;&#125;&#125;,
      &#123;$sort:&#123;total:-1&#125;&#125;,
      &#123;$limit:1&#125; ])</code></pre>
<p>这里我们可以找出独角兽最喜欢吃的食物，以及拿到喜欢这种食物的独角兽的名单。 <code>$sort</code> 和 <code>$limit</code> 的组合能让你拿到 “top N” 这种查询的结果。</p>
<p>还有另外一个强大的管道操作叫做 <a target="_blank" rel="noopener" href="http://docs.mongodb.org/manual/reference/operator/aggregation/project/#pipe._S_project"><code>$project</code></a> (类似于 <code>find</code>)，不但允许你拿到指定字段，还可以根据现存字段进行创建或计算一个新字段。比如，可以用数学操作，在做平均运算之前，对几个字段进行加法运算，或者你可以用字符串操作创建一个新的字段，用于拼接现有字段。</p>
<p>这只是用聚合所能做到的众多功能中的皮毛， 2.6 的聚合拥有了更强大的力量，比如聚合命令可以返回结果集的游标(我们已经在第一章学过了) 或者可以将结果写到另外一个新集合中，通过 <code>$out</code> 管道操作。你可以从 <a target="_blank" rel="noopener" href="http://docs.mongodb.org/manual/core/aggregation-pipeline/">MongoDB 手册</a> 得到关于管道操作和表达式操作更多的例子。</p>
<h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>MapReduce 分两步进行数据处理。首先是 map，然后 reduce。在 map 步骤中，转换输入文档和输出一个 key=&gt;value 对(key 和/或 value 可以很复杂)。然后, key/value 对以 key 进行分组，有同样的 key 的 value 会被收入一个数组中。在 reduce 步骤中，获取 key 和该 key 的 value 的数组，生成最终结果。map 和 reduce 方法用 JavaScript 来编写。</p>
<p>在 MongoDB 中我们对一个集合使用 <code>mapReduce</code> 命令。 <code>mapReduce</code> 执行 map 方法， reduce 方法和 output 指令。在我们的 shell 中，我们可以创建输入一个 JavaScript 方法。许多库中，支持字符串方法 (有点丑)。第三个参数设置一个附加参数，比如说我们可以过滤，排序和限制那些我们想要分析的文档。我们也可以提供一个 <code>finalize</code> 方法来处理 <code>reduce</code> 步骤之后的结果。</p>
<p>在你的大多数聚合中，也许无需用到 MapReduce , 但如果需要，你可以读到更多关于它的内容，从 <a target="_blank" rel="noopener" href="http://openmymind.net/2011/1/20/Understanding-Map-Reduce/">我的 blog</a> 和 <a target="_blank" rel="noopener" href="http://docs.mongodb.org/manual/core/map-reduce/">MongoDB 手册</a>。</p>
<h2 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h2><p>在这章中我们介绍了 MongoDB 的 <a target="_blank" rel="noopener" href="http://docs.mongodb.org/manual/aggregation/">聚合功能(aggregation capabilities)</a>。 一旦你理解了聚合管道(Aggregation Pipeline)的构造，它还是相对容易编写的，并且它是一个聚合数据的强有力工具。 MapReduce 更难理解一点，不过它强力无边，就像你用 JavaScript 写的代码一样。</p>
<h1 id="第七章-性能和工具"><a href="#第七章-性能和工具" class="headerlink" title="第七章 - 性能和工具"></a>第七章 - 性能和工具</h1><p>在这章中，我们来讲几个关于性能的话题，以及在 MongoDB 开发中用到的一些工具。我们不会深入其中的一个话题，不过我们会指出每个话题中最重要的方面。</p>
<h2 id="索引-Index"><a href="#索引-Index" class="headerlink" title="索引(Index)"></a>索引(Index)</h2><p>首先我们要介绍一个特殊的集合 <code>system.indexes</code> ，它保存了我们数据库中所有的索引信息。索引的作用在 MongoDB 中和关系型数据库基本一致: 帮助改善查询和排序的性能。创建索引用 <code>ensureIndex</code> :</p>
<pre><code>// where &quot;name&quot; is the field name
db.unicorns.ensureIndex(&#123;name: 1&#125;);</code></pre>
<p>删除索引用 <code>dropIndex</code>:</p>
<pre><code>db.unicorns.dropIndex(&#123;name: 1&#125;);</code></pre>
<p>可以创建唯一索引，这需要把第二个参数 <code>unique</code> 设置为 <code>true</code>:</p>
<pre><code>db.unicorns.ensureIndex(&#123;name: 1&#125;,
    &#123;unique: true&#125;);</code></pre>
<p>索引可以内嵌到字段中 (再说一次，用点号) 和任何数组字段。我们可以这样创建复合索引:</p>
<pre><code>db.unicorns.ensureIndex(&#123;name: 1,
    vampires: -1&#125;);</code></pre>
<p>索引的顺序 (1 升序, -1 降序) 对单键索引不起任何影响，但它会在使用复合索引的时候有所不同，比如你用不止一个索引来进行排序的时候。</p>
<p>阅读 <a target="_blank" rel="noopener" href="http://docs.mongodb.org/manual/indexes/">indexes page</a> 获取更多关于索引的信息。</p>
<h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><p>需要检查你的查询是否用到了索引，你可以通过 <code>explain</code> 方法:</p>
<pre><code>db.unicorns.find().explain()</code></pre>
<p>输出告诉我们，我们用的是 <code>BasicCursor</code> (意思是没索引), 12 个对象被扫描，用了多少时间，什么索引，如果有索引，还会有其他有用信息。</p>
<p>如果我们改变查询索引语句，查询一个有索引的字段，我们可以看到 <code>BtreeCursor</code> 作为索引被用到填充请求中去:</p>
<pre><code>db.unicorns.find(&#123;name: &#39;Pilot&#39;&#125;).explain()</code></pre>
<h2 id="复制-Replication"><a href="#复制-Replication" class="headerlink" title="复制(Replication)"></a>复制(Replication)</h2><p>MongoDB 的复制在某些方面和关系型数据库的复制类似。所有的生产部署应该都是副本集，理想情况下，三个或者多个服务器都保持相同的数据。写操作被发送到单个服务器，也即主服务器，然后从它异步复制到所有的从服务器上。你可以控制是否允许从服务器上进行读操作，这可以让一些特定的查询从主服务器中分离出来，当然，存在读取到旧数据的风险。如果主服务器异常关闭，从服务中的一个将会自动晋升为新的主服务器继续工作。另外，MongoDB 的复制不在本书的讨论范围之内。</p>
<h2 id="分片-Sharding"><a href="#分片-Sharding" class="headerlink" title="分片(Sharding)"></a>分片(Sharding)</h2><p>MongoDB 支持自动分片。分片是实现数据扩展的一种方法，依靠在跨服务器或者集群上进行数据分区来实现。一个最简单的实现是把所有的用户数据，按照名字首字母 A-M 放在服务器 1 ，然后剩下的放在服务器 2。谢天谢地，MongoDB 的拆分能力远比这种分法要强。分片不在本书的讨论范围之内，不过你应当有分片的概念，并且，当你的需求增长超过了使用单一副本集的时候，你应该考虑它。</p>
<p>尽管复制有时候可以提高性能(通过将长时间查询隔离到从服务器，或者降低某些类型的查询的延迟),但它的主要目的是维护高可用性。分片是扩展 MongoDB 集群的主要方法。把复制和分片结合起来实现可扩展和高可用性的通用方法。</p>
<h2 id="状态-Stats"><a href="#状态-Stats" class="headerlink" title="状态(Stats)"></a>状态(Stats)</h2><p>你可以通过 <code>db.stats()</code> 查询数据库的状态。基本上都是关于数据库大小的信息。你还可以查询集合的状态，比如说 <code>unicorns</code> 集合，可以输入 <code>db.unicorns.stats()</code>。基本上都是关于集合大小的信息，以及集合的索引信息。</p>
<h2 id="分析器-Profiler"><a href="#分析器-Profiler" class="headerlink" title="分析器(Profiler)"></a>分析器(Profiler)</h2><p>你可以这样执行 MongoDB profiler :</p>
<pre><code>db.setProfilingLevel(2);</code></pre>
<p>启动之后，我们可以执行一个命令:</p>
<pre><code>db.unicorns.find(&#123;weight: &#123;$gt: 600&#125;&#125;);</code></pre>
<p>然后检查 profiler:</p>
<pre><code>db.system.profile.find()</code></pre>
<p>输出会告诉我们:什么时候执行了什么，有多少文档被扫描，有多少数据被返回。</p>
<p>你要停止 profiler 只需要再调用一次 <code>setProfilingLevel</code> ，不过这次参数是 <code>0</code>。指定 <code>1</code> 作为第一个参数，将会统计那些超过 100 milliseconds 的任务. 100 milliseconds 是默认的阈值，你可以在第二个参数中，指定不同的阈值时间，以 milliseconds 为单位:</p>
<pre><code>//profile anything that takes
//more than 1 second
db.setProfilingLevel(1, 1000);</code></pre>
<h2 id="备份和还原"><a href="#备份和还原" class="headerlink" title="备份和还原"></a>备份和还原</h2><p>在 MongoDB 的 <code>bin</code> 目录下有一个可执行文件 <code>mongodump</code> 。简单执行 <code>mongodump</code> 会链接到 localhost 并备份你所有的数据库到 <code>dump</code> 子目录。你可以用 <code>mongodump --help</code> 查看更多执行参数。常用的参数有 <code>--db DBNAME</code> 备份指定数据库和 <code>--collection COLLECTIONNAME</code> 备份指定集合。你可以用 <code>mongorestore</code> 可执行文件，同样在 <code>bin</code> 目录下，还原之前的备份。同样， <code>--db</code> 和 <code>--collection</code> 可以指定还原的数据库和/或集合。 <code>mongodump</code> 和 <code>mongorestore</code> 使用 BSON，这是 MongoDB 的原生格式。</p>
<p>比如，来备份我们的 <code>learn</code> 数据库导 <code>backup</code> 文件夹，我们需要执行(在控制台或者终端中执行该命令，而不是在 mongo shell 中):</p>
<pre><code>mongodump --db learn --out backup</code></pre>
<p>如果只还原 <code>unicorns</code> 集合，我们可以这样做:</p>
<pre><code>mongorestore --db learn --collection unicorns \
    backup/learn/unicorns.bson</code></pre>
<p>值得一提的是， <code>mongoexport</code> 和 <code>mongoimport</code> 是另外两个可执行文件，用于导出和从 JSON/CSV 格式文件导入数据。比如说，我们可以像这样导出一个 JSON:</p>
<pre><code>mongoexport --db learn --collection unicorns</code></pre>
<p>CSV 格式是这样:</p>
<pre><code>mongoexport --db learn \
    --collection unicorns \
    --csv --fields name,weight,vampires</code></pre>
<p>注意 <code>mongoexport</code> 和 <code>mongoimport</code> 不一定能正确代表数据。真实的备份中，只能使用 <code>mongodump</code> 和 <code>mongorestore</code> 。  你可以从 MongoDB 手册中读到更多的 <a target="_blank" rel="noopener" href="http://docs.mongodb.org/manual/core/backups/">备份须知</a> 。</p>
<h2 id="小结-6"><a href="#小结-6" class="headerlink" title="小结"></a>小结</h2><p>在这章中我们介绍了 MongoDB 的各种命令，工具和性能细节。我们没有涉及所有的东西，不过我们已经把常用的都看了一遍。MongoDB 的索引和关系型数据库中的索引非常类似，其他一些工具也一样。不过，在 MongoDB 中，这些更易于使用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>你现在应该有足够的能力开始在真实项目中使用 MongoDB 了。虽然 MongoDB 远不止我们学到的这些内容，但是你要作的下一步是，把学到的知识融会贯通，熟悉我们需要用到的功能。<a target="_blank" rel="noopener" href="http://www.mongodb.org/">MongoDB website</a> 有许多有用的信息。官网的 <a target="_blank" rel="noopener" href="http://groups.google.com/group/mongodb-user">MongoDB user group</a> 是个问问题的好地方。</p>
<p>NoSQL 不光是为需求而生，它同时还是不断尝试创新的成果。不得不承认，我们的领域是不断前行的。如果我们不尝试，一旦失败，我们就绝不会取得成功。就是这样的，我认为，这是让你在职业生涯一路走好的方法。</p>
<hr>
<p><em>1</em> :中文版本 <a target="_blank" rel="noopener" href="https://github.com/geminiyellow/the-little-redis-book/blob/master/zh-cn/redis.md">the-little-redis-book</a></p>
<p><em>2</em> :参考 <a target="_blank" rel="noopener" href="https://github.com/justinyhuang/the-little-mongodb-book-cn/blob/master/mongodb.md">justinyhuang</a> 的翻译。MongoDB 属于 NoSQL，但是和传统关系型数据库类似，且较为通用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/network/security/HTTPS-SSL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/network/security/HTTPS-SSL/" class="post-title-link" itemprop="url">HTTPS与SSL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-10-31 12:26:00" itemprop="dateCreated datePublished" datetime="2016-10-31T12:26:00+08:00">2016-10-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-23 13:04:00" itemprop="dateModified" datetime="2021-04-23T13:04:00+08:00">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/network/" itemprop="url" rel="index"><span itemprop="name">network</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTPS(Hypertext Transfer Protocol Secure)即安全的HTTP. HTTPS的安全基础是安全套接层(Secure Sockets Layer, SSL). HTTP工作在应用层(OSI模型的最高层), SSL协议工作在一个较低的子层, 位于TCP/IP协议和HTTP协议之间. 在HTTP报文传输前对其加密, 并在到达时对其解密. 严格地讲, HTTPS并不是一个单独的协议, 而是工作在SSL协议上的HTTP协议. </p>
<p>HTTPS，即安全的超文本传输协议，采用了SSL技术，被广泛使用以保证Web应用系统的安全性。访问Web应用的编程接口大多封装了 SSL，使得访问 HTTPS 和访问 HTTP 一样简单。</p>
<p><img src="/images/network/security/https-protocal-ssl.png" alt="img"></p>
<p>HTTPS主要作用有两种：(1)确认通讯双方的身份, (2)建立安全通道, 保证数据传输安全. </p>
<h2 id="HTTPS的主要作用"><a href="#HTTPS的主要作用" class="headerlink" title="HTTPS的主要作用"></a>HTTPS的主要作用</h2><h3 id="确认通讯双方的身份"><a href="#确认通讯双方的身份" class="headerlink" title="确认通讯双方的身份"></a>确认通讯双方的身份</h3><p>HTTPS通讯中, 通过签名技术, 通讯双方可以确认对方身份. 身份认证分为单向认证和双向认证.<br>单向认证中只有服务器端有证书, 双向认证中服务器和客户端都有证书. 一般的HTTPS站点只有服务器有证书, 而客户端无证书. </p>
<p>单向认证是双向认证的简化版. </p>
<h3 id="建立安全通道-保证数据传输安全"><a href="#建立安全通道-保证数据传输安全" class="headerlink" title="建立安全通道, 保证数据传输安全"></a>建立安全通道, 保证数据传输安全</h3><p>基于SSL协议通讯双方可以协商一个用于对称加密的密钥, 该密钥是一个难以破解的随机数, 而且依赖通讯双方的证书、私钥等来协商. 密钥协商好后, 通讯双方用该密钥对数据进行加解密, 从而保证数据安全. </p>
<h2 id="HTTPS与HTTP协议的差异"><a href="#HTTPS与HTTP协议的差异" class="headerlink" title="HTTPS与HTTP协议的差异"></a>HTTPS与HTTP协议的差异</h2><ol>
<li>HTTP 的URL是以”http://“开始, HTTPS的URL是以“https://”开始；</li>
<li>HTTP默认端口为80, HTTPS的默认端口为443；</li>
<li>采用HTTPS的Web Server需要到CA申请证书；</li>
<li>HTTPS由HTTP+SSL来实现, 可进行加密传输、身份认证等, 要比HTTP安全</li>
<li>HTTP的信息是明文传输, 而HTTPS的信息是加密传输　　</li>
</ol>
<h1 id="HTTPS的工作原理"><a href="#HTTPS的工作原理" class="headerlink" title="HTTPS的工作原理"></a>HTTPS的工作原理</h1><p>HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，更是一件经过艺术家精心设计的艺术品，TLS/SSL中使用了非对称加密，对称加密以及HASH算法。握手过程的简单描述如下：</p>
<ol>
<li>浏览器将自己支持的一套加密规则发送给网站。</li>
<li>网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。</li>
<li>获得网站证书之后浏览器要做以下工作：<br>a) 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。<br>b) 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。<br>c) 使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。</li>
<li>网站接收浏览器发来的数据之后要做以下的操作：<br>a) 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。<br>b) 使用密码加密一段握手消息，发送给浏览器。</li>
<li>浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</li>
</ol>
<p>这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。另外，HTTPS一般使用的加密与HASH算法如下：</p>
<p>非对称加密算法：RSA，DSA/DSS</p>
<p>对称加密算法：AES，RC4，3DES</p>
<p>HASH算法：MD5，SHA1，SHA256</p>
<p>其中非对称加密算法用于在握手过程中加密生成的密码，对称加密算法用于对真正传输的数据进行加密，而HASH算法用于验证数据的完整性。由于浏览器生成的密码是整个数据加密的关键，因此在传输的时候使用了非对称加密算法对其加密。非对称加密算法会生成公钥和私钥，公钥只能用于加密数据，因此可以随意传输，而网站的私钥用于对数据进行解密，所以网站都会非常小心的保管自己的私钥，防止泄漏。</p>
<p><img src="/images/network/security/http-ssl.png"></p>
<h1 id="Java中的HTTPS"><a href="#Java中的HTTPS" class="headerlink" title="Java中的HTTPS"></a>Java中的HTTPS</h1><p>Java 包含了访问 Https 链接的 API，会用到一个关键类 <strong>HttpsURLConnection</strong> ;  参见如下实现代码：</p>
<p>代码1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建URL对象</span></span><br><span class="line">URL myURL = <span class="keyword">new</span> URL(<span class="string">&quot;https://www.sun.com&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建HttpsURLConnection对象，并设置其SSLSocketFactory对象</span></span><br><span class="line">HttpsURLConnection httpsConn = (HttpsURLConnection) myURL.openConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取得该连接的输入流，以读取响应内容</span></span><br><span class="line">InputStreamReader insr = <span class="keyword">new</span> InputStreamReader(httpsConn.getInputStream());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取服务器的响应内容并显示</span></span><br><span class="line"><span class="keyword">int</span> respInt = insr.read();</span><br><span class="line"><span class="keyword">while</span> (respInt != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>) respInt);</span><br><span class="line">    respInt = insr.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在取得connection的时候和正常浏览器访问一样，仍然会<strong>验证服务端的证书是否被信任</strong>（权威机构发行或者被权威机构签名）; 如果服务端证书不被信任，则默认的实现就会有问题，一般来说，用<strong>SunJSSE</strong>会抛如下异常信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javax.net.ssl.SSLHandshakeException:</span><br><span class="line">sun.security.validator.ValidatorException: PKIX path building failed:</span><br><span class="line">sun.security.provider.certpath.SunCertPathBuilderException: unable to</span><br><span class="line">find valid certification path to requested target</span><br></pre></td></tr></table></figure>

<h1 id="JSSE"><a href="#JSSE" class="headerlink" title="JSSE"></a>JSSE</h1><p>Java安全套接扩展 (Java Secure Socket Extension, <code>JSSE</code>) 是实现Internet安全通信的一系列包的集合。它是一个<code>SSL</code>和<code>TLS</code>的纯Java实现，可以透明地提供数据加密、服务器认证、信息完整性等功能，可以使我们像使用普通的套接字一样使用JSSE建立的安全套接字。JSSE是一个开放的标准，不只是Sun公司才能实现一个JSSE，事实上其他公司有自己实现的JSSE。</p>
<h2 id="TrustStore文件"><a href="#TrustStore文件" class="headerlink" title="TrustStore文件"></a>TrustStore文件</h2><p>客户端的 TrustStore 文件。客户端的 TrustStore 文件中保存着被客户端所信任的服务器的证书信息。客户端在进行SSL连接时，JSSE将根据这个文件中的证书决定是否信任服务器端的证书。</p>
<p>JSSE中，有一个信任管理器类负责决定是否信任远端的证书，这个类有如下的处理规则：</p>
<ol>
<li>若系统属性 <strong>javax.net.sll.trustStore</strong> 指定了 TrustStore 文件，那么信任管理器就去jre安装路径下的 lib/security/目录中寻找并使用这个文件来检查证书。</li>
<li>若该系统属性没有指定 TrustStore 文件，它就会去jre安装路径下寻找默认的 TrustStore 文件，这个文件的相对路径为：lib/security/<strong>jssecacerts</strong>。</li>
<li>若 jssecacerts 不存在，但是 cacerts 存在（它随J2SDK一起发行，含有数量有限的可信任的基本证书），那么这个默认的 TrustStore 文件就是 lib/security/<strong>cacerts</strong>。</li>
</ol>
<p>那遇到这种情况，怎么处理呢？有以下两种方案：</p>
<ol>
<li>按照以上信任管理器的规则，<strong>将服务端的公钥(证书)导入到jssecacerts</strong>，或者是在系统属性中设置要加载的 trustStore 文件的路径; 证书导入可以用如下命令：<code>keytool -import -file src_cer_file –keystore dest_cer_store</code> ; 证书可以通过浏览器导出获得; </li>
<li>实现自己的证书信任管理器类，比如 <strong>MyX509TrustManager</strong> ，该类必须实现<code>X509TrustManager</code>接口中的三个method; 然后在HttpsURLConnection中加载自定义的类.</li>
</ol>
<p>　　Java提供了一种非常简洁的方法来访问HTTPS网页，即使用类HttpsURLConnection、URL等。这几个类为支持HTTPS对JSSE相关类做了进一步的封装，例子如下所示：</p>
<p>TrustStore文件中导入了 <code>https://www.oracle.com</code> 的证书，运行代码 1 当使用<code>HttpsUrlConnection</code>访问该网址时，可以正常的访问。然而把访问的URL改为 <code>https://login.bjut.edu.cn</code> 时，程序将抛出异常<code>javax.net.ssl.SSLException</code>，这是由于<code>https://login.bjut.edu.cn</code> 站点的安全证书不被<code>JSSE</code>所信任。根据<code>JSSE</code>简介中对信任管理器的分析，一种解决这个问题的方法是按照信任管理器的处理规则，把站点的证书放到证书库文件<code>jssecacerts</code>中，或者把证书存放到任一 <code>TrustStore</code> 文件中，然后设置系统属性 <code>javax.net.sll.trustStore</code> 指向该文件。另一种解决方法则是自己实现信任管理器类，让它信任我们指定的证书。下面分别介绍这两种方法: </p>
<h2 id="将证书导入到TrustStore文件中"><a href="#将证书导入到TrustStore文件中" class="headerlink" title="将证书导入到TrustStore文件中"></a>将证书导入到TrustStore文件中</h2><p>Java提供了命令行工具keytool用于创建证书或者把证书从其它文件中导入到Java自己的TrustStore文件中。把证书从其它文件导入到TrustStore文件中的命令行格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -import -file src_cer_file –keystore dest_cer_store</span><br></pre></td></tr></table></figure>
<p>　　其中，src_cer_file为存有证书信息的源文件名，dest_cer_store为目标TrustStore文件。</p>
<p>　　在使用<code>keytool</code>之前，首先要取得源证书文件，这个源文件可使用IE浏览器获得，IE浏览器会把访问过的<code>HTTPS</code>站点的证书保存到本地。从IE浏览器导出证书的方法是打开“Internet 选项”，选择“内容”选项卡，点击“证书…”按钮，在打开的证书对话框中，选中一个证书，然后点击“导出…”按钮，按提示一步步将该证书保存到一文件中。最后就可利用keytool把该证书导入到Java的TrustStore文件中。为了能使Java程序找到该文件，应该把这个文件复制到jre安装路径下的<code>lib/security/</code>目录中。</p>
<p>　　这样，只需在程序中设置系统属性<code>javax.net.sll.trustStore</code>指向文件dest_cer_store，就能使JSSE信任该证书，从而使程序可以访问使用未经验证的证书的HTTPS站点。</p>
<p>　　使用这种方法，编程非常简单，但需要手工导出服务器的证书。当服务器证书经常变化时，就需要经常进行手工导出证书的操作。下面介绍的实现X509证书信任管理器类的方法将避免手工导出证书的问题。</p>
<h2 id="X509证书信任管理器类的实现及应用"><a href="#X509证书信任管理器类的实现及应用" class="headerlink" title="X509证书信任管理器类的实现及应用"></a>X509证书信任管理器类的实现及应用</h2><p>　　在JSSE中，证书信任管理器类就是实现了接口<code>X509TrustManager</code>的类。可以自己实现该接口，让它信任我们指定的证书。</p>
<p>　　接口<code>X509TrustManager</code>有下述三个公有的方法需要我们实现：</p>
<p>　　1. <code>void checkClientTrusted(X509Certificate[] chain, String authType)      throws CertificateException</code></p>
<p>　　该方法检查客户端的证书，若不信任该证书则抛出异常。由于我们不需要对客户端进行认证，因此我们只需要执行默认的信任管理器的这个方法。JSSE中，默认的信任管理器类为<code>TrustManager</code>。</p>
<p>　　1. <code>void checkServerTrusted(X509Certificate[] chain, String authType)      throws CertificateException</code></p>
<p>　　该方法检查服务器的证书，若不信任该证书同样抛出异常。通过自己实现该方法，可以使之信任我们指定的任何证书。在实现该方法时，也可以简单的不做任何处理，即一个空的函数体，由于不会抛出异常，它就会信任任何证书。</p>
<p>　　1. <code>X509Certificate[] getAcceptedIssuers()</code></p>
<p>　　返回受信任的X509证书数组。</p>
<p>　　自己实现了信任管理器类，如何使用呢？类<code>HttpsURLConnection</code>似乎并没有提供方法设置信任管理器。其实，<code>HttpsURLConnection</code>通过<code>SSLSocket</code>来建立与HTTPS的安全连接，<code>SSLSocket</code>对象是由<code>SSLSocketFactory</code>生成的。<code>HttpsURLConnection</code>提供了方法<code>setSSLSocketFactory(SSLSocketFactory)</code>设置它使用的<code>SSLSocketFactory</code>对象。<code>SSLSocketFactory</code>通过<code>SSLContext</code>对象来获得，在初始化SSLContext对象时，可指定信任管理器对象。下面用一个图简单表示这几个JSSE类的关系：</p>
<p><img src="/images/java/JSSE-classes.gif" alt="img"></p>
<p>　　假设自己实现的X509TrustManager类的类名为：MyX509TrustManager，下面的代码片断说明了如何使用MyX509TrustManager：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.net.ssl.TrustManager;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.TrustManagerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.X509TrustManager;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyStore;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.CertificateException;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.X509Certificate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyX509TrustManager</span> <span class="keyword">implements</span> <span class="title">X509TrustManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * The default X509TrustManager returned by SunX509.  We’ll delegate</span></span><br><span class="line"><span class="comment">    * decisions to it, and fall back to the logic in this class if the</span></span><br><span class="line"><span class="comment">    * default X509TrustManager doesn’t trust it.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    X509TrustManager sunJSSEX509TrustManager;</span><br><span class="line"></span><br><span class="line">    MyX509TrustManager() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">// create a &quot;default&quot; JSSE X509TrustManager.</span></span><br><span class="line"></span><br><span class="line">        KeyStore ks = KeyStore.getInstance(<span class="string">&quot;JKS&quot;</span>);</span><br><span class="line">        ks.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;trustedCerts&quot;</span>),</span><br><span class="line">                <span class="string">&quot;passphrase&quot;</span>.toCharArray());</span><br><span class="line">        TrustManagerFactory tmf =</span><br><span class="line">                TrustManagerFactory.getInstance(<span class="string">&quot;SunX509&quot;</span>, <span class="string">&quot;SunJSSE&quot;</span>);</span><br><span class="line">        tmf.init(ks);</span><br><span class="line">        TrustManager tms[] = tmf.getTrustManagers();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Iterate over the returned trustmanagers, look</span></span><br><span class="line"><span class="comment">* for an instance of X509TrustManager.  If found,</span></span><br><span class="line"><span class="comment">* use that as our &quot;default&quot; trust manager.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tms.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tms[i] <span class="keyword">instanceof</span> X509TrustManager) &#123;</span><br><span class="line">                sunJSSEX509TrustManager = (X509TrustManager) tms[i];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Find some other way to initialize, or else we have to fail the</span></span><br><span class="line"><span class="comment">* constructor.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Couldn’t initialize&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Delegate to the default trust manager.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sunJSSEX509TrustManager.checkClientTrusted(chain, authType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CertificateException excep) &#123;</span><br><span class="line"><span class="comment">// do any special handling here, or rethrow exception.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Delegate to the default trust manager.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sunJSSEX509TrustManager.checkServerTrusted(chain, authType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CertificateException excep) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Possibly pop up a dialog box asking whether to trust the</span></span><br><span class="line"><span class="comment">        * cert chain.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Merely pass this through.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">        <span class="keyword">return</span> sunJSSEX509TrustManager.getAcceptedIssuers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用信任管理器创建HTTPS连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建SSLContext对象，并使用我们指定的信任管理器初始化</span></span><br><span class="line">TrustManager[] tm = &#123;<span class="keyword">new</span> MyX509TrustManager ()&#125;;</span><br><span class="line">SSLContext sslContext = SSLContext.getInstance(<span class="string">&quot;SSL&quot;</span>,<span class="string">&quot;SunJSSE&quot;</span>);</span><br><span class="line">sslContext.init(<span class="keyword">null</span>, tm, <span class="keyword">new</span> java.security.SecureRandom());</span><br><span class="line"></span><br><span class="line"><span class="comment">//从上述SSLContext对象中得到SSLSocketFactory对象</span></span><br><span class="line">SSLSocketFactory ssf = sslContext.getSocketFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建HttpsURLConnection对象，并设置其SSLSocketFactory对象</span></span><br><span class="line">HttpsURLConnection httpsConn = (HttpsURLConnection)myURL.openConnection();</span><br><span class="line">httpsConn.setSSLSocketFactory(ssf);</span><br></pre></td></tr></table></figure>


<p>这样，HttpsURLConnection对象就可以正常连接HTTPS了，无论其证书是否经权威机构的验证，只要实现了接口X509TrustManager的类MyX509TrustManager信任该证书。</p>
<p>第一种方式<strong>不会破坏JSSE的安全性</strong>，但是要手工导入证书，如果服务器很多，那每台服务器的JRE都必须做相同的操作; 第二种方式<strong>灵活性更高</strong>，但是要小心实现，否则可能会留下安全隐患; </p>
<h2 id="Java-Key-Store"><a href="#Java-Key-Store" class="headerlink" title="Java Key Store"></a>Java Key Store</h2><p>Java Key Store(JKS)是Java语言中给出的一种密码保护的文件, 可存储密钥和证书. JKS文件好比一个仓库, 为防范别人随便乱拿, 仓库可以设置一把锁, 即JKS文件的密码(storepass). 仓库里可存放多种密钥, 如公钥、私钥和密钥对(由配对公钥和私钥组成). 每个密钥都有一个名字, 称为别名(alias). 仓库里的公钥只要你能进入仓库你就可以随便查看拿走, 私钥则是有密码的(keypass), 只允许有权限的人查看拿走. 所以从JKS文件中读取公钥只需要知道JKS文件(仓库)的密码即可, 但读取私钥时则还必须有私钥的密码[1]. </p>
<h1 id="网站支持SSL"><a href="#网站支持SSL" class="headerlink" title="网站支持SSL"></a>网站支持SSL</h1><ol>
<li>将证书上传到服务器</li>
<li>设置Nignx <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 需要注意：证书路径一定要对，将ssl_certificate 和 ssl_certificate_key的值改成你证书实际存放的路径</span><br><span class="line">server &#123;</span><br><span class="line">    listen 443;</span><br><span class="line">    server_name www.w3ctech.com;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate &#x2F;home&#x2F;conf&#x2F;1_www.w3ctech.com_cert.crt;</span><br><span class="line">    ssl_certificate_key &#x2F;home&#x2F;conf&#x2F;2_www.w3ctech.com.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_protocols TLSv1;</span><br><span class="line">    ssl_ciphers HIGH:!aNULL:!MD5;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        root html;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>禁掉80端口 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    #省略其他...</span><br><span class="line">    # http访问时，301跳转至https</span><br><span class="line">    if ($scheme &#x3D; http) &#123;</span><br><span class="line">        return 301 https:&#x2F;&#x2F;$server_name$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<p>[参考文献]:</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://www.blogjava.net/etlan/archive/2006/06/29/55767.html">导入HTTPS证书</a></li>
<li><a target="_blank" rel="noopener" href="http://www.binghe.org/2010/03/use-httpsurlconnection-in-java/">Java中用HttpsURLConnection访问Https链接的问题</a></li>
<li><a target="_blank" rel="noopener" href="http://toutiao.com/a6346453007501377794/?iid=5952171257">实现HTTPS，原来如此简单</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.jobbole.com/48369/">HTTPS连接的前几毫秒发生了什么</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/tenfyguo/article/details/40958727">下】安全HTTPS-全面详解对称加密，非对称加密，数字签名，数字证书和HTTPS</a></li>
<li><a target="_blank" rel="noopener" href="http://www.codeceo.com/article/https-make-safe.html">详解Https是如何确保安全的？ – 码农网</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/network/security/encrypt-decrypt-signature-certificate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/network/security/encrypt-decrypt-signature-certificate/" class="post-title-link" itemprop="url">加密/解密/签名/证书及在Java中的使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-10-21 12:26:00" itemprop="dateCreated datePublished" datetime="2016-10-21T12:26:00+08:00">2016-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-23 13:04:00" itemprop="dateModified" datetime="2021-04-23T13:04:00+08:00">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文属于安全专题: 旨在介绍加密和解密相关内容。<br>主要包括：加密解密算法的分类、常见的加密和解密算法以及Java API</p>
</blockquote>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>这是一种与消息认证码结合使用以确保消息完整性的技术。主要使用单向散列函数算法，可用于检验消息的完整性，<br>和通过散列密码直接以文本形式保存等，目前广泛使用的算法有 MD4、MD5、SHA-1，jdk1.5对上面都提供了支持，<br>在java中进行消息摘要很简单， <code>java.security.MessageDigest</code> 提供了一个简易的操作方法：</p>
<h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取md5摘要</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> info 要加密的信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String 获取md5摘要</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">digestWithMD5</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] digesta = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 得到一个md5的消息摘要</span></span><br><span class="line">        MessageDigest messageDigest = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        <span class="comment">// 添加要进行计算摘要的信息</span></span><br><span class="line">        messageDigest.update(info.getBytes());</span><br><span class="line">        <span class="comment">// 得到该摘要</span></span><br><span class="line">        digesta = messageDigest.digest();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将摘要转为字符串</span></span><br><span class="line">    <span class="keyword">return</span> EncodingUtils.byte2hex(digesta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进行SHA加密</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> info 要加密的信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String 加密后的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">digestWithSHA</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] digesta = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 得到一个SHA-1的消息摘要</span></span><br><span class="line">        MessageDigest messageDigest = MessageDigest.getInstance(<span class="string">&quot;SHA-1&quot;</span>);</span><br><span class="line">        <span class="comment">// 添加要进行计算摘要的信息</span></span><br><span class="line">        messageDigest.update(info.getBytes());</span><br><span class="line">        <span class="comment">// 得到该摘要</span></span><br><span class="line">        digesta = messageDigest.digest();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将摘要转为字符串</span></span><br><span class="line">    <span class="keyword">return</span> EncodingUtils.byte2hex(digesta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><p><a href="/Java/io/object-serialization/">之前的文章</a> 介绍Java对象序列化的时候，曾经提到了对序列化后的对象加密来提高安全性。本文重点介绍<strong>Java的加解密API及其运用</strong>。</p>
<p>消息摘要只能检查消息的完整性，但是单向的，对明文消息并不能加密，要加密明文的消息的话，就要使用其他的算法，要确保机密性，我们需要使用私钥密码术来交换私有消息。　</p>
<p>加密，是对原文进行编码生成难以获取原文的乱码的过程。而解密则是对加密后的文本还原成原文的过程。</p>
<h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><p>A用一个密钥对一个文件加密，而B读取这个文件的话，则需要和A一样的密钥，双方共享一个私钥（而在web环境下，私钥在传递时容易被侦听）：　　</p>
<p>对称加密, 就是在编码时使用的密钥<code>e</code>和解码时一样<code>d</code>(<code>e=d</code>), 统称为密钥<code>k</code> .</p>
<p> <strong>加解密的过程</strong></p>
<p>发送端用共享密钥<code>k</code>对明文<code>p</code>进行加密, 得到密文<code>c</code>, 并将得到的密文发送给接收端, 接收端收到密文后, 并用其相同的共享密钥k对密文进行解密, 得出明文<code>p</code>.</p>
<p><strong>不足</strong></p>
<ol>
<li>共享密钥：发送方和接收方需要首先共享相同的密钥, 即存在密钥<code>k</code>的分发问题, 如何安全的把共享密钥在双方进行分享, 这本身也是一个如何安全通信的问题:</li>
</ol>
<ul>
<li>一种方法是提前双方约定好, 不通过具体的通信进行协商, 避免被监听和截获.</li>
<li>另一种方式是通过非对称加密信道进行对称密码的分发和共享, 即<strong>混合加密系统</strong>.</li>
</ul>
<ol>
<li>每方一个秘钥：密钥管理的复杂度问题. 由于对称加密的密钥是一对一的使用方式, 若一方要跟n方通信, 则需要维护n对密钥.</li>
</ol>
<p><strong>优点</strong></p>
<p>加密和解密的速度要比非对称加密快很多, 因此常用非对称加密建立的安全信道进行共享密钥的分享, 完成后, 具体的加解密则使用对称加密. 即<code>混合加密系统</code>.</p>
<p>密钥<code>k</code>的长度对解密破解的难度有很重大的影响, <code>k</code>的长度越长, 对应的密码空间就越大, 遭到暴力破解或者词典破解的难度就更大, 就更加安全.</p>
<p>使用私钥加密的话，</p>
<ul>
<li>首先需要一个密钥，可用 <code>javax.crypto.KeyGenerator</code> 产生一个密钥 (<code>java.security.Key</code>),</li>
<li>然后传递给一个加密工具(<code>javax.crypto.Cipher</code>), 该工具再使用相应的算法来进行加密，主要 对称算法有 ES（实际密钥只用到56位），AES（支持三种密钥长度：128、192、256位），通常首先128位，其他的还有DESede等，jdk1.5种也 提供了对对称算法的支持，</li>
</ul>
<p><strong>常见的对称加密算法</strong></p>
<p>一般加密和解密的算法是公开的, 需要保持隐秘的是密钥<code>k</code>, 流行的<code>对称加密</code>算法有：<code>DES</code>, <code>Triple-DES</code>, <code>RC2</code>和<code>RC4</code></p>
<h2 id="创建加密密钥"><a href="#创建加密密钥" class="headerlink" title="创建加密密钥"></a>创建加密密钥</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建对称加密的密匙</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> algorithm 加密算法,可用 DES,DESede,Blowfish</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> SecretKey 秘密（对称）密钥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SecretKey <span class="title">createSecretKey</span><span class="params">(String algorithm)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明KeyGenerator对象</span></span><br><span class="line">    KeyGenerator keygen;</span><br><span class="line">    <span class="comment">// 声明 密钥对象</span></span><br><span class="line">    SecretKey secretKey = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 返回生成指定算法的秘密密钥的 KeyGenerator 对象</span></span><br><span class="line">        keygen = KeyGenerator.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 生成一个密钥</span></span><br><span class="line">        secretKey = keygen.generateKey();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回密匙</span></span><br><span class="line">    <span class="keyword">return</span> secretKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="加密-1"><a href="#加密-1" class="headerlink" title="加密"></a>加密</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据密匙进行DES加密</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key  密匙</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> info 要加密的信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String 加密后的信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">encryptByDES</span><span class="params">(SecretKey key, String info)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义 加密算法,可用 DES,DESede,Blowfish</span></span><br><span class="line">    String algorithm = <span class="string">&quot;DES&quot;</span>;</span><br><span class="line">    <span class="comment">// 加密随机数生成器 (RNG),(可以不写)</span></span><br><span class="line">    SecureRandom secureRandom = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">    <span class="comment">// 定义要生成的密文</span></span><br><span class="line">    <span class="keyword">byte</span>[] cipherByte = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 得到加密/解密器</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 用指定的密钥和模式初始化Cipher对象</span></span><br><span class="line">        <span class="comment">// 参数:(ENCRYPT_MODE, DECRYPT_MODE, WRAP_MODE,UNWRAP_MODE)</span></span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, key, secureRandom);</span><br><span class="line">        <span class="comment">// 对要加密的内容进行编码处理,</span></span><br><span class="line">        cipherByte = cipher.doFinal(info.getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回密文的十六进制形式</span></span><br><span class="line">    <span class="keyword">return</span> EncodingUtils.byte2hex(cipherByte);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据密匙进行DES解密</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key   密匙</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sInfo 要解密的密文</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> String 返回解密后信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">decryptByDES</span><span class="params">(SecretKey key, String sInfo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义 加密算法,</span></span><br><span class="line">    String algorithm = <span class="string">&quot;DES&quot;</span>;</span><br><span class="line">    <span class="comment">// 加密随机数生成器 (RNG)</span></span><br><span class="line">    SecureRandom secureRandom = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">    <span class="keyword">byte</span>[] cipherByte = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 得到加密/解密器</span></span><br><span class="line">        Cipher cipher = Cipher.getInstance(algorithm);</span><br><span class="line">        <span class="comment">// 用指定的密钥和模式初始化Cipher对象</span></span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, key, secureRandom);</span><br><span class="line">        <span class="comment">// 对要解密的内容进行编码处理</span></span><br><span class="line">        cipherByte = cipher.doFinal(EncodingUtils.hex2byte(sInfo));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return byte2hex(cipherByte);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(cipherByte);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="秘钥共享"><a href="#秘钥共享" class="headerlink" title="秘钥共享"></a>秘钥共享</h2><p>不使用随机因子</p>
<p>//TODO 待完善</p>
<h1 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h1><p>加密的密钥<code>e</code>和解密的密钥<code>d</code>是不同的（<code>e!=d</code>）, 并且加密的密钥<code>e</code>是公开的, 叫做 <code>公钥</code>, 而解密的密钥<code>d</code>是保密的, 叫<code>私钥</code>.</p>
<p>速度很慢（比对称加密慢100到1000倍），公钥的主要算法有RSA，还包括Blowfish,Diffie-Helman 等，jdk1.5种提供了对RSA的支持，是一个改进的地方</p>
<p>RSA算法（由发明者Rivest，Shmir和Adleman姓氏首字母缩写而来）是著名的公开密钥加密算法。</p>
<p>非对称加密的另一用途是身份验证：用私钥加密的信息，可以用公钥对其解密，接收者由此可知这条信息确实来自于拥有私钥的某人。私钥加密的过程即数字签名。</p>
<p>用公钥加密的数据只有私钥才能解密；相反的，用私钥加密的数据只有公钥才能解密，正是这种不对称性才使得公用密钥密码系统被广泛应用。</p>
<p><strong>过程</strong></p>
<p>加密一方使用接收方的公钥<code>e</code> <strong>(如何找到呢？大部分的公钥传递工作实际上都是通过数字证书来实现的)</strong>, 然后用公钥<code>e</code>对明文<code>p</code>进行加密后得到密文<code>c</code>, 并将得到的密文发送给接收方, 接收方收到密文后, 用自己保留的私钥<code>d</code>进行解密, 得到明文<code>p</code>, 需要注意的是：用公钥加密的密文, 只有拥有私钥的一方才能解密, 这样就可以解决加密的各方可以统一使用一个公钥即可.</p>
<p><strong>优点</strong></p>
<ol>
<li>不存在密钥分发的问题, 解码方可以自己生成密钥对, 一个做私钥存起来, 另外一个作为公钥进行发布.</li>
<li>解决了密钥管理的复杂度问题, 多个加密方都可以使用一个已知的公钥进行加密, 但只有拥有私钥的一方才能解密.</li>
</ol>
<p><strong>不足</strong></p>
<p>加解密的速度没有对称加密快.</p>
<p><strong>常见的非对称加密算法</strong></p>
<p>最常见的非对称加密算法就是RSA</p>
<h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.Key;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyPairGenerator;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyPair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] plainText=originString.getBytes(<span class="string">&quot;UTF8&quot;</span>);　　</span><br><span class="line"><span class="comment">//构成一个RSA密钥　</span></span><br><span class="line">System.out.println(<span class="string">&quot;Start generating RSA key&quot;</span>);</span><br><span class="line">KeyPairGenerator keyGen=KeyPairGenerator.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">keyGen.initialize(<span class="number">1024</span>);　　</span><br><span class="line">KeyPair key=keyGen.generateKeyPair();　</span><br><span class="line">System.out.println(<span class="string">&quot;Finish generating RSA key&quot;</span>);　　</span><br><span class="line"><span class="comment">//获得一个RSA的Cipher类，使用公鈅加密　　</span></span><br><span class="line">Cipher cipher=Cipher.getInstance(<span class="string">&quot;RSA/ECB/PKCS1Padding&quot;</span>);　</span><br><span class="line">System.out.println(<span class="string">&quot;\n&quot;</span>+cipher.getProvider().getInfo());　</span><br><span class="line">System.out.println(<span class="string">&quot;\nStart encryption&quot;</span>);　</span><br><span class="line">cipher.init(Cipher.ENCRYPT_MODE,key.getPublic());　　</span><br><span class="line"><span class="keyword">byte</span>[] cipherText=cipher.doFinal(plainText);　　</span><br><span class="line">System.out.println(<span class="string">&quot;Finish encryption:&quot;</span>);　　</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(cipherText,<span class="string">&quot;UTF8&quot;</span>));　　</span><br><span class="line"><span class="comment">//使用私鈅解密　　</span></span><br><span class="line">System.out.println(<span class="string">&quot;\nStart decryption&quot;</span>);　</span><br><span class="line">cipher.init(Cipher.DECRYPT_MODE,key.getPrivate());　　</span><br><span class="line"><span class="keyword">byte</span>[] newPlainText=cipher.doFinal(cipherText);　　</span><br><span class="line">System.out.println(<span class="string">&quot;Finish decryption:&quot;</span>);　　</span><br><span class="line">String(newPlainText,<span class="string">&quot;UTF8&quot;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h1><p>混合加密系统, 比如在两个节点间通过便捷的公开密码加密技术建立起安全通信, 然后再用安全的通信产生并发送临时的随机对称密钥, 通过更快的对称加密技术对剩余的数据进行加密.</p>
<h1 id="Cipher"><a href="#Cipher" class="headerlink" title="Cipher"></a>Cipher</h1><p>KeyGenerator</p>
<p>javax.crypto.KeyGenerator<br>public final SecretKey generateKey()<br>//生成一个密钥</p>
<p>public static final KeyGenerator getInstance(String algorithm)<br>//返回生成指定算法的秘密密钥的KeyGenerator对象。</p>
<p>javax.crypto 接口 SecretKey</p>
<p>javax.crypto.Cipher 此类为加密和解密提供密码功能。它构成了 Java Cryptographic Extension (JCE) 框架的核心</p>
<p>public final void init(int opmode,Key key)</p>
<p>public final byte[] doFinal(byte[] input) 按单部分操作加密或解密数据，或者结束一个多部分操作</p>
<p>java.security.KeyPairGenerator</p>
<p>static KeyPairGenerator getInstance(String algorithm)<br>返回生成指定算法的 public/private 密钥对的 KeyPairGenerator 对象。</p>
<p>java.security.Signature</p>
<p>使用 Signature 对象签名数据或验证签名包括以下三个阶段：</p>
<ol>
<li>初始化，使用<br>初始化验证签名的公钥（请参见 initVerify），或使用<br>初始化签署签名的私钥（也可以选择“安全随机数生成器”）initSign(PrivateKey)和initSign(PrivateKey, SecureRandom)）。</li>
<li>更新<br>根据初始化类型，这可更新要签名或验证的字节。请参见 update 方法。</li>
<li>签署或验证所有更新字节的签名。请参见 sign 方法和 verify 方法。</li>
</ol>
<h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><p>上面讨论了非对称加密技术在编码中的使用, 解决的是传送数据的私密性, 一般是用公钥作为<code>加密key</code>, 而私钥作为解密<code>key</code>, 那假如是用私钥作为加密key, 而公钥作为解密key呢？<br>java中为数字签名提供了良好的支持，<code>java.security.Signature</code> 类提供了消息签名：</p>
<blockquote>
<p>这里要求私钥加密后公钥可解密</p>
</blockquote>
<p>由于私钥只有对应一方才知道, 因此若通过对应的公钥可以验证对方是用对应的私钥进行加密的, 则可以说明对方的身份, 这就是<strong>数字签名</strong>.</p>
<p> 数字签名需要解决的两个任务是：</p>
<ol>
<li>谁编写的报文；</li>
<li>报文的内容是否被篡改过；</li>
</ol>
<p>数字签名的过程一般如下：</p>
<ol>
<li><em>发送方A</em> 首先对变长的报文提取成一个定长的摘要, 一般是<code>md5</code>等</li>
<li><em>A</em> 对摘要应用了一个签名函数, 并且用自己的私钥作为参数, 因为只有<em>A</em>才知道私钥, 所以正确的签名会说明签名者就是其所有者.</li>
<li>一旦计算出签名, 节点<em>A</em>就将其附加到报文的末尾, 并将报文和签名一起都发送给<em>B</em></li>
<li>在<em>接收端B</em>, 首先会按照同样的算法计算出报文的摘要, 然后对签名用<em>A</em>的公钥进行解码, 得出解码后的摘要, 两个摘要进行比较, 则可以<strong>判断是否是<em>A</em>发送的且内容没被篡改过</strong>.</li>
</ol>
<p><img src="/images/network/security/validateSign.png" alt="数字签名"></p>
<h2 id="创建公钥和私钥"><a href="#创建公钥和私钥" class="headerlink" title="创建公钥和私钥"></a>创建公钥和私钥</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建密匙组，并将公匙，私匙放入到指定文件中</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 默认放入mykeys.bat文件中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createPairKeyWithDSA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据特定的算法一个密钥对生成器</span></span><br><span class="line">        KeyPairGenerator keygen = KeyPairGenerator.getInstance(<span class="string">&quot;DSA&quot;</span>);</span><br><span class="line">        <span class="comment">// 加密随机数生成器 (RNG)</span></span><br><span class="line">        SecureRandom random = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">        <span class="comment">// 重新设置此随机对象的种子</span></span><br><span class="line">        random.setSeed(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 使用给定的随机源（和默认的参数集合）初始化确定密钥大小的密钥对生成器</span></span><br><span class="line">        keygen.initialize(<span class="number">512</span>, random);<span class="comment">// keygen.initialize(512);</span></span><br><span class="line">        <span class="comment">// 生成密钥组</span></span><br><span class="line">        KeyPair keys = keygen.generateKeyPair();</span><br><span class="line">        <span class="comment">// 得到公匙</span></span><br><span class="line">        PublicKey pubkey = keys.getPublic();</span><br><span class="line">        <span class="comment">// 得到私匙</span></span><br><span class="line">        PrivateKey prikey = keys.getPrivate();        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DSA签名"><a href="#DSA签名" class="headerlink" title="DSA签名"></a>DSA签名</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 利用私匙对信息进行签名 把签名后的信息放入到指定的文件中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> info     要签名的信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> signfile 存入的文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signWithDSA</span><span class="params">(String info, String signfile)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从文件当中读取私匙</span></span><br><span class="line">    PrivateKey myprikey = ...;</span><br><span class="line">    <span class="comment">// 从文件中读取公匙</span></span><br><span class="line">    PublicKey mypubkey = ...;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Signature 对象可用来生成和验证数字签名</span></span><br><span class="line">        Signature signet = Signature.getInstance(<span class="string">&quot;DSA&quot;</span>);</span><br><span class="line">        <span class="comment">// 初始化签署签名的私钥</span></span><br><span class="line">        signet.initSign(myprikey);</span><br><span class="line">        <span class="comment">// 更新要由字节签名或验证的数据</span></span><br><span class="line">        signet.update(info.getBytes());</span><br><span class="line">        <span class="comment">// 签署或验证所有更新字节的签名，返回签名</span></span><br><span class="line">        <span class="keyword">byte</span>[] signed = signet.sign();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="验证DSA签名"><a href="#验证DSA签名" class="headerlink" title="验证DSA签名"></a>验证DSA签名</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取数字签名文件 根据公匙，签名，信息验证信息的合法性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 验证成功 false 验证失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateSignWithDSA</span><span class="params">(String signfile)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取公匙</span></span><br><span class="line">    PublicKey mypubkey = ...;</span><br><span class="line">    <span class="comment">// 读取签名</span></span><br><span class="line">    <span class="keyword">byte</span>[] signed =...;</span><br><span class="line">    <span class="comment">// 读取信息</span></span><br><span class="line">    String info = ...;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始一个Signature对象,并用公钥和签名进行验证</span></span><br><span class="line">        Signature signetcheck = Signature.getInstance(<span class="string">&quot;DSA&quot;</span>);</span><br><span class="line">        <span class="comment">// 初始化验证签名的公钥</span></span><br><span class="line">        signetcheck.initVerify(mypubkey);</span><br><span class="line">        <span class="comment">// 使用指定的 byte 数组更新要签名或验证的数据</span></span><br><span class="line">        signetcheck.update(info.getBytes());</span><br><span class="line">        System.out.println(info);</span><br><span class="line">        <span class="comment">// 验证传入的签名</span></span><br><span class="line">        <span class="keyword">return</span> signetcheck.verify(signed);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="数字证书和CA"><a href="#数字证书和CA" class="headerlink" title="数字证书和CA"></a>数字证书和CA</h1><h2 id="3-1-确认主机的真实性"><a href="#3-1-确认主机的真实性" class="headerlink" title="3.1. 确认主机的真实性"></a>3.1. 确认主机的真实性</h2><p>**采用https 的server（服务器）必须从CA（Certificate Authority）申请一个用于证明服务器用途类型的数字证书（或者叫CA证书）.该证书只有用于对应的server 时，客户端才信任此主机. **</p>
<p>CA（Certificate Authority）即”认证机构”，是负责签发证书、认证证书、管理已颁发证书的机构，是PKI（Public Key Infrastructure，公钥基础设施）的核心。它要制定政策和具体步骤来验证、识别用户身份，并对用户证书进行签名，以确保证书持有者的身份和公钥的拥有权。</p>
<p><strong>CA 也拥有一个证书（内含公钥）和私钥</strong>。网上的公众用户通过验证 CA 的签字从而信任CA ，任何人都可以得到 CA 的证书（含公钥），用以验证它所签发的证书。</p>
<p> </p>
<h2 id="3-2-什么是数字证书"><a href="#3-2-什么是数字证书" class="headerlink" title="3.2. 什么是数字证书"></a>3.2. 什么是数字证书</h2><p><strong>数字证书（</strong>CA证书是经过认证的数字证书<strong>）</strong>是一个用于互联网通讯中认证身份的工具，由权威机构——CA机构（Certificate Authority）发行。其作用类似于司机的驾驶执照和公民身份证。CA作为公正的第三方来确保证书的有效性[6]。全国存在多个CA机构（只要你有公信力你也可以成立一家CA机构）。</p>
<p><strong>数字证书包含一个公钥以及该密钥所有者的信息。证书还标明有有效期，并通过另一密钥（CA私钥）进行签名，</strong>该密钥能保证这些属性的真实性，最重要的是，保证公钥本身的真实性[14]。最简单的证书包含一个<strong>公钥</strong>、名称以及证书授权中心的数字签名（<strong>公开密钥只是证书的一部分内容</strong>）。目前，证书的格式和验证方法普遍遵循<strong>X.509</strong> 国际标准。</p>
<p>CA机构自身也拥有一个<strong>证书</strong>（<strong>内含公钥</strong>）和一个<strong>私钥。</strong></p>
<p><strong>用户如果想得到一个数字证书，他应先向 CA申请，CA审查申请者的身份后，给他分配一个公钥，并将公钥与申请者的身份信息绑在一起，同时用自己的私钥签字，最终生成一个证书，发给申请者；同时还将一个与公钥关联的私钥也发给申请者。证书的内容主要有：CA信息、CA签字、证书拥有者信息、证书公钥和证书有效期等。</strong></p>
<p>某人需要验证一个证书时，用签发该证书的CA的公钥来解密其签名信息，以验证证书是否可信。CA证书也需要验证，验证CA证书是一个递归上溯的过程，验证过程终止于根证书。<strong>根证书是一份特殊的证书，它的签发者是它本身，下载根证书就表明用户对该根证书，以及其所签发的证书都信任。</strong></p>
<p><img src="http://img.blog.csdn.net/20141109225903192?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGVuZnlndW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p> </p>
<h2 id="3-3-数字证书基本原理"><a href="#3-3-数字证书基本原理" class="headerlink" title="3.3. 数字证书基本原理"></a>3.3. 数字证书基本原理</h2><p>数字证书采用<strong>公开密钥加密体制</strong>，利用一个强关联的密钥对进行加、解密。证书拥有者保存好自己的私钥，用它进行解密和签名；并把公钥公开，供一组用户所共享，用于加密和验证签名。</p>
<p>1、<strong>加密：</strong>发送数据时，发送方使用接收方的公钥对数据加密，接收方用私钥解密，还原消息。算法保证公钥加密的数据只有对应的<strong>私钥</strong>才能解密。</p>
<p>2、<strong>数字签名：</strong>证书拥有者用私钥对信息进行加密，由于私钥仅为本人所有，这样就生成了别人无法伪造的数据，该数据即<strong>数字签名</strong>。采用数字签名，能够确认以下两点：</p>
<p>（1）保证信息是由签名者所发送，签名者不能否认或者难以否认；</p>
<p>（2）保证信息自签发后到收到为止，未曾做过任何修改，签发的文件是真实的文件。</p>
<p>算法保证只有公钥才能解开私钥加密的信息。</p>
<h2 id="3-4-如何生成数字证书"><a href="#3-4-如何生成数字证书" class="headerlink" title="3.4. 如何生成数字证书"></a>3.4. 如何生成数字证书</h2><p>略</p>
<p> </p>
<p>A用私钥加密了，那么B接受到消息后，用A提供的公钥解密；那么现在有个讨厌的C，他把消息拦截了，然后用自己的私 钥加密，同时把自己的公钥发给B，并告诉B，那是A的公钥，结果….，这时候就需要一个中间机构出来说话了（相信权威，我是正确的），就出现了 Certificate Authority(也即CA），有名的CA机构有Verisign等，目前数字认证的工业标准是：CCITT的X.509：数字证书：它将一个身份标识连同公钥一起进行封装，并由称为认证中心或 CA 的第三方进行数字签名。</p>
<p><strong>实际上, 好多的公钥都是通过数字证书进行发布的</strong>, 数字证书类似一个人的身份证一样, 由对应的官方的颁发结构颁发的, 类似一个人的身份证有姓名, 身份证ID, 有效期, 颁发机构-一般是某某派出所等, 数字证书也有类似的形式.</p>
<p>基本的数字证书包括了一些常见的信息：</p>
<ol>
<li>对象的名称（人, 服务器, 组织等）</li>
<li>过期时间</li>
<li>对象的公钥</li>
<li>证书发布者（由谁为证书担保）</li>
<li>来自证书发布者的数字签名.<br>…</li>
</ol>
<p>需要注意的是, 任何人都可以创建一个证书, 但不是所有人都能够获得受人尊敬的签发权从而为证书信息提供担保, 并用其私人密钥签发证书.</p>
<p>不幸的是, 数字证书没有单一的全球标准, 但现在使用的大多数证书是以一种标准格式– <code>X.509 v3</code>, 来存储它们的信息.</p>
<p>x.509证书格式：</p>
<table>
<thead>
<tr>
<th><strong>字段</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>版本号</td>
<td>这个证书的X.509证书版本号, 现在通常是版本3</td>
</tr>
<tr>
<td>序列号</td>
<td>证书颁发机构CA生成的唯一整数, CA生成的每个证书都要有一个唯一的系列号, 类似身份证号码</td>
</tr>
<tr>
<td>签名算法ID</td>
<td>签名使用是算法, 如用RSA加密的MD2摘要</td>
</tr>
<tr>
<td>证书颁发者</td>
<td>以X.500格式说明的CA的组织名称</td>
</tr>
<tr>
<td>有效期</td>
<td>证书的有效期, 由一个起始日期和一个结束日期来表示</td>
</tr>
<tr>
<td>对象名称</td>
<td>证书中描述的实体, 比如一个人或者一个组织, 对象名称以x.500格式表示</td>
</tr>
<tr>
<td>对象的公开密钥信息</td>
<td>证书对象的公钥, 公钥使用的算法, 以及所有附加的参数</td>
</tr>
<tr>
<td>发布者唯一的ID(可选)</td>
<td>可选的证书发布者唯一ID, 这样可以重用相同的发布者名称了</td>
</tr>
<tr>
<td>对象唯一的ID（可选)</td>
<td>可选的证书对象唯一ID, 这样就可以重用相同的对象名称了</td>
</tr>
<tr>
<td>扩展</td>
<td>一些扩展信息</td>
</tr>
<tr>
<td>证书的颁发机构签名</td>
<td>CA用指定的签名算法对上述所有字段的数字签名</td>
</tr>
</tbody></table>
<p>x.509证书有很多种, 如服务器端证书, 个人证书等. 每个证书均有对应于证书公钥的私钥, 私钥不能被导出, 访问一般需要密码等. 浏览器会默认存储一些受信任的根证书颁发机构的证书.</p>
<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><h3 id="客户端对服务器认证"><a href="#客户端对服务器认证" class="headerlink" title="客户端对服务器认证"></a>客户端对服务器认证</h3><p>在支付网站中, 用户需要确认他们输入支付密码的站点是真正的经过认证的站点, 而不是被钓鱼的网站, 因此用户有必要认证对应的服务器, 而这种方式是通过服务器证书来进行的. 过程大概如下：</p>
<ol>
<li><p>通过https建立一个安全web事务之后, 浏览器会自动获取所连服务器的数字证书；</p>
<p> 其中服务器证书包括了：</p>
<p> Web站点名称和主机名<br> Web站点的公钥<br> 颁发机构的名称<br> 颁发机构给证书的签名</p>
</li>
<li><p>若服务器<strong>没有证书</strong>, 则安全连接失败.</p>
</li>
<li><p>浏览器首先检查服务器<strong>证书是否还在有效期</strong>内, 若过期, 则提示失效；</p>
</li>
<li><p>浏览器查看服务器证书对应的CA, 若该CA是很权威的机构, 则浏览器可能已经知道了对应的公钥了（<strong>浏览器会预先安装很多签名颁发机构的证书并认为是受信任的</strong>）, 这时, 浏览器用CA的数字证书里面的公钥来<strong>验证</strong>该CA颁发的服务器<strong>证书</strong>的有效性. 类似去公安局验证某人的身份证是否是真的.</p>
</li>
<li><p>若浏览器对签名颁发机构CA一无所知, 浏览器<strong>无法确定</strong>是否该信任这个签名颁发机构, 它通常会向用户<strong>提示</strong>一个对话框, 看看他是否相信这个签名发布者.</p>
</li>
<li><p>一旦完成了对服务器证书的验证, 接下来就可以<strong>使用服务器证书</strong>里面的<strong>公钥</strong>进行服务器身份的<strong>验证</strong>；</p>
</li>
<li><p>客户端生成一个<strong>随机数</strong>给到服务器, 要求对应服务器用证书的<strong>私钥</strong>进行<strong>签名</strong>.</p>
</li>
<li><p>服务器对随机数进行签名, 并回传给到客户端.</p>
</li>
<li><p>客户端用服务器证书的<strong>公钥</strong>对<strong>随机数</strong>的<strong>签名</strong>进行<strong>验证</strong>, 若验证通过, 则说明对应的服务器确实拥有对应服务器证书的私钥, 因此判断服务器的身份正常. 否则, 则任务服务器身份被伪造.</p>
</li>
</ol>
<h3 id="服务器对客户端认证"><a href="#服务器对客户端认证" class="headerlink" title="服务器对客户端认证"></a>服务器对客户端认证</h3><p>客户端证书和服务器证书类似, 只是服务器证书增加一些对服务器站点名称和主机名等内容的签注, 客户端证书一般是某个机构针对个人颁发的, 用于标识个人的身份. 如财付通提示用户安装对应的数字证书, 就是一个客户端证书, <strong>在安装客户端证书的时候, 实际上会把用户对应该证书的私钥要保存起来.</strong> 客户端用私钥进行签名, 然后第三方用客户端证书的公钥进行验签实现对客户端身份的认证.</p>
<h3 id="双向认证"><a href="#双向认证" class="headerlink" title="双向认证"></a>双向认证</h3><p>在发送已加密的HTTP报文前, 客户端和服务器要进行一次SSL握手, 在这个握手的过程中, 它们要完成以下工作：</p>
<ol>
<li>  交换协议版本号；</li>
<li>  选择一个两端都了解的密码；</li>
<li>  对两端的身份进行验证；</li>
<li>  生成临时的会话密钥, 后续便用该密钥进行加密信道.</li>
</ol>
<h3 id="信任所有的证书"><a href="#信任所有的证书" class="headerlink" title="信任所有的证书"></a>信任所有的证书</h3><h3 id="密钥库"><a href="#密钥库" class="headerlink" title="密钥库"></a>密钥库</h3><p>java平台为你提供了密钥库，用作密钥和证书的资源库。从物理上讲，密钥库是缺省名称为 <code>.keystore</code> 的文件（有一个选项使它成为加密文件）。密钥和证书可以拥有名称（称为别名），每个别名都由唯一的密码保护。密钥库本身也受密码保护；您可以选择让每个别名密码与主密钥库密码匹配。　　</p>
<p>使用工具keytool，我们来做一件自我认证的事情吧（相信我的认证）：　　</p>
<ol>
<li><p>创建密钥库<br><code>keytool -genkey -v -alias feiUserKey -keyalg RSA</code><br>默认在自己的home目录下（windows系统是c:\documents and settings&lt;你的用户名&gt; 目录下的.keystore文件），创建我们用 RSA 算法生成别名为 feiUserKey 的自签名的证书,如果使用了-keystore mm 就在当前目录下创建一个密钥库mm文件来保存密钥和证书。　</p>
</li>
<li><p>查看证书：<br><code>keytool -list</code> 列举了密钥库的所有的证书　　也可以在dos下输入<br><code>keytool -help</code> 查看帮助。</p>
</li>
<li><p>JAR的签名　　</p>
</li>
</ol>
<p>JAR文件在Java中相当于 ZIP 文件，允许将多个 Java 类文件打包到一个具有 .jar 扩展名的文件中，然后可以对这个jar文件进行数字签名，以证实其来源和真实性。该 JAR 文件的接收方可以根据发送方的签名决定是否信任该代码，并可以确信该内容在接收之前没有被篡改过。同时在部署中，可以通过在策略文件中放置访问控制语句根据签名者的身份分配对机器资源的访问权。这样，有些Applet的安全检验访问就得以进行。　　</p>
<p>使用<code>jarsigner</code>工具可以对jar文件进行签名：　　</p>
<p>现在假设我们有个Test.jar文件（可以使用jar命令行工具生成）：　　</p>
<p><code>jarsigner Test.jar feiUserKey</code> (这里我们上面创建了该别名的证书) ，详细信息可以输入<code>jarsigner</code>查看帮助　　</p>
<p>验证其真实性：<code>jarsigner -verify　Test.jar</code><br>(注意，验证的是jar是否被修改了，但不检验减少的，如果增加了新的内容，也提示，但减少的不会提示。）　　</p>
<p>使用Applet中：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;applet code=&quot;Test.class&quot; archive=&quot;Test.jar&quot; width=&quot;150&quot; height=&quot;100&quot;&gt;&lt;/applet&gt;</span><br></pre></td></tr></table></figure>
<p>然后浏览器就会提示你：准许这个会话-拒绝-始终准许-查看证书等。　　</p>
<h2 id="安全套接字层（SSL-Secure-Sockets-Layer）和传输层安全性（TLS-Transport-Layer-Security）"><a href="#安全套接字层（SSL-Secure-Sockets-Layer）和传输层安全性（TLS-Transport-Layer-Security）" class="headerlink" title="安全套接字层（SSL Secure Sockets Layer）和传输层安全性（TLS Transport Layer Security）"></a>安全套接字层（SSL Secure Sockets Layer）和传输层安全性（TLS Transport Layer Security）</h2><p>安全套接字层和传输层安全性是用于在客户机和服务器之间构建安全的通信通道的协议。它也用来为客户机认证服务器，以及（不太常用的）为服务器认证客户机。该协议在浏览器应用程序中比较常见，浏览器窗口底部的锁表明 SSL/TLS 有效：　　</p>
<p>1）当使用 SSL/TLS（通常使用 https:// URL）向站点进行请求时，从服务器向客户机发送一个证书。客户机使用已安装的公共 CA 证书通过这个证书验证服务器的身份，然后检查 IP 名称（机器名）与客户机连接的机器是否匹配。　　</p>
<p>2）客户机生成一些可以用来生成对话的私钥（称为会话密钥）的随机信息，然后用服务器的公钥对它加密并将它发送到服务器。服务器用自己的私钥解密消息，然后用该随机信息派生出和客户机一样的私有会话密钥。通常在这个阶段使用 RSA 公钥算法。　　</p>
<p>3）客户机和服务器使用私有会话密钥和私钥算法（通常是 RC4）进行通信。使用另一个密钥的消息认证码来确保消息的完整性。java中<code>javax.net.ssl.SSLServerSocketFactory</code>类提供了一个很好的SSLServerSocker的工 厂类，熟悉Socket编程的读者可以去练习。当编写完服务器端之后，在浏览器上输入https://主机名:端口就会通过SSL/TLS进行通话了。</p>
<p>注 意：运行服务端的时候要带系统环境变量运行：<br><code>javax.net.ssl.keyStore=密钥库</code>(创建证书时，名字应该为主机名，<br>比如 localhost)和<br><code>javax.net.ssl.keyStorePassword=你的密码</code></p>
<hr>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="[参考文献]:"></a>[参考文献]:</h1><ol>
<li>[安全专题][a-security]</li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/tenfyguo/article/details/40922813">安全HTTPS-全面详解对称加密，非对称加密，数字签名，数字证书和HTTPS</a></li>
<li><a href="">Applied Crypotography(Bruce Schneier)</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/database/MySQL/syntax_3_multitable_join/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/database/MySQL/syntax_3_multitable_join/" class="post-title-link" itemprop="url">MySQL多表关联与笛卡尔积</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-10-13 00:00:00" itemprop="dateCreated datePublished" datetime="2016-10-13T00:00:00+08:00">2016-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-23 13:04:00" itemprop="dateModified" datetime="2021-04-23T13:04:00+08:00">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DataBase/" itemprop="url" rel="index"><span itemprop="name">DataBase</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="多表关联"><a href="#多表关联" class="headerlink" title="多表关联"></a>多表关联</h1><p>内联接 外联接 左外联接 右外连接 全外连接 自然联接</p>
<h1 id="笛卡尔"><a href="#笛卡尔" class="headerlink" title="笛卡尔"></a>笛卡尔</h1><p>笛卡尔（Descartes）乘积又叫直积。假设集合A={a,b}，集合B={0,1,2}，则两个集合的笛卡尔积为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">(a,0),</span><br><span class="line">(a,1),</span><br><span class="line">(a,2),</span><br><span class="line">(b,0),</span><br><span class="line">(b,1),</span><br><span class="line">(b,2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以扩展到多个集合的情况。</p>
<h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a,b <span class="keyword">where</span> a.x <span class="operator">=</span> b.x; <span class="operator">/</span><span class="operator">/</span>内连接</span><br></pre></td></tr></table></figure>
<p>与</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">inner</span> <span class="keyword">join</span> b <span class="keyword">on</span> a.x<span class="operator">=</span>b.x; <span class="operator">/</span><span class="operator">/</span>内连接</span><br></pre></td></tr></table></figure>
<p>效果是一样的，都是计算笛卡尔积，对上面笛卡尔积的每一条记录看它是否满足限制条件，如果满足，则它在结果集中。</p>
<h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><p>当外连接，不加任何条件时，也会计算笛卡尔积。如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">left</span> <span class="keyword">join</span> b <span class="keyword">on</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="交叉连接-CROSS-JOIN"><a href="#交叉连接-CROSS-JOIN" class="headerlink" title="交叉连接(CROSS JOIN)"></a>交叉连接(CROSS JOIN)</h2><p>没有WHERE 子句，它返回<code>连接表</code>中所有数据行的笛卡尔积<br>先返回 左表所有行，左表行在与右表行一一组合，等于两个表相乘.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">cross</span> <span class="keyword">join</span> b <span class="keyword">where</span> a.x<span class="operator">=</span>b.x;</span><br></pre></td></tr></table></figure>
<p>等同于</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">inner</span> <span class="keyword">join</span> b <span class="keyword">on</span> a.x<span class="operator">=</span>b.x;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>MySQL中不存在交叉连接</p>
</blockquote>
<h2 id="避免笛卡尔积的方法"><a href="#避免笛卡尔积的方法" class="headerlink" title="避免笛卡尔积的方法"></a>避免笛卡尔积的方法</h2><p>由于笛卡尔积的结果集是各个查询表规模之积，往往是数量级的差别。</p>
<h3 id="转换为子查询"><a href="#转换为子查询" class="headerlink" title="转换为子查询"></a>转换为子查询</h3><p>假设存在如下三个表:</p>
<p>查询方式一:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">	u.user_id <span class="keyword">AS</span> recommendUserId</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	user_info u</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	<span class="number">1</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">AND</span> u.user_id <span class="keyword">IN</span> (</span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">		a.entity_id</span><br><span class="line">	<span class="keyword">FROM</span></span><br><span class="line">		address_info a</span><br><span class="line">	<span class="keyword">WHERE</span></span><br><span class="line">		a.city_code <span class="operator">=</span> <span class="number">10010</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>查询方式二：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">	u.user_id <span class="keyword">AS</span> recommendUserId</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	user_info u,</span><br><span class="line">	address_info a</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	<span class="number">1</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">AND</span> a.city_code <span class="operator">=</span> <span class="string">&#x27;10010&#x27;</span></span><br></pre></td></tr></table></figure>
<p>对比发现： ‘查询方式一’使用了子查询，查询是分两步进行的，第一步先从<code>address_info</code>选出一个结果，然后在<code>user_info</code>中查询，规模为<code>user_info</code>的大小。<br>而<code>查询方式二</code>查询规模是笛卡尔积，即<code>user_info</code>与<code>address_info</code>规模之积。</p>
<h1 id="内连接-1"><a href="#内连接-1" class="headerlink" title="内连接"></a>内连接</h1><p>内连 接只保留交叉积中满足连接条件的那些行。如果某行在一个表中存在，但在另一个表中不存在，则结果表中不包括该信息。</p>
<h1 id="外连接-1"><a href="#外连接-1" class="headerlink" title="外连接"></a>外连接</h1><p>左外连 接包括内连 接和左表中未包括在内连 接中的那些行。</p>
<p>右外连 接包括内连 接和右表中未包括在内连 接中的那些行。</p>
<p>全外连 接包括内连 接以及左表和右表中未包括在内连 接中的行。<br>内连 接一般是检索两个表里连接字段都存在的数据。<br>左连接的意思是，查询左（语句前面）表里的所有内容，无论右边表里有没有。右边表里没有的内容用NULL代替。<br>右连接和左连接相反。</p>
<h2 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h2><h2 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h2><h2 id="全外连接"><a href="#全外连接" class="headerlink" title="全外连接"></a>全外连接</h2><h1 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h1><hr>
<p>[参考文献]：</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_8250c39a0101k74c.html">SQL中—-SELECT语句中内连接,左连接,右连接,自连接和全连接 </a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/18/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">aaronzhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">236</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">127</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aaronzhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
