<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Guadazi">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Guadazi">
<meta property="og:locale">
<meta property="article:author" content="aaronzhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Guadazi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Guadazi</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/tool/Maven/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/tool/Maven/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-22 22:07:02" itemprop="dateCreated datePublished" datetime="2021-04-22T22:07:02+08:00">2021-04-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打印插件的所有命令详情</span></span><br><span class="line">mvn help:describe -Dplugin=javafx -Ddetail</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -DskipTests -Dfast -Drat.skip=true -Dhaoop.version=2.6.0-cdh5.15.1 -Pvendor-repos -Dinclude-hadoop -Dscala-2.11 -T2C</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> -Dfast  <span class="comment">#在flink根目录下pom.xml文件中fast配置项目中含快速设置,其中包含了多项构建时的跳过参数. #例如apache的文件头(rat)合法校验，代码风格检查，javadoc生成的跳过等，详细可阅读pom.xml</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> install maven的安装命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -T2C <span class="comment">#支持多处理器或者处理器核数参数,加快构建速度,推荐Maven3.3及以上</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -Pinclude-hadoop  将hadoop的 jar包，打入到lib/中</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -Pvendor-repos   <span class="comment"># 如果需要指定hadoop的发行商，如CDH，需要使用-Pvendor-repos</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -Dscala-2.11     <span class="comment"># 指定scala的版本为2.11</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -Dhadoop.version=2.6.0-cdh5.15.1  指定 hadoop 的版本</span></span><br><span class="line"></span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「实力不允许偷懒」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/qq_17310871/article/details/106677165</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/tool/JavaFx-3D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/tool/JavaFx-3D/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-22 22:07:02" itemprop="dateCreated datePublished" datetime="2021-04-22T22:07:02+08:00">2021-04-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JavaFX-3D"><a href="#JavaFX-3D" class="headerlink" title="JavaFX 3D"></a>JavaFX 3D</h1><p><a target="_blank" rel="noopener" href="https://www.genuinecoder.com/javafx-3d-transform-objects-with-keyboard-input/">JavaFX 3D Tutorial</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=TRJ0GqDBDac&list=PLhs1urmduZ295Ryetga7CNOqDymN_rhB_&index=12">more surface detail with bump mapping</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/String.split/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/String.split/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-22 22:07:02" itemprop="dateCreated datePublished" datetime="2021-04-22T22:07:02+08:00">2021-04-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="String-split"><a href="#String-split" class="headerlink" title="String.split"></a>String.split</h1><h2 id="正则表达式分割字符串"><a href="#正则表达式分割字符串" class="headerlink" title="正则表达式分割字符串"></a>正则表达式分割字符串</h2><h3 id="保留末尾空格与空字符串情形"><a href="#保留末尾空格与空字符串情形" class="headerlink" title="保留末尾空格与空字符串情形"></a>保留末尾空格与空字符串情形</h3><p><code>split(delimiter)</code> 默认会从结果数组中去掉空字符串. 要关闭这个机制，将重载方法 <code>split(delimiter, limit)</code> 的 <code>limit</code> 设置为负值，如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] split = data.split(<span class="string">&quot;\\|&quot;</span>, -<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>更详细的介绍:</p>
<p><code>split(regex)</code> 内部是调用<code>split(regex, 0)</code>的返回结果，参考官方文档 <a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-int-">documentation</a> 有这个方法的详细介绍</p>
<blockquote>
<p><code>limit</code>参数控制应用pattern的次数，因此会影响所得数组的长度。<br>如果限制<code>n</code><strong>大于零</strong>，则将最多应用<code>n-1</code>次该pattern，该数组的长度将不大于n，并且该数组的最后一个条目将包含除最后一个匹配的定界符之外的所有输入。<br>如果<code>n</code>为<strong>非正数</strong>，则该pattern将被尽可能多地应用，并且数组可以具有任何长度。<br>如果<code>n</code>为<strong>零</strong>，则该pattern将被尽可能多地应用，该数组可以具有任何长度，并且<strong>尾随的空字符串将被丢弃</strong>。</p>
</blockquote>
<p><strong>Exception</strong>:</p>
<p><strong>空字符串分拆的情况</strong></p>
<p>值得一提的是，只有在拆分机制创建了空字符串，删除尾随的空字符串才有意义。 因此，对于空字符串的分拆<code>&quot;&quot;.split(任何东西)</code>，因为我们无法进一步拆分<code>&quot;&quot;</code>，所以我们将得到结果<code>[&quot;&quot;]</code>数组。发生这种情况是因为此处未发生拆分，因此尽管存在空白，但<code>&quot;&quot;</code>还是尾随表示原始字符串，而不是拆分过程创建的空字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> ~ jshell</span><br><span class="line">|  欢迎使用 JShell -- 版本 <span class="number">15</span></span><br><span class="line">|  要大致了解该版本, 请键入: /help intro</span><br><span class="line"></span><br><span class="line">jshell&gt; String demo=<span class="string">&quot;&quot;</span>;</span><br><span class="line">demo ==&gt; <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">jshell&gt; String[] demoSplit = demo.split(<span class="string">&quot;[,;]&quot;</span>);</span><br><span class="line">demoSplit ==&gt; String[<span class="number">1</span>] &#123; <span class="string">&quot;&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="踢掉空格"><a href="#踢掉空格" class="headerlink" title="踢掉空格"></a>踢掉空格</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Splitter.on(pattern).omitEmptyStrings().splitToList(<span class="string">&quot;&quot;</span>);</span><br><span class="line">System.out.println(list.size());  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h3 id="StringUtils-split"><a href="#StringUtils-split" class="headerlink" title="StringUtils.split"></a>StringUtils.split</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.commons.lang.StringUtils#splitByWholeSeparator(java.lang.String, java.lang.String, int)</span><br></pre></td></tr></table></figure>
<p>分割字符串，正则表达式作为普通字符串</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/metric/%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E4%B8%8ETLAB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/metric/%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%E4%B8%8ETLAB/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-22 22:07:02" itemprop="dateCreated datePublished" datetime="2021-04-22T22:07:02+08:00">2021-04-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="栈上分配与TLAB"><a href="#栈上分配与TLAB" class="headerlink" title="栈上分配与TLAB"></a>栈上分配与TLAB</h1><h2 id="逃逸分析-Escape-Analysis"><a href="#逃逸分析-Escape-Analysis" class="headerlink" title="逃逸分析(Escape Analysis)"></a>逃逸分析(Escape Analysis)</h2><h2 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h2><p>针对那些作用域不会逃逸出方法的对象，在分配内存时不再将对象分配在堆内存中，而是将对象属性打散后分配在栈（线程私有的，属于栈内存）上，这样，随着方法的调用结束，栈空间的回收就会随着将栈上分配的打散后的对象回收掉，不再给gc增加额外的无用负担，从而提升应用程序整体的性能</p>
<p>优点：</p>
<p>　　　　1）可以在函数调用结束后自行销毁对象，不需要垃圾回收器的介入，有效避免垃圾回收带来的负面影响</p>
<p>　　　　2）栈上分配速度快，提高系统性能</p>
<p>线程私有变量，大对象虚拟机会分配到TLAB中，<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a7414c0ebb17">TLAB（Thread Local Allocation Buffer）要不要了解下？</a></p>
<p>在栈上分配该对象的内存,当栈帧从Java虚拟机栈中弹出，就自动销毁这个对象。减小垃圾回收器压力。</p>
<h2 id="TLAB"><a href="#TLAB" class="headerlink" title="TLAB"></a>TLAB</h2><p>TLAB全称ThreadLocalAllocBuffer，是线程的一块私有内存，如果设置了虚拟机参数 -XX:UseTLAB，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用，这个申请动作还是需要原子操作的。</p>
<p>TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能使用自己专属的分配指针来分配空间，均摊对GC堆（eden区）里共享的分配指针做更新而带来的同步开销。</p>
<p>TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB，而在老TLAB里的对象还留在原地什么都不用管——它们无法感知自己是否是曾经从TLAB分配出来的，而只关心自己是在eden里分配的。</p>
<table>
<thead>
<tr>
<th>启动参数</th>
<th>JVM内存分配模式</th>
<th>Eden区</th>
<th>YoungGC</th>
<th>耗时</th>
</tr>
</thead>
<tbody><tr>
<td>-XX:+DoEscapeAnalysis（开逃逸分析）-XX:+UseTLAB （开启TLAB）</td>
<td>虚拟机栈上分配模式(小对象)</td>
<td>较少使用</td>
<td>较少使用</td>
<td>很低</td>
</tr>
<tr>
<td>-XX:-DoEscapeAnalysis（关闭逃逸分析）-XX:+UseTLAB（开启TLAB）</td>
<td>TLAB区分配模式</td>
<td>大量使用</td>
<td>大量使用</td>
<td>较高</td>
</tr>
<tr>
<td>-XX:-DoEscapeAnalysis（关闭逃逸分析）-XX:-UseTLAB（关闭TLAB）</td>
<td>Eden区分配模式</td>
<td>大量使用</td>
<td>大量使用</td>
<td>特别高</td>
</tr>
</tbody></table>
<p>在学习Java的过程中，一般认为new出来的对象都是被分配在堆上的，其实这个结论不完全正确，因为是大部分new出来的对象被分配在堆上，而不是全部。通过对Java对象分配的过程分析，可以知道有另外两个地方也是可以存放对象的。这两个地方分别栈 （涉及逃逸分析相关知识）和TLAB（Thread Local Allocation Buffer）。我们首先对这两者进行介绍，而后对Java对象分配过程进行介绍。</p>
<h3 id="栈上分配-1"><a href="#栈上分配-1" class="headerlink" title="栈上分配"></a><strong>栈上分配</strong></h3><p>在JVM中，堆是线程共享的，因此堆上的对象对于各个线程都是共享和可见的，只要持有对象的引用，就可以访问堆中存储的对象数据。虚拟机的垃圾收集系统可以回收堆中不再使用的对象，但对于垃圾收集器来说，无论筛选可回收对象，还是回收和整理内存都需要耗费时间。</p>
<p>如果确定一个对象的作用域不会逃逸出方法之外，那可以将这个对象分配在栈上，这样，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，无须通过垃圾收集器回收，可以减小垃圾收集器的负载。</p>
<p>JVM允许将线程私有的对象打散分配在栈上，而不是分配在堆上。分配在栈上的好处是可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提高系统性能。<br><strong>栈上分配的技术基础：</strong><br><strong>一是逃逸分析：</strong>逃逸分析的目的是判断对象的作用域是否有可能逃逸出函数体。关于逃逸分析的问题可以看我另一篇文章：</p>
<p><strong>二是标量替换：</strong>允许将对象打散分配在栈上，比如若一个对象拥有两个字段，会将这两个字段视作局部变量进行分配。</p>
<p>只能在server模式下才能启用逃逸分析，参数-XX:DoEscapeAnalysis启用逃逸分析，参数-XX:+EliminateAllocations开启标量替换（默认打开）。Java SE 6u23版本之后，HotSpot中默认就开启了逃逸分析，可以通过选项-XX:+PrintEscapeAnalysis查看逃逸分析的筛选结果。</p>
<h3 id="TLAB-1"><a href="#TLAB-1" class="headerlink" title="TLAB"></a><strong>TLAB</strong></h3><p>TLAB的全称是Thread Local Allocation Buffer，即线程本地分配缓存区，这是一个线程专用的内存分配区域。<br>由于对象一般会分配在堆上，而堆是全局共享的。因此在同一时间，可能会有多个线程在堆上申请空间。因此，每次对象分配都必须要进行同步（虚拟机采用CAS配上失败重试的方式保证更新操作的原子性），而在竞争激烈的场合分配的效率又会进一步下降。JVM使用TLAB来避免多线程冲突，在给对象分配内存时，每个线程使用自己的TLAB，这样可以避免线程同步，提高了对象分配的效率。  </p>
<p>TLAB本身占用eEden区空间，在开启TLAB的情况下，虚拟机会为<strong>每个Java线程分配一块TLAB空间</strong>。参数-XX:+UseTLAB开启TLAB，默认是开启的。TLAB空间的内存非常小，缺省情况下仅占有整个Eden空间的1%，当然可以通过选项-XX:TLABWasteTargetPercent设置TLAB空间所占用Eden空间的百分比大小。<br>由于TLAB空间一般不会很大，因此大对象无法在TLAB上进行分配，总是会直接分配在堆上。TLAB空间由于比较小，因此很容易装满。比如，一个100K的空间，已经使用了80KB，当需要再分配一个30KB的对象时，肯定就无能为力了。这时虚拟机会有两种选择，第一，废弃当前TLAB，这样就会浪费20KB空间；第二，将这30KB的对象直接分配在堆上，保留当前的TLAB，这样可以希望将来有小于20KB的对象分配请求可以直接使用这块空间。实际上虚拟机内部会维护一个叫作refill_waste的值，当请求对象大于refill_waste时，会选择在堆中分配，若小于该值，则会废弃当前TLAB，新建TLAB来分配对象。这个阈值可以使用TLABRefillWasteFraction来调整，它表示TLAB中允许产生这种浪费的比例。默认值为64，即表示使用约为1/64的TLAB空间作为refill_waste。默认情况下，TLAB和refill_waste都会在运行时不断调整的，使系统的运行状态达到最优。如果想要禁用自动调整TLAB的大小，可以使用-XX:-ResizeTLAB禁用ResizeTLAB，并使用-XX:TLABSize手工指定一个TLAB的大小。<br>-XX:+PrintTLAB可以跟踪TLAB的使用情况。一般不建议手工修改TLAB相关参数，推荐使用虚拟机默认行为。</p>
<h3 id="对象内存分配的两种方法"><a href="#对象内存分配的两种方法" class="headerlink" title="对象内存分配的两种方法"></a><strong>对象内存分配的两种方法</strong></h3><p>为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p>
<p>指针碰撞(Serial、ParNew等带Compact过程的收集器)<br>假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump the Pointer）。<br>空闲列表(CMS这种基于Mark-Sweep算法的收集器)<br>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。  
  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p><strong>总体流程</strong><br><img src="_v_images/20200818211412253_811602284" alt="这里写图片描述"></p>
<p><strong>对象分配流程</strong><br><img src="_v_images/20200818211412147_1281640355" alt="这里写图片描述"><br>如果开启栈上分配，JVM会先进行栈上分配，如果没有开启栈上分配或则不符合条件的则会进行TLAB分配，如果TLAB分配不成功，再尝试在eden区分配，如果对象满足了直接进入老年代的条件，那就直接分配在老年代。</p>
<p><strong>对象在内存的引用方式</strong><br><img src="_v_images/20200818211411943_2105805507" alt="这里写图片描述"></p>
<p><strong>对象在内存中的结构</strong><br><img src="_v_images/20200818211411726_1562017878" alt="这里写图片描述"></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000004606059">参考</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/metric/MAT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/metric/MAT/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-22 22:07:02" itemprop="dateCreated datePublished" datetime="2021-04-22T22:07:02+08:00">2021-04-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h1><p>为了演示MAT的使用方法，本文采用jamp生成了一个Java继承的dump文件。</p>
<h2 id="4-1-Overview选项"><a href="#4-1-Overview选项" class="headerlink" title="4.1 Overview选项"></a>4.1 Overview选项</h2><p>当成功启动MAT后，通过菜单选项“File-&gt;Open heap dump…”打开指定的dump文件后，将会生成Overview选项，如下所示：</p>
<p><img src="_v_images/20201115133304752_1908958530">  </p>
<pre><code>在Overview选项中，以饼状图的形式列举出了程序内存消耗的一些基本信息，其中每一种不同颜色的饼块都代表了不同比例的内存消耗情况。</code></pre>
<h3 id="4-2-Dominator-Tree"><a href="#4-2-Dominator-Tree" class="headerlink" title="4.2 Dominator Tree"></a>4.2 Dominator Tree</h3><p>如果说需要定位内存泄露的代码点，我们可以通过Dominator Tree菜单选项来进行排查。Dominator Tree提供了一个列表。<br>Dominator Tree：对象之间dominator关系树。如果从GC Root到达Y的的所有path都经过X，那么我们称X dominates Y，或者X是Y的Dominator 。<br>Dominator Tree由系统中复杂的对象图计算而来。从MAT的dominator tree中可以看到占用内存最大的对象以及每个对象的dominator，如下所示：</p>
<p> <img src="_v_images/20201115133304642_1953557219"></p>
<p>点开“+”符号，可以进一步查看内层应用情况，同时还可以看到对应类对象的属性值，如下所示：</p>
<p><img src="_v_images/20201115133304535_2038220777">  </p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="4-3-Histogram选项"><a href="#4-3-Histogram选项" class="headerlink" title="4.3 Histogram选项"></a>4.3 Histogram选项</h3><p>进一步，可以通过Histogram分析，Histogram列出了每个类的实例数量，点击Action下的Histogram，得到以下结果：</p>
<p><img src="_v_images/20201115133304326_712812495">  </p>
<p>如果需要查询特性的某个类，我们可以在第一行输入类名或者关键词进行正则匹配查找，如查找“netty”：</p>
<p><img src="_v_images/20201115133304118_1508343283">  </p>
<p>可以看出，查找“netty”输出的结果列表是无序的，如果匹配到的结果很多，查找起来比较困难，因此，我们可以对结果进行排序：选中结果列表的任意一行，鼠标右键-》Colums-&gt;Sort By-&gt;如Class Name，结果如下：</p>
<p><img src="_v_images/20201115133303913_1472138606">  </p>
<pre><code>当我们找到疑似存在泄漏的类之后，我们可以进行进一步分析。比较重要的一点，选中疑似类，右键出来选中List Objects,得到的结果再右键选中&quot;Paths to GC Roots&quot;,我们可以通过它快速找到GC ROOT，如果存在GC ROOT，它就不会被回收。</code></pre>
<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="4-4-Path-to-GC-Roots"><a href="#4-4-Path-to-GC-Roots" class="headerlink" title="4.4 Path to GC Roots"></a>4.4 Path to GC Roots</h3><pre><code>查看一个对象到RC Roots的引用链  

通常在排查内存泄漏的时候，我们会选择exclude all phantom/weak/soft etc.references，意思是查看排除虚引用/弱引用/软引用等的引用链，因为被虚引用/弱引用/软引用的对象可以直接被GC给回收，我们要看的就是某个对象否还存在Strong 引用链（在导出HeapDump之前要手动出发GC来保证），如果有，则说明存在内存泄漏，然后再去排查具体引用。 </code></pre>
<p><img src="_v_images/20201115133303706_1037916552">  </p>
<p><strong>其它重要选项：</strong></p>
<p>1. List objects ：<br>with incoming references 引用到该对象的对象<br>with outcoming references 被该对象引用的对象</p>
<p>2. Show objects by class ：<br>incoming references 引用到该对象的对象<br>outcoming references 被该对象引用的对象 </p>
<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><p>4.5 OQL(Object Query Language)</p>
<p>类似SQL查询语言<br>Classes：Table<br>Objects：Rows<br>Fileds： Cols</p>
<p><code>select  *  from com.example.mat.Listener</code></p>
<p><strong>查找size＝0并且未使用过的ArrayList</strong><br><code>select  *  from java.util.ArrayList  where size=0  and modCount=0</code></p>
<p><strong>查找所有的Activity</strong><br>select * from instanceof android.app.Activity</p>
<h3 id="4-6-利用Histogram和Dominator-Tree分析内存泄露"><a href="#4-6-利用Histogram和Dominator-Tree分析内存泄露" class="headerlink" title="4.6  利用Histogram和Dominator Tree分析内存泄露"></a>4.6  利用Histogram和Dominator Tree分析内存泄露</h3><pre><code>在分析内存泄露时，必须要掌握粒度，所谓粒度就是你此刻dump的hprof文件究竟是分析谁的泄露，如果你在开始前心中没有个目标，最后取出来的hprof也分析不出什么原因。粒度越小，对你分析问题也就越有利，当你把一个个小粒度问题解决后，整个App的泄露就迎刃而解了。也许这么说，大家心中有点迷糊。下面就举例来说吧：

假如现在有个项目包含Module几十个，每个Module包含的Activity数以百计，现在让你分析它是否内存泄露，如果你只是胡乱抓个hprof根本分析不出什么。假如你就针对某个Activity分析这样问题就简单多了。比如你现在分析ActivityA的内存泄露问题，你可以参考如下步骤：

Step1：进入ActivityA之前，你先dump个hprof文件HprofA；

Step2：进入ActivityA操作一会，再退出ActivityA后dump个hprof文件HprofB；

Step3：采用Histogram和Dominator Tree对比分析这两个Hprof文件，即可得出ActivityA是否泄露</code></pre>
<p>现在以分析TestActivity为例，按上述步骤实战分析，先抓取进入TestActivity前后的hprof文件，按如下步骤对比两个hprof的异同，如下图1,2：</p>
<p><img src="_v_images/20201115133303497_195864697">  </p>
<p>图1 选择所需比较的hprof  </p>
<p><img src="_v_images/20201115133303286_1803136553">  </p>
<p>图2 比较两个hprof  </p>
<pre><code>正如图2所示，易知在执行进出TestActivity后，多出了个TestActivity对象，按理论上来说在进入Activity后会创建个Activity，但是按Back键返回后这个Activity就会被销毁进而从Task栈上被移除，也就是说这个操作前后不应该会多出个Activity，因此可以断定TestActivity存在泄漏。

TestActivity存在泄漏，那我们应该怎么解决呢？因此我们就需要找到为何泄漏，为什么本该销毁的Activity却没有被销毁？如知真相如何，请看下图3-4</code></pre>
<p><img src="_v_images/20201115133303070_1797820935">  </p>
<p>图3 获取TestActivity的Reference chain  </p>
<p><img src="_v_images/20201115133302509_954891646">  </p>
<p>图4 TestActivity的引用关系  </p>
<pre><code>从图4易知TestActivity没有被释放就是因为GC Root(TestActivity$1)引用着TestActivity，到此原因也一目了然。找到了只是开始，解决才是关键。这时让我们查看下TestActivity代码：  </code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object mLock = <span class="keyword">new</span> Object();     <span class="meta">@Override</span>    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;                <span class="keyword">super</span>.onCreate(savedInstanceState);        DebugUtil.StrictModeDebug();        setContentView(R.layout.test_main);           <span class="keyword">new</span> Thread()&#123;<span class="comment">//匿名线程            public void run() &#123;                synchronized (mLock) &#123;                    try &#123;                        mLock.wait();                    &#125; catch (InterruptedException e) &#123;                        // TODO Auto-generated catch block                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;.start();    &#125;&#125;</span></span><br></pre></td></tr></table></figure>
<pre><code>从代码上可以发现TestActivity里存在个匿名线程，且一直处于等待状态，直到退出TestActivity仍未被唤醒，进而导致该线程就一直没有结束，它所持有的TestActivity也就无法被释放了（可能大家听到此处会很疑惑，线程没有结束可以理解，但是它并没有持有TestActivity呀？我只能说是隐含this，如还不明白，请自行参阅java内部类相关内容），如要解决此泄露，只需在Activity的onDestory里将线程唤醒让其可以正常结束就OK了。</code></pre>
<p><strong>优化建议</strong></p>
<ol>
<li>使用线程时，一定要确保线程在周期性对象（如Activity）销毁时能正常结束，如能正常结束，但是Activity销毁后还需执行一段时间，也可能造成泄露，此时可采用WeakReference方法来解决，另外在使用Handler的时候，如存在Delay操作，也可以采用WeakReference；</li>
<li>使用Handler + HandlerThread时，记住在周期性对象销毁时调用looper.quit()方法；</li>
<li>建议少使用匿名类或内部类，可考虑使用嵌套类（带static那种类），减少对周期性对象的隐性持有；</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/jvm/GraalVm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/jvm/GraalVm/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-22 22:07:01" itemprop="dateCreated datePublished" datetime="2021-04-22T22:07:01+08:00">2021-04-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="GraalVm"><a href="#GraalVm" class="headerlink" title="GraalVm"></a>GraalVm</h1><p><a target="_blank" rel="noopener" href="https://www.graalvm.org/docs/getting-started-with-graalvm/">https://www.graalvm.org/docs/getting-started-with-graalvm/</a>    </p>
<p><a target="_blank" rel="noopener" href="https://medium.com/graalvm/simplifying-native-image-generation-with-maven-plugin-and-embeddable-configuration-d5b283b92f57">https://medium.com/graalvm/simplifying-native-image-generation-with-maven-plugin-and-embeddable-configuration-d5b283b92f57</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/JavaFx/basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/JavaFx/basic/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-22 22:07:01" itemprop="dateCreated datePublished" datetime="2021-04-22T22:07:01+08:00">2021-04-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="basic"><a href="#basic" class="headerlink" title="basic"></a>basic</h1><h2 id="UI框架"><a href="#UI框架" class="headerlink" title="UI框架"></a>UI框架</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/FXMisc/RichTextFX/tree/master/richtextfx-demos">RichTextFx 文本编辑框</a></li>
<li><a target="_blank" rel="noopener" href="http://fxexperience.com/controlsfx">ControllsFx</a></li>
<li><a target="_blank" rel="noopener" href="http://github.com/jfoenixadmin/JFoenix">JFoenix</a></li>
<li><a target="_blank" rel="noopener" href="http://bitbucket.org/Jerady/fontawesomefx">fontawesomefx</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/collection/ConcurrentSkipListMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/collection/ConcurrentSkipListMap/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-22 22:07:01" itemprop="dateCreated datePublished" datetime="2021-04-22T22:07:01+08:00">2021-04-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基于跳跃表的-ConcurrentSkipListMap-内部实现（Java-8）"><a href="#基于跳跃表的-ConcurrentSkipListMap-内部实现（Java-8）" class="headerlink" title="基于跳跃表的 ConcurrentSkipListMap 内部实现（Java 8）"></a>基于跳跃表的 ConcurrentSkipListMap 内部实现（Java 8）</h1><p>我们知道 HashMap 是一种键值对形式的数据存储容器，但是它有一个缺点是，元素内部无序。由于它内部根据键的 hash 值取模表容量来得到元素的存储位置，所以整体上说 HashMap 是无序的一种容器。当然，jdk 中也为我们提供了基于红黑树的存储的 TreeMap 容器，它的内部元素是有序的，但是由于它内部通过红黑结点的各种变换来维持二叉搜索树的平衡，相对复杂，并且在并发环境下碍于 rebalance 操作，性能会受到一定的影响。</p>
<p>跳表（SkipList）是一种随机化的数据结构，通过“空间来换取时间”的一个算法，建立多级索引，实现以二分查找遍历一个有序链表。时间复杂度等同于红黑树，O(log n)。但实现却远远比红黑树要简单，本篇我们主要从以下几个方面来对这种并发版本的数据结构进行学习：</p>
<ul>
<li>跳跃表的数据结构介绍</li>
<li>ConcurrentSkipListMap 的前导知识预备</li>
<li>基本的成员属性介绍</li>
<li>put 方法并发添加</li>
<li>remove 方法的并发删除</li>
<li>get 方法获取指定结点的 value</li>
<li>其它的一些方法的简单描述</li>
</ul>
<h2 id="一、跳跃表的数据结构介绍"><a href="#一、跳跃表的数据结构介绍" class="headerlink" title="一、跳跃表的数据结构介绍"></a>一、跳跃表的数据结构介绍</h2><p><img src="_v_images/20200819194446142_966009886" alt="这里写图片描述"></p>
<p>跳跃表具有以下几个必备的性质：</p>
<ul>
<li>最底层包含所有节点的一个有序的链表</li>
<li>每一层都是一个有序的链表</li>
<li>每个节点都有两个指针，一个指向右侧节点（没有则为空），一个指向下层节点（没有则为空）</li>
<li>必备一个头节点指向最高层的第一个节点，通过它可以遍历整张表</li>
</ul>
<p>当我们查找一个元素的时候就是这样的：</p>
<p><img src="_v_images/20200819194445937_815191891" alt="这里写图片描述"></p>
<p>查找的过程有点像我们的二分查找，不过这里我们是通过为链表建立多级索引，以空间换时间来实现二分查找。所以，跳表的查询操作的时间复杂度为 O(logN)。</p>
<p>接着我们看看跳表的插入操作：<br>首先，跳表的插入必然会在底层增加一个节点，但是往上的层次是否需要增加节点则完全是随机的，SkipList 通过概率保证整张表的节点分布均匀，它不像红黑树是通过人为的 rebalance 操作来保证二叉树的平衡性。（数学对于计算机还是很重要的）。</p>
<p>通过概率算法得到新插入节点的一个 level 值，如果小于当前表的最大 level，从最底层到 level 层都添加一个该节点。例如：</p>
<p><img src="_v_images/20200819194445733_1944248029" alt="这里写图片描述"></p>
<p>如图，首先 119 节点会被添加到最底层链表的合适位置，然后通过概率算法得到 level 为 2，于是 1—level 层中的每一层都添加了 119 节点。</p>
<p>如果概率算法得到的 level 大于当前表的最大 level 值的话，那么将会新增一个 level，并且将新节点添加到该 level 上。</p>
<p><img src="_v_images/20200819194445529_52135211" alt="这里写图片描述"></p>
<p>跳表的删除操作其实就是一个查找加删除节点的操作</p>
<p><img src="_v_images/20200819194445324_1213153640" alt="这里写图片描述"></p>
<p>好了，有关跳表这种数据结构的基本理论知识已经简单的介绍了，下面我们看 jdk 中对该数据结构的基本实现情况，并了解它的并发版本是如何实现的。</p>
<h2 id="二、ConcurrentSkipListMap-的前导知识预备"><a href="#二、ConcurrentSkipListMap-的前导知识预备" class="headerlink" title="二、ConcurrentSkipListMap 的前导知识预备"></a>二、ConcurrentSkipListMap 的前导知识预备</h2><p>在实际分析 put 方法之前，有一些预备的知识我们需要先有个大致的了解，否则在实际分析源码的时候会感觉吃力些。</p>
<p>首先是删除操作，在我们上述的跳表数据结构中谈及的删除操作主要是定位待删结点+删除该结点的一个复合操作。而在我们的并发跳表中，删除操作相对复杂点，需要分为以下三个步骤：</p>
<ul>
<li>找到待删结点并将其 value 属性值由 notnull 置为 null，整个过程是基于 CAS 无锁式算法的</li>
<li>向待删结点的 next 位置新增一个 marker 标记结点，整个过程也是基于 CAS 无锁式算法</li>
<li>CAS 式删除具体的结点，实际上也就是跳过该待删结点，让待删结点的前驱节点直接越过本身指向待删结点的后继结点即可</li>
</ul>
<p>例如我们有以下三个结点，n 为待删除的结点。</p>
<blockquote>
<p>+------+ +------+ +——+<br>… | b |——&gt;| n |—–&gt;| f | …<br>+------+ +------+ +——+</p>
</blockquote>
<p>第一步是找到 n ，然后 CAS 该结点的 value 值为 null。如果该步骤失败了，那么 ConcurrentSkipListMap 会通过循环再次尝试 CAS 将 n 的 value 属性赋值为 null。</p>
<p>第二步是建立在第一步成功的前提下的，n 的当前 value 属性的值为 null，ConcurrentSkipListMap 试图在 n 的后面增加一个空的 node 结点（marker）以分散下一步的并发冲突性。</p>
<blockquote>
<p>+------+ +------+ +------+ +——+<br>… | b |——&gt;| n |—–&gt;|marker|—-&gt;| f | …<br>+------+ +------+ +------+ +——+</p>
</blockquote>
<p>第三步，断链操作。如果 marker 添加失败，将不会有第三步，直接回重新回到第一步。如果成功添加，那么将试图断开 b 到 n 的链接，直接绕过 n，让 b 的 next 指向 f。那么，这个 n 结点将作为内存中的一个游离结点，最终被 GC 掉。断开失败的话，也将回到第一步。</p>
<blockquote>
<p>+------+ +——+<br>… | b |———————–&gt;| f | …<br>+------+ +——+</p>
</blockquote>
<p>主要还是有关删除这方面的预备知识，其它的信息点我们将从实际方法的源码中再进行分析。</p>
<h2 id="三、基本的成员属性介绍"><a href="#三、基本的成员属性介绍" class="headerlink" title="三、基本的成员属性介绍"></a>三、基本的成员属性介绍</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> Object value;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(K key, Object value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略其它的一些基于当前结点的 CAS 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是 node 结点类型的定义，是最基本的数据存储单元。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt; node;</span><br><span class="line">    <span class="keyword">final</span> Index&lt;K,V&gt; down;</span><br><span class="line">    <span class="keyword">volatile</span> Index&lt;K,V&gt; right;</span><br><span class="line"></span><br><span class="line">    Index(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right) &#123;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">        <span class="keyword">this</span>.down = down;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略其它的一些基于当前结点的 CAS 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Index 结点封装了 node 结点，作为跳表的最基本组成单元。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadIndex</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Index</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> level;</span><br><span class="line">    HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, <span class="keyword">int</span> level) &#123;</span><br><span class="line">        <span class="keyword">super</span>(node, down, right);</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>封装了 Index 结点，作为每层的头结点，level 属性用于标识当前层次的序号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The topmost head index of the skiplist.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> HeadIndex&lt;K,V&gt; head;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>整个跳表的头结点，通过它可以遍历访问整张跳表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较器，用于比较两个元素的键值大小，如果没有显式传入则默认为自然排序</span></span><br><span class="line"><span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Special value used to identify base-level header</span></span><br><span class="line"><span class="comment"> * 特殊的值，用于初始化跳表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object BASE_HEADER = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>紧接着，我们看看它的几个构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未传入比较器，则为默认值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;</span><br><span class="line">    initialize();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentSkipListMap</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    initialize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有的构造器都会调用这个初始化的方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    keySet = <span class="keyword">null</span>;</span><br><span class="line">    entrySet = <span class="keyword">null</span>;</span><br><span class="line">    values = <span class="keyword">null</span>;</span><br><span class="line">    descendingMap = <span class="keyword">null</span>;</span><br><span class="line">    head = <span class="keyword">new</span> HeadIndex&lt;K,V&gt;(<span class="keyword">new</span> Node&lt;K,V&gt;(<span class="keyword">null</span>, BASE_HEADER, <span class="keyword">null</span>),<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个初始化方法主要完成的是对整张跳表的一个初始化操作，head 头指针指向这个并没有什么实际意义的头结点。</p>
<p>基本的成员属性就简单介绍到这，重点还是那三个内部类，都分别代表了什么样的结点类型，都使用在何种场景下，务必清晰。</p>
<h3 id="四、put-并发添加的内部实现"><a href="#四、put-并发添加的内部实现" class="headerlink" title="四、put 并发添加的内部实现"></a>四、put 并发添加的内部实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本的 put 方法，向跳表中添加一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> doPut(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>put 方法的内部调用的是 doPut 方法来实现添加元素的，但是由于 doPut 方法的方法体很长，我们分几个部分进行分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一部分</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doPut</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; z;</span><br><span class="line">    <span class="comment">//边界值判断，空的 key 自然是不允许插入的</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//拿到比较器的引用</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">	    <span class="comment">//根据 key，找到待插入的位置</span></span><br><span class="line">	    <span class="comment">//b 叫做前驱节点，将来作为新加入结点的前驱节点</span></span><br><span class="line">	    <span class="comment">//n 叫做后继结点，将来作为新加入结点的后继结点</span></span><br><span class="line">	    <span class="comment">//也就是说，新节点将插入在 b 和 n 之间</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">	        <span class="comment">//如果 n 为 null，那么说明 b 是链表的最尾端的结点，这种情况比较简单，直接构建新节点插入即可</span></span><br><span class="line">	        <span class="comment">//否则走下面的判断体</span></span><br><span class="line">            <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object v; <span class="keyword">int</span> c;</span><br><span class="line">                Node&lt;K,V&gt; f = n.next;</span><br><span class="line">                <span class="comment">//如果 n 不再是 b 的后继结点了，说明有其他线程向 b 后面添加了新元素</span></span><br><span class="line">                <span class="comment">//那么我们直接退出内循环，重新计算新节点将要插入的位置</span></span><br><span class="line">                <span class="keyword">if</span> (n != b.next)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//value =0 说明 n 已经被标识位待删除，其他线程正在进行删除操作</span></span><br><span class="line">                <span class="comment">//调用 helpDelete 帮助删除，并退出内层循环重新计算待插入位置</span></span><br><span class="line">                <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123; </span><br><span class="line">                    n.helpDelete(b, f);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//b 已经被标记为待删除，前途结点 b 都丢了，可不得重新计算待插入位置吗</span></span><br><span class="line">                <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n) </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">				<span class="comment">//如果新节点的 key 大于 n 的 key 说明找到的前驱节点有误，按序往后挪一个位置即可</span></span><br><span class="line">				<span class="comment">//回到内层循环重新试图插入</span></span><br><span class="line">                <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    b = n;</span><br><span class="line">                    n = f;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//新节点的 key 等于 n 的 key，这是一次 update 操作，CAS 更新即可</span></span><br><span class="line">                <span class="comment">//如果更新失败，重新进循环再来一次</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (onlyIfAbsent || n.casValue(v, value)) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> V vv = (V)v;</span><br><span class="line">                        <span class="keyword">return</span> vv;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">	    <span class="comment">//无论遇到何种问题，到这一步说明待插位置已经确定</span></span><br><span class="line">            z = <span class="keyword">new</span> Node&lt;K,V&gt;(key, value, n);</span><br><span class="line">            <span class="keyword">if</span> (!b.casNext(n, z))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//如果成功了，退出最外层循环，完成了底层的插入工作        </span></span><br><span class="line">            <span class="keyword">break</span> outer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上这一部分主要完成了向底层链表插入一个节点，至于其中具体的怎么找前驱节点的方法稍后介绍。但这其实只不过才完成一小半的工作，就像红黑树在插入后需要 rebalance 一样，我们的跳表需要根据概率算法保证节点分布稳定，它的调节措施相对于红黑树来说就简单多了，通过往上层索引层添加相关引用即可，以空间换时间。具体的我们来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二部分</span></span><br><span class="line"><span class="comment">//获取一个线程无关的随机数，占四个字节，32 个比特位</span></span><br><span class="line"><span class="keyword">int</span> rnd = ThreadLocalRandom.nextSecondarySeed();</span><br><span class="line">	<span class="comment">//和 1000 0000 0000 0000 0000 0000 0000 0001 与</span></span><br><span class="line">	<span class="comment">//如果等于 0，说明这个随机数最高位和最低位都为 0，这种概率很大</span></span><br><span class="line">	<span class="comment">//如果不等于 0，那么将仅仅把新节点插入到最底层的链表中即可，不会往上层递归</span></span><br><span class="line">    <span class="keyword">if</span> ((rnd &amp; <span class="number">0x80000001</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>, max;</span><br><span class="line">        <span class="comment">//用低位连续为 1 的个数作为 level 的值，也是一种概率策略</span></span><br><span class="line">        <span class="keyword">while</span> (((rnd &gt;&gt;&gt;= <span class="number">1</span>) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">            ++level;</span><br><span class="line">        Index&lt;K,V&gt; idx = <span class="keyword">null</span>;</span><br><span class="line">        HeadIndex&lt;K,V&gt; h = head;</span><br><span class="line">        <span class="comment">//如果概率算得的 level 在当前跳表 level 范围内</span></span><br><span class="line">        <span class="comment">//构建一个从 1 到 level 的纵列 index 结点引用</span></span><br><span class="line">        <span class="keyword">if</span> (level &lt;= (max = h.level)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则需要新增一个 level 层</span></span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            level = max + <span class="number">1</span>; </span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            Index&lt;K,V&gt;[] idxs =(Index&lt;K,V&gt;[])<span class="keyword">new</span> Index&lt;?,?&gt;[level+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= level; ++i)</span><br><span class="line">                idxs[i] = idx = <span class="keyword">new</span> Index&lt;K,V&gt;(z, idx, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                h = head;</span><br><span class="line">                <span class="keyword">int</span> oldLevel = h.level;</span><br><span class="line">                <span class="comment">//level 肯定是比 oldLevel 大一的，如果小了说明其他线程更新过表了</span></span><br><span class="line">                <span class="keyword">if</span> (level &lt;= oldLevel) </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                HeadIndex&lt;K,V&gt; newh = h;</span><br><span class="line">                Node&lt;K,V&gt; oldbase = h.node;</span><br><span class="line">                <span class="comment">//正常情况下，循环只会执行一次，如果由于其他线程的并发操作导致 oldLevel 的值不稳定，那么会执行多次循环体</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = oldLevel+<span class="number">1</span>; j &lt;= level; ++j)</span><br><span class="line">                    newh = <span class="keyword">new</span> HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j);</span><br><span class="line">                <span class="comment">//更新头指针</span></span><br><span class="line">                <span class="keyword">if</span> (casHead(h, newh)) &#123;</span><br><span class="line">                    h = newh;</span><br><span class="line">                    idx = idxs[level = oldLevel];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这一部分的代码主要完成的是根据 level 的值，确认是否需要增加一层索引，如果不需要则构建好底层到 level 层的 index 结点的纵向引用。如果需要，则新创建一层索引，完成 head 结点的指针转移，并构建好纵向的 index 结点引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三部分</span></span><br><span class="line"><span class="keyword">if</span> ((rnd &amp; <span class="number">0x80000001</span>) == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//省略第二部分的代码段</span></span><br><span class="line"><span class="comment">//第三部分的代码是紧接着第二部分代码段后面的</span></span><br><span class="line">	splice: <span class="keyword">for</span> (<span class="keyword">int</span> insertionLevel = level;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = h.level;</span><br><span class="line">            <span class="keyword">for</span> (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123;</span><br><span class="line">	            <span class="comment">//其他线程并发操作导致头结点被删除，直接退出外层循环</span></span><br><span class="line">	            <span class="comment">//这种情况发生的概率很小，除非并发量实在太大</span></span><br><span class="line">                <span class="keyword">if</span> (q == <span class="keyword">null</span> || t == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span> splice;</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; n = r.node;</span><br><span class="line">                    <span class="keyword">int</span> c = cpr(cmp, key, n.key);</span><br><span class="line">                    <span class="comment">//如果 n 正在被其他线程删除，那么调用 unlink 去删除它</span></span><br><span class="line">                    <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="comment">//重新获取 q 的右结点，再次进入循环</span></span><br><span class="line">                        r = q.right;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//c &gt; 0 说明前驱结点定位有误，重新进入</span></span><br><span class="line">                    <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        q = r;</span><br><span class="line">                        r = r.right;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == insertionLevel) &#123;</span><br><span class="line">		            <span class="comment">//尝试着将 t 插在 q 和 r 之间，如果失败了，退出内循环重试</span></span><br><span class="line">                    <span class="keyword">if</span> (!q.link(r, t))</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">// restart</span></span><br><span class="line">                    <span class="comment">//如果插入完成后，t 结点被删除了，那么结束插入操作</span></span><br><span class="line">                    <span class="keyword">if</span> (t.node.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        findNode(key);</span><br><span class="line">                        <span class="keyword">break</span> splice;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// insertionLevel-- 处理底层链接</span></span><br><span class="line">                    <span class="keyword">if</span> (--insertionLevel == <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span> splice;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">//--j，j 应该与 insertionLevel 同步，它代表着我们创建的那个纵向的结点数组的索引</span></span><br><span class="line">				<span class="comment">//并完成层次下移操作</span></span><br><span class="line">                <span class="keyword">if</span> (--j &gt;= insertionLevel &amp;&amp; j &lt; level)</span><br><span class="line">                    t = t.down;</span><br><span class="line">                <span class="comment">//至此，新节点在当前层次的前后引用关系已经被链接完成，现在处理下一层</span></span><br><span class="line">                q = q.down;</span><br><span class="line">                r = q.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们根据概率算法得到了一个 level 值，并且通过第二步创建了 level 个新节点并构成了一个纵向的引用关联，但是这些纵向的结点并没有链接到每层中。而我们的第三部分代码就是完成的这个工作，将我们的新节点在每个索引层都构建好前后的链接关系。下面用三张图描述着三个部分所完成的主要工作。</p>
<p>初始化的跳表如下：</p>
<p><img src="_v_images/20200819194445120_1704156511" alt="这里写图片描述"></p>
<p>第一部分，新增一个结点到最底层的链表上。</p>
<p><img src="_v_images/20200819194444915_223530245" alt="这里写图片描述"></p>
<p>第二部分，假设概率得出一个 level 值为 10，那么根据跳表的算法描述需要新建一层索引层。</p>
<p><img src="_v_images/20200819194444711_692580724" alt="这里写图片描述"></p>
<p>第三步，链接各个索引层次上的新节点。</p>
<p><img src="_v_images/20200819194444122_943848032" alt="这里写图片描述"></p>
<p>这样就完成了新增结点到跳表中的全部过程，大体上已如上图描述，至于 ConcurrentSkipListMap 中关于并发处理的细节之处，图中无法展示，大家可据此重新感受下源码的实现过程。下面我们着重描述下整个 doPut 方法中还涉及的其他几个方法的具体实现。</p>
<p><strong>首先是 findPredecessor 方法</strong>，我们说该方法将根据给定的 key，为我们返回最合适的前驱节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node&lt;K,V&gt; <span class="title">findPredecessor</span><span class="params">(Object key, Comparator&lt;? <span class="keyword">super</span> K&gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Index&lt;K,V&gt; q = head, r = q.right, d;;) &#123;</span><br><span class="line">            <span class="comment">//r 为空说明 head 后面并没有其他节点了</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt; n = r.node;</span><br><span class="line">				<span class="comment">// r 节点处于待删除状态，那么尝试 unlink 它，失败了将重新进入循环再此尝试</span></span><br><span class="line">				<span class="comment">//否则重新获取 q 的右结点并重新进入循环查找前驱节点</span></span><br><span class="line">                <span class="keyword">if</span> (n.value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!q.unlink(r))</span><br><span class="line">                        <span class="keyword">break</span>;           <span class="comment">// restart</span></span><br><span class="line">                    r = q.right;         <span class="comment">// reread r</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//大于零说明当前位置上的 q 还不是我们要的前驱节点，继续往后找</span></span><br><span class="line">                <span class="keyword">if</span> (cpr(cmp, key, k) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    q = r;</span><br><span class="line">                    r = r.right;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前的 level 结束了或者 cpr(cmp, key, k) &lt;= 0 会达到此位置</span></span><br><span class="line">            <span class="comment">//往低层递归，如果没有低层了，那么当前的 q 就是最合适的前驱节点</span></span><br><span class="line">            <span class="comment">//整个循环只有这一个出口，无论如何最终都会从此处结束方法</span></span><br><span class="line">            <span class="keyword">if</span> ((d = q.down) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> q.node;</span><br><span class="line">           <span class="comment">//否则向低层递归并重置 q 和 r</span></span><br><span class="line">            q = d;</span><br><span class="line">            r = d.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后总结下 findPredecessor 方法的大体逻辑，首先程序会从 head 节点开始在当前的索引层上寻找最后一个比给定 key 小的结点，它就是我们需要的前驱节点（q），我们只需要返回它即可。</p>
<p><strong>其次我们看看 helpDelete 方法</strong>，当检测到某个结点的 value 属性值为 null 的时候，一般都会调用这个方法来删除该结点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   一般的调用形式如下：</span></span><br><span class="line"><span class="comment">   n.helpDelete(b, f);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helpDelete</span><span class="params">(Node&lt;K,V&gt; b, Node&lt;K,V&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f == next &amp;&amp; <span class="keyword">this</span> == b.next) &#123;</span><br><span class="line">       <span class="keyword">if</span> (f == <span class="keyword">null</span> || f.value != f) </span><br><span class="line">            casNext(f, <span class="keyword">new</span> Node&lt;K,V&gt;(f));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.casNext(<span class="keyword">this</span>, f.next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该方法是 Node 结点的内部实例方法，逻辑相对简单，此处不再赘述。通过该方法可以完成将 b.next 指向 f，完成对 n 结点的删除。</p>
<p>至此，有关 put 方法的源码分析就简单到这，大部分的代码还是用于实现跳表这种数据结构的构建和插入，关于并发的处理，你会发现基本都是双层 for 循环+ CAS 无锁式更新，如果遇到竞争失利将退出里层循环重新进行尝试，否则成功的话就会直接 return 或者退出外层循环并结束 CAS 操作。下面我们看删除操作是如何实现的。</p>
<h2 id="五、remove-并发删除操作的内部实现"><a href="#五、remove-并发删除操作的内部实现" class="headerlink" title="五、remove 并发删除操作的内部实现"></a>五、remove 并发删除操作的内部实现</h2><p>remove 方法的部分内容我们在介绍相关预备知识中已经提及过，此处的理解想必会容易些。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doRemove(key, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码比较多，建议读者结合自己的 jdk 源码共同来分析</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">doRemove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">//找到 key 的前驱节点</span></span><br><span class="line">		<span class="comment">//因为删除不单单是根据 key 找到对应的结点，然后赋 null 就完事的，还要负责链接该结点前后的关联</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; <span class="keyword">int</span> c;</span><br><span class="line">            <span class="comment">//目前 n 基本上就是我们要删除的结点，它为 null，那自然不用继续了，已经被删除了</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="comment">//再次确认 n 还是不是 b 的后继结点，如果不是将退出里层循环重新进入</span></span><br><span class="line">            <span class="keyword">if</span> (n != b.next)               </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//如果有人正在删除 n，那么帮助它删除</span></span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;     </span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//b 被删除了，重新定位前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)     </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//正常情况下，key 应该等于 n.key</span></span><br><span class="line">            <span class="comment">//key 大于 n.key 说明我们要找的结点可能在 n 的后面，往后递归即可</span></span><br><span class="line">            <span class="comment">//key 小于 n.key 说明 key 所代表的结点根本不存在</span></span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                b = n;</span><br><span class="line">                n = f;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果删除是根据键和值两个参数来删除的话，value 是不为 null 的</span></span><br><span class="line">            <span class="comment">//这种情况下，如果 n 的 value 属性不等于我们传入的 value ，那么是不进行删除的</span></span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span> &amp;&amp; !value.equals(v))</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">			<span class="comment">//下面三个步骤才是整个删除操作的核心，大致的逻辑我们也在上文提及过了，此处想必会容易理解些</span></span><br><span class="line">			<span class="comment">//第一步，尝试将待删结点的 value 属性赋值 null，失败将退出重试</span></span><br><span class="line">            <span class="keyword">if</span> (!n.casValue(v, <span class="keyword">null</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//第二步和第三步如果有一步由于竞争失败，将调用 findNode 方法根据我们第一步的成果，也就是删除所有 value 为 null 的结点</span></span><br><span class="line">            <span class="keyword">if</span> (!n.appendMarker(f) || !b.casNext(n, f))</span><br><span class="line">                findNode(key);  </span><br><span class="line">            <span class="comment">//否则说明三个步骤都成功完成了   </span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                findPredecessor(key, cmp);  </span><br><span class="line">                <span class="comment">//判断此次删除后是否导致某一索引层没有其他节点了，并适情况删除该层索引  </span></span><br><span class="line">                <span class="keyword">if</span> (head.right == <span class="keyword">null</span>)</span><br><span class="line">                    tryReduceLevel();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> V vv = (V)v;</span><br><span class="line">            <span class="keyword">return</span> vv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>remove 方法其实从整体上来看，首先会有一堆的判断，根据给定的 key 和 value 会判断是否存在与 key 对应的一个节点，也会判断和待删结点相关的前后结点是否正在被删除，并适情况帮助删除。其次才是删除的三大步骤，核心步骤还是将待删结点的 value 属性赋 null 以标记该结点无用了，至于这个 marker 也是为了分散并发冲突的，最后通过 casNext 完成结点的删除。</p>
<h2 id="六、get-方法获取指定结点的-value"><a href="#六、get-方法获取指定结点的-value" class="headerlink" title="六、get 方法获取指定结点的 value"></a><strong>六、get 方法获取指定结点的 value</strong></h2><p>算上本小节将要介绍的 “查” 方法，我们就完成了对并发跳表 “增删改查” 的全部分析。 相对于“增”来说，其他的三种操作还是相对容易的，尤其是本小节的“查”操作，下面我们看看它的内部实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGet(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">doGet</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cmp = comparator;</span><br><span class="line">	<span class="comment">//依然是双层循环来处理并发</span></span><br><span class="line">    outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123;</span><br><span class="line">            Object v; <span class="keyword">int</span> c;</span><br><span class="line">            <span class="comment">//以下的一些判断的作用已经描述了多次，此处不再赘述了</span></span><br><span class="line">            <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            Node&lt;K,V&gt; f = n.next;</span><br><span class="line">            <span class="keyword">if</span> (n != b.next)           </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> ((v = n.value) == <span class="keyword">null</span>) &#123;    </span><br><span class="line">                n.helpDelete(b, f);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (b.value == <span class="keyword">null</span> || v == n)  </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//c = 0 说明 n 就是我们要的结点</span></span><br><span class="line">            <span class="keyword">if</span> ((c = cpr(cmp, key, n.key)) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> V vv = (V)v;</span><br><span class="line">                <span class="keyword">return</span> vv;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//c &lt; 0 说明不存在这个 key 所对应的结点</span></span><br><span class="line">            <span class="keyword">if</span> (c &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span> outer;</span><br><span class="line">            b = n;</span><br><span class="line">            n = f;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>doGet 方法的实现相对还是比较简单的，所以并没有给出太多的注释，主要还是由于大量的并发判断的代码都是一样的，大多都已经在 doPut 方法中给予了详细的注释了。</p>
<h2 id="七、其它的一些方法的简单描述"><a href="#七、其它的一些方法的简单描述" class="headerlink" title="七、其它的一些方法的简单描述"></a><strong>七、其它的一些方法的简单描述</strong></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否包含指定 key 的结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGet(key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据 key 返回该 key 所代表的结点的 value 值，不存在该结点则返回默认的 defaultValue</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    V v;</span><br><span class="line">    <span class="keyword">return</span> (v = doGet(key)) == <span class="keyword">null</span> ? defaultValue : v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回跳表的实际存储元素个数，采取遍历来进行统计</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; n = findFirst(); n != <span class="keyword">null</span>; n = n.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n.getValidValue() != <span class="keyword">null</span>)</span><br><span class="line">            ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (count &gt;= Integer.MAX_VALUE) ? Integer.MAX_VALUE : (<span class="keyword">int</span>) count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回所有键的集</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NavigableSet&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    KeySet&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">return</span> (ks != <span class="keyword">null</span>) ? ks : (keySet = <span class="keyword">new</span> KeySet&lt;K&gt;(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回所有值的集</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Values&lt;V&gt; vs = values;</span><br><span class="line">    <span class="keyword">return</span> (vs != <span class="keyword">null</span>) ? vs : (values = <span class="keyword">new</span> Values&lt;V&gt;(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里需要说明一点的是，虽然返回来的是键或者值的一个集合，但是无论你是通过这个集合获取键或者值，还是删除集合中的键或者值，都会直接映射到当前跳表实例中。原因是这个集合中没有一个方法是自己实现的，都是调用传入的跳表实例的内部方法，具体的大家查看源码即可知晓，此处不再贴出源码。</p>
<p>至此，有关 SkipList 这种跳表数据结构及其在 jdk 中的实现，以及它的并发版本 ConcurrentSkipListMap 的实现，我们都已经简单的分析完了，有理解错误之处，望指出，相互学习！</p>
<h4 id="参考的几篇优秀博文"><a href="#参考的几篇优秀博文" class="headerlink" title="参考的几篇优秀博文"></a><strong>参考的几篇优秀博文</strong></h4><p><a target="_blank" rel="noopener" href="http://xiaobaoqiu.github.io/blog/2014/12/19/javabing-fa-rong-qi-zhi-skiplist/">Java并发容器之SkipList（需要科学上网）  
</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/lihui6636/article/details/48947407">深入Java集合学习系列：ConcurrentSkipListMap实现原理</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/guangcigeyun/article/details/8278349">Java多线程（四）之ConcurrentSkipListMap深入分析</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/bigdata/Flink/Flink-SQL-Calcite/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/bigdata/Flink/Flink-SQL-Calcite/" class="post-title-link" itemprop="url">Flink-SQL原理之Calcite</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-18 07:58:00" itemprop="dateCreated datePublished" datetime="2021-04-18T07:58:00+08:00">2021-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-22 22:07:02" itemprop="dateModified" datetime="2021-04-22T22:07:02+08:00">2021-04-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/bigdata/" itemprop="url" rel="index"><span itemprop="name">bigdata</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>Flink SQL是Flink API的最顶层抽象，在使用Flink SQL的时候，是否被其便捷和高效惊艳到？到底一条SQL语句是如何运行起来的？提到Flink SQL，离不开SQL引擎框架 – Calcite。Calcite是面向Hadoop的查询引擎，提供了SQL解析、优化、多重数据源查询的基础框架。Flink借助Calcite实现了SQL解析、优化和graph生成。</p>
</blockquote>
<h2 id="Flink-API与Flink-SQL简介"><a href="#Flink-API与Flink-SQL简介" class="headerlink" title="Flink API与Flink SQL简介"></a>Flink API与Flink SQL简介</h2><p><img src="https://gitee.com/averyzhang/pic-go/raw/master/img/20210418105609.png" alt="img"></p>
<p>Flink提供了三层API抽象，每一层API都是便捷性和变现力之前的权衡，来应对不同的计算场景。</p>
<p>Flink SQL是最顶层的抽象，这层抽象在语义和程序表达式上都类似于Table API，但是程序实现都是SQL表达式: </p>
<ol>
<li><p>SQL和Table API都是遵循关系模型：元数据和操作</p>
<ul>
<li>元数据类似于关系型数据库中的schema</li>
<li>操作类似于关系型数据库中的操作, 如select、project、join、group-by和aggregate</li>
</ul>
</li>
<li><p>SQL和Table API都是声明式定义，而不会执行执行的具体代码</p>
</li>
<li><p>简洁，通过UDF扩展，但比core API的表达能力差</p>
</li>
<li><p>执行之前，通过优化器中的优化规则对用户编写的表达式进行优化</p>
</li>
<li><p>TableEnvironment是Flink SQL和Table API的入口，可以无缝切换到DataStream/DataSet, 允许混用。</p>
</li>
</ol>
<h2 id="Calcite"><a href="#Calcite" class="headerlink" title="Calcite"></a>Calcite</h2><h3 id="Calcite简介"><a href="#Calcite简介" class="headerlink" title="Calcite简介"></a>Calcite简介</h3><p>是一个动态数据的管理框架，可以用来构建数据库系统的语法解析模块</p>
<ul>
<li>不包含数据存储、数据处理等功能</li>
<li>可以通过编写 Adaptor 来扩展功能，以支持不同的数据处理平台</li>
<li>Flink SQL 使用并对其扩展以支持 SQL 语句的解析和验证</li>
</ul>
<p>Calcite提供了SQL parser、SQL validation、Query optimizer、SQL generator和Data federator</p>
<h3 id="查询的执行过程"><a href="#查询的执行过程" class="headerlink" title="查询的执行过程"></a>查询的执行过程</h3><p>分四步: </p>
<p><img src="https://gitee.com/averyzhang/pic-go/raw/master/img/20210418225117.png" alt="img"></p>
<ol>
<li>Parse(SQL -&gt; SqlNode ):  使用JavaCC生成的parser来转换查询</li>
<li>validate(SqlNode -&gt; SqlNode ): 通过元数据验证查询</li>
<li>optimize: 逻辑计划优化和转换为物理计划<ul>
<li>语义分析(SqlNode -&gt; RelNode/RexNode ): 根据 SqlNode 及元信息构建 RelNode 树，也就是最初版本的逻辑计划（Logical Plan）；</li>
<li>逻辑计划优化(RelNode -&gt; RelNode ): 优化器的核心，根据前面生成的逻辑计划按照相应的规则（Rule）进行优化；</li>
</ul>
</li>
<li>execute: 物理计划转换为应用框架的执行逻辑(如Flink的graph)</li>
</ol>
<h3 id="Catalog"><a href="#Catalog" class="headerlink" title="Catalog"></a>Catalog</h3><p>定义Calcite查询的命名空间:</p>
<p><code>Schema</code> :  <code>schema</code>和<code>table</code>的集合，可以任意嵌套</p>
<p><code>Table</code>: 代表单个数据集，字段定义为<code>RelDataType</code></p>
<p><code>RelDataType</code>:  代表数据集中的字段，支持所有的SQL数据类型，包括结构体</p>
<p><code>Statistic</code>: 提供用于优化的表统计信息, 如行数、分布信息、是否为key</p>
<p><img src="https://gitee.com/averyzhang/pic-go/raw/master/img/20210418173928.png" alt="image-20210418173928391"></p>
<h3 id="SQL-parser"><a href="#SQL-parser" class="headerlink" title="SQL parser"></a>SQL parser</h3><ul>
<li>LL(K) parser通过JavaCC(Java Compiler Compiler)写的</li>
<li>输入的查询转换为AST(abstract syntax tree)</li>
<li><code>SqlNode</code>代表Token</li>
<li><code>SqlNode</code>可以通过<code>unparse</code>方法转换会SQL</li>
</ul>
<p><img src="https://gitee.com/averyzhang/pic-go/raw/master/img/20210418181320.png" alt="image-20210418181320343"></p>
<p><code>SqlNode</code>代表AST中的一个节点</p>
<p><img src="https://gitee.com/averyzhang/pic-go/raw/master/img/20210418181402.png" alt="image-20210418181402108"></p>
<p><code>SqlDialect</code>代表特定数据库的方言规则</p>
<h3 id="Query-optimizer"><a href="#Query-optimizer" class="headerlink" title="Query optimizer"></a>Query optimizer</h3><p>查询计划(Query plans)代表执行一个查询必须的步骤</p>
<p><img src="https://gitee.com/averyzhang/pic-go/raw/master/img/20210418184009.png" alt="image-20210418184009836"></p>
<p>Query优化:</p>
<ul>
<li>优化逻辑计划</li>
<li>目标通常是尽量减少计划中必须在早期处理的数据量</li>
<li>将逻辑计划转换为物理计划</li>
<li>物理计划与引擎有关，代表了物理执行过程</li>
</ul>
<p>常见的优化方法:</p>
<table>
<thead>
<tr>
<th><strong>RBO</strong></th>
<th><strong>规则名称</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>列裁剪</td>
<td>column_prune</td>
<td>Prune unused fields</td>
</tr>
<tr>
<td>子查询去关联</td>
<td>decorrelate</td>
<td></td>
</tr>
<tr>
<td>子查询转换为join</td>
<td></td>
<td>Convert subqueries to joins</td>
</tr>
<tr>
<td>聚合消除</td>
<td>aggregation_eliminate</td>
<td></td>
</tr>
<tr>
<td>投影消除</td>
<td>projection_eliminate</td>
<td></td>
</tr>
<tr>
<td>最大最小消除</td>
<td>max_min_eliminate</td>
<td></td>
</tr>
<tr>
<td>谓词下推</td>
<td>predicate_push_down</td>
<td></td>
</tr>
<tr>
<td>外连接消除</td>
<td>outer_join_eliminate</td>
<td></td>
</tr>
<tr>
<td>分区裁剪</td>
<td>partition_processor</td>
<td></td>
</tr>
<tr>
<td>聚合下推</td>
<td>aggregation_push_down</td>
<td></td>
</tr>
<tr>
<td>TopN 下推</td>
<td>topn_push_down</td>
<td></td>
</tr>
<tr>
<td>Join 重排序</td>
<td>join_reorder</td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/averyzhang/pic-go/raw/master/img/20210418190336.png" alt="image-20210418190335990"></p>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ol>
<li><strong>关系代数</strong>（Relational algebra）：即关系表达式。它们通常以动词命名，例如 Sort, Join, Project, Filter, Scan, Sample.</li>
<li><strong>行表达式</strong>（Row expressions）：例如 RexLiteral (常量), RexVariable (变量), RexCall (调用) 等，例如投影列表（Project）、过滤规则列表（Filter）、JOIN 条件列表和 ORDER BY 列表、WINDOW 表达式、函数调用等。使用 RexBuilder 来构建行表达式。</li>
<li>表达式有各种<strong>特征</strong>（Trait）：使用 Trait 的 satisfies() 方法来测试某个表达式是否符合某 Trait 或 Convention.</li>
<li><strong>转化特征</strong>（Convention）：属于 Trait 的子类，用于转化 RelNode 到具体平台实现（可以将下文提到的 Planner 注册到 Convention 中）. 例如 JdbcConvention，FlinkConventions.DATASTREAM 等。同一个关系表达式的输入必须来自单个数据源，各表达式之间通过 Converter 生成的 Bridge 来连接。</li>
<li><strong>规则</strong>（Rules）：用于将一个表达式转换（Transform）为另一个表达式。它有一个由 RelOptRuleOperand 组成的列表来决定是否可将规则应用于树的某部分。</li>
</ol>
<h3 id="Planner-规划器"><a href="#Planner-规划器" class="headerlink" title="Planner(规划器)"></a>Planner(规划器)</h3><p><strong>规划器</strong>（Planner） ：即请求优化器，它可以根据一系列规则和成本模型（例如基于成本的优化模型 VolcanoPlanner、启发式优化模型 HepPlanner）来将一个表达式转为语义等价（但效率更优）的另一个表达式。</p>
<h4 id="HepPlanner-启发式优化模型"><a href="#HepPlanner-启发式优化模型" class="headerlink" title="HepPlanner(启发式优化模型)"></a>HepPlanner(启发式优化模型)</h4><ul>
<li>与Spark优化器类似的启发式优化器</li>
<li>启发式优化比CBO要快速</li>
<li>如果规则对计划做出相反的改变，则存在无限递归的风险</li>
</ul>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="VolcanoPlanner-基于成本的优化模型"><a href="#VolcanoPlanner-基于成本的优化模型" class="headerlink" title="VolcanoPlanner(基于成本的优化模型)"></a>VolcanoPlanner(基于成本的优化模型)</h4><ul>
<li>遍历所有的规则，选择代价最小的计划</li>
<li>代价是通过关系表达式提供的</li>
<li>并不是所有可能的计划都会计算</li>
<li>当经过指定的迭代未显著提升将停止优化</li>
<li>代价包括行数、I/O和CPU</li>
<li>Statistics用来提高代价评估的准确性</li>
<li>Calcite提供了工具来在统计资源消耗</li>
</ul>
<h2 id="Flink-与-Calcite"><a href="#Flink-与-Calcite" class="headerlink" title="Flink 与 Calcite"></a>Flink 与 Calcite</h2><h3 id="Calcite中Flink中的重要作用"><a href="#Calcite中Flink中的重要作用" class="headerlink" title="Calcite中Flink中的重要作用"></a>Calcite中Flink中的重要作用</h3><p><img src="https://gitee.com/averyzhang/pic-go/raw/master/img/20210418224641.png" alt="在这里插入图片描述"></p>
<p>在Flink中，Calcite扮演着重要的角色：</p>
<ul>
<li>以Calcite Catalog为核心，上面承载了Table/SQL API</li>
<li>Flink SQL和Table的代码最后生成Calcite Logic Plan(SqlNode Tree)</li>
<li>随后验证、优化为 RelNode 树，</li>
<li>最终通过 Rules（规则）和 Convention（转化特征）生成具体的 DataSet Plan（批处理）或 DataStream Plan（流处理），即 Flink 算子构成的处理逻辑。</li>
</ul>
<p><img src="https://gitee.com/averyzhang/pic-go/raw/master/img/20210418225006.png" alt="在这里插入图片描述"></p>
<p>Table / SQL API 的编程框架如下：</p>
<ul>
<li><p>通过 TableEnvironment 配置 CalciteConfig 对象，自动设置 SQL &amp; Table API 默认处理参数。</p>
</li>
<li><p>使用 registerTableSource() 来将一个 TableSource 注册到 rootSchema. 后续可以通过 scan() 获取此 Table 并调用各种 Table API 进行处理。</p>
</li>
<li><p>接下可以调用 sqlQuery() 和 sqlUpdate() 方法来使用 SQL 语句进行数据处理。</p>
</li>
</ul>
<h3 id="Flink-SQL的执行流程"><a href="#Flink-SQL的执行流程" class="headerlink" title="Flink SQL的执行流程"></a>Flink SQL的执行流程</h3><p><code>Planner接口</code>: 解析SQL，转换为Transformation</p>
<p><code>Executor接口</code>: 将Planner转换的Transformation生成streamGraph并执行</p>
<p><code>Parser接口</code>: 负责SQL解析，parse方法将SQL语句转换为Operation数组</p>
<ul>
<li>通过Calcite将SQL解析为SqlNode</li>
<li>根据SqlNode的类型，将SqlNode转换为Operation数组</li>
</ul>
<p>DDL语句的转换过程:</p>
<p>SqlNode转换为RelNode:</p>
<ul>
<li>推断Table类型</li>
<li>推断计算列</li>
<li>推断watermark分配</li>
</ul>
<p>SQL转换:</p>
<ol>
<li>Operation-&gt;RelNode</li>
<li>优化RelNode</li>
<li>RelNode-&gt;ExecNode</li>
<li>ExecNode-&gt;Transformation算子</li>
</ol>
<p>[参考文献]</p>
<ol>
<li>[Parsing database Query with Apache Calcite](<a target="_blank" rel="noopener" href="https://blog.knoldus.com/parsing-database-query-with-apache-calcite/">Parsing database Query with Apache Calcite - Knoldus Blogs</a>)</li>
<li><a target="_blank" rel="noopener" href="https://www.slideshare.net/julianhyde/apache-calcite-one-planner-fits-all">Apache Calcite: One planner fits all (slideshare.net)</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/bigdata/Flink/Flink-SQL-Window/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/bigdata/Flink/Flink-SQL-Window/" class="post-title-link" itemprop="url">Flink sql window</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-12 19:47:00" itemprop="dateCreated datePublished" datetime="2021-04-12T19:47:00+08:00">2021-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-22 22:07:02" itemprop="dateModified" datetime="2021-04-22T22:07:02+08:00">2021-04-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/bigdata/" itemprop="url" rel="index"><span itemprop="name">bigdata</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>flink窗口函数包含滚动窗口、滑动窗口、会话窗口和OVER窗口</p>
<h2 id="Flink-SQL-窗口的基本概念与使用"><a href="#Flink-SQL-窗口的基本概念与使用" class="headerlink" title="Flink SQL 窗口的基本概念与使用"></a>Flink SQL 窗口的基本概念与使用</h2><h3 id="滚动窗口"><a href="#滚动窗口" class="headerlink" title="滚动窗口"></a>滚动窗口</h3><p>滚动窗口（TUMBLE）将每个元素分配到一个指定大小的窗口中。通常，滚动窗口有一个固定的大小，并且不会出现重叠。例如，如果指定了一个5分钟大小的滚动窗口，无限流的数据会根据时间划分为<code>[0:00 - 0:05)</code>、<code>[0:05, 0:10)</code>、<code>[0:10, 0:15)</code>等窗口。下图展示了一个30秒的滚动窗口。<br><img src="_v_images/20210412125050690_701107302"><br>使用标识函数选出窗口的起始时间或者结束时间，窗口的时间属性用于下级Window的聚合。</p>
<table>
<thead>
<tr>
<th>窗口标识函数</th>
<th>返回类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>TUMBLE_START(time-attr, size-interval)</code></td>
<td>TIMESTAMP</td>
<td>返回窗口的起始时间（包含边界）。例如<code>[00:10, 00:15)</code> 窗口，返回<code>00:10</code> 。</td>
</tr>
<tr>
<td><code>TUMBLE_END(time-attr, size-interval)</code></td>
<td>TIMESTAMP</td>
<td>返回窗口的结束时间（包含边界）。例如<code>[00:00, 00:15]</code>窗口，返回<code>00:15</code>。</td>
</tr>
<tr>
<td><code>TUMBLE_ROWTIME(time-attr, size-interval)</code></td>
<td>TIMESTAMP(rowtime-attr)</td>
<td>返回窗口的结束时间（不包含边界）。例如<code>[00:00, 00:15]</code>窗口，返回<code>00:14:59.999</code> 。返回值是一个rowtime attribute，即可以基于该字段做时间属性的操作，例如，级联窗口只能用在基于Event Time的Window上</td>
</tr>
<tr>
<td><code>TUMBLE_PROCTIME(time-attr, size-interval)</code></td>
<td>TIMESTAMP(rowtime-attr)</td>
<td>返回窗口的结束时间（不包含边界）。例如<code>[00:00, 00:15]</code>窗口，返回<code>00:14:59.999</code>。返回值是一个proctime attribute，即可以基于该字段做时间属性的操作，例如，级联窗口只能用在基于Processing Time的Window上</td>
</tr>
</tbody></table>
<p>TUMBLE window示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.TypeHint;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.TypeInformation;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple3;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.TimeCharacteristic;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.timestamps.AscendingTimestampExtractor;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.EnvironmentSettings;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.Table;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.bridge.java.StreamTableEnvironment;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Timestamp;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TumbleWindowExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1 注册环境</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        EnvironmentSettings mySetting = EnvironmentSettings</span><br><span class="line">                .newInstance()</span><br><span class="line"><span class="comment">//                .useOldPlanner()</span></span><br><span class="line">                .useBlinkPlanner()</span><br><span class="line">                .inStreamingMode()</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 environment</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">// 指定系统时间概念为 event time</span></span><br><span class="line">        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line"></span><br><span class="line">        StreamTableEnvironment tEnv = StreamTableEnvironment.create(env,mySetting);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始数据</span></span><br><span class="line">        DataStream&lt;Tuple3&lt;Long, String,Integer&gt;&gt; log = env.fromCollection(Arrays.asList(</span><br><span class="line">                <span class="comment">//时间 14:53:00</span></span><br><span class="line">                <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="number">1572591180_000L</span>,<span class="string">&quot;xiao_ming&quot;</span>,<span class="number">300</span>),</span><br><span class="line">                <span class="comment">//时间 14:53:09</span></span><br><span class="line">                <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="number">1572591189_000L</span>,<span class="string">&quot;zhang_san&quot;</span>,<span class="number">303</span>),</span><br><span class="line">                <span class="comment">//时间 14:53:12</span></span><br><span class="line">                <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="number">1572591192_000L</span>, <span class="string">&quot;xiao_li&quot;</span>,<span class="number">204</span>),</span><br><span class="line">                <span class="comment">//时间 14:53:21</span></span><br><span class="line">                <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="number">1572591201_000L</span>,<span class="string">&quot;li_si&quot;</span>, <span class="number">208</span>)</span><br><span class="line">                ));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定时间戳</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple3&lt;Long, String, Integer&gt;&gt; logWithTime = log.assignTimestampsAndWatermarks(<span class="keyword">new</span> AscendingTimestampExtractor&lt;Tuple3&lt;Long, String, Integer&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractAscendingTimestamp</span><span class="params">(Tuple3&lt;Long, String, Integer&gt; element)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> element.f0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为 Table</span></span><br><span class="line">        Table logT = tEnv.fromDataStream(logWithTime, <span class="string">&quot;t.rowtime, name, v&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Table result = tEnv.sqlQuery(<span class="string">&quot;SELECT TUMBLE_START(t, INTERVAL &#x27;10&#x27; SECOND) AS window_start,&quot;</span> +</span><br><span class="line">                <span class="string">&quot;TUMBLE_END(t, INTERVAL &#x27;10&#x27; SECOND) AS window_end, SUM(v) FROM &quot;</span></span><br><span class="line">                + logT + <span class="string">&quot; GROUP BY TUMBLE(t, INTERVAL &#x27;10&#x27; SECOND)&quot;</span>);</span><br><span class="line"></span><br><span class="line">        TypeInformation&lt;Tuple3&lt;Timestamp,Timestamp,Integer&gt;&gt; tpinf = <span class="keyword">new</span> TypeHint&lt;Tuple3&lt;Timestamp,Timestamp,Integer&gt;&gt;()&#123;&#125;.getTypeInfo();</span><br><span class="line">        tEnv.toAppendStream(result, tpinf).print();</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>sql逻辑，每十秒钟聚合<br>执行结果：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(2019-11-01 06:53:00.0,2019-11-01 06:53:10.0,603)  </span><br><span class="line">(2019-11-01 06:53:20.0,2019-11-01 06:53:30.0,208)  </span><br><span class="line">(2019-11-01 06:53:10.0,2019-11-01 06:53:20.0,204)</span><br></pre></td></tr></table></figure>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>滑动窗口（HOP），也被称作Sliding Window。不同于滚动窗口，滑动窗口的窗口可以重叠。</p>
<p>滑动窗口有两个参数：slide和size。slide为每次滑动的步长，size为窗口的大小。</p>
<ul>
<li>slide &lt; size，则窗口会重叠，每个元素会被分配到多个窗口。</li>
<li>slide = size，则等同于滚动窗口（TUMBLE）。</li>
<li>slide &gt; size，则为跳跃窗口，窗口之间不重叠且有间隙。</li>
</ul>
<p>通常，大部分元素符合多个窗口情景，窗口是重叠的。因此，滑动窗口在计算移动平均数（moving averages）时很实用。例如，计算过去5分钟数据的平均值，每10秒钟更新一次，可以设置slide为10秒，size为5分钟。下图为您展示间隔为30秒，窗口大小为1分钟的滑动窗口。</p>
<p><img src="_v_images/20210412125050182_1936746176" alt="滑动窗口" title="滑动窗口"></p>
<p>使用滑动窗口标识函数选出窗口的起始时间或者结束时间，窗口的时间属性用于下级Window的聚合。</p>
<table>
<thead>
<tr>
<th>窗口标识函数</th>
<th>返回类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>HOP_START（&lt;time-attr&gt;, &lt;slide-interval&gt;, &lt;size-interval&gt;）</code></td>
<td>TIMESTAMP</td>
<td>返回窗口的起始时间（包含边界）。例如<code>[00:10, 00:15)</code> 窗口，返回<code>00:10</code> 。</td>
</tr>
<tr>
<td><code>HOP_END（&lt;time-attr&gt;, &lt;slide-interval&gt;, &lt;size-interval&gt;）</code></td>
<td>TIMESTAMP</td>
<td>返回窗口的结束时间（包含边界）。例如<code>[00:00, 00:15)</code> 窗口，返回<code>00:15</code>。</td>
</tr>
<tr>
<td><code>HOP_ROWTIME（&lt;time-attr&gt;, &lt;slide-interval&gt;, &lt;size-interval&gt;）</code></td>
<td>TIMESTAMP（rowtime-attr）</td>
<td>返回窗口的结束时间（不包含边界）。例如<code>[00:00, 00:15)</code> 窗口，返回<code>00:14:59.999</code>。返回值是一个rowtime attribute，即可以基于该字段做时间类型的操作，只能用在基于event time的window上。</td>
</tr>
<tr>
<td><code>HOP_PROCTIME（&lt;time-attr&gt;, &lt;slide-interval&gt;, &lt;size-interval&gt;）</code></td>
<td>TIMESTAMP（rowtime-attr）</td>
<td>返回窗口的结束时间（不包含边界）。例如<code>[00:00, 00:15)</code> 窗口，返回<code>00:14:59.999</code> 。返回值是一个proctime attribute</td>
</tr>
</tbody></table>
<p>滑动窗口实例：<br>java代码同上，sql语句改为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> HOP_START(t, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">SECOND</span>, <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> <span class="keyword">SECOND</span>) <span class="keyword">AS</span> window_start, HOP_END(t, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">SECOND</span>, <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> <span class="keyword">SECOND</span>) <span class="keyword">AS</span> window_end, <span class="built_in">SUM</span>(v) <span class="keyword">FROM</span>   logT   <span class="keyword">GROUP</span> <span class="keyword">BY</span> HOP(t, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">SECOND</span>, <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> <span class="keyword">SECOND</span>)</span><br></pre></td></tr></table></figure>
<p>每间隔5秒统计10秒内的数据<br>sql结果如下：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(2019-11-01 06:53:15.0,2019-11-01 06:53:25.0,208)  </span><br><span class="line">(2019-11-01 06:53:10.0,2019-11-01 06:53:20.0,204)  </span><br><span class="line">(2019-11-01 06:53:05.0,2019-11-01 06:53:15.0,507)  </span><br><span class="line">(2019-11-01 06:53:20.0,2019-11-01 06:53:30.0,208)  </span><br><span class="line">(2019-11-01 06:53:00.0,2019-11-01 06:53:10.0,603)  </span><br><span class="line">(2019-11-01 06:52:55.0,2019-11-01 06:53:05.0,300)</span><br></pre></td></tr></table></figure>
<h3 id="会话窗口"><a href="#会话窗口" class="headerlink" title="会话窗口"></a>会话窗口</h3><p>会话窗口（SESSION）通过Session活动来对元素进行分组。会话窗口与滚动窗口和滑动窗口相比，没有窗口重叠，没有固定窗口大小。相反，当它在一个固定的时间周期内不再收到元素，即会话断开时，这个窗口就会关闭。</p>
<p>会话窗口通过一个间隔时间（Gap）来配置，这个间隔定义了非活跃周期的长度。例如，一个表示鼠标点击活动的数据流可能具有长时间的空闲时间，并在两段空闲之间散布着高浓度的点击。 如果数据在指定的间隔（Gap）之后到达，则会开始一个新的窗口。</p>
<p>会话窗口示例如下图。每个Key由于不同的数据分布，形成了不同的Window。</p>
<p><img src="_v_images/20210412125049773_363551252"><br>使用标识函数选出窗口的起始时间或者结束时间，窗口的时间属性用于下级Window的聚合。</p>
<table>
<thead>
<tr>
<th>窗口标识函数</th>
<th>返回类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>SESSION_START（&lt;time-attr&gt;, &lt;gap-interval&gt;）</code></td>
<td>Timestamp</td>
<td>返回窗口的起始时间（包含边界）。如<code>[00:10, 00:15)</code> 的窗口，返回 <code>00:10</code> ，即为此会话窗口内第一条记录的时间。</td>
</tr>
<tr>
<td><code>SESSION_END（&lt;time-attr&gt;, &lt;gap-interval&gt;）</code></td>
<td>Timestamp</td>
<td>返回窗口的结束时间（包含边界）。如<code>[00:00, 00:15)</code> 的窗口，返回 <code>00:15</code>，即为此会话窗口内最后一条记录的时间+<code>&lt;gap-interval&gt;</code>。</td>
</tr>
<tr>
<td><code>SESSION_ROWTIME（&lt;time-attr&gt;, &lt;gap-interval&gt;）</code></td>
<td>Timestamp（rowtime-attr）</td>
<td>返回窗口的结束时间（不包含边界）。如 <code>[00:00, 00:15)</code> 的窗口，返回<code>00:14:59.999</code> 。返回值是一个rowtime attribute，也就是可以基于该字段进行时间类型的操作。该参数只能用于基于event time的window 。</td>
</tr>
<tr>
<td><code>SESSION_PROCTIME（&lt;time-attr&gt;, &lt;gap-interval&gt;）</code></td>
<td>Timestamp（rowtime-attr）</td>
<td>返回窗口的结束时间（不包含边界）。如 <code>[00:00, 00:15)</code> 的窗口，返回 <code>00:14:59.999</code> 。返回值是一个 proctime attribute，也就是可以基于该字段进行时间类型的操作。该参数只能用于基于processing time的window 。</td>
</tr>
</tbody></table>
<p>会话窗口实例：<br>java代码同上<br>sql语句如下：<br>每隔5秒聚合</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SESSION_START(t, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">SECOND</span>) <span class="keyword">AS</span> window_start,</span><br><span class="line">SESSION_END(t, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">SECOND</span>) <span class="keyword">AS</span> window_end, <span class="built_in">SUM</span>(v) <span class="keyword">FROM</span>  logT  <span class="keyword">GROUP</span> <span class="keyword">BY</span> SESSION(t, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">SECOND</span>)</span><br></pre></td></tr></table></figure>
<p>sql结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(2019-11-01 06:53:21.0,2019-11-01 06:53:26.0,208)  </span><br><span class="line">(2019-11-01 06:53:00.0,2019-11-01 06:53:05.0,300)  </span><br><span class="line">(2019-11-01 06:53:09.0,2019-11-01 06:53:17.0,507)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="OVER窗口"><a href="#OVER窗口" class="headerlink" title="OVER窗口"></a>OVER窗口</h3><p>OVER窗口（OVER Window）是传统数据库的标准开窗，不同于Group By Window，OVER窗口中每1个元素都对应1个窗口。窗口内的元素是当前元素往前多少个或往前多长时间的元素集合，因此流数据元素分布在多个窗口中。</p>
<p>在应用OVER窗口的流式数据中，每1个元素都对应1个OVER窗口。每1个元素都触发1次数据计算，每个触发计算的元素所确定的行，都是该元素所在窗口的最后1行。在实时计算的底层实现中，OVER窗口的数据进行全局统一管理（数据只存储1份），逻辑上为每1个元素维护1个OVER窗口，为每1个元素进行窗口计算，完成计算后会清除过期的数据。</p>
<p>Flink SQL中对OVER窗口的定义遵循标准SQL的定义语法，传统OVER窗口没有对其进行更细粒度的窗口类型命名划分。按照计算行的定义方式，OVER Window可以分为以下两类：</p>
<ul>
<li>ROWS OVER Window：每一行元素都被视为新的计算行，即每一行都是一个新的窗口。</li>
<li>RANGE OVER Window：具有相同时间值的所有元素行视为同一计算行，即具有相同时间值的所有行都是同一个窗口。</li>
</ul>
<p>Rows OVER Window语义</p>
<p>窗口数据</p>
<p>ROWS OVER Window的每个元素都确定一个窗口。ROWS OVER Window分为Unbounded（无界流）和Bounded（有界流）两种情况。<br>Unbounded ROWS OVER Window数据示例如下图所示。<br><img src="_v_images/20210412125049063_1513990833"></p>
<p>虽然上图所示窗口user1的w7、w8及user2的窗口w3、w4都是同一时刻到达，但它们仍然在不同的窗口，这一点与RANGE OVER Window不同。</p>
<p>Bounded ROWS OVER Window数据以3个元素（往前2个元素）的窗口为例，如下图所示。</p>
<p><img src="_v_images/20210412125048555_824932679"></p>
<p>虽然上图所示窗口user1的w5、w6及user2的窗口w1、w2都是同一时刻到达，但它们仍然在不同的窗口，这一点与RANGE OVER Window不同。</p>
<p>RANGE OVER Window语义</p>
<p>窗口数据</p>
<p>RANGE OVER Window所有具有共同元素值（元素时间戳）的元素行确定一个窗口，RANGE OVER Window分为Unbounded和Bounded的两种情况。<br>Unbounded RANGE OVER Window数据示例如下图所示。</p>
<p><img src="_v_images/20210412125048048_1968314666"><br>上图所示窗口user1的w7、user2的窗口w3，两个元素同一时刻到达，属于相同的window，这一点与ROWS OVER Window不同。</p>
<p>Bounded RANGE OVER Window数据，以3秒中数据<code>(INTERVAL &#39;2&#39; SECOND)</code>的窗口为例，如下图所示。</p>
<p><img src="_v_images/20210412125047258_2027952546"></p>
<p>上图所示窗口user1的w6、user2的窗口w3，元素都是同一时刻到达，属于相同的window，这一点与ROWS OVER Window不同。</p>
<p>OVER窗口实例：<br>java代码同上<br>初始数据如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始数据</span></span><br><span class="line">DataStream&lt;Tuple3&lt;Long, String,Integer&gt;&gt; log = env.fromCollection(Arrays.asList(</span><br><span class="line">        <span class="comment">//时间 14:53:00</span></span><br><span class="line">        <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="number">1572591180_000L</span>,<span class="string">&quot;xiao_ming&quot;</span>,<span class="number">999</span>),</span><br><span class="line">        <span class="comment">//时间 14:53:09</span></span><br><span class="line">        <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="number">1572591189_000L</span>,<span class="string">&quot;zhang_san&quot;</span>,<span class="number">303</span>),</span><br><span class="line">        <span class="comment">//时间 14:53:12</span></span><br><span class="line">        <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="number">1572591192_000L</span>, <span class="string">&quot;xiao_li&quot;</span>,<span class="number">888</span>),</span><br><span class="line">        <span class="comment">//时间 14:53:21</span></span><br><span class="line">        <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="number">1572591201_000L</span>,<span class="string">&quot;li_si&quot;</span>, <span class="number">908</span>),</span><br><span class="line">        <span class="comment">//2019-11-01 14:53:31</span></span><br><span class="line">        <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="number">1572591211_000L</span>,<span class="string">&quot;li_si&quot;</span>, <span class="number">555</span>),</span><br><span class="line">        <span class="comment">//2019-11-01 14:53:41</span></span><br><span class="line">        <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="number">1572591221_000L</span>,<span class="string">&quot;zhang_san&quot;</span>, <span class="number">666</span>),</span><br><span class="line">        <span class="comment">//2019-11-01 14:53:51</span></span><br><span class="line">        <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="number">1572591231_000L</span>,<span class="string">&quot;xiao_ming&quot;</span>, <span class="number">777</span>),</span><br><span class="line">        <span class="comment">//2019-11-01 14:54:01</span></span><br><span class="line">        <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="number">1572591241_000L</span>,<span class="string">&quot;xiao_ming&quot;</span>, <span class="number">213</span>),</span><br><span class="line">        <span class="comment">//2019-11-01 14:54:11</span></span><br><span class="line">        <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="number">1572591251_000L</span>,<span class="string">&quot;zhang_san&quot;</span>, <span class="number">300</span>),</span><br><span class="line">        <span class="comment">//2019-11-01 14:54:21</span></span><br><span class="line">        <span class="keyword">new</span> Tuple3&lt;&gt;(<span class="number">1572591261_000L</span>,<span class="string">&quot;li_si&quot;</span>, <span class="number">112</span>)</span><br><span class="line">));</span><br></pre></td></tr></table></figure>
<p>ROWS over Windown sql语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name,v,<span class="built_in">MAX</span>(v) <span class="keyword">OVER</span>(</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> name </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> t </span><br><span class="line"><span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">2</span> PRECEDING <span class="keyword">AND</span> <span class="keyword">CURRENT</span> <span class="type">ROW</span></span><br><span class="line">) <span class="keyword">FROM</span> logT</span><br></pre></td></tr></table></figure>
<p>sql结果如下：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(zhang_san,303,303)  </span><br><span class="line">(xiao_li,888,888)  </span><br><span class="line">(li_si,908,908)  </span><br><span class="line">(xiao_ming,999,999)  </span><br><span class="line">(zhang_san,666,666)  </span><br><span class="line">(li_si,555,908)  </span><br><span class="line">(xiao_ming,777,999)  </span><br><span class="line">(li_si,112,908)  </span><br><span class="line">(zhang_san,300,666)  </span><br><span class="line">(xiao_ming,213,999)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>RANGE OVER Window sql 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name,v,<span class="built_in">MAX</span>(v) <span class="keyword">OVER</span>(</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> name </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> t </span><br><span class="line"><span class="keyword">RANGE</span> <span class="keyword">BETWEEN</span> <span class="type">INTERVAL</span> <span class="string">&#x27;15&#x27;</span> <span class="keyword">SECOND</span> PRECEDING <span class="keyword">AND</span> <span class="keyword">CURRENT</span> <span class="type">ROW</span></span><br><span class="line">) <span class="keyword">FROM</span>  logT</span><br></pre></td></tr></table></figure>
<p>sql结果如下：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(xiao_ming,999,999)  </span><br><span class="line">(xiao_li,888,888)  </span><br><span class="line">(zhang_san,303,303)  </span><br><span class="line">(li_si,908,908)  </span><br><span class="line">(li_si,555,908)  </span><br><span class="line">(xiao_ming,777,777)  </span><br><span class="line">(zhang_san,666,666)  </span><br><span class="line">(li_si,112,112)  </span><br><span class="line">(xiao_ming,213,777)  </span><br><span class="line">(zhang_san,300,300)</span><br></pre></td></tr></table></figure>
<p>本文的java代码来自：<br><a target="_blank" rel="noopener" href="https://github.com/CheckChe0803/flink-simple-tutorial/tree/master/table/src/main/java/sql/window">https://github.com/CheckChe08…</a></p>
<h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/UkpkS_JiRGR0ibZKYechbg">https://mp.weixin.qq.com/s/UkpkS_JiRGR0ibZKYechbg</a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>窗口是无限流上一种核心机制，可以流分割为有限大小的“窗口”，同时，在窗口内进行聚合，从而把源源不断产生的数据根据不同的条件划分成一段一段有边界的数据区间，使用户能够利用窗口功能实现很多复杂的统计分析需求。</p>
<h3 id="Window分类"><a href="#Window分类" class="headerlink" title="Window分类"></a>Window分类</h3><p>1、TimeWindow与CountWindow Flink Window可以是时间驱动的（<code>TimeWindow</code>），也可以是数据驱动的（CountWindow）。由于flink-planner-blink SQL中目前只支持TimeWindow相应的表达语句（<code>TUMBLE</code>、<code>HOP</code>、<code>SESSION</code>），因此，本文主要介绍TimeWindow SQL示例和逻辑，CountWindow感兴趣的读者可自行分析。</p>
<p>2、TimeWindow子类型 Flink TimeWindow有滑动窗口(<code>HOP</code>)、滚动窗口(<code>TUMBLE</code>)以及会话窗口(<code>SESSION</code>)三种，所选取的字段时间，可以是系统时间(<code>PROCTIME</code>)或事件时间(<code>EVENT TIME</code>)两种，接来下依次介绍。</p>
<h4 id="Tumble-Window（滚动窗口）"><a href="#Tumble-Window（滚动窗口）" class="headerlink" title="Tumble Window（滚动窗口）"></a>Tumble Window（滚动窗口）</h4><p>翻转窗口Assigner将每个元素分配给具有指定大小的窗口。翻转窗口的大小是固定的，且不会重叠。例如，指定一个大小为5分钟的翻滚窗口，并每5分钟启动一个新窗口，如下图所示：</p>
<p><img src="_v_images/20210412125430504_1844331455" alt="图片"></p>
<p>TUMBLE ROWTIME语法示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sessionOrderTableRowtime (</span><br><span class="line">    ctime <span class="type">TIMESTAMP</span>,</span><br><span class="line">    categoryName <span class="type">VARCHAR</span>,</span><br><span class="line">    shopName <span class="type">VARCHAR</span>,</span><br><span class="line">    itemName <span class="type">VARCHAR</span>,</span><br><span class="line">    userId <span class="type">VARCHAR</span>,</span><br><span class="line">    price <span class="type">FLOAT</span>,</span><br><span class="line">    action <span class="type">BIGINT</span>,</span><br><span class="line">    WATERMARK <span class="keyword">FOR</span> ctime <span class="keyword">AS</span> withOffset(ctime, <span class="number">1000</span>),</span><br><span class="line">    proc <span class="keyword">AS</span> PROCTIME()</span><br><span class="line">) <span class="keyword">with</span> (</span><br><span class="line">    `type` <span class="operator">=</span> <span class="string">&#x27;kafka&#x27;</span>,</span><br><span class="line">    format <span class="operator">=</span> <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">    updateMode <span class="operator">=</span> <span class="string">&#x27;append&#x27;</span>,</span><br><span class="line">    `group.id` <span class="operator">=</span> <span class="string">&#x27;groupId&#x27;</span>,</span><br><span class="line">    bootstrap.servers <span class="operator">=</span> <span class="string">&#x27;xxxxx:9092&#x27;</span>,</span><br><span class="line">    version <span class="operator">=</span> <span class="string">&#x27;0.10&#x27;</span>,</span><br><span class="line">    `zookeeper.connect` <span class="operator">=</span> <span class="string">&#x27;xxxxx:2181&#x27;</span>,</span><br><span class="line">    startingOffsets <span class="operator">=</span> <span class="string">&#x27;latest&#x27;</span>,</span><br><span class="line">    topic <span class="operator">=</span> <span class="string">&#x27;sessionsourceproctime&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> popwindowsink (</span><br><span class="line">    countA <span class="type">BIGINT</span>,</span><br><span class="line">    ctime_start <span class="type">TIMESTAMP</span>,</span><br><span class="line">    ctime_end <span class="type">VARCHAR</span>,</span><br><span class="line">    ctime_rowtime <span class="type">VARCHAR</span>,</span><br><span class="line">    categoryName <span class="type">VARCHAR</span>,</span><br><span class="line">    price_sum <span class="type">FLOAT</span></span><br><span class="line">) <span class="keyword">with</span> (</span><br><span class="line">    format <span class="operator">=</span> <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">    updateMode <span class="operator">=</span> <span class="string">&#x27;append&#x27;</span>,</span><br><span class="line">    bootstrap.servers <span class="operator">=</span> <span class="string">&#x27;xxxxx:9092&#x27;</span>,</span><br><span class="line">    version <span class="operator">=</span> <span class="string">&#x27;0.10&#x27;</span>,</span><br><span class="line">    topic <span class="operator">=</span> <span class="string">&#x27;sessionsinkproctime&#x27;</span>,</span><br><span class="line">    `type` <span class="operator">=</span> <span class="string">&#x27;kafka&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> popwindowsink</span><br><span class="line">(<span class="keyword">SELECT</span></span><br><span class="line"><span class="built_in">COUNT</span>(<span class="operator">*</span>),</span><br><span class="line">TUMBLE_START(ctime, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">MINUTE</span>),</span><br><span class="line">DATE_FORMAT(TUMBLE_END(ctime, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">MINUTE</span>), <span class="string">&#x27;yyyy-MM-dd-HH-mm-ss:SSS&#x27;</span>), <span class="comment">--将TUMBLE_END转为可视化的日期</span></span><br><span class="line">DATE_FORMAT(TUMBLE_ROWTIME(ctime, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">MINUTE</span>), <span class="string">&#x27;yyyy-MM-dd-HH-mm-ss:SSS&#x27;</span>), <span class="comment">--这里TUMBLE_ROWTIME为TUMBLE_END-1ms，一般用于后续窗口级联聚合</span></span><br><span class="line">categoryName,</span><br><span class="line"><span class="built_in">SUM</span>(price)</span><br><span class="line"><span class="keyword">FROM</span> sessionOrderTableRowtime</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> TUMBLE(ctime, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">MINUTE</span>), categoryName)</span><br></pre></td></tr></table></figure>
<p>TUMBLEP ROCTIME语法示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> popwindowsink</span><br><span class="line">(<span class="keyword">SELECT</span></span><br><span class="line"><span class="built_in">COUNT</span>(<span class="operator">*</span>),</span><br><span class="line">TUMBLE_START(proc, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">MINUTE</span>),</span><br><span class="line">DATE_FORMAT(TUMBLE_END(proc, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">MINUTE</span>), <span class="string">&#x27;yyyy-MM-dd-HH-mm-ss:SSS&#x27;</span>),</span><br><span class="line">DATE_FORMAT(TUMBLE_PROCTIME(proc, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">MINUTE</span>), <span class="string">&#x27;yyyy-MM-dd-HH-mm-ss:SSS&#x27;</span>), <span class="comment">--注意这里proc字段即Source DDL中指定的PROCTIME</span></span><br><span class="line">categoryName,</span><br><span class="line"><span class="built_in">SUM</span>(price)</span><br><span class="line"><span class="keyword">FROM</span> sessionOrderTableRowtime</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> TUMBLE(proc, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">MINUTE</span>), categoryName)</span><br></pre></td></tr></table></figure>
<p>ROWTIME与PROCTIME区别：</p>
<ul>
<li>在使用上：主要是填入的ctime、proc关键字的区别，这两个字段在Source DDL中指定方式不一样.</li>
<li>在实现原理上：ROWTIME模式，根据ctime对应的值，去确定窗口的start、end；PROCTIME模式，在WindowOperator处理数据时，获取本地系统时间，去确定窗口的start、end.</li>
</ul>
<p>由于生产系统中，主要使用ROWTIME来计算、聚合、统计，PROCTIME一般用于测试或对统计精度要求不高的场景，本文后续都主要以ROWTIME进行分析。</p>
<h4 id="Hop-Window（滑动窗口）"><a href="#Hop-Window（滑动窗口）" class="headerlink" title="Hop Window（滑动窗口）"></a>Hop Window（滑动窗口）</h4><p>滑动窗口Assigner将元素分配给多个固定长度的窗口。类似于滚动窗口分配程序，窗口的大小由窗口大小参数配置。因此，如果滑动窗口小于窗口大小，则滑动窗口可以重叠。在这种情况下，元素被分配到多个窗口。其实，滚动窗口TUMBLE是滑动窗口的一个特例。例子，设置一个10分钟长度的窗口，以5分钟间隔滑动。这样，每5分钟就会出现一个窗口，其中包含最近10分钟内到达的事件，如下图：</p>
<p><img src="_v_images/20210412125430097_940076266" alt="图片"></p>
<p>HOP ROWTIME语法示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> popwindowsink</span><br><span class="line">(<span class="keyword">SELECT</span></span><br><span class="line"><span class="built_in">COUNT</span>(<span class="operator">*</span>),</span><br><span class="line">HOP_START(ctime, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">MINUTE</span>,  <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> <span class="keyword">MINUTE</span>),</span><br><span class="line">DATE_FORMAT(HOP_END(ctime, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">MINUTE</span>,  <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> <span class="keyword">MINUTE</span>), <span class="string">&#x27;yyyy-MM-dd-HH-mm-ss:SSS&#x27;</span>),</span><br><span class="line">DATE_FORMAT(HOP_ROWTIME(ctime, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">MINUTE</span>,  <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> <span class="keyword">MINUTE</span>), <span class="string">&#x27;yyyy-MM-dd-HH-mm-ss:SSS&#x27;</span>), <span class="comment">--注意这里ctime字段即Source DDL中指定的ROWTIME</span></span><br><span class="line">categoryName,</span><br><span class="line"><span class="built_in">SUM</span>(price)</span><br><span class="line"><span class="keyword">FROM</span> sessionOrderTableRowtime</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> HOP(ctime, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">MINUTE</span>,  <span class="type">INTERVAL</span> <span class="string">&#x27;10&#x27;</span> <span class="keyword">MINUTE</span>), categoryName)</span><br></pre></td></tr></table></figure>
<h4 id="Session-Window（会话窗口）"><a href="#Session-Window（会话窗口）" class="headerlink" title="Session Window（会话窗口）"></a>Session Window（会话窗口）</h4><p>会话窗口Assigner根据活动会话对元素进行分组。与翻滚窗口和滑动窗口相比，会话窗口不会重叠，也没有固定的开始和结束时间。相反，会话窗口在一段时间内不接收元素时关闭，即，当一段不活跃的间隙发生时，当前会话关闭，随后的元素被分配给新的会话。</p>
<p><img src="_v_images/20210412125429689_1075804874" alt="图片"></p>
<p>SESSION ROWTIME语法示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> popwindowsink</span><br><span class="line">(<span class="keyword">SELECT</span></span><br><span class="line"><span class="built_in">COUNT</span>(<span class="operator">*</span>),</span><br><span class="line">SESSION_START(ctime, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">MINUTE</span>),</span><br><span class="line">DATE_FORMAT(SESSION_END(ctime, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">MINUTE</span>, <span class="string">&#x27;yyyy-MM-dd-HH-mm-ss:SSS&#x27;</span>),</span><br><span class="line">DATE_FORMAT(SESSION_ROWTIME(ctime, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">MINUTE</span>), <span class="string">&#x27;yyyy-MM-dd-HH-mm-ss:SSS&#x27;</span>), <span class="comment">--注意这里ctime字段即Source DDL中指定的ROWTIME</span></span><br><span class="line">categoryName,</span><br><span class="line"><span class="built_in">SUM</span>(price)</span><br><span class="line"><span class="keyword">FROM</span> sessionOrderTableRowtime</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> SESSION(ctime, <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">MINUTE</span>), categoryName)</span><br></pre></td></tr></table></figure>
<h3 id="Window分类及整体流程"><a href="#Window分类及整体流程" class="headerlink" title="Window分类及整体流程"></a>Window分类及整体流程</h3><p><img src="_v_images/20210412125429282_375710651" alt="图片"></p>
<p>上图内部流程分析：</p>
<p>应用层SQL:<br>1.1 window分类及配置，包括滑动、翻转、会话类型窗口<br>1.2 window时间类型配置，默认待字段名的EventTime，也可以通过PROCTIME()配置为ProcessingTime<br>Calcite解析引擎:<br>2.1 Calcite SQL解析，包括逻辑、优化、物理计划和算子绑定(#translateToPlanInternal)，在本文特指StreamExecGroupWindowAggregateRule和StreamExecGroupWindowAggregate物理计划<br>WindowOperator算子创建相关:<br>3.1 StreamExecGroupWindowAggregate#createWindowOperator创建算子<br>3.2 WindowAssigner的创建，根据输入的数据，和窗口类型，生成多个窗口<br>3.3 processElement()真实处理数据，包括聚合运算，生成窗口，更新缓存，提交数据等功能<br>3.4 Trigger根据数据或时间，来决定窗口触发</p>
<h3 id="创建WindowOperator算子"><a href="#创建WindowOperator算子" class="headerlink" title="创建WindowOperator算子"></a>创建WindowOperator算子</h3><p>由于window语法主要是在group by语句中使用，calcite创建WindowOperator算子伴随着聚合策略的实现，包括聚合规则匹配(StreamExecGroupWindowAggregateRule)，以及生成聚合physical算子StreamExecGroupWindowAggregate两个子流程：</p>
<p><img src="_v_images/20210412125428973_1212879820" alt="图片"></p>
<p>上图内部流程分析：</p>
<p>a. StreamExecGroupWindowAggregateRule会对window进行提前匹配，<br>生成的WindowEmitStrategy内部具有：是否为EventTime表标识、是否为SessionWindow、early fire和late fire配置、延迟毫秒数（窗口结束时间加上这个毫秒数即数据清理时间）<br>b. StreamExecGroupWindowAggregateRule会获取聚合逻辑计划中，window配置的时间字段，记录时间字段index信息，window的触发和清理都会用到这个时间<br>c. StreamExecGroupWindowAggregate入口即为translateToPlanInternal，它的实现方式与spark比较类似，会先循环调用child子节点translateToPlan方法，生成inputtranform信息作为输入<br>d.创建aggregateHandler是一个代码生成的过程，其生成的创建的class实现了accumulate、retract、merge、update方法，这个handler最后也传递给了WindowOperater，处理数据时，可以进行聚合、回撤并输出最新数据给下游<br>e. StreamExecGroupWindowAggregate与window相关的最后一步就是调用#createWindowOperator创建算子，其内部先创建了一个WindowOperatorBuilder，设置window类型、retract标识、trigger(window触发条件)、聚合函数句柄等，最后创建WindowOperator</p>
<h3 id="WindowOperator处理数据图解"><a href="#WindowOperator处理数据图解" class="headerlink" title="WindowOperator处理数据图解"></a>WindowOperator处理数据图解</h3><p>在上一小节，已经完成了WindowOperator参数的设定，并创建实例，接下来我们主要分析WindowOperator真实处理数据的流程(起点在WindowOperator#processElement方法)：</p>
<p><img src="_v_images/20210412125428666_1517359800" alt="图片"></p>
<p>processElement处理数据流程：</p>
<p>a、 获取当前record具有的事件时间，如果是Processing Time模式，从时间服务Service里面获取时间即可<br>b、使用上一步获取的时间，接着调用windowFunction.assignWindow生成窗口，其内部实际上是调用各类型的WindowAssigner生成窗口，windowFunction有三大类，分别是Paned（滑动）、Merge（会话）、General（前两种以外的），WindowAssigner类型大致有5类，分别是Tumbling（翻转）、Sliding（滑动）、Session（会话）、CountTumbling 、CountSlide这几类,根据输入的一条数据和时间，可以生成1到多个窗口<br>c、接下来是遍历涉及的窗口进行聚合，包括从windowState获取聚合前值、使用句柄进行聚合、更新状态至windowState，将当前转态<br>d、上一步聚合完成后，就可以遍历窗口，使用TriggerContext（其实就是不同类型窗口Trigger触发器的代理），综合early fire、late fire、水印时间与窗口结束时间，综合判断是否触发窗口写出<br>e、如果TriggerContext判断出触发条件为true，则调用emitWindowResult写出，其内部有retract判断，更新当前state及previous state，写出数据等操作<br>f、如果TriggerContext判断出触发条件为false，则触发需要注册cleanupTimer,到达指定时间后，触发onEventTime或onProcessingTime<br>g、onEventTime或onProcessingTime功能十分类似，首先会触发emitWindowResult提交结果，另外会判断窗口结束时间+Lateness和当前时间是否相等，相等则表示可以清除窗口数据、当前state及previous state、窗口对应trigger。</p>
<h3 id="WindowOperator源码调试"><a href="#WindowOperator源码调试" class="headerlink" title="WindowOperator源码调试"></a>WindowOperator源码调试</h3><p>为了更直观的理解Window内部运行原理，这里我们引入一个Flink源码中已有的SQL Window测试用例，并进行了简单的修改（即修改为使用HOP滑动窗口）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">classWindowJoinITCase&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function">def <span class="title">testRowTimeInnerJoinWithWindowAggregateOnFirstTime</span><span class="params">()</span>: Unit </span>= &#123;</span><br><span class="line">    val sqlQuery =</span><br><span class="line">      <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        |SELECT t1.key, HOP_END(t1.rowtime, INTERVAL &#x27;4&#x27; SECOND, INTERVAL &#x27;20&#x27; SECOND), COUNT(t1.key)</span></span><br><span class="line"><span class="string">        |FROM T1 AS t1</span></span><br><span class="line"><span class="string">        |GROUP BY HOP(t1.rowtime, INTERVAL &#x27;4&#x27; SECOND, INTERVAL &#x27;20&#x27; SECOND), t1.key</span></span><br><span class="line"><span class="string">        |&quot;</span><span class="string">&quot;&quot;</span>.stripMargin</span><br><span class="line"></span><br><span class="line">    val data1 = <span class="keyword">new</span> mutable.MutableList[(String, String, Long)]</span><br><span class="line">    data1.+=((<span class="string">&quot;A&quot;</span>, <span class="string">&quot;L-1&quot;</span>, <span class="number">1000L</span>))</span><br><span class="line">    data1.+=((<span class="string">&quot;A&quot;</span>, <span class="string">&quot;L-2&quot;</span>, <span class="number">2000L</span>))</span><br><span class="line">    data1.+=((<span class="string">&quot;A&quot;</span>, <span class="string">&quot;L-3&quot;</span>, <span class="number">3000L</span>))</span><br><span class="line">    <span class="comment">//data1.+=((&quot;B&quot;, &quot;L-8&quot;, 2000L))</span></span><br><span class="line">    data1.+=((<span class="string">&quot;B&quot;</span>, <span class="string">&quot;L-4&quot;</span>, <span class="number">4000L</span>))</span><br><span class="line">    data1.+=((<span class="string">&quot;C&quot;</span>, <span class="string">&quot;L-5&quot;</span>, <span class="number">2100L</span>))</span><br><span class="line">    data1.+=((<span class="string">&quot;A&quot;</span>, <span class="string">&quot;L-6&quot;</span>, <span class="number">10000L</span>))</span><br><span class="line">    data1.+=((<span class="string">&quot;A&quot;</span>, <span class="string">&quot;L-7&quot;</span>, <span class="number">13000L</span>))</span><br><span class="line"></span><br><span class="line">    val t1 = env.fromCollection(data1)</span><br><span class="line">      .assignTimestampsAndWatermarks(<span class="keyword">new</span> Row3WatermarkExtractor2)</span><br><span class="line">      .toTable(tEnv, <span class="string">&#x27;key, &#x27;</span>id, <span class="string">&#x27;rowtime)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    tEnv.registerTable(&quot;T1&quot;, t1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    val sink = new TestingAppendSink</span></span><br><span class="line"><span class="string">    val t_r = tEnv.sqlQuery(sqlQuery)</span></span><br><span class="line"><span class="string">    val result = t_r.toAppendStream[Row]</span></span><br><span class="line"><span class="string">    result.addSink(sink)</span></span><br><span class="line"><span class="string">    env.execute()</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>1、StreamExecGroupWindowAggregate#createWindowOperator()创建算子</p>
<p>StreamExecGroupWindowAggregate#createWindowOperator()是创建WindowOperator算子的地方，对应的代码和注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamExecGroupWindowAggregate</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> def <span class="title">createWindowOperator</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      config: TableConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">      aggsHandler: GeneratedNamespaceAggsHandleFunction[_],</span></span></span><br><span class="line"><span class="function"><span class="params">      recordEqualiser: GeneratedRecordEqualiser,</span></span></span><br><span class="line"><span class="function"><span class="params">      accTypes: Array[LogicalType],</span></span></span><br><span class="line"><span class="function"><span class="params">      windowPropertyTypes: Array[LogicalType],</span></span></span><br><span class="line"><span class="function"><span class="params">      aggValueTypes: Array[LogicalType],</span></span></span><br><span class="line"><span class="function"><span class="params">      inputFields: Seq[LogicalType],</span></span></span><br><span class="line"><span class="function"><span class="params">      timeIdx: Int)</span>: WindowOperator[_, _] </span>= &#123;</span><br><span class="line"></span><br><span class="line">    val builder = WindowOperatorBuilder</span><br><span class="line">      .builder()</span><br><span class="line">      .withInputFields(inputFields.toArray)</span><br><span class="line">    val timeZoneOffset = -config.getTimeZone.getOffset(Calendar.ZONE_OFFSET)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置WindowOperatorBuilder，最后通过Builder创建WindowOperator</span></span><br><span class="line">    val newBuilder = window match &#123;</span><br><span class="line">      <span class="function"><span class="keyword">case</span> <span class="title">TumblingGroupWindow</span><span class="params">(_, timeField, size)</span> <span class="comment">//Tumble PROCTIME模式，内部设置Assiger</span></span></span><br><span class="line"><span class="function">          <span class="keyword">if</span> <span class="title">isProctimeAttribute</span><span class="params">(timeField)</span> &amp;&amp; <span class="title">hasTimeIntervalType</span><span class="params">(size)</span> </span>=&gt;</span><br><span class="line">        builder.tumble(toDuration(size), timeZoneOffset).withProcessingTime()</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">case</span> <span class="title">TumblingGroupWindow</span><span class="params">(_, timeField, size)</span> <span class="comment">//Tumble ROWTIME模式，内部设置Assiger</span></span></span><br><span class="line"><span class="function">          <span class="keyword">if</span> <span class="title">isRowtimeAttribute</span><span class="params">(timeField)</span> &amp;&amp; <span class="title">hasTimeIntervalType</span><span class="params">(size)</span> </span>=&gt;</span><br><span class="line">        builder.tumble(toDuration(size), timeZoneOffset).withEventTime(timeIdx)</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">case</span> <span class="title">SlidingGroupWindow</span><span class="params">(_, timeField, size, slide)</span> <span class="comment">//HOP PROCTIME模式，内部设置Assiger</span></span></span><br><span class="line"><span class="function">          <span class="keyword">if</span> <span class="title">isProctimeAttribute</span><span class="params">(timeField)</span> &amp;&amp; <span class="title">hasTimeIntervalType</span><span class="params">(size)</span> </span>=&gt;</span><br><span class="line">        builder.sliding(toDuration(size), toDuration(slide), timeZoneOffset)</span><br><span class="line">          .withProcessingTime()</span><br><span class="line">       .....</span><br><span class="line">      <span class="function"><span class="keyword">case</span> <span class="title">SessionGroupWindow</span><span class="params">(_, timeField, gap)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">if</span> <span class="title">isRowtimeAttribute</span><span class="params">(timeField)</span> </span>=&gt;</span><br><span class="line">        builder.session(toDuration(gap)).withEventTime(timeIdx)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retraction和Trigger设置</span></span><br><span class="line">    <span class="comment">//默认是no retract和EventTime.afterEndOfWindow</span></span><br><span class="line">    <span class="keyword">if</span> (emitStrategy.produceUpdates) &#123;</span><br><span class="line">      <span class="comment">// mark this operator will send retraction and set new trigger</span></span><br><span class="line">      newBuilder</span><br><span class="line">        .withSendRetraction()</span><br><span class="line">        .triggering(emitStrategy.getTrigger)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newBuilder</span><br><span class="line">      .aggregate(aggsHandler, recordEqualiser, accTypes, aggValueTypes, windowPropertyTypes)</span><br><span class="line">      .withAllowedLateness(Duration.ofMillis(emitStrategy.getAllowLateness))</span><br><span class="line">      .build()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、WindowOperator#processElement()处理数据，注册Timer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamExecGroupWindowAggregate</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> def <span class="title">createWindowOperator</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      config: TableConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">      aggsHandler: GeneratedNamespaceAggsHandleFunction[_],</span></span></span><br><span class="line"><span class="function"><span class="params">      recordEqualiser: GeneratedRecordEqualiser,</span></span></span><br><span class="line"><span class="function"><span class="params">      accTypes: Array[LogicalType],</span></span></span><br><span class="line"><span class="function"><span class="params">      windowPropertyTypes: Array[LogicalType],</span></span></span><br><span class="line"><span class="function"><span class="params">      aggValueTypes: Array[LogicalType],</span></span></span><br><span class="line"><span class="function"><span class="params">      inputFields: Seq[LogicalType],</span></span></span><br><span class="line"><span class="function"><span class="params">      timeIdx: Int)</span>: WindowOperator[_, _] </span>= &#123;</span><br><span class="line"></span><br><span class="line">    val builder = WindowOperatorBuilder</span><br><span class="line">      .builder()</span><br><span class="line">      .withInputFields(inputFields.toArray)</span><br><span class="line">    val timeZoneOffset = -config.getTimeZone.getOffset(Calendar.ZONE_OFFSET)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置WindowOperatorBuilder，最后通过Builder创建WindowOperator</span></span><br><span class="line">    val newBuilder = window match &#123;</span><br><span class="line">      <span class="function"><span class="keyword">case</span> <span class="title">TumblingGroupWindow</span><span class="params">(_, timeField, size)</span> <span class="comment">//Tumble PROCTIME模式，内部设置Assiger</span></span></span><br><span class="line"><span class="function">          <span class="keyword">if</span> <span class="title">isProctimeAttribute</span><span class="params">(timeField)</span> &amp;&amp; <span class="title">hasTimeIntervalType</span><span class="params">(size)</span> </span>=&gt;</span><br><span class="line">        builder.tumble(toDuration(size), timeZoneOffset).withProcessingTime()</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">case</span> <span class="title">TumblingGroupWindow</span><span class="params">(_, timeField, size)</span> <span class="comment">//Tumble ROWTIME模式，内部设置Assiger</span></span></span><br><span class="line"><span class="function">          <span class="keyword">if</span> <span class="title">isRowtimeAttribute</span><span class="params">(timeField)</span> &amp;&amp; <span class="title">hasTimeIntervalType</span><span class="params">(size)</span> </span>=&gt;</span><br><span class="line">        builder.tumble(toDuration(size), timeZoneOffset).withEventTime(timeIdx)</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">case</span> <span class="title">SlidingGroupWindow</span><span class="params">(_, timeField, size, slide)</span> <span class="comment">//HOP PROCTIME模式，内部设置Assiger</span></span></span><br><span class="line"><span class="function">          <span class="keyword">if</span> <span class="title">isProctimeAttribute</span><span class="params">(timeField)</span> &amp;&amp; <span class="title">hasTimeIntervalType</span><span class="params">(size)</span> </span>=&gt;</span><br><span class="line">        builder.sliding(toDuration(size), toDuration(slide), timeZoneOffset)</span><br><span class="line">          .withProcessingTime()</span><br><span class="line">       .....</span><br><span class="line">      <span class="function"><span class="keyword">case</span> <span class="title">SessionGroupWindow</span><span class="params">(_, timeField, gap)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">if</span> <span class="title">isRowtimeAttribute</span><span class="params">(timeField)</span> </span>=&gt;</span><br><span class="line">        builder.session(toDuration(gap)).withEventTime(timeIdx)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retraction和Trigger设置</span></span><br><span class="line">    <span class="comment">//默认是no retract和EventTime.afterEndOfWindow</span></span><br><span class="line">    <span class="keyword">if</span> (emitStrategy.produceUpdates) &#123;</span><br><span class="line">      <span class="comment">// mark this operator will send retraction and set new trigger</span></span><br><span class="line">      newBuilder</span><br><span class="line">        .withSendRetraction()</span><br><span class="line">        .triggering(emitStrategy.getTrigger)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newBuilder</span><br><span class="line">      .aggregate(aggsHandler, recordEqualiser, accTypes, aggValueTypes, windowPropertyTypes)</span><br><span class="line">      .withAllowedLateness(Duration.ofMillis(emitStrategy.getAllowLateness))</span><br><span class="line">      .build()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行数据：</p>
<p><img src="_v_images/20210412125428458_505070513" alt="图片"></p>
<p>3、Timer触发 I、InternalTimerServiceImpl#advanceWatermark()</p>
<p>WindowOperator#onEventTime()的调用前，可以先看其上层调用：InternalTimerServiceImpl#advanceWatermark()</p>
<p><img src="_v_images/20210412125428150_761077256" alt="图片"></p>
<p>当获取的watermark为9999L时，把eventTimeTimerQueue队列中所有小于这个值的timer poll出来，调用WindowOperator.onEnventTime(timer)</p>
<p>II、WindwOperator#onEventTime()</p>
<p>WindwOperator#onEventTime()方法比较清晰，主要是window的触发和window的清理两段逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowOperator</span></span>&#123;</span><br><span class="line">    publicvoidonEventTime(InternalTimer&lt;K, W&gt; timer) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        setCurrentKey(timer.getKey());</span><br><span class="line"></span><br><span class="line">        triggerContext.window = timer.getNamespace();</span><br><span class="line">        <span class="keyword">if</span> (triggerContext.onEventTime(timer.getTimestamp())) &#123;</span><br><span class="line">            <span class="comment">// fire</span></span><br><span class="line">            emitWindowResult(triggerContext.window);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (windowAssigner.isEventTime()) &#123;</span><br><span class="line">            windowFunction.cleanWindowIfNeeded(triggerContext.window, timer.getTimestamp());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>III、emitWindowResult()提交结果</p>
<p>#emitWindowResult()重点关注下其第一行代码：BaseRow aggResult = windowFunction.getWindowAggregationResult(window); 这个表示根据具体的TimeWindow{start=4000, end=24000}，去获取聚合数据，如果是滑动窗口，需要将4000, 8000 ,12000，16000 , 20000, 24000这几段affect窗口里面的聚合值合并起来，内部逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> classPanedWindowProcessFunction&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseRow <span class="title">getWindowAggregationResult</span><span class="params">(W window)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Iterable&lt;W&gt; panes = windowAssigner.splitIntoPanes(window);</span><br><span class="line">        BaseRow acc = windowAggregator.createAccumulators();</span><br><span class="line">        <span class="comment">// null namespace means use heap data views</span></span><br><span class="line">        windowAggregator.setAccumulators(<span class="keyword">null</span>, acc);</span><br><span class="line">        <span class="keyword">for</span> (W pane : panes) &#123;</span><br><span class="line">            BaseRow paneAcc = ctx.getWindowAccumulators(pane);</span><br><span class="line">            <span class="keyword">if</span> (paneAcc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                windowAggregator.merge(pane, paneAcc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> windowAggregator.getValue(window);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="_v_images/20210412125427840_804453196" alt="图片"></p>
<h3 id="Emit（Trigger）触发器"><a href="#Emit（Trigger）触发器" class="headerlink" title="Emit（Trigger）触发器"></a>Emit（Trigger）触发器</h3><ul>
<li>配置方式指定Trigger：Flink1.9.0目前支持通过TableConifg配置earlyFireInterval、lateFireInterval毫秒数，来指定窗口结束之前、窗口结束之后的触发策略（默认是watermark超过窗口结束后触发一次），策略的解析在WindowEmitStrategy，在StreamExecGroupWindowAggregateRule就会创建和解析这个策略</li>
<li>SQL方式指定Trigger：Flink1.9.0代码中calcite部分已有SqlEmit相关的实现，后续可以支持SQL 语句（INSERT INTO）中配置EMIT触发器</li>
</ul>
<p>本文Emit和Trigger都是触发器这一个概念，只是使用的方式不一样</p>
<p>1、Emit策略 Emit 策略是指在Flink SQL 中，query的输出策略（如能忍受的延迟）可能在不同的场景有不同的需求，而这部分需求，传统的 ANSI SQL 并没有对应的语法支持。比如用户需求：1小时的时间窗口，窗口触发之前希望每分钟都能看到最新的结果，窗口触发之后希望不丢失迟到一天内的数据。针对这类需求，抽象出了EMIT语法，并扩展到了SQL语法。</p>
<p>2、用途 EMIT语法的用途目前总结起来主要提供了：控制延迟、数据精确性，两方面的功能。</p>
<ul>
<li>控制延迟。针对大窗口，设置窗口触发之前的EMIT输出频率，减少用户看到结果的延迟(WITH| WITHOUT DELAY)。</li>
<li>数据精确性。不丢弃窗口触发之后的迟到的数据，修正输出结果(minIdleStateRetentionTime，在WindowEmitStrategy中生成allowLateness)。</li>
</ul>
<p>在选择EMIT策略时，还需要与处理开销进行权衡。因为越低的输出延迟、越高的数据精确性，都会带来越高的计算开销。</p>
<p>3、语法 EMIT 语法是用来定义输出的策略，即是定义在输出（INSERT INTO）上的动作。当未配置时，保持原有默认行为，即 window 只在 watermark 触发时 EMIT 一个结果。</p>
<p>语法：INSERT INTO tableName query EMIT strategy [, strategy]*</p>
<p>strategy ::= {WITH DELAY timeInterval | WITHOUT DELAY} [BEFORE WATERMARK |AFTER WATERMARK]</p>
<p>timeInterval ::=‘string’ timeUnit</p>
<p>WITH DELAY：声明能忍受的结果延迟，即按指定 interval 进行间隔输出。WITHOUT DELAY：声明不忍受延迟，即每来一条数据就进行输出。BEFORE WATERMARK：窗口结束之前的策略配置，即watermark 触发之前。AFTER WATERMARK：窗口结束之后的策略配置，即watermark 触发之后。注：</p>
<ul>
<li>其中 strategy可以定义多个，同时定义before和after的策略。但不能同时定义两个 before 或 两个after 的策略。</li>
<li>若配置了AFTER WATERMARK 策略，需要显式地在TableConfig中配置minIdleStateRetentionTime标识能忍受的最大迟到时间。</li>
<li>minIdleStateRetentionTime在window中只影响窗口何时清除，不直接影响窗口何时触发， 例如配置为3600000，最多容忍1小时的迟到数据，超过这个时间的数据会直接丢弃</li>
</ul>
<p>4、示例 如果我们已经有一个TUMBLE（ctime, INTERVAL ‘1’ HOUR）的窗口，tumble_window 的输出是需要等到一小时结束才能看到结果，我们希望能尽早能看到窗口的结果（即使是不完整的结果）。例如，我们希望每分钟看到最新的窗口结果：INSERT INTO result SELECT * FROM tumble_window EMIT WITH DELAY ‘1’ MINUTE BEFORE WATERMARK – 窗口结束之前，每隔1分钟输出一次更新结果</p>
<p>tumble_window 会忽略并丢弃窗口结束后到达的数据，而这部分数据对我们来说很重要，希望能统计进最终的结果里。而且我们知道我们的迟到数据不会太多，且迟到时间不会超过一天以上，并且希望收到迟到的数据立刻就更新结果：INSERT INTO result SELECT * FROM tumble_window EMIT WITH DELAY ‘1’ MINUTE BEFORE WATERMARK, WITHOUT DELAY AFTER WATERMARK –窗口结束之后，每条到达的数据都输出</p>
<p>tEnv.getConfig.setIdleStateRetentionTime(Time.days(1), Time.days(2))//min、max，只有Time.days(1)这个参数直接对window生效</p>
<p>补充一下WITH DELAY ‘1’这种配置的周期触发策略（即DELAY大于0），最后都是由ProcessingTime系统时间触发：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WindowEmitStrategy</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> def <span class="title">createTriggerFromInterval</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      enableDelayEmit: Boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">      interval: Long)</span>: Option[Trigger[TimeWindow]] </span>= &#123;</span><br><span class="line">    <span class="keyword">if</span> (!enableDelayEmit) &#123;</span><br><span class="line">      None</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (interval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// 系统时间触发，小于wm的所有timer都执行onProcessingTime()</span></span><br><span class="line">        Some(ProcessingTimeTriggers.every(Duration.ofMillis(interval)))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 为0则每条都触发</span></span><br><span class="line">        Some(ElementTriggers.every())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、Trigger类和结构关系 在源码中，Window Trigger的实现子类有10个左右，需要结合上一个小节的EMIT SQL能更容易理清他们之间的关系，这里简单介绍下：</p>
<p><img src="_v_images/20210412125427432_1763085070" alt="图片"></p>
<ul>
<li><p>AfterEndOfWindow：这个就是没配置任何EMIT策略时，默认的EvenTime、ProcTime</p>
</li>
<li><p>Window触发策略（即窗口结束后触发一次）</p>
</li>
<li><p>EveryElement：即delay=0，在processElement()时直接触发，无论是在窗口结束之前或者窗口结束之后都触发，且不再注册timer</p>
</li>
<li><p>AfterEndOfWindowNoLate：对应EMIT WITHOUT DELAY AFTER WATERMARK，窗口结束之前不输出，窗口结束之后无延迟输出</p>
</li>
<li><p>AfterFirstElementPeriodic：对应WITH DELAY ‘1’ MINUTE BEFORE| AFTER WATERMARK，即按系统时间周期执行，由ProcessingTime系统时间周期触发</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">aaronzhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">237</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">127</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aaronzhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
