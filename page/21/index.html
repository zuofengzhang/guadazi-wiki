<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Guadazi">
<meta property="og:url" content="http://example.com/page/21/index.html">
<meta property="og:site_name" content="Guadazi">
<meta property="og:locale">
<meta property="article:author" content="aaronzhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/21/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Guadazi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Guadazi</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/collection/collection-map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/collection/collection-map/" class="post-title-link" itemprop="url">Java Collection与Map</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-05-12 08:44:00" itemprop="dateCreated datePublished" datetime="2016-05-12T08:44:00+08:00">2016-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-19 15:02:11" itemprop="dateModified" datetime="2021-04-19T15:02:11+08:00">2021-04-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="/Java/advanced-engineer-outline/">&lt;&lt; Java高级软件工程师知识结构</a></p>
<blockquote>
<ol>
<li>掌握Collection和Map的继承体系。</li>
<li>掌握ArrayList、LinkedList、Vector、Stack、PriorityQueue、HashSet、LinkedHashSet、TreeSet、HashMap、</li>
<li>LinkedHashMap、TreeMap、WeakHashMap、EnumMap、HashTable的特点和实现原理。<br>4.掌握CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap的实现原理和适用场景。</li>
</ol>
</blockquote>
<h1 id="Java-Collection与Map的继承关系"><a href="#Java-Collection与Map的继承关系" class="headerlink" title="Java Collection与Map的继承关系"></a>Java Collection与Map的继承关系</h1><p>在程序设计中, 集合可以存储和传递一组数据. 集合虽然比不上数组的查询速度, 但是有更加方便的功能,<br>如可变长度、键值对、去重复等.<br>其家族成员有:</p>
<p><img src="/images/java/Collection_Map/java-collections-integrated-relation.png"></p>
<p><code>Collection</code>是一个接口, 该接口允许添加和查找一个或多个元素、<code>生成迭代器</code>等功能.</p>
<p><code>List</code> <code>Set</code>和<code>Queue</code>分别是继承了<code>Collocation</code>的子接口.<br><code>List</code>用于存放可重复可为<code>null</code>的元素的有序集合. 并且可以对元素进行精确地控制, 可根据整数索引访问元素.<br><code>Set</code>用于存放不可重复可为<code>null</code>的元素的集合,<br><code>Map</code>并没有继承<code>Collection</code>, 是由一系列键值对组成的集合. 在<code>Map</code>中一个<code>key</code>对应一个<code>value</code>, key不能相同.</p>
<h1 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h1><p>实现了List接口的集合主要有 <code>ArrayList</code> <code>LinkedList</code> <code>Vector</code> <code>Stack</code></p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p><strong>特性</strong></p>
<ol>
<li><strong>可重复</strong>, <strong>可为null</strong>: 添加元素是将元素存放到数组中</li>
<li><strong>有序</strong></li>
<li>擅长随机访问： 快速检索 增删慢</li>
<li><strong>非线程同步</strong><br>通过<code>Collections.synchronizedList(new ArrayList());</code>转换为线程安全的List</li>
</ol>
<p><strong>实现原理</strong><br>动态数组, 底层也是通过<code>单个Java数组</code>实现的, <code>ArrayList</code>根据元素个数动态调整内部数组的长度以达到实现动态数组的效果.<br>内部数组的初始长度为10, 当添加的元素的个数超出了内部数组的长度时, 调用JNI函数对内部数组实现扩容（为原长度的<code>150%</code>）和复制.<br>本质上, <code>ArrayList</code>是采用了<strong>线性表</strong>的结构, 因此, <code>ArrayList</code>具有快速检索的优点也具有增删慢的缺点.</p>
<p><strong>复杂度</strong><br>添加n个元素需要O(n)时间</p>
<blockquote>
<p><strong>优化建议 :</strong><br>如果确定了插入元素的多少, 最好可以指定初始容量值,<br>避免过多的进行扩容和复制而浪费时间.</p>
</blockquote>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p><strong>特性</strong></p>
<ol>
<li><strong>不能随机访问</strong></li>
<li><strong>非线程同步</strong><br> 通过<code>Collections.synchronizedList(new LinkedList());</code>转换为线程安全的List</li>
<li>善于<strong>插入和删除</strong> 不善于随机访问</li>
</ol>
<p><strong>实现原理</strong><br>双向链表, 可以通过<code>get</code> <code>remove</code> <code>insert</code>方法操作首部和尾部的元素.</p>
<p><strong>复杂度</strong></p>
<p><strong>与ArrayList对比</strong><br>由于<code>ArrayList</code>是线性表的形式存储的, 需要连续的存储空间. 而<code>LinkedList</code>不需要连续,<br>因此在存储数据量较大的情况下, 优先选择<code>LinkedList</code>.</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p><strong>特性</strong></p>
<ol>
<li><strong>线程同步</strong></li>
<li>与ArrayList一样 <strong>???</strong></li>
</ol>
<p><strong>实现原理</strong><br>线程安全的动态数组, 内部也是采用单个数组</p>
<p><strong>复杂度</strong></p>
<h2 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack 栈"></a>Stack 栈</h2><p><strong>特性</strong></p>
<ol>
<li><strong>后进先出的栈</strong></li>
<li>提供了除了ArrayList和Vector以外的栈操作方法:<ul>
<li>push 压入栈</li>
<li>pop  出栈</li>
<li>peek 得到栈顶</li>
<li>empty 测试栈是否为空</li>
<li>search 检测一个元素在栈中的位置</li>
</ul>
</li>
</ol>
<p><strong>实现原理</strong><br>用<code>Vector</code>构建,而非继承自<code>Vector</code></p>
<p><strong>复杂度</strong></p>
<p>【样例】: 使用栈实现计算器</p>
<h1 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h1><p><strong>特性</strong></p>
<ol>
<li><strong>不可重复</strong></li>
<li><strong>最多只允许一个null</strong></li>
</ol>
<h2 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h2><p><strong>特性</strong></p>
<ol>
<li>枚举专用Set</li>
<li>不是同步的<br>多线程情况下, 最好在创建时完成这一操作, 以防止意外的非同步访问<br><code>Set&lt;MyEnum&gt; s = Collections.synchronizedSet(EnumSet.noneOf(MyEnum.class));</code></li>
<li>枚举 set 中所有键都必须来自单个枚举类型, 该枚举类型在创建 set 时显式或隐式地指定.</li>
</ol>
<p><strong>实现原理</strong></p>
<p>//TODO</p>
<p><strong>复杂度</strong></p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p><strong>特性</strong></p>
<ol>
<li><strong>速度最快的集合</strong></li>
<li>不能重复，最多一个为null</li>
</ol>
<p><strong>实现原理</strong><br>内部存在一个HashMap, 借助于HashCode来实现, 所以不保证元素的顺序</p>
<p><strong>复杂度</strong></p>
<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p><strong>特性</strong></p>
<ol>
<li>有序</li>
</ol>
<p><strong>实现原理</strong><br>内部是<code>LinkedHashMap</code>实现的<br>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它 <strong>同时使用链表维护元素的次序</strong> 。<br>当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。<br>LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</p>
<p><strong>复杂度</strong></p>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p><strong>特性</strong></p>
<ol>
<li>总是处于排序状态的Set(顺序取决于元素的自然顺序或者创建Set时指定的Comparator)</li>
<li>非线程同步<br> 多线程情况下,最好在创建时进行, 以防止对 set 的意外非同步访问：<br> <code>SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));</code></li>
</ol>
<p><strong>实现原理</strong><br>内部由TreeMap(使用<a target="_blank" rel="noopener" href="http://www.cnblogs.com/liqizhou/archive/2012/09/27/java%E4%B8%ADtreemap%E5%92%8Ctreeset%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91.html">红黑树</a>)来实现</p>
<p><strong>复杂度</strong></p>
<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p><strong>特性</strong></p>
<ol>
<li>键值对</li>
<li>Key不能重复</li>
</ol>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><strong>特性</strong></p>
<ol>
<li><strong>线程不安全</strong></li>
<li>初始容量设定</li>
</ol>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><a target="_blank" rel="noopener" href="http://www.importnew.com/7099.html">参考链接: HashMap的工作原理</a></p>
<p>以哈希表的数据结构实现. 内部存在一个哈希表数组, 每个数组元素又有一组长度不确定的链表.</p>
<p><img src="/images/java/Collection_Map/java-collections-hashtable.png"></p>
<p><code>HashMap</code>是基于hashing的原理，我们使用<code>put(key, value)</code>存储对象到HashMap中，使用<code>get(key)</code>从HashMap中获取对象。当我们给<code>put()</code>方法传递键和值时，我们先对键调用<code>hashCode()</code>方法，返回的hashCode用于找到bucket位置来储存<strong>Entry对象</strong>。”这里关键点在于指出，HashMap是在bucket中储存<strong>键对象和值对象</strong>，作为Map.Entry。</p>
<p><code>HashMap</code>在bucket中存储<code>Map.Entry</code>对象，每个Map.Entry保存有key和value。</p>
<h3 id="get的工作原理"><a href="#get的工作原理" class="headerlink" title="get的工作原理"></a>get的工作原理</h3><p>当使用get(key)方法，<br>首先调用hashing方法，利用<code>key.hashcode</code>计算key所在的bucket，找到相应的bucket后。<br>然后遍历bucket中的Map.Entry，首先比对<code>key.hashcode</code>值，其次比对(key值或<code>key.equals</code>方法比对两个对象)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp;  ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">return</span> e;</span><br></pre></td></tr></table></figure>
<p>在这里，使用了 <code>&amp;&amp;</code> 的短路特性: 只要第一个条件不满足，不再比较后面的条件；只有前面的条件满足了，才比较后面的条件。<br>等价于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(e.hash==hash)&#123;</span><br><span class="line">  <span class="keyword">if</span>((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))&#123;</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="key的hashcode相同的情况"><a href="#key的hashcode相同的情况" class="headerlink" title="key的hashcode相同的情况"></a>key的<code>hashcode</code>相同的情况</h3><p>因为<code>hashcode</code>相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。当<code>hashcode</code>相同时，还会调用key.equals比对两个key对象是否相同。</p>
<h3 id="负载因子-0-75"><a href="#负载因子-0-75" class="headerlink" title="负载因子 0.75"></a>负载因子 0.75</h3><p>“如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？”<br>默认的负载因子大小为 0.75，也就是说，当一个map填满了 75% 的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。<br>这个过程叫作 <strong>rehashing</strong>，因为它调用hash方法找到新的bucket位置。</p>
<h3 id="rehashing-过程"><a href="#rehashing-过程" class="headerlink" title="rehashing 过程"></a>rehashing 过程</h3><p>重新调整HashMap大小存在的问题:<br>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候， HashMap 并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。</p>
<h3 id="key类型的选择与提速"><a href="#key类型的选择与提速" class="headerlink" title="key类型的选择与提速"></a>key类型的选择与提速</h3><ul>
<li><p>hashing的概念</p>
</li>
<li><p>HashMap 中解决碰撞的方法</p>
</li>
<li><p>equals()和hashCode()的应用，以及它们在HashMap中的重要性</p>
</li>
<li><p><strong>不可变对象的好处</strong></p>
<p>使用不可变的、声明作final的对象，并且采用合适的<code>equals()</code>和<code>hashCode()</code>方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用 String，Interger 这样的wrapper类作为键是非常好的选择。而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。</p>
<p>不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。<strong>不可变性还有其他的优点如线程安全</strong>。如果你可以仅仅通过将某个field声明成final就能<strong>保证hashCode是不变的</strong>，那么请这么做吧。</p>
<p>因为获取对象的时候要用到<code>equals()</code>和<code>hashCode()</code>方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的<code>hashcode</code>的话，那么碰撞的几率就会小些，这样就能提高<code>HashMap</code>的性能。</p>
</li>
</ul>
<p><strong>复杂度</strong></p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p><strong>特性</strong></p>
<ol>
<li>非线程同步</li>
<li>有序： 可以按照访问顺序或者插入顺序排序</li>
</ol>
<p><strong>实现原理</strong><br>底层使用哈希表与<strong>双向链表</strong>来保存所有元素。其基本操作与父类 HashMap 相似</p>
<p>LinkedHashMap 定义了排序模式 accessOrder，该属性为 boolean 型变量，对于访问顺序，为 true；<br>对于插入顺序，则为 false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。</p>
<p>//TODO 排序模式</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p><strong>特性</strong></p>
<ol>
<li><strong>可排序</strong></li>
<li>不是同步的<br><code>SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));</code></li>
</ol>
<p><strong>实现原理</strong><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/liqizhou/archive/2012/09/27/java%E4%B8%ADtreemap%E5%92%8Ctreeset%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91.html">红黑树</a>的数据结构, 实现了SortedMap接口</p>
<p><strong>复杂度</strong></p>
<p><strong>应用</strong><br>TreeMap 常用于在接口参数拼接中，以自动对key排序</p>
<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><p><strong>特性</strong></p>
<ol>
<li>当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值</li>
</ol>
<p><strong>实现原理</strong><br>使用<a target="_blank" rel="noopener" href="http://www.cnblogs.com/-OYK/archive/2011/10/24/2222874.html" title="Java中的四种引用类型">弱引用</a>作为内部数据的存储方案。 WeakHashMap可以作为简单缓存表的解决方案，<br>当系统内存不够的时候，垃圾收集器会自动的清除没有在其他任何地方被引用的键值对。</p>
<h2 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h2><p><strong>特性</strong></p>
<ol>
<li>Key必须是Enum</li>
<li>EnumMap的key不允许为null，value可以为null，按照key在enum中的顺序进行保存，非线程安全。</li>
</ol>
<p><strong>实现原理</strong></p>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p><strong>特性</strong></p>
<ol>
<li><strong>线程安全</strong></li>
<li>性能比HashMap差</li>
</ol>
<p><strong>实现原理</strong><br>哈希表<br>使用 synchronized 锁住所有的读写操作</p>
<p><strong>复杂度</strong></p>
<h1 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h1><blockquote>
<p>// FIXME 实现原理</p>
</blockquote>
<p>队列, 它主要分为两大类:</p>
<ul>
<li>一类是阻塞式队列, 队列满了以后再插入元素则会抛出异常, 主要包括<ul>
<li><code>ArrayBlockQueue</code></li>
<li><code>PriorityBlockingQueue</code></li>
<li><code>LinkedBlockingQueue</code></li>
</ul>
</li>
<li>另一类是双端队列, 支持在头、尾两端插入和移除元素, 主要包括：<ul>
<li><code>ArrayDeque</code></li>
<li><code>LinkedBlockingDeque</code></li>
<li><code>LinkedList</code></li>
</ul>
</li>
</ul>
<p>常见的队列有:</p>
<ol>
<li>ArrayDeque, （数组双端队列）</li>
<li>PriorityQueue, （优先级队列）</li>
<li>ConcurrentLinkedQueue, （基于链表的并发队列）</li>
<li>DelayQueue, （延期阻塞队列）（阻塞队列实现了BlockingQueue接口）</li>
<li>ArrayBlockingQueue, （基于数组的并发阻塞队列）</li>
<li>LinkedBlockingQueue, （基于链表的FIFO阻塞队列）</li>
<li>LinkedBlockingDeque, （基于链表的FIFO双端阻塞队列）</li>
<li>PriorityBlockingQueue, （带优先级的无界阻塞队列）</li>
<li>SynchronousQueue （并发同步阻塞队列）</li>
</ol>
<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>无界优先级队列<br><strong>特性</strong></p>
<ol>
<li>有序:<ul>
<li>顺序取决于元素的自然顺序或者创建队列时指定的Comparator</li>
<li>依靠自然顺序的优先级队列还不允许插入不可比较的对象（这样做可能导致 ClassCastException）。</li>
</ul>
</li>
<li>不允许元素为null</li>
<li>优先级队列是无界的<br>有一个内部容量，控制着用于存储队列元素的数组大小。它通常至少等于队列的大小。<br>随着不断向优先级队列添加元素，其容量会自动增加。无需指定容量增加策略的细节。</li>
<li>非线程安全</li>
</ol>
<h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>无界优先级阻塞队列<br><strong>特性</strong></p>
<ol>
<li>有序: 与PriorityQueue相同</li>
<li>不允许元素为null</li>
<li>无界: 资源耗尽时执行add会失败（导致 OutOfMemoryError）</li>
<li>线程安全</li>
</ol>
<h1 id="几种特殊的"><a href="#几种特殊的" class="headerlink" title="几种特殊的"></a>几种特殊的</h1><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a><code>CopyOnWriteArrayList</code></h2><p><code>ArrayList</code>的一个线程安全的变体, 所有可变操作（<code>add</code>、<code>set</code> 等等）都是通过对底层数组进行一次新的复制作为新的内部数组来实现的.</p>
<ul>
<li>这一般需要很大的开销, 但是当遍历操作的数量大大超过可变操作的数量时, 这种方法可能比其他替代方法更有效.</li>
<li>在不能或不想进行同步遍历, 但又需要从并发线程中排除冲突时, 它也很有用.</li>
</ul>
<p><code>“快照”风格</code>的迭代器方法在创建迭代器时使用了对数组状态的引用. 此数组在迭代器的生存期内不会更改, 因此不可能发生冲突, 并且迭代器保证不会抛出<code>ConcurrentModificationException</code>. 创建迭代器以后, 迭代器就不会反映列表的添加、移除或者更改. 在迭代器上进行的元素更改操作（remove、set 和 add）不受支持. 这些方法将抛出 <code>UnsupportedOperationException</code>.</p>
<p>允许使用所有元素, 包括 null.</p>
<p>内存一致性效果：</p>
<p>当存在其他并发 collection 时, 将对象放入 <code>CopyOnWriteArrayList</code> 之前的线程中的操作 <code>happen-before</code><br>随后通过另一线程从 <code>CopyOnWriteArrayList</code> 中访问或移除该元素的操作.</p>
<p>这个类和ArrayList最大的区别就是add(E) 的时候。容器会自动copy一份出来然后再尾部add(E)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">Object[] elements = getArray();</span><br><span class="line"><span class="keyword">int</span> len = elements.length;</span><br><span class="line">Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">newElements[len] = e;</span><br><span class="line">setArray(newElements);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a><code>CopyOnWriteArraySet</code></h2><p>对其所有操作使用内部 <code>CopyOnWriteArrayList</code> 的 Set. 因此, 它共享以下相同的基本属性：</p>
<p>它最适合于具有以下特征的应用程序：</p>
<ul>
<li>set 大小通常保持很小, 只读操作远多于可变操作, 需要在遍历期间防止线程间的冲突.</li>
<li>它是线程安全的.</li>
<li>因为通常需要复制整个基础数组, 所以可变操作（add、set 和 remove 等等）的开销很大.</li>
<li>迭代器不支持可变 remove 操作.</li>
<li>使用迭代器进行遍历的速度很快, 并且不会与其他线程发生冲突. 在构造迭代器时, 迭代器依赖于不变的数组快照.</li>
</ul>
<p><strong>示例用法</strong></p>
<p>以下代码使用一个写时复制（copy-on-write）的 set, 以维护在状态更新时执行某项操作的一组 Handler 对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;Handler&gt; handlers = <span class="keyword">new</span> CopyOnWriteArraySet&lt;Handler&gt;();</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHandler</span><span class="params">(Handler h)</span> </span>&#123;</span><br><span class="line">handlers.add(h);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">long</span> internalState;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">changeState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">internalState = ...;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">changeState();</span><br><span class="line"><span class="keyword">for</span> (Handler handler : handlers)</span><br><span class="line">    handler.handle();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><blockquote>
<p>   //FIXME 重写介绍</p>
</blockquote>
<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><ol>
<li>结构</li>
</ol>
<p><img src="/images/java/Collection_Map/concurrentHashMap-construction.png" alt="c"></p>
<ol>
<li>详情请参考: <a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/index.html">探索 ConcurrentHashMap 高并发性的实现机制</a>的<a href="/Java/collection/ConcurrentHashMap/">本地版</a></li>
</ol>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="Collections类中的静态方法"><a href="#Collections类中的静态方法" class="headerlink" title="Collections类中的静态方法"></a>Collections类中的静态方法</h2><p>在 Collections类中有多个静态方法，它们可以获取通过同步方法封装非同步集合而得到的集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Collection <span class="title">synchronizedCollention</span><span class="params">(Collection c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">synchronizedList</span><span class="params">(list l)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title">synchronizedMap</span><span class="params">(Map m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set <span class="title">synchronizedSet</span><span class="params">(Set s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SortedMap <span class="title">synchronizedSortedMap</span><span class="params">(SortedMap sm)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SortedSet <span class="title">synchronizedSortedSet</span><span class="params">(SortedSet ss)</span></span></span><br></pre></td></tr></table></figure>
<p>这些方法基本上返回具有同步集合方法版本的新类。比如，为了创建多线程安全且由ArrayList支持的List，可以使用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = Collection.synchronizedList(<span class="keyword">new</span> ArrayList());</span><br></pre></td></tr></table></figure>
<p>注意，ArrayList实例马上封装起来，不存在对未同步化ArrayList的直接引用（即直接封装匿名实例）。这是一种最安全的途径。如果另一个线程要直接引用ArrayList实例，它可以执行非同步修改。</p>
<p>//FIXME 实现原理</p>
<h2 id="CopyOnWrite机制"><a href="#CopyOnWrite机制" class="headerlink" title="CopyOnWrite机制"></a>CopyOnWrite机制</h2><h2 id="synchronized机制"><a href="#synchronized机制" class="headerlink" title="synchronized机制"></a>synchronized机制</h2><h2 id="ReteenLock机制"><a href="#ReteenLock机制" class="headerlink" title="ReteenLock机制"></a>ReteenLock机制</h2><h2 id="ConcurrentHashMap是个特例"><a href="#ConcurrentHashMap是个特例" class="headerlink" title="ConcurrentHashMap是个特例"></a>ConcurrentHashMap是个特例</h2><h1 id="异同点"><a href="#异同点" class="headerlink" title="异同点"></a>异同点</h1><h2 id="Vector-和-ArrayList"><a href="#Vector-和-ArrayList" class="headerlink" title="Vector 和 ArrayList"></a>Vector 和 ArrayList</h2><ol>
<li>Vector是线程同步的, 所以它也是线程安全的, 而ArrayList是线程异步的, 是不安全的. 如果不考虑到线程的安全因素, 一般用ArrayList效率比较高.</li>
<li>如果集合中的元素的数目大于目前集合数组的长度时, Vector增长率为目前数组长度的100%, 而ArrayList增长率为目前数组长度的50%. 如果在集合中使用数据量比较大的数据, 用Vector有一定的优势.</li>
<li>如果查找一个指定位置的数据, Vector和ArrayList使用的时间是相同的, 都是<code>O(1)</code>,这个时候使用Vector和ArrayList都可以; 而如果移动一个指定位置的数据花费的时间为<code>O(n-i)</code>  n为总长度, 这个时候就应该考虑到使用LinkedList, 因为它移动一个指定位置的数据所花费的时间为<code>O(1)</code>, 而查询一个指定位置的数据时花费的时间为<code>O(i)</code>.</li>
</ol>
<h2 id="Arraylist和LinkedList"><a href="#Arraylist和LinkedList" class="headerlink" title="Arraylist和LinkedList"></a>Arraylist和LinkedList</h2><ol>
<li>ArrayList是实现了基于动态数组的数据结构, LinkedList基于链表的数据结构.</li>
<li>对于随机访问<code>get</code>和<code>set</code>, <code>ArrayList</code>优于<code>LinkedList</code>, 因为<code>LinkedList</code>要移动指针.</li>
<li>对于新增和删除操作<code>add</code>和<code>remove</code>, <code>LinkedList</code>比较占优势, 因为<code>ArrayList</code>要移动数据.<br>这一点要看实际情况的. 若只对单条数据插入或删除, <code>ArrayList</code>的速度反而优于<code>LinkedList</code>. 但若是批量随机的插入删除数据, <code>LinkedList</code>的速度大大优于<code>ArrayList</code>. 因为<code>ArrayList</code>每插入一条数据, 要移动插入点及之后的所有数据.</li>
</ol>
<h2 id="HashMap-与-TreeMap"><a href="#HashMap-与-TreeMap" class="headerlink" title="HashMap 与 TreeMap"></a>HashMap 与 TreeMap</h2><ol>
<li>HashMap通过hashcode对其内容进行快速查找, 而TreeMap中所有的元素都保持着某种固定的顺序,<br> 如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）.</li>
<li>在Map 中插入、删除和定位元素, HashMap 是最好的选择. 但如果您要按自然顺序或自定义顺序遍历键, 那么TreeMap会更好.<br>使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现.  这个TreeMap没有调优选项, 因为该树总处于平衡状态.</li>
</ol>
<h2 id="HashMap与HashTable的区别"><a href="#HashMap与HashTable的区别" class="headerlink" title="HashMap与HashTable的区别"></a>HashMap与HashTable的区别</h2><ol>
<li>继承不同<br><code>public class Hashtable extends Dictionary implements Map</code><br><code>public class HashMap  extends AbstractMap implements Map</code></li>
<li>Hashtable 中的方法是同步的, 而HashMap中的方法在缺省情况下是非同步的. 在多线程并发的环境下, 可以直接使用Hashtable, 但是要使用HashMap的话就要自己增加同步处理了.</li>
<li>Hashtable中, key和value都不允许出现null值, 在HashMap中, null可以作为键, 这样的键只有一个; 可以有一个或多个键所对应的值为null. 当get()方法返回null值时, 即可以表示 HashMap中没有该键,也可以表示该键所对应的值为null. 因此, 在HashMap中不能由get()方法来判断HashMap中是否存在某个键, 而应该用containsKey()方法来判断.</li>
<li>两个遍历方式的内部实现上不同.<br>Hashtable、HashMap都使用了 Iterator. 而由于历史原因, Hashtable还使用了Enumeration的方式 .</li>
<li>哈希值的使用不同, HashTable直接使用对象的hashCode. 而HashMap重新计算hash值.</li>
<li>Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式. HashTable中hash数组默认大小是11, 增加的方式是 old*2+1. HashMap中hash数组的默认大小是16, 而且一定是2的指数</li>
</ol>
<h2 id="对集合的选择"><a href="#对集合的选择" class="headerlink" title="对集合的选择"></a>对集合的选择</h2><h3 id="对List的选择"><a href="#对List的选择" class="headerlink" title="对List的选择"></a>对List的选择</h3><ol>
<li>对于随机查询与迭代遍历操作, 数组比所有的容器都要快. 所以在随机访问中一般使用ArrayList</li>
<li>LinkedList使用双向链表对元素的增加和删除提供了非常好的支持, 而ArrayList执行增加和删除元素需要进行元素位移.</li>
<li>对于Vector而已, 我们一般都是避免使用.</li>
<li>将ArrayList当做首选, 毕竟对于集合元素而已我们都是进行遍历, 只有当程序的性能因为List的频繁插入和删除而降低时, 再考虑LinkedList.</li>
</ol>
<h3 id="对Set的选择"><a href="#对Set的选择" class="headerlink" title="对Set的选择"></a>对Set的选择</h3><ol>
<li><code>HashSet</code>由于使用<code>HashCode</code>实现, 所以在某种程度上来说它的性能永远比<code>TreeSet</code>要好, 尤其是进行增加和查找操作.</li>
<li>虽然<code>TreeSet</code>没有<code>HashSet</code>性能好, 但是由于它可以维持元素的排序, 所以它还是存在用武之地的.</li>
</ol>
<h3 id="对Map的选择"><a href="#对Map的选择" class="headerlink" title="对Map的选择"></a>对Map的选择</h3><ol>
<li>HashMap与HashSet同样, 支持快速查询. 虽然HashTable的速度也不慢, 但是在HashMap面前还是稍微慢了些, 所以HashMap在查询方面可以取代HashTable.</li>
<li>由于TreeMap需要维持内部元素的顺序, 所以它通常要比HashMap和HashTable慢.</li>
</ol>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组复制System-arrayCopy"><a href="#数组复制System-arrayCopy" class="headerlink" title="数组复制System.arrayCopy"></a>数组复制<code>System.arrayCopy</code></h3><p>该方法是个JNI函数, 是在JVM中实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*从src的srcPos位置复制数据到dest的destPos位置, 长度为length</span></span><br><span class="line"><span class="comment">*src - 源数组.</span></span><br><span class="line"><span class="comment">*srcPos - 源数组中的起始位置.</span></span><br><span class="line"><span class="comment">*dest - 目标数组.</span></span><br><span class="line"><span class="comment">*destPos - 目标数据中的起始位置.</span></span><br><span class="line"><span class="comment">*length - 要复制的数组元素的数量.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="Arrays-copyOf"><a href="#Arrays-copyOf" class="headerlink" title="Arrays.copyOf"></a>Arrays.copyOf</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 由U类型复制为T类型？</span></span><br><span class="line"><span class="comment">* original - 要复制的数组</span></span><br><span class="line"><span class="comment">* newLength - 要返回的副本的长度</span></span><br><span class="line"><span class="comment">* newType - 要返回的副本的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">  T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">? (T[]) <span class="keyword">new</span> Object[newLength]</span><br><span class="line">: (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">  System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line"> Math.min(original.length, newLength));</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Arrays-asList-将数组转换为ArrayList"><a href="#Arrays-asList-将数组转换为ArrayList" class="headerlink" title="Arrays.asList: 将数组转换为ArrayList"></a>Arrays.asList: 将数组转换为ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;T&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Arrays.asList返回的<code>ArrayList</code>并不是<code>java.util.ArrayList</code>, 只是<code>Arrays</code>的内部类. 该类只提供了一些基本的操作,</p>
<ol>
<li>size：元素数量</li>
<li>toArray：转换为数组, 实现了数组的浅拷贝.</li>
<li>get：获得指定元素.</li>
<li>contains：是否包含某元素.<br>asList返回的是一个长度不可变的列表. 数组是多长, 转换成的列表是多长, 我们是无法通过add、remove来增加或者减少其长度的<br>我们经常需要使用到Arrays这个工具的asList()方法将其转换成列表. 方便是方便, 但是有时候会出现莫名其妙的问题. 如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] datas = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">  List list = Arrays.asList(datas);</span><br><span class="line">  System.out.println(list.size());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<p>结果是1, 为什么会是1而不是5呢？先注意这个参数: T…a, 这个参数是一个泛型的变长参数, 我们知道 <strong>基本数据类型是不可能泛型化的</strong> ,也就是说8个基本数据类型是不可作为泛型参数的, 但是为什么编译器没有报错呢？这是因为数组会当做一个对象来处理, 它是可以泛型的, 所以我们的程序是把一个int型的数组作为了T的类型,所以在转换之后List中就只会存在一个类型为int数组的元素了.<br>所以我们这样的程序<code>System.out.println(datas.equals(list.get(0)));</code>输出结果肯定是<code>true</code>.<br>当然如果将int改为Integer, 则长度就会变成5了.</p>
<h3 id="Arrays-fill"><a href="#Arrays-fill" class="headerlink" title="Arrays.fill"></a>Arrays.fill</h3><p>使用值填充数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">Arrays.fill(a,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 使用0填充数组a</span></span><br></pre></td></tr></table></figure>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h3><p>Map的遍历,都是需要转换为Collection</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = ...;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>由Map生成<code>Collection</code>, 获取所有的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; values = map.values();</span><br><span class="line">Iterator&lt;String&gt; iterator = values.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>由Map.keySet, 遍历key值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">Iterator&lt;String&gt; keyIterator = keySet.iterator();</span><br></pre></td></tr></table></figure></li>
<li><p>获取Map.Entry类型的Set</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; entryIterator = entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line">	Map.Entry&lt;String, String&gt; entry = entryIterator.next();</span><br><span class="line">	String key = entry.getKey();</span><br><span class="line">	String value = entry.getValue();</span><br><span class="line">	System.out.println(key + <span class="string">&quot;\t&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Collection的遍历方法"><a href="#Collection的遍历方法" class="headerlink" title="Collection的遍历方法"></a>Collection的遍历方法</h3></li>
<li><p>Iterator 迭代子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; values2 = map.values();</span><br><span class="line">Iterator&lt;String&gt; iterator2 = values2.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">	System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>foreach</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String valueItem : values2) &#123;</span><br><span class="line">	System.out.println(valueItem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>List特有的遍历方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">assert</span> list != <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">	System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当然也可以写成</span></span><br><span class="line"><span class="keyword">for</span> (String aList : list) &#123;</span><br><span class="line">	System.out.println(aList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>List遍历方式有三种:</p>
<ul>
<li>下标遍历</li>
<li>Iterator遍历</li>
<li>Foreach遍历（最快）</li>
</ul>
</li>
</ol>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><blockquote>
<p>FIXME 排序：集合自带排序 对集合排序</p>
</blockquote>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Java中有多少种数据结构-分别是什么？"><a href="#Java中有多少种数据结构-分别是什么？" class="headerlink" title="Java中有多少种数据结构, 分别是什么？"></a>Java中有多少种数据结构, 分别是什么？</h2><pre><code>- List：是列表, 有下标值, 存储元素可以重复, 遍历元素是有序的.
- Set：是散列集, 无下标值, 存储元素不可重复, 遍历元素时无序的.
- Map：是以键值对存储, 一个key一个value, key不可以重复, value可以重复.
- 数组：指定类型, 固定长度, 元素存储地址是连续的.
- 树：元素以树形结构存储, 只有一个根节点.
- 栈：元素是先进后出, 后进先出.
- 向量：动态数组, 可以存储任何类型元素, 动态长度, 元素存储地址是连续的.
- 队列：元素存储是排列有序的, 一定保证先进的先出, 后进的后出.</code></pre>
<hr>
<p>修改记录:</p>
<ol>
<li>HashMap的详细实现原理 重写ConcurrentHashMap介绍     2016-08-20</li>
</ol>
<hr>
<p>参考文献:</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://cmsblogs.com/?p=106">java提高篇（二十）集合大家族</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/softwave/article/details/4166598">Java集合类详解</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/index.html">探索 ConcurrentHashMap 高并发性的实现机制</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/jvm/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/jvm/JVM/" class="post-title-link" itemprop="url">深入理解JVM(Java虚拟机)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-05-04 12:26:00" itemprop="dateCreated datePublished" datetime="2016-05-04T12:26:00+08:00">2016-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-19 15:02:11" itemprop="dateModified" datetime="2021-04-19T15:02:11+08:00">2021-04-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>JVM内存区域划分
    1. 掌握程序计数器、堆、虚拟机栈、本地方法栈、方法区（JAVA8已移除）、元空间（JAVA8新增）的作用及基本原理.
    2. 掌握堆的划分:  新生代（Eden、Survivor1、Survivor2）和老年代的作用及工作原理.
    3. 掌握JVM内存参数设置及调优.
类加载
    1. 掌握类的加载阶段:  加载、链接（验证、准备、解析）、初始化、使用、卸载.
    2. 掌握类加载器分类及其应用:  启动类加载器、扩展类加载器、应用程序类加载器、自定义加载器.</code></pre>
<h1 id="运行时内存结构"><a href="#运行时内存结构" class="headerlink" title="运行时内存结构"></a>运行时内存结构</h1><h1 id="Class文件格式"><a href="#Class文件格式" class="headerlink" title="Class文件格式"></a>Class文件格式</h1><h1 id="Java字节码和执行引擎"><a href="#Java字节码和执行引擎" class="headerlink" title="Java字节码和执行引擎"></a>Java字节码和执行引擎</h1><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h1 id="监控调优"><a href="#监控调优" class="headerlink" title="监控调优"></a>监控调优</h1><h1 id="GC算法和垃圾回收"><a href="#GC算法和垃圾回收" class="headerlink" title="GC算法和垃圾回收"></a>GC算法和垃圾回收</h1><h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><h1 id="线程和锁"><a href="#线程和锁" class="headerlink" title="线程和锁"></a>线程和锁</h1><h1 id="JVM内存区域划分"><a href="#JVM内存区域划分" class="headerlink" title="JVM内存区域划分"></a>JVM内存区域划分</h1><p><img src="/images/java/JVM/jvm-struct.jpg" alt="java虚拟机运行时数据区"><br><img src="/images/java/JVM/jvm-struct-thread.jpg" alt="java虚拟机运行时数据区与线程的关系"></p>
<p>JVM内存区域可以划分为:</p>
<ul>
<li>程序计数器</li>
<li>堆</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>方法区(Java8已移除)</li>
<li>元空间(Java8新增)</li>
</ul>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><ol>
<li><p>程序计数器可以看做是当前线程所执行的字节码的行号指示器. 在JVM的概念模型里, 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令.</p>
</li>
<li><p>由于JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的, 为了在线程切换后能恢复到正确的执行位置, 每条线程都需要有一个独立的程序计数器, 独立存储, 互不影响. 所以, 程序计数器是<strong>线程私有</strong>的内存区域.</p>
</li>
<li><p>如果线程执行的是一个Java方法, 计数器记录的是正在执行的虚拟机字节码指令的地址；如果线程执行的是一个Native方法, 计数器的值为空.</p>
</li>
<li><p>程序计数器是Java虚拟机规范中<strong>唯一</strong>一个<strong>没有</strong>规定任何<strong>OutOfMemoryError</strong>情况的区域.</p>
</li>
</ol>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><ol>
<li><p>Java虚拟机栈描述的是Java方法执行的内存模型:  </p>
<p>每个方法执行的同时会创建一个栈帧, 栈帧用于存储<strong>局部变量表</strong>、操作数栈、动态链接、方法出口等信息. 每个方法从调用直至执行完成的过程, 就对应着一个栈帧在虚拟机栈中入栈到出栈的过程.</p>
<p><img src="/images/java/JVM/jvm-stack-frame.png" alt="栈帧"></p>
</li>
</ol>
<ol>
<li><p>Java虚拟机栈是<strong>线程私有</strong>的, 它的生命周期与线程相同.</p>
</li>
<li><p>程序员主要关注的stack栈内存, 就是虚拟机栈中局部变量表部分.<br>局部变量表存放了编译时期可知的各种<strong>基本数据类型</strong>和<strong>对象引用</strong>.<br>局部变量表所需的内存空间在编译时期完成分配, 当进入一个方法时, 这个方法需要在栈帧中分配多大的局部变量空间是完全确定的, 在方法运行期间不会改变局部变量表的大小.</p>
</li>
<li><p>Java虚拟机规范对这个区域规定了两种异常情况:  </p>
</li>
</ol>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度, 将抛出<code>StackOverflowError</code> 异常；</li>
<li>如果虚拟机栈可以动态扩展, 如果扩展时无法申请到足够的内存, 就会抛出<code>OutOfMemoryError</code>异常；<br>  （当前大部分JVM都可以动态扩展, 只不过JVM规范也允许固定长度的虚拟机栈）</li>
</ul>
<blockquote>
<p>栈深度:   每次方法调用, 都会创建一个栈帧, 一个方法调用另一个方法, 栈帧就会深度增加一层</p>
</blockquote>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><ol>
<li><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的, 它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务（也就是字节码）, 而本地方法栈为虚拟机使用到的Native方法服务.</p>
</li>
<li><p>Java虚拟机规范对本地方法栈使用的语言、使用方法与数据结构并没有强制规定, 因此可以由虚拟机自由实现. 例如:  HotSpot虚拟机直接将本地方法栈和虚拟机栈合二为一.</p>
</li>
<li><p>同虚拟机栈相同, Java虚拟机规范对这个区域也规定了两种异常情况<code>StackOverflowError</code> 和 <code>OutOfMemoryError</code>异常.</p>
</li>
</ol>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ol>
<li>Java堆是被<strong>所有的线程共享</strong>的一块内存区域, 在虚拟机启动时创建.<br>Java堆的唯一目的就是存放对象实例, 几乎所有的对象实例都在这里分配内存.</li>
<li>Java堆是垃圾回收器管理的主要区域, 因此也被称为”GC堆”.</li>
</ol>
<p>从内存回收的角度看, 由于现在收集器基本都采用分代收集算法, 所以Java堆可以细分为:  新生代、老生代；</p>
<p>从内存分配的角度看, 线程共享的Java堆可能划分出多个线程私有的分配缓冲区（TLAB）；</p>
<p>不论如何划分, 都与存放的内容无关, 无论哪个区域, 存储的仍然是对象实例.</p>
<ol>
<li><p>Java虚拟机规范规定, Java堆可以处于物理上不连续的内存空间中, 只要逻辑上是连续的即可, 就像我们的磁盘空间一样. 在实现上, 既可以是固定大小的, 也可以是可扩展的, 不过当前主流JVM都是按照可扩展来实现的.</p>
</li>
<li><p>Java虚拟机规范规定, 如果在堆上没有内存完成实例分配, 并且堆上也无法再扩展时, 将会抛出<code>OutOfMemoryError</code>异常.</p>
</li>
<li><p>内存泄露和内存溢出<br> Java堆内存的<code>OOM</code>异常是非常常见的异常情况, 重点是根据内存中的对象是否是必要的, 来弄清楚到底是出现了<code>内存泄露(Memory Leak)</code>还是<code>内存溢出(Memory Overflow)</code>.</p>
</li>
</ol>
<ul>
<li> 内存泄露:  指程序中一些对象不会被GC所回收, 它始终占用内存, 即被分配的对象引用链可达但已无用. （可用内存减少）</li>
<li> 内存溢出:  程序运行过程中无法申请到足够的内存而导致的一种错误. 内存溢出通常发生于OLD段或Perm段垃圾回收后, 仍然无内存空间容纳新的Java对象的情况.</li>
<li> 内存泄露是内存溢出的一种诱因, 不是唯一因素.</li>
</ul>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ol>
<li><p>方法区也是被<code>所有的线程共享</code>的一块内存区域. 它用于存储已被虚拟机加载的<code>类信息</code>、<code>常量</code>、<code>静态变量</code>、<code>即时编译器编译后的代码</code>等数据.</p>
</li>
<li><p>Java虚拟机规范对方法区的限制非常宽松, 除了和Java堆一样 不需要连续的内存和可以选择固定大小或者可扩展之外, 还可以选择不实现垃圾回收.<br> 这区域的内存回收目标主要是针对常量池的回收和类型的卸载, 一般而言, 这个区域的内存回收比较难以令人满意, 尤其是类型的回收, 条件相当苛刻, 但是这部分区域的内存回收确实是必要的.</p>
</li>
<li><p>Java虚拟机规范规定, 当方法区无法满足内存分配的需求时, 将抛出<code>OutOfMemoryError</code>异常.</p>
</li>
<li><p><strong>运行时常量池</strong></p>
<p><code>运行时常量池</code>是方法区的一部分. Class文件中除了有类的版本、字段、方法、接口等描述信息外, 还有一项信息是常量池, 用于存放编译期生成的各种字面量和符号引用, 这部分内容将在类加载后进入方法区的运行时常量池中存放.</p>
<p><code>运行时常量池</code>相对于Class文件常量池的另外一个重要特征是具备动态性, Java语言并不要求常量一定只有编译期才能产生, 也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池, 运行期间也可能将新的常量放入池中, 这种特性被开发人员利用比较多的就是String类的intern()方法.</p>
</li>
<li><p>String.intern()</p>
<p><code>String.intern()</code>是一个<code>Native</code>方法, 它的作用是:  如果字符串常量池中已经包含了一个等于此String对象的字符串, 则返回代表池中这个字符串的String对象；否则, 将此String对象包含的字符串添加到常量池中, 并且返回此字符串的引用.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;计算机&quot;</span>).append(<span class="string">&quot;软件&quot;</span>).toString();</span><br><span class="line"> System.out.println(str1.intern() == str1);</span><br><span class="line"></span><br><span class="line"> String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line"> System.out.println(str2.intern() == str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这段代码在JDK1.6中运行, 会得到两个false, 而在JDK1.7中运行, 会得到一个true和一个false. 原因是:  </p>
<ol>
<li>在JDK1.6中<code>intern()</code>方法会把首次遇到的字符串实例复制到永久代中, 返回的也是永久代中这个字符串实例的引用, 而由<code>StringBuilder</code>创建的字符串实例在Java堆上, 所以必然不是一个引用.</li>
<li>在JDK1.7中<code>intern()</code>方法不会复制实例, 只是在常量池中记录首次出现的实例引用, 因此<code>intern()</code>返回的引用和由<code>StringBuilder</code>创建的字符串实例是同一个.</li>
<li>str2返回false是因为Java这个字符串在执行<code>StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString()</code>之前已经出现过, 字符串常量池中已经有它的引用了, 不符合首次出现的原则, 而”计算机软件”这个字符串是首次出现的.</li>
</ol>
<h1 id="堆的划分"><a href="#堆的划分" class="headerlink" title="堆的划分"></a>堆的划分</h1><p><img src="/images/java/JVM/jvm-heap-generations.jpg" alt="堆的分代划分"><br>堆的分代划分</p>
<ol>
<li><p>Young（年轻代）</p>
<p>年轻代分三个区. 一个<code>Eden</code>区, 两个 <code>Survivor</code>区. 大部分对象在<code>Eden</code>区中生成. 当Eden区满时, 还存活的对象将被复制到Survivor区（两个中的一个）, 当这个 Survivor区满时, 此区的存活对象将被复制到另外一个Survivor区, 当这个Survivor区也满了的时候, 从第一个Survivor区复制过来的并且此时还存活的对象, 将被复制“<code>年老区(Tenured)</code>”. 需要注意, Survivor的两个区是对称的, 没先后关系, 所以同一个区中可能同时存在从Eden复制过来的对象和从前一个Survivor复制过来的对象, 而复制到年老区的只有从第一个Survivor区过来的对象. 而且, Survivor区总有一个是空的.</p>
</li>
<li><p>Tenured（年老代）</p>
<p>年老代存放从年轻代存活的对象. 一般来说年老代存放的都是生命期较长的对象.</p>
</li>
<li><p>Perm（持久代）</p>
<p>用于存放静态文件, 如Java类、方法等. 持久代对垃圾回收没有显著影响, 但是有些应用可能动态生成或者调用一些Class, 例如Hibernate等,  在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类. 持久代大小通过-XX:MaxPermSize=进行设置.</p>
</li>
</ol>
<h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>GC有两种类型:  Scavenge GC和Full GC.</p>
<ol>
<li><p><code> Scavenge GC</code></p>
<p>一般情况下, 当新对象生成, 并且在Eden申请空间失败时, 就好触发Scavenge GC, 堆Eden区域进行GC, 清除非存活对象, 并且把尚且存活的对象移动到Survivor区. 然后整理Survivor的两个区.</p>
</li>
<li><p><code> Full GC</code></p>
<p>对整个堆进行整理, 包括Young、Tenured和Perm. Full GC比Scavenge GC要慢, 因此应该尽可能减少Full GC. 有如下原因可能导致Full GC:  </p>
</li>
</ol>
<ul>
<li>   Tenured被写满</li>
<li> Perm域被写满<ul>
<li>   System.gc()被显示调用</li>
<li>   上一次GC之后Heap的各域分配策略动态变化</li>
</ul>
</li>
</ul>
<h2 id="基本回收算法"><a href="#基本回收算法" class="headerlink" title="基本回收算法"></a>基本回收算法</h2><ul>
<li>引用计数（Reference Counting）<br>比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。</li>
<li>标记-清除（Mark-Sweep）<br>此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</li>
<li>复制（Copying）<br>此 算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。次算法每次只处理 正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不过出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍 内存空间。</li>
<li>标记-整理（Mark-Compact）<br>此算法结 合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活 对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</li>
<li>增量收集（Incremental Collecting）<br>实施垃圾回收算法，即：在应用进行的同时进行垃圾回收。不知道什么原因JDK5.0中的收集器没有使用这种算法的。</li>
<li>分代（Generational Collecting）<br>基于对对象生命周期分析后得出的垃圾回收算法。把对象分为年青代、年老代、持久代，对不同生命周期的对象使用不同的算法（上述方式中的一个）进行回收。现在的垃圾回收器（从J2SE1.2开始）都是使用此算法的。</li>
</ul>
<h1 id="JVM内存参数设置与调优"><a href="#JVM内存参数设置与调优" class="headerlink" title="JVM内存参数设置与调优"></a>JVM内存参数设置与调优</h1><p>常见配置举例</p>
<p>堆大小设置</p>
<p>  JVM 中最大堆大小有三方面限制:  相关操作系统的数据模型（32-bt还是64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制. 32位系统 下, 一般限制在1.5G~2G；64为操作系统对内存无限制. 我在Windows Server 2003 系统, 3.5G物理内存, JDK5.0下测试, 最大可设置为1478m.</p>
<p>典型设置:  </p>
<ul>
<li><code>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k</code><ul>
<li> -Xmx3550m:  设置JVM最大可用内存为3550M.</li>
<li> -Xms3550m:  设置JVM初始内存为3550m. 此值可以设置与-Xmx相同, 以避免每次垃圾回收完成后JVM重新分配内存.</li>
<li> -Xmn2g:  设置年轻代大小为2G. 整个堆大小=年轻代大小 + 年老代大小 + 持久代大小. 持久代一般固定大小为64m, 所以增大年轻代后, 将会减小年老代大小. 此值对系统性能影响较大, Sun官方推荐配置为整个堆的3/8.</li>
<li> -Xss128k:   设置每个线程的堆栈大小. JDK5.0以后每个线程堆栈大小为1M, 以前每个线程堆栈大小为256K. 更具应用的线程所需内存大小进行调整. 在相同物理内 存下, 减小这个值能生成更多的线程. 但是操作系统对一个进程内的线程数还是有限制的, 不能无限生成, 经验值在3000~5000左右.</li>
</ul>
</li>
<li><code>java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0</code><ul>
<li> -XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）. 设置为4, 则年轻代与年老代所占比值为1:  4, 年轻代占整个堆栈的1/5</li>
<li> -XX:SurvivorRatio=4:  设置年轻代中Eden区与Survivor区的大小比值. 设置为4, 则两个Survivor区与一个Eden区的比值为2:4, 一个Survivor区占整个年轻代的1/6</li>
<li> -XX:MaxPermSize=16m:设置持久代大小为16m.</li>
<li> -XX:MaxTenuringThreshold=0:  设置垃圾最大年龄. 如果设置为0的话, 则年轻代对象不经过Survivor区, 直接进入年老代. 对于年老代比较多的应用, 可以提高效率. 如果将此值设置为一个较大值, 则年轻代对象会在Survivor区进行多次复制, 这样可以增加对象再年轻代的存活时间, 增加在年轻代即被回收的概论.</li>
</ul>
</li>
</ul>
<h2 id="调优总结"><a href="#调优总结" class="headerlink" title="调优总结"></a>调优总结</h2><ol>
<li><p>年轻代大小选择</p>
<p>  响应时间优先的应用:  尽可能设大, 直到接近系统的最低响应时间限制（根据实际情况选择）. 在此种情况下, 年轻代收集发生的频率也是最小的. 同时, 减少到达年老代的对象.</p>
<p>  吞吐量优先的应用:  尽可能设大, 可能到达Gbit的程度. 因为对响应时间没有要求, 垃圾收集可以并行进行, 一般适合8CPU以上的应用.</p>
</li>
<li><p>年老代大小选择</p>
<pre><code>响应时间优先的应用:  

年老代使用并发收集器, 所以其大小需要小心设置, 一般要考虑并发会话率和会话持续时间等一些参数. 如果堆设置小了, 可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了, 则需要较长的收集时间. 最优化的方案, 一般需要参考以下数据获得:  </code></pre>
<ul>
<li>   并发垃圾收集信息</li>
<li>   持久代并发收集次数</li>
<li>   传统GC信息</li>
<li>   花在年轻代和年老代回收上的时间比例 减少年轻代和年老代花费的时间, 一般会提高应用的效率</li>
</ul>
<p>吞吐量优先的应用:  一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代. 原因是, 这样可以尽可能回收掉大部分短期对象, 减少中期的对象, 而年老代尽存放长期存活对象.</p>
</li>
<li><p>较小堆引起的碎片问题</p>
<p>因为年老代的并发收集器使用标记、清除算法, 所以不会对堆进行压缩. 当收集器回收时, 他会把相邻的空间进行合并, 这样可以分配给较大的对象. 但是, 当堆空间 较小时, 运行一段时间以后, 就会出现“碎片”, 如果并发收集器找不到足够的空间, 那么并发收集器将会停止, 然后使用传统的标记、清除方式进行回收. 如果出 现“碎片”, 可能需要进行如下配置:  </p>
<ul>
<li>-XX:+UseCMSCompactAtFullCollection:  使用并发收集器时, 开启对年老代的压缩.</li>
<li>-XX:CMSFullGCsBeforeCompaction=0:  上面配置开启的情况下, 这里设置多少次Full GC后, 对年老代进行压缩</li>
</ul>
</li>
</ol>
<h2 id="常见配置参数汇总"><a href="#常见配置参数汇总" class="headerlink" title="常见配置参数汇总"></a>常见配置参数汇总</h2><ol>
<li>堆设置<ul>
<li>-Xms:初始堆大小</li>
<li>-Xmx:最大堆大小</li>
<li>-XX:NewSize=n:设置年轻代大小</li>
<li>-XX:NewRatio=n:设置年轻代和年老代的比值. 如:为3, 表示年轻代与年老代比值为1:  3, 年轻代占整个年轻代年老代和的1/4</li>
<li>-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值. 注意Survivor区有两个. 如:  3, 表示Eden:  Survivor=3:  2, 一个Survivor区占整个年轻代的1/5</li>
<li>-XX:MaxPermSize=n:设置持久代大小</li>
</ul>
</li>
<li>收集器设置<ul>
<li>-XX:+UseSerialGC:设置串行收集器</li>
<li>-XX:+UseParallelGC:设置并行收集器</li>
<li>-XX:+UseParalledlOldGC:设置并行年老代收集器</li>
<li>-XX:+UseConcMarkSweepGC:设置并发收集器</li>
</ul>
</li>
<li>垃圾回收统计信息<ul>
<li>-XX:+PrintGC</li>
<li>-XX:+Printetails</li>
<li>-XX:+PrintGCTimeStamps</li>
<li>-Xloggc:filename</li>
</ul>
</li>
<li>并行收集器设置<ul>
<li>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数. 并行收集线程数.</li>
<li>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间</li>
<li>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比. 公式为1/(1+n)</li>
</ul>
</li>
<li>并发收集器设置<ul>
<li>-XX:+CMSIncrementalMode:设置为增量模式. 适用于单CPU情况.</li>
<li>-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时, 使用的CPU数. 并行收集线程数.</li>
</ul>
</li>
</ol>
<h1 id="类加载-1"><a href="#类加载-1" class="headerlink" title="类加载"></a>类加载</h1><h2 id="类的加载阶段"><a href="#类的加载阶段" class="headerlink" title="类的加载阶段"></a>类的加载阶段</h2><p>类加载分为装载、链接、初始化三步.</p>
<ol>
<li><p>装载</p>
<p>通过类的全限定名和ClassLoader加载类, 主要是将指定的.Class文件加载至JVM. 当类被加载以后, 在JVM内部就以“类的全限定名+ClassLoader实例ID”来标明类.</p>
<p>在内存中, ClassLoader实例和类的实例都位于堆中, 它们的类信息都位于方法区.</p>
<p>装载过程采用了一种被称为“双亲委派模型（Parent Delegation Model）”的方式, 当一个ClassLoader要加载类时, 它会先请求它的双亲ClassLoader（其实这里只有两个ClassLoader, 所以称为父ClassLoader可能更容易理解）加载类, 而它的双亲ClassLoader会继续把加载请求提交再上一级的ClassLoader, 直到启动类加载器. 只有其双亲ClassLoader无法加载指定的类时, 它才会自己加载类.</p>
<p>双亲委派模型是JVM的第一道安全防线, 它保证了类的安全加载, 这里同时依赖了类加载器隔离的原理:  不同类加载器加载的类之间是无法直接交互的, 即使是同一个类, 被不同的ClassLoader加载, 它们也无法感知到彼此的存在. 这样即使有恶意的类冒充自己在核心包（例如java.lang）下, 由于它无法被启动类加载器加载, 也造成不了危害.</p>
<p>由此也可见, 如果用户自定义了类加载器, 那就必须自己保障类加载过程中的安全.</p>
</li>
<li><p>链接</p>
<p>链接的任务是把二进制的类型信息合并到JVM运行时状态中去.<br>链接分为以下三步:  </p>
</li>
</ol>
<ul>
<li>验证:  校验.Class文件的正确性, 确保该文件是符合规范定义的, 并且适合当前JVM使用.</li>
<li>准备:  为类分配内存, 同时初始化类中的静态变量赋值为默认值.</li>
<li>解析（可选）:  主要是把类的常量池中的符号引用解析为直接引用, 这一步可以在用到相应的引用时再解析.</li>
</ul>
<ol>
<li>初始化</li>
</ol>
<p>初始化类中的静态变量, 并执行类中的static代码、构造函数.</p>
<p>JVM规范严格定义了何时需要对类进行初始化:  </p>
<ul>
<li>通过new关键字、反射、clone、反序列化机制实例化对象时.</li>
<li>调用类的静态方法时.</li>
<li>使用类的静态字段或对其赋值时.</li>
<li>通过反射调用类的方法时.</li>
<li>初始化该类的子类时（初始化子类前其父类必须已经被初始化）.</li>
<li>JVM启动时被标记为启动类的类（简单理解为具有main方法的类）.</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><img src="/images/java/JVM/ClassLoader-01.png"></p>
<p>ClassLoader的分类:  </p>
<p>1）BootstrapClassLoader（启动类加载器）<br>　　负责加载$JAVA_HOME中jre/lib/rt.jar里所有的Class，加载System.getProperty(“sun.boot.Class.path”)所指定的路径或jar。<br>2）ExtensionClassLoader（标准扩展类加载器）<br>　　负责加载java平台中扩展功能的一些jar包，包括<code>$JAVA_HOME</code>中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包。<br>   在System.getProperty(“java.ext.dirs”)所指定的路径或jar。<br>3）AppClassLoader（系统类加载器）<br>　　负责记载Classpath中指定的jar包及目录中Class<br>4）CustomClassLoader（自定义加载器）<br>　　属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现。</p>
<h3 id="类加载器的顺序-双亲委派"><a href="#类加载器的顺序-双亲委派" class="headerlink" title="类加载器的顺序: 双亲委派"></a>类加载器的顺序: 双亲委派</h3><p>当一个ClassLoader要加载类时，它会先请求它的双亲ClassLoader（其实这里只有两个ClassLoader，所以称为父ClassLoader可能更容易理解）加载类，而它的双亲ClassLoader会继续把加载请求提交再上一级的ClassLoader，直到启动类加载器。只有其双亲ClassLoader无法加载指定的类时，它才会自己加载类。</p>
<p>双亲委派模型是JVM的第一道安全防线，它保证了类的安全加载，这里同时依赖了类加载器隔离的原理：不同类加载器加载的类之间是无法直接交互的，即使是同一个类，被不同的ClassLoader加载，它们也无法感知到彼此的存在。这样即使有恶意的类冒充自己在核心包（例如java.lang）下，由于它无法被启动类加载器加载，也造成不了危害。</p>
<p>由此也可见，如果用户自定义了类加载器，那就必须自己保障类加载过程中的安全。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/7ebbe102c1ae">深入理解JVM 1</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/anders_zhuo/article/details/47776569">JVM调优总结 </a></li>
<li><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/26594">浅析Java虚拟机结构与机制 </a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/ochangwen/article/details/51407574"> 深入理解JVM03–垃圾收集算法</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/jvm/jvm2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/jvm/jvm2/" class="post-title-link" itemprop="url">GC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-05-04 12:26:00" itemprop="dateCreated datePublished" datetime="2016-05-04T12:26:00+08:00">2016-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-19 15:02:11" itemprop="dateModified" datetime="2021-04-19T15:02:11+08:00">2021-04-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>heap分代的目的是，应对不同生命周期的对象，大部分对象是朝生夕死的，也用一些常量是长期占用内存的，如数据值的枚举<br>动态调整：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/regular-expression/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/regular-expression/" class="post-title-link" itemprop="url">正则表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-04-21 11:28:00" itemprop="dateCreated datePublished" datetime="2016-04-21T11:28:00+08:00">2016-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-19 15:02:11" itemprop="dateModified" datetime="2021-04-19T15:02:11+08:00">2021-04-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><ol>
<li><code>\w</code> 匹配一个字符，可以是数字、下划线、字母或者汉字</li>
<li><code>\b</code> 匹配的是位置，它的前一个字符和后一个字符不全是(一个是, 一个不是或不存在) <code>\w</code></li>
</ol>
<ul>
<li><code>\bhi\b</code> 匹配hi单词， 对于history和him都不匹配</li>
<li><code>\bhi\b.*\blucy\b</code> hi单词后面若干字符之后是lucy</li>
</ul>
<ol>
<li><code>.</code> 匹配除了换行符之外的任一字符<br><code>\bhi.lucy\b</code>在hi和lucy中存在一个除了换行符之外的任一字符</li>
<li><code>*</code> 匹配的是数量 0~若干个<br><code>\bhi\b.*\blucy\b</code> hi单词后面若干个除换行符以外的字符之后是lucy</li>
<li><code>\s</code> 匹配任意的空白符</li>
<li><code>\d</code> 匹配数字<br><code>0\d&#123;2&#125;-\d&#123;8&#125;</code> 匹配以0开头，紧接着是2位数字，接着是-，最后是8位数字<br><code>\d+</code> 匹配多于一个数字</li>
<li><code>[0123456789]</code>或者<code>[0-9]</code> 匹配数字与<code>\d</code>的意义完全相同</li>
<li><code>^</code> 匹配字符串的开始</li>
<li><code>$</code> 匹配字符串的结束<br><code>^\b&#123;5,12&#125;$</code> 匹配5到12位的数字</li>
</ol>
<h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h2><p>使用斜杠<code>\</code>对特殊字符转义，转换为普通字符</p>
<h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td><code>+</code></td>
<td>重复一次或者更多次</td>
</tr>
<tr>
<td><code>?</code></td>
<td>重复零次或一次</td>
</tr>
<tr>
<td><code>&#123;n&#125;</code></td>
<td>重复n次</td>
</tr>
<tr>
<td><code>&#123;n,&#125;</code></td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td><code>&#123;n,m&#125;</code></td>
<td>重复n到m次</td>
</tr>
</tbody></table>
<p><code>windows\d+</code> windows后面紧跟着多于一个数字<br><code>^\w+</code> 以多于一个字符开头</p>
<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><ol>
<li><p><code>[aeiou]</code> aeiou中的一个字符</p>
</li>
<li><p><code>[0-9]</code> 从0到9</p>
</li>
<li><p><code>[0-9A-Za-z]</code> 完全等同于 <code>\w</code>(如果不考虑中文字符)</p>
</li>
<li><p><code>[) -]</code> 从右括号、空格和减号中选择一个</p>
<p> <code>\(?0\d&#123;2&#125;[) -]?\d&#123;8&#125;</code> 首先是一个转义字符<code>\(</code>， 它可能出现0次或1次(?)， 然后是一个0， 后面跟着2个数字<code>\d&#123;2&#125;</code>，然后是)或-或空格中的一个，它出现1此或不出现(?), 最后是8个数字(\d{8}).</p>
</li>
</ol>
<h2 id="分枝条件"><a href="#分枝条件" class="headerlink" title="分枝条件"></a>分枝条件</h2><p>分枝条件: 满足若干条件中的一个就能匹配. 要注意优先级和各条件顺序问题.</p>
<p>** 例1 匹配电话号码<br>要匹配两种电话号码形式:  (0755)12345678 或者 0755-12345678 以及 0751-1234567</p>
<p><code>\(\d&#123;3,4&#125;\)\d&#123;7,8&#125;|\d&#123;3,4&#125;-\d&#123;7,8&#125;</code></p>
<p>** 例2: 注意分枝条件各条件的顺序<br>美国的邮编是有两种形式的: 5位数字 或者用连字号间隔的9位数字, 如12345和12345-1234两种形式.</p>
<p>应该使用<code>\d&#123;5&#125;-\d&#123;4&#125;|\d&#123;5&#125;</code>, 而不能使用<code>\d&#123;5&#125;|\d&#123;5&#125;-\d&#123;4&#125;</code><br>也就是说, 如果<code>\d&#123;5&#125;</code>提前匹配了<code>12345</code>之后会返回而丢弃掉后面的四位.</p>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>分组可以实现子表达式重复出现.</p>
<p><code>(\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1,3&#125;</code> 匹配以点号分割的四组数字, 每组数字是1到3位,如 <code>999.999.999.999</code> 或<code>1.1.0.0</code></p>
<p>** IP地址的匹配 **<br>IP地址分为4段, 每段的数字范围为: 0~255<br>正则表达式只能匹配字符串的格式, 不支持数值比较, 因此需要用尽可能精简的方式准确列出所有的可能性</p>
<p><code>((2[0-4]\d|25[0-5]|[0-1]?\d\d?)\.)&#123;3&#125;(2[0-4]\d|25[0-5]|[0-1]?\d\d?)</code></p>
<p>解释:</p>
<ol>
<li><code>2[0-4]\d</code> 首位是2,第二位可以为0到4,第三位是任意数字</li>
<li><code>25[0-5]</code> 前两位是25,第三位必须是0到5, 因为最大是255</li>
<li><code>[0-1]?\d\d?</code> 首位是0或1, 也可以首位不存在, 第二位为任何数字, 第三位是任意数字, 也可以不存在, 不存在这种情况下, 就只有前两位.<br> 为什么不是<code>[0-1]?\d?\d</code>?</li>
</ol>
<h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><p>对字符类进行反义, 只需要将上面<a href="">字符类</a>一节的所有的字符转为大写</p>
<table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>\W</code></td>
<td>匹配任意不是字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配任意不是空白符的字符</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配任意非数字的字符</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>匹配不是单词开头或结束的位置</td>
</tr>
<tr>
<td><code>[^x]</code></td>
<td>匹配除了x以外的任意字符</td>
</tr>
<tr>
<td><code>[^aeiou]</code></td>
<td>匹配除了aeiou这几个字母以外的任意字符</td>
</tr>
</tbody></table>
<h2 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h2><p>用于引用上文中匹配到的字符- 给上文中出现的表达式添加组号, 在下文中引用这个组号</p>
<table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>(exp)</code></td>
<td>匹配exp,并捕获文本到自动命名的组里</td>
</tr>
<tr>
<td><code>(?&lt;name&gt;exp)</code></td>
<td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td>
</tr>
<tr>
<td><code>(?:exp)</code></td>
<td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td>
</tr>
</tbody></table>
<p>分组命名规则为:</p>
<ul>
<li>  分组0对应整个正则表达式</li>
<li>  实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号</li>
<li>  你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．</li>
</ul>
<p>例1 <strong>自动命名</strong><br><code>\b(\w+)\b\s+\1\b</code> 首先匹配一个单词(<code>\w+</code>)并放到分组1中, 在下文中通过<code>\1</code>引用上文中分组1匹配到的字符.<br>该表达式用于匹配重复单词. 如 <code>hello hello</code></p>
<p>例2 <strong>手动命名</strong><br><code>\b(?&lt;name&gt;\w+)\b\s+\k&lt;name&gt;\b</code> 首先匹配一个单词(<code>\w+</code>) 并将这个单词放入name组中, 在下文中引用name分组, 看后面是否再出现<br>注意反向引用时的格式: <code>\k&lt;name&gt;</code></p>
<p>例3 <strong>不捕获</strong><br>    <code>\b(?:\w+)\b\s+</code> 不捕获</p>
<h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>零宽断言和负向零宽断言用于指示位置, 零宽断言分为两种, 分别指示匹配表达式的前面和后面.</p>
<h3 id="零宽度正预测先行断言"><a href="#零宽度正预测先行断言" class="headerlink" title="零宽度正预测先行断言"></a>零宽度正预测先行断言</h3><p>用于指示匹配表达式的字符串的上一个字符位置</p>
<p><code>\b\w+(?=ing\b)</code> 匹配以ing结尾的单词的前面部分(除了ing以外的部分).<br>如果查找 <code> I&#39;m singing while you&#39;re dancing.</code>时, 它会匹配sing和danc.</p>
<h3 id="零宽度正回顾后发断言"><a href="#零宽度正回顾后发断言" class="headerlink" title="零宽度正回顾后发断言"></a>零宽度正回顾后发断言</h3><p>用于指示匹配表达式的字符串的下一个字符位置</p>
<p><code>(?&lt;=\bre)\w+\b</code> 匹配以re开头的单词的后半部分</p>
<p><code>((?&lt;=\d)\d&#123;3&#125;+\b)</code>匹配一个数字后面是若干的三个数字的后面部分.<br>对1234567890进行查找时结果是234567890</p>
<h2 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h2><p>负向零宽断言, 与上一节中的正向零宽断言相对, 用于匹配不是某个字符或不在某些字符类里的方法</p>
<p>确保某个字符没有出现, 但并不想去匹配它, 就可以使用<code>负向零宽断言</code></p>
<h3 id="零宽度负预测先行断言-exp"><a href="#零宽度负预测先行断言-exp" class="headerlink" title="零宽度负预测先行断言(?!exp)"></a>零宽度负预测先行断言(?!exp)</h3><p>断言此位置的后面不能匹配表达式exp。<br>例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；<br>\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。</p>
<h3 id="零宽度负回顾后发断言"><a href="#零宽度负回顾后发断言" class="headerlink" title="零宽度负回顾后发断言"></a>零宽度负回顾后发断言</h3><p>同理，可以用(<code>?&lt;!exp</code>),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：<br><code>(?&lt;![a-z])\d&#123;7&#125;</code> 匹配前面不是小写字母的七位数字。</p>
<p>请详细分析表达式<code>(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)</code>，这个表达式最能表现零宽断言的真正用途。</p>
<p>一个更复杂的例子：<br><code>(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)</code>匹配不包含属性的简单HTML标签内里的内容。<br><code>(?&lt;=&lt;(\w+)&gt;)</code>指定了这样的前缀：被尖括号括起来的单词(比如可能是<b>)，<br>然后是.<code>*(任意的字符串)</code>,最后是一个后缀(?=&lt;/\1&gt;)。注意后缀里的/，<br>它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，<br>前面的(\w+)匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。<br>整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>通过语法<code>(?#comment)</code>来包含注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(?&lt;&#x3D;    # 断言要匹配的文本的前缀</span><br><span class="line"> &lt;(\w+)&gt; # 查找尖括号括起来的字母或数字(即HTML&#x2F;XML标签)</span><br><span class="line">)       # 前缀结束</span><br><span class="line">.*      # 匹配任意文本</span><br><span class="line">(?&#x3D;     # 断言要匹配的文本的后缀</span><br><span class="line"> &lt;\&#x2F;\1&gt;  # 查找尖括号括起来的内容：前面是一个&quot;&#x2F;&quot;，后面是先前捕获的标签</span><br><span class="line">)       # 后缀结束</span><br></pre></td></tr></table></figure>

<h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>*?</code></td>
<td>重复任意次，但尽可能少重复</td>
</tr>
<tr>
<td><code>+?</code></td>
<td>重复1次或更多次，但尽可能少重复</td>
</tr>
<tr>
<td><code>??</code></td>
<td>重复0次或1次，但尽可能少重复</td>
</tr>
<tr>
<td><code>&#123;n,m&#125;?</code></td>
<td>重复n到m次，但尽可能少重复</td>
</tr>
<tr>
<td><code>&#123;n,&#125;?</code></td>
<td>重复n次以上，但尽可能少重复</td>
</tr>
</tbody></table>
<h2 id="处理选项"><a href="#处理选项" class="headerlink" title="处理选项"></a>处理选项</h2><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>IgnoreCase</code>(忽略大小写)</td>
<td>匹配时不区分大小写。</td>
</tr>
<tr>
<td><code>Multiline</code>(多行模式)</td>
<td>更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)</td>
</tr>
<tr>
<td><code>Singleline</code>(单行模式)</td>
<td>更改.的含义，使它与每一个字符匹配（包括换行符\n）。</td>
</tr>
<tr>
<td><code>IgnorePatternWhitespace</code>(忽略空白)</td>
<td>忽略表达式中的非转义空白并启用由#标记的注释。</td>
</tr>
<tr>
<td><code>ExplicitCapture</code>(显式捕获)</td>
<td>仅捕获已被显式命名的组。</td>
</tr>
</tbody></table>
<h2 id="平衡组-递归匹配"><a href="#平衡组-递归匹配" class="headerlink" title="平衡组/递归匹配"></a>平衡组/递归匹配</h2><p>用于在嵌套的层次结构中, 判断是否嵌套.</p>
<ul>
<li>   <code>(?&#39;group&#39;)</code> 把捕获的内容命名为group,并压入堆栈(Stack)</li>
<li>   <code>(?&#39;-group&#39;)</code> 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败</li>
<li>   <code>(?(group)yes|no)</code> 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分</li>
<li>   <code>(?!)</code> 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;                         #最外层的左括号</span><br><span class="line">[^&lt;&gt;]*                #最外层的左括号后面的不是括号的内容</span><br><span class="line">(</span><br><span class="line"> (</span><br><span class="line">  (?&#39;Open&#39;&lt;)    #碰到了左括号，在黑板上写一个&quot;Open&quot;</span><br><span class="line">  [^&lt;&gt;]*       #匹配左括号后面的不是括号的内容</span><br><span class="line"> )+</span><br><span class="line"> (</span><br><span class="line">  (?&#39;-Open&#39;&gt;)   #碰到了右括号，擦掉一个&quot;Open&quot;</span><br><span class="line">  [^&lt;&gt;]*        #匹配右括号后面不是括号的内容</span><br><span class="line"> )+</span><br><span class="line">)*</span><br><span class="line">(?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的&quot;Open&quot;；如果还有，则匹配失败</span><br><span class="line"></span><br><span class="line">&gt;                         #最外层的右括号</span><br></pre></td></tr></table></figure>
<p>我们需要做的是每碰到了左括号，就在压入一个”Open”,每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。</p>
<h2 id="其他语法"><a href="#其他语法" class="headerlink" title="其他语法"></a>其他语法</h2><table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>报警字符(打印它的效果是电脑嘀一声)</td>
</tr>
<tr>
<td>\b</td>
<td>通常是单词分界位置，但如果在字符类里使用代表退格</td>
</tr>
<tr>
<td>\t</td>
<td>制表符，Tab</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\v</td>
<td>竖向制表符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\e</td>
<td>Escape</td>
</tr>
<tr>
<td>\0nn</td>
<td>ASCII代码中八进制代码为nn的字符</td>
</tr>
<tr>
<td>\xnn</td>
<td>ASCII代码中十六进制代码为nn的字符</td>
</tr>
<tr>
<td>\unnnn</td>
<td>Unicode代码中十六进制代码为nnnn的字符</td>
</tr>
<tr>
<td>\cN</td>
<td>ASCII控制字符。比如\cC代表Ctrl+C</td>
</tr>
<tr>
<td>\A</td>
<td>字符串开头(类似^，但不受处理多行选项的影响)</td>
</tr>
<tr>
<td>\Z</td>
<td>字符串结尾或行尾(不受处理多行选项的影响)</td>
</tr>
<tr>
<td>\z</td>
<td>字符串结尾(类似$，但不受处理多行选项的影响)</td>
</tr>
<tr>
<td>\G</td>
<td>当前搜索的开头</td>
</tr>
<tr>
<td>\p{name}</td>
<td>Unicode中命名为name的字符类，例如\p{IsGreek}</td>
</tr>
<tr>
<td>(?&gt;exp)</td>
<td>贪婪子表达式</td>
</tr>
<tr>
<td>(?<x>-<y>exp)</td>
<td>平衡组</td>
</tr>
<tr>
<td>(?im-nsx:exp)</td>
<td>在子表达式exp中改变处理选项</td>
</tr>
<tr>
<td>(?im-nsx)</td>
<td>为表达式后面的部分改变处理选项</td>
</tr>
<tr>
<td>(?(exp)yes</td>
<td>no)</td>
</tr>
<tr>
<td>(?(exp)yes)</td>
<td>同上，只是使用空表达式作为no</td>
</tr>
<tr>
<td>(?(name)yes</td>
<td>no)</td>
</tr>
<tr>
<td>(?(name)yes)</td>
<td>同上，只是使用空表达式作为no</td>
</tr>
</tbody></table>
<h1 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h1><h2 id="电子邮箱Email"><a href="#电子邮箱Email" class="headerlink" title="电子邮箱Email"></a>电子邮箱Email</h2><p><code>\w+([-+.]\w+)*@\w+([-.]\w)*\.\w+([-.]\w+)*</code><br>Email地址是以@分割, <code>@</code>前面的部分为用户名, 后面为域名.<br>用户名部分可以包含字母/数字/下划线/-/+/., 但是只能字母/数字/下划线开头.<br>不能出现+-.连续<br>而域名部分可以包含字母/数字/下划线/-以及. 也是只能字母/数字/下划线开头.</p>
<p>用户名部分<code>\w+([-+.]\w+)*</code> , 必须是至少一个<code>\w</code>开头,</p>
<h2 id="手机号码"><a href="#手机号码" class="headerlink" title="手机号码"></a>手机号码</h2><p><code>[1-9][3,4,5,7,8]/d&#123;9&#125;</code></p>
<h2 id="汉字"><a href="#汉字" class="headerlink" title="汉字"></a>汉字</h2><p><code>[\u4e00-\u9fa5]</code></p>
<h2 id="QQ号码"><a href="#QQ号码" class="headerlink" title="QQ号码"></a>QQ号码</h2><p><code>[1-9]\d&#123;4,&#125;</code></p>
<h2 id="邮编"><a href="#邮编" class="headerlink" title="邮编"></a>邮编</h2><p><code>[1-9]\d&#123;5&#125;</code></p>
<h2 id="不含abc的单词"><a href="#不含abc的单词" class="headerlink" title="不含abc的单词"></a>不含abc的单词</h2><p><code>\b((?!abc)\w)+\b</code></p>
<h2 id="时间-小时-分钟-24小时制"><a href="#时间-小时-分钟-24小时制" class="headerlink" title="时间(小时:分钟, 24小时制)"></a>时间(小时:分钟, 24小时制)</h2><p>((1|0?)[0-9]|2[0-3]):([0-5][0-9])</p>
<h2 id="姓名"><a href="#姓名" class="headerlink" title="姓名"></a>姓名</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String regex=<span class="string">&quot;^([(?&lt;cc&gt;a-zA-Z\\u4e00-\\u9fa5)]+)|([a-zA-Z\\u4e00-\\u9fa5]+[a-zA-Z\\u4e00-\\u9fa5. _·]*)$&quot;</span>;</span><br><span class="line">String [] tem=&#123;</span><br><span class="line">  <span class="string">&quot;张大千&quot;</span>,</span><br><span class="line">    <span class="string">&quot;张.大千&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zhangdaqian&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zhang.daqian&quot;</span>,</span><br><span class="line">    <span class="string">&quot;张大千Quene&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zhang daqian&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zhang_daqian&quot;</span>,</span><br><span class="line">    <span class="string">&quot; 张大千&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.张大千&quot;</span>,</span><br><span class="line">    <span class="string">&quot;_张大千&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (String s : tem) &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> matches = Pattern.matches(regex, s);</span><br><span class="line">  System.out.println(s+<span class="string">&quot;:\t&quot;</span>+(matches?<span class="string">&quot;√&quot;</span>:<span class="string">&quot;×&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">张大千:	√</span><br><span class="line">张.大千:	√</span><br><span class="line">zhangdaqian:	√</span><br><span class="line">zhang.daqian:	√</span><br><span class="line">张大千Quene:	√</span><br><span class="line">zhang daqian:	√</span><br><span class="line">zhang_daqian:	√</span><br><span class="line"> 张大千:	×</span><br><span class="line">.张大千:	×</span><br><span class="line">_张大千:	×</span><br></pre></td></tr></table></figure>


<h1 id="Java中运用"><a href="#Java中运用" class="headerlink" title="Java中运用"></a>Java中运用</h1><p>java.util.regex 包主要由三个类所组成：Pattern、Matcher 和 PatternSyntaxException。</p>
<ul>
<li>Pattern 对象表示一个已编译的正则表达式。Pattern 类没有提供公共的构造方法。要构建一个模式，首先必须调用公共的静态 <code>compile</code> 方法，它将返回一个 Pattern 对象。这个方法接受正则表达式作为第一个参数。</li>
<li>Matcher 是一个靠着输入的字符串来解析这个模式和完成匹配操作的对象。与 Pattern 相似，Matcher 也没有定义公共的构造方法，需要通过调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</li>
<li>PatternSyntaxException 对象是一个未检查异常，指示了正则表达式中的一个语法错误。</li>
</ul>
<h2 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String message=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">// 大小写不敏感</span></span><br><span class="line">Pattern pattern = Pattern.compile(message, Pattern.CASE_INSENSITIVE );</span><br><span class="line"><span class="comment">// 大小写不敏感且使用Unix的行结束符</span></span><br><span class="line">pattern = Pattern.compile(<span class="string">&quot;[az]$&quot;</span>, Pattern.MULTILINE | Pattern.UNIX_LINES);</span><br><span class="line"><span class="comment">// 使用int变量， 启用Unicode折叠感知和大小写不敏感</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> flags = Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE;</span><br><span class="line">Pattern pattern = Pattern.compile(<span class="string">&quot;aa&quot;</span>, flags);</span><br></pre></td></tr></table></figure>
<p>** matches(String, CharSequence) 方法 **</p>
<p>Pattern 类定义了一个方便的 matches 方法，用于快速地检查模式是否表示给定的输入字符串。与使用所有的公共静态方法一样，应该通过它的类名来调用 matches 方法，诸如 Pattern.matches(“\d”,”1”);。这个例子中，方法返回 true，这是由于数字“1”匹配了正则表达式\d。</p>
<p>** split(String) 方法 **</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String REGEX = <span class="string">&quot;:&quot;</span>;</span><br><span class="line">String INPUT = <span class="string">&quot;one:two:three:four:five&quot;</span>;</span><br><span class="line">Pattern p = Pattern.compile(REGEX);</span><br><span class="line">String[] items = p.split(INPUT);</span><br><span class="line"><span class="keyword">for</span>(String s : items) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">REGEX=<span class="string">&quot;//d&quot;</span>;</span><br><span class="line">INPUT=<span class="string">&quot;one9two4three7four1five&quot;</span>;</span><br><span class="line">Pattern p = Pattern.compile(REGEX);</span><br><span class="line">String[] items = p.split(INPUT);</span><br><span class="line"><span class="keyword">for</span>(String s : items) &#123;</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果 one two three four five</span></span><br></pre></td></tr></table></figure>
<p>** public static String quote(String s)** ：返回指定字符串字面模式的字符串。此方法会产生一个字符串，能被用于构建一个与字符串 s 匹配的 Pattern，好像它是一个字面上的模式。输入序列中的元字符和转义序列将没有特殊的意义了。<br>**　　public String toString() ** ：返回这个模式的字符串表现形式。这是一个编译过的模式中的正则表达式。</p>
<p>** java.lang.String中等价的方法 **</p>
<p><code>java.lang.String</code> 通过模拟 <code>java.util.regex.Pattern</code> 行为的几个方法，也可以支持正则表达式。方便起见，下面主要摘录了出现在 API 关键的方法。</p>
<ul>
<li><code>public boolean matches(String regex)</code>：告知字符串是否匹配给定的正则表达式。调用 <code>str.matches(regex)</code>方法所产生的结果与作为表达式的 <code>Pattern.matches(regex, str)</code>的结果是完全一致。</li>
<li><code>public String[] split(String regex, int limit)</code>：依照匹配给定的正则表达式来拆分字符串。调用 <code>str.split(regex, n)</code>方法所产生的结果与作为表达式的 <code>Pattern.compile(regex).split(str, n)</code> 的结果完全一致。</li>
<li><code>public String[] split(String regex)</code>：依照匹配给定的正则表达式来拆分字符串。这个方法与调用两个参数的 split 方法是相同的，第一个参数使用给定的表达式，第二个参数限制为 0。在结果数组中不包括尾部的空字符串。</li>
<li>还有一个替换方法，把一个 <code>CharSequence</code> 替换成另外一个：<br><code>public String replace(CharSequence target,CharSequence replacement)</code>：将字符串中每一个匹配替换匹配字面目标序列的子字符串，替换成指定的字面替换序列。这个替换从字符串的开始处理直至结束，例如，把字符串“aaa”中的“aa”替换成“b”，结果是“ba”，而不是“ab”。</li>
</ul>
<h2 id="Matcher"><a href="#Matcher" class="headerlink" title="Matcher"></a>Matcher</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">索引方法</span><br><span class="line"></span><br><span class="line">　　索引方法（index methods）提供了一些正好在输入字符串中发现匹配的索引值：</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">start</span><span class="params">()</span>：返回之前匹配的开始索引。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> group)</span>：返回之前匹配操作中通过给定组所捕获序列的开始索引。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">end</span><span class="params">()</span>: 返回最后匹配字符后的偏移量。</span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">end</span><span class="params">(<span class="keyword">int</span> group)</span>: 返回之前匹配操作中通过给定组所捕获序列的最后字符之后的偏移量。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">研究方法</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　研究方法（study methods）回顾输入的字符串，并且返回一个用于指示是否找到模式的布尔值。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lookingAt</span><span class="params">()</span>: 尝试从区域开头处开始，输入序列与该模式匹配。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">()</span>: 尝试地寻找输入序列中，匹配模式的下一个子序列。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> start)</span>: 重置匹配器，然后从指定的索引处开始，尝试地寻找输入序列中，匹配模式的下一个子序列。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">()</span>: 尝试将整个区域与模式进行匹配</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">替换方法</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　替换方法（replacement methods）用于在输入的字符串中替换文本有用处的方法。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> Matcher <span class="title">appendReplacement</span><span class="params">(StringBuffer sb, String replacement)</span>：实现非结尾处的增加和替换操作。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> StringBuffer <span class="title">appendTail</span><span class="params">(StringBuffer sb)</span>：实现结尾处的增加和替换操作。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String replacement)</span>：使用给定的替换字符串来替换输入序列中匹配模式的每一个子序列。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> String <span class="title">replaceFirst</span><span class="params">(String replacement)</span>：使用给定的替换字符串来替换输入序列中匹配模式的第一个子序列。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">quoteReplacement</span><span class="params">(String s)</span>：返回指定字符串的字面值来替换字符串。这个方法会生成一个字符串，用作 Matcher 的 appendReplacement 方法中的字面值替换 s。所产生的字符串将与作为字面值序列的 s 中的字符序列匹配。斜线（\）和美元符号（$）将不再有特殊意义了。</span></span><br></pre></td></tr></table></figure>
<p>** 使用 start 和 end 方法 **</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String REGEX = <span class="string">&quot;\\bdog\\b&quot;</span>;</span><br><span class="line">String INPUT = <span class="string">&quot;dog dog dog doggie dogg&quot;</span>;</span><br><span class="line">Pattern p = Pattern.compile(REGEX);</span><br><span class="line">Matcher m = p.matcher(INPUT);        <span class="comment">// 获得匹配器对象</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line"> count++;</span><br><span class="line"> System.out.println(<span class="string">&quot;Match number &quot;</span> + count);</span><br><span class="line"> System.out.println(<span class="string">&quot;start(): &quot;</span> + m.start());</span><br><span class="line"> System.out.println(<span class="string">&quot;end(): &quot;</span> + m.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>** 使用 matches 和 lookingAt 方法 **</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String REGEX = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">String INPUT = <span class="string">&quot;fooooooooooooooooo&quot;</span>;</span><br><span class="line">Pattern pattern;</span><br><span class="line">Matcher matcher;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">pattern = Pattern.compile(REGEX);</span><br><span class="line">matcher = pattern.matcher(INPUT);</span><br><span class="line">System.out.println(<span class="string">&quot;Current REGEX is: &quot;</span> + REGEX);</span><br><span class="line">System.out.println(<span class="string">&quot;Current INPUT is: &quot;</span> + INPUT);</span><br><span class="line">System.out.println(<span class="string">&quot;lookingAt(): &quot;</span> + matcher.lookingAt());</span><br><span class="line">System.out.println(<span class="string">&quot;matches(): &quot;</span> + matcher.matches());</span><br></pre></td></tr></table></figure>
<p>** 使用 replaceFirst(String) 和 replaceAll(String) 方法 **</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String REGEX = <span class="string">&quot;dog&quot;</span>;</span><br><span class="line">String INPUT = <span class="string">&quot;The dog says meow. All dogs say meow.&quot;</span>;</span><br><span class="line">String REPLACE = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line"></span><br><span class="line">Pattern p = Pattern.compile(REGEX);</span><br><span class="line">Matcher m = p.matcher(INPUT);       <span class="comment">// 获得匹配器对象</span></span><br><span class="line">INPUT = m.replaceAll(REPLACE);</span><br><span class="line">System.out.println(INPUT);</span><br></pre></td></tr></table></figure>
<p>** 使用 appendReplacement(StringBuffer, String) 和<br>　     appendTail(StringBuffer) 方法 **</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String REGEX = <span class="string">&quot;a*b&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> String INPUT = <span class="string">&quot;aabfooaabfooabfoob&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> String REPLACE = <span class="string">&quot;-&quot;</span>;</span><br><span class="line">Pattern p = Pattern.compile(REGEX);</span><br><span class="line">Matcher m = p.matcher(INPUT);       <span class="comment">// 获得匹配器对象</span></span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">    m.appendReplacement(sb, REPLACE);</span><br><span class="line">&#125;</span><br><span class="line">m.appendTail(sb);</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure>

<p>** 在 java.lang.String 中等价的 Matcher 方法 **</p>
<p>为了使用方便，String 类看上去还不错地模仿了 Matcher 的两个方法：</p>
<p><code>public String replaceFirst(String regex, String replacement)</code>：使用给定的替换字符串替换该字符串中匹配了给定正则表达式的第一个子字符串。调用 str.replaceFirst(regex, repl)方法与使用 Pattern.compile(regex).matcher(str).replaceFirst(repl)产生的结果是完全相同的。</p>
<p><code>public String replaceAll(String regex, String replacement)</code>：使用给定的替换字符串替换该字符串中匹配了给定正则表达式的每一个子字符串。调用 str.replaceAll(regex, repl)方法与使用 Pattern.compile(regex).matcher(str).replaceAll(repl)产生的结果是完全相同的。</p>
<h2 id="PatternSyntaxException"><a href="#PatternSyntaxException" class="headerlink" title="PatternSyntaxException"></a>PatternSyntaxException</h2><p>PatternSyntaxException 是未检查异常，指示正则表达式模式中的语法错误。PatternSyntaxException 类提供了下面的一些方法，用于确定在什么地方发生了错误：</p>
<ul>
<li>public String getDescription()：获得错误描述。</li>
<li>public int getIndex()：获得错误索引。</li>
<li>public String getPattern()：获得字符串形式的错误正则表达式。</li>
<li>public String getMessage()：获得一个多行的字符串，包括语法错误和错误的索引、错误的正则表达式模式，以及模式内可视化的索引指示。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Pattern pattern = <span class="keyword">null</span>;</span><br><span class="line">Matcher matcher = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Console console = System.console();</span><br><span class="line"><span class="keyword">if</span> (console == <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;No console.&quot;</span>);</span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pattern = Pattern.compile(console.readLine(<span class="string">&quot;%nEnter your regex: &quot;</span>));</span><br><span class="line">        matcher = pattern.matcher(console.readLine(<span class="string">&quot;Enter input string to search: &quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PatternSyntaxException pse)&#123;</span><br><span class="line">        console.format(<span class="string">&quot;There is a problem with the regular expression!%n&quot;</span>);</span><br><span class="line">        console.format(<span class="string">&quot;The pattern in question is: %s%n&quot;</span>, pse.getPattern());</span><br><span class="line">        console.format(<span class="string">&quot;The description is: %s%n&quot;</span>, pse.getDescription());</span><br><span class="line">        console.format(<span class="string">&quot;The message is: %s%n&quot;</span>, pse.getMessage());</span><br><span class="line">        console.format(<span class="string">&quot;The index is: %s%n&quot;</span>, pse.getIndex());</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">        console.format(<span class="string">&quot;I found the text \&quot;%s\&quot; starting at &quot;</span> +</span><br><span class="line">                <span class="string">&quot;index %d and ending at index %d.%n&quot;</span>,</span><br><span class="line">                matcher.group(), matcher.start(), matcher.end()</span><br><span class="line">                );</span><br><span class="line">        found = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!found)&#123;</span><br><span class="line">        console.format(<span class="string">&quot;No match found.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Enter your regex: ?i)</span><br><span class="line">There is a problem with the regular expression!</span><br><span class="line">The pattern in question is: ?i)</span><br><span class="line">The description is: Dangling meta character &#39;?&#39;</span><br><span class="line">The message is: Dangling meta character &#39;?&#39; near index 0</span><br><span class="line">?i)</span><br><span class="line">^</span><br><span class="line">The index is: 0</span><br></pre></td></tr></table></figure>
<h2 id="问题与练习"><a href="#问题与练习" class="headerlink" title="问题与练习"></a>问题与练习</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">〖问题〗</span><br><span class="line"></span><br><span class="line">1. 在 java.util.regex 包中有哪三个公共的类？描述一下它们的作用。</span><br><span class="line">2. 考虑一下字符串“foo”，它的开始索引是多少？结束索引是多少？解释一下这些编号的意思。</span><br><span class="line">3. 普通字符和元字符有什么不同？各给出它们的一个例子。</span><br><span class="line">4. 如何把元字符表现成像普通字符那样？</span><br><span class="line">5. 附有方括号的字符集称为什么？它有什么作用？</span><br><span class="line">6. 这里是三个预定义的字符类：\d、\s和\w。描述一下它们各表示什么？并使用方括号的形式将它们重写。</span><br><span class="line">7. 对于\d、\s和\w，写出两个简单的表达式，匹配它们相反的字符集。</span><br><span class="line">8. 思考正则表达式(dog)&#123;3&#125;，识别一下其中的两个子表达式。这个表达式会匹配什么字符串？</span><br><span class="line"></span><br><span class="line">〖练习〗</span><br><span class="line"></span><br><span class="line">1. 使用反向引用写一个表达式，用于匹配一个人的名字，假设这个人的 first 名字与 last 名字是相同的。</span><br><span class="line"></span><br><span class="line">【问题答案】</span><br><span class="line"></span><br><span class="line">1. 问：在 java.util.regex 包中有哪三个公共的类？描述一下它们的作用。</span><br><span class="line">答：</span><br><span class="line"></span><br><span class="line">编译后的 Pattern 实例表示正则表达式。</span><br><span class="line">Matcher 实例是解析模式和靠着输入的字符串完成匹配操作的引擎。</span><br><span class="line">PatternSyntaxException 定义一个未检查异常，指示正则表达式中的语法错误。</span><br><span class="line"></span><br><span class="line">2. 问：考虑一下字符串“foo”，它的开始索引是多少？结束索引是多少？解释一下这些编号的意思。</span><br><span class="line"></span><br><span class="line">答：字符串中的每一个字符位于其自身的单元格中。索引位置在两个单元格之间。字符串“foo”开始于索引 0，结束于索引 3，即便是这些字符仅占用了 0、1 和 2 号单元格。</span><br><span class="line"></span><br><span class="line">3. 问：普通字符和元字符有什么不同？各给出它们的一个例子。</span><br><span class="line"></span><br><span class="line">答：正则表达式中的普通字符匹配其本身。元字符是一个特殊的字符，会影响被匹配模式的方式。字母A是一个普通字符。标点符号.是一个元字符，其匹配任意的单字符。</span><br><span class="line"></span><br><span class="line">4. 问：如何把元字符表现成像普通字符那样？答：有两种方法：</span><br><span class="line"></span><br><span class="line">在元字符前加上反斜线（\）；</span><br><span class="line">把元字符置于\Q（开始）\E（结束）的引用表达式中。</span><br><span class="line"></span><br><span class="line">5. 问：附有方括号的字符集称为什么？它有什么作用？</span><br><span class="line"></span><br><span class="line">答：是一个字符类。通过方括号间的表达式，匹配指定字符类中的任意一个字符。</span><br><span class="line"></span><br><span class="line">6. 问：这里是三个预定义的字符类：\d、\s和\w。描述一下它们各表示什么？并使用方括号的形式将它们重写。</span><br><span class="line"></span><br><span class="line">答：\d 匹配任意数字[0-9]</span><br><span class="line">　　\s 匹配任意空白字符[ \t\n-x0B\f\r ]</span><br><span class="line">　　\w 匹配任意单词字符[a-zA-Z_0-9]</span><br><span class="line"></span><br><span class="line">7. 问：对于\d、\s和\w，写出两个简单的表达式，匹配它们相反的字符集。</span><br><span class="line"></span><br><span class="line">答：\d \D [^\d]</span><br><span class="line">　　\s \S [^\s]</span><br><span class="line">　　\w \W [^\w]</span><br><span class="line"></span><br><span class="line">8. 问：思考正则表达式(dog)&#123;3&#125;，识别一下其中的两个子表达式。这个表达式会匹配什么字符串？</span><br><span class="line"></span><br><span class="line">答：表达式由捕获组(dog)和接着的贪婪量词&#123;3&#125;所组成。它匹配字符串“dogdogdog”。</span><br><span class="line"></span><br><span class="line">【练习答案】</span><br><span class="line"></span><br><span class="line">1. 练习：使用反向引用写一个表达式，用于匹配一个人的名字，假设这个人的 first 名字与 last 名字是相同的。</span><br><span class="line"></span><br><span class="line">解答：([A-Z][a-zA-Z]*)\s\1</span><br></pre></td></tr></table></figure>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>替换字符串中的字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String regularExpressionString=...;</span><br><span class="line">Matcher m = Pattern.compile(regularExpressionString, Pattern.CASE_INSENSITIVE).matcher(source); </span><br><span class="line">String result=m.replaceAll(newstring); </span><br><span class="line">System.out.println(<span class="string">&quot;使用正则表达式不区分大小写的替换结果&quot;</span>+result);</span><br><span class="line"></span><br><span class="line">Matcher m1 = Pattern.compile(regularExpressionString, Pattern.CANON_EQ).matcher(source); </span><br><span class="line">String result1=m1.replaceAll(newstring); </span><br><span class="line">System.out.println(<span class="string">&quot;使用正则表达式区分大小写的替换结果&quot;</span>+result1); </span><br></pre></td></tr></table></figure>
<hr>
<p>参考文献:</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://www.jb51.net/tools/zhengze.html">正则表达式30分钟入门教程</a></li>
<li><a href="www.zuidaima.com/share/1835085544524800.htm">java正则表达式语法详解及其使用代码实例</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/TimeApiInJava8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/TimeApiInJava8/" class="post-title-link" itemprop="url">Java8 Time API</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-04-12 11:28:00" itemprop="dateCreated datePublished" datetime="2016-04-12T11:28:00+08:00">2016-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-19 15:02:11" itemprop="dateModified" datetime="2021-04-19T15:02:11+08:00">2021-04-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.TemporalAdjusters;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeApiInJava8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dateToLocalDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">final</span> Instant instant = date.toInstant();</span><br><span class="line">        System.out.println(instant);</span><br><span class="line">        <span class="keyword">final</span> ZoneId defaultZoneId = ZoneId.systemDefault();</span><br><span class="line">        ZonedDateTime atZone = instant.atZone(defaultZoneId);</span><br><span class="line">        <span class="keyword">final</span> LocalDate localDate = atZone.toLocalDate();</span><br><span class="line">        System.out.println(localDate);</span><br><span class="line">        LocalDateTime localDateTime = atZone.toLocalDateTime();</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dateToLocalDateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        Instant instant = date.toInstant();</span><br><span class="line">        ZoneId systemDefault = ZoneId.systemDefault();</span><br><span class="line">        LocalDateTime.ofInstant(instant, systemDefault);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDateTime <span class="title">longToLocalDateTime</span><span class="params">(Long time)</span> </span>&#123;</span><br><span class="line">        ZoneId systemDefault = ZoneId.systemDefault();</span><br><span class="line">        Instant instant = Instant.ofEpochMilli(time);</span><br><span class="line">        LocalDateTime localDateTime = instant.atZone(systemDefault).toLocalDateTime();</span><br><span class="line">        <span class="keyword">return</span> localDateTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localDateNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LocalDate now = LocalDate.now();</span><br><span class="line">        System.out.println(<span class="string">&quot;localDateNow: &quot;</span> + now);</span><br><span class="line">        System.out.println(<span class="string">&quot;year: &quot;</span> + now.getYear());</span><br><span class="line">        System.out.println(<span class="string">&quot;month: &quot;</span> + now.getMonthValue());</span><br><span class="line">        System.out.println(<span class="string">&quot;day: &quot;</span> + now.getDayOfMonth());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localDateDiff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LocalDate nowLocalDate = LocalDate.of(<span class="number">2019</span>, <span class="number">12</span>, <span class="number">15</span>);</span><br><span class="line">        LocalDate birthLocalDate = LocalDate.of(<span class="number">1986</span>, <span class="number">2</span>, <span class="number">14</span>);</span><br><span class="line">        <span class="keyword">long</span> l = nowLocalDate.toEpochDay() - birthLocalDate.toEpochDay();</span><br><span class="line">        System.out.println(<span class="string">&quot;date diff: &quot;</span> + l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstLastDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LocalDate now = LocalDate.now();</span><br><span class="line">        LocalDate firstDayOfMonth = now.with(TemporalAdjusters.firstDayOfMonth());</span><br><span class="line">        LocalDate lastDayOfMonth = now.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">        LocalDate firstDayOfNextYear = now.with(TemporalAdjusters.firstDayOfNextYear());</span><br><span class="line">        LocalDate lastDayOfYear = now.with(TemporalAdjusters.lastDayOfYear());</span><br><span class="line">        LocalDate firstDayOfYear = now.with(TemporalAdjusters.firstDayOfYear());</span><br><span class="line">        System.out.println(<span class="string">&quot;firstDayOfMonth: &quot;</span> + firstDayOfMonth);</span><br><span class="line">        System.out.println(<span class="string">&quot;lastDayOfMonth: &quot;</span> + lastDayOfMonth);</span><br><span class="line">        System.out.println(<span class="string">&quot;firstDayOfNextYear: &quot;</span> + firstDayOfNextYear);</span><br><span class="line">        System.out.println(<span class="string">&quot;lastDayOfYear: &quot;</span> + lastDayOfYear);</span><br><span class="line">        System.out.println(<span class="string">&quot;firstDayOfYear: &quot;</span> + firstDayOfYear);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDayOfMonth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LocalDate localDate = LocalDate.of(<span class="number">2019</span>, <span class="number">2</span>, <span class="number">14</span>);</span><br><span class="line">        LocalDate lastDay = localDate.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">        <span class="keyword">int</span> dayOfMonth = lastDay.getDayOfMonth();</span><br><span class="line">        System.out.println(<span class="string">&quot;day of month: &quot;</span> + dayOfMonth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localDateCompareTo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LocalDate date1 = LocalDate.of(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">20</span>);</span><br><span class="line">        LocalDate date2 = LocalDate.of(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">21</span>);</span><br><span class="line">        System.out.println(date1 + <span class="string">&quot;.compareTo(&quot;</span> + date2 + <span class="string">&quot;): &quot;</span> + date1.compareTo(date2));</span><br><span class="line">        System.out.println(date1 + <span class="string">&quot;.compareTo(&quot;</span> + date1 + <span class="string">&quot;): &quot;</span> + date1.compareTo(date1));</span><br><span class="line">        System.out.println(date2 + <span class="string">&quot;.compareTo(&quot;</span> + date1 + <span class="string">&quot;): &quot;</span> + date2.compareTo(date1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextMonth</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        LocalDate localDate = LocalDate.of(<span class="number">2018</span>, <span class="number">2</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下一周的该星期</span></span><br><span class="line">        LocalDate nextWeeks1 = localDate.minusWeeks(-<span class="number">1</span>);</span><br><span class="line">        System.out.println(nextWeeks1);</span><br><span class="line">        <span class="comment">// 2018-02-19</span></span><br><span class="line">        LocalDate nextWeeks2 = localDate.plusWeeks(<span class="number">1</span>);</span><br><span class="line">        System.out.println(nextWeeks2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取下个月的这天</span></span><br><span class="line">        LocalDate nextMonth1 = localDate.minusMonths(-<span class="number">1</span>);</span><br><span class="line">        System.out.println(nextMonth1);</span><br><span class="line">        <span class="comment">// 2018-03-12</span></span><br><span class="line">        LocalDate nextMonth2 = localDate.plusMonths(<span class="number">1</span>);</span><br><span class="line">        System.out.println(nextMonth2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下个月的1号</span></span><br><span class="line">        LocalDate localDate3 = LocalDate.of(localDate.getYear(), localDate.getMonthValue() + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(localDate3);</span><br><span class="line">        <span class="comment">// 2018-03-01</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localDatePeriod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LocalDate date1 = LocalDate.of(<span class="number">2018</span>, <span class="number">10</span>, <span class="number">9</span>);</span><br><span class="line">        LocalDate date2 = LocalDate.of(<span class="number">2019</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        Period period = Period.between(date1, date2);</span><br><span class="line">        <span class="keyword">int</span> years = period.getYears();</span><br><span class="line">        <span class="keyword">int</span> months = period.getMonths();</span><br><span class="line">        <span class="keyword">int</span> days = period.getDays();</span><br><span class="line">        System.out.println(<span class="string">&quot;years:&quot;</span> + years + <span class="string">&quot;, months:&quot;</span> + months + <span class="string">&quot;, days:&quot;</span> + days);</span><br><span class="line">        <span class="comment">// years:0, months:5, days:23</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ofEpochSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Instant now = Instant.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line">        <span class="comment">// 2019-03-13T06:41:32.865Z</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去除毫秒</span></span><br><span class="line">        <span class="keyword">long</span> l = now.toEpochMilli() / <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 通过秒构建Instant对象</span></span><br><span class="line">        Instant instant = Instant.ofEpochSecond(l);</span><br><span class="line">        System.out.println(instant);</span><br><span class="line">        <span class="comment">// 2019-03-13T06:41:32Z</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stringToLocalDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String string = <span class="string">&quot;2018-12-07&quot;</span>;</span><br><span class="line">        LocalDate parse = LocalDate.parse(string);</span><br><span class="line">        System.out.println(parse.toString());</span><br><span class="line">        <span class="comment">// 结果是2018-12-07</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localDateTimeToZonedDateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String string = <span class="string">&quot;2018-12-07T09:33:38&quot;</span>;</span><br><span class="line">        LocalDateTime parse = LocalDateTime.parse(string);</span><br><span class="line">        ZonedDateTime z1 = ZonedDateTime.of(parse, ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">        System.out.println(z1.toString());</span><br><span class="line">        <span class="comment">// 2018-12-07T09:33:38+08:00[Asia/Shanghai]</span></span><br><span class="line"></span><br><span class="line">        ZonedDateTime z2 = ZonedDateTime.of(parse, ZoneId.of(<span class="string">&quot;Z&quot;</span>));</span><br><span class="line">        System.out.println(z2.toString());</span><br><span class="line">        <span class="comment">// 2018-12-07T09:33:38Z</span></span><br><span class="line"></span><br><span class="line">        ZonedDateTime z3 = ZonedDateTime.of(parse, ZoneId.of(<span class="string">&quot;UTC&quot;</span>));</span><br><span class="line">        System.out.println(z3.toString());</span><br><span class="line">        <span class="comment">// 2018-12-07T09:33:38Z[UTC]</span></span><br><span class="line"></span><br><span class="line">        ZonedDateTime z4 = ZonedDateTime.of(parse, ZoneId.of(<span class="string">&quot;UTC+08:00&quot;</span>));</span><br><span class="line">        System.out.println(z4.toString());</span><br><span class="line">        <span class="comment">// 2018-12-07T09:33:38+08:00[UTC+08:00]</span></span><br><span class="line"></span><br><span class="line">        ZonedDateTime z5 = ZonedDateTime.of(parse, ZoneId.of(<span class="string">&quot;+08:00&quot;</span>));</span><br><span class="line">        System.out.println(z5.toString());</span><br><span class="line">        <span class="comment">// 2018-12-07T09:33:38+08:00</span></span><br><span class="line"></span><br><span class="line">        ZonedDateTime z6 = ZonedDateTime.of(parse, ZoneId.of(<span class="string">&quot;+00:00&quot;</span>));</span><br><span class="line">        System.out.println(z6.toString());</span><br><span class="line">        <span class="comment">// 2018-12-07T09:33:38Z</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">        TimeApiInJava8 timeApi = <span class="keyword">new</span> TimeApiInJava8();</span><br><span class="line">        timeApi.dateToLocalDate();</span><br><span class="line">        timeApi.dateToLocalDateTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;long to localDateTime: &quot;</span> + timeApi.longToLocalDateTime(System.currentTimeMillis()));</span><br><span class="line">        timeApi.localDateNow();</span><br><span class="line">        timeApi.localDateDiff();</span><br><span class="line">        timeApi.firstLastDay();</span><br><span class="line">        timeApi.getDayOfMonth();</span><br><span class="line">        timeApi.localDateCompareTo();</span><br><span class="line">        timeApi.nextMonth();</span><br><span class="line">        timeApi.localDatePeriod();</span><br><span class="line">        timeApi.ofEpochSecond();</span><br><span class="line">        timeApi.stringToLocalDate();</span><br><span class="line">        timeApi.localDateTimeToZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/Throwable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/Throwable/" class="post-title-link" itemprop="url">Java异常</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-04-12 11:28:00" itemprop="dateCreated datePublished" datetime="2016-04-12T11:28:00+08:00">2016-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-19 15:02:11" itemprop="dateModified" datetime="2021-04-19T15:02:11+08:00">2021-04-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>请参考<a target="_blank" rel="noopener" href="http://blog.csdn.net/hguisu/article/details/6155636" title="深入理解java异常处理机制">深入理解java异常处理机制</a></p>
<p>异常是指当程序中某些地方出错时创建的一种特殊的运行时错误对象。Java创建异常对象后，就发送给Java程序，即抛出异常(throwing an exception)。程序捕捉到这个异常后，可以编写相应的异常处理代码进行处理。使用异常处理可以使得程序更加健壮，有助于调试和后期维护。</p>
<h1 id="Throwable的继承体系"><a href="#Throwable的继承体系" class="headerlink" title="Throwable的继承体系"></a>Throwable的继承体系</h1><p>Throwable类派生了两个类：Exception类和Error类，其中Error类系统保留，而Exception类供应用程序使用，它下面又派生出几个具体的异常类，都对应着一项具体的运行错误</p>
<p><img src="/images/java/Throwable/inherit.png"></p>
<h1 id="异常的工作原理"><a href="#异常的工作原理" class="headerlink" title="异常的工作原理"></a>异常的工作原理</h1><p>抛出异常：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。</p>
<p>捕获异常：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</p>
<h1 id="常见的受检异常"><a href="#常见的受检异常" class="headerlink" title="常见的受检异常"></a>常见的受检异常</h1><p> 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p>
<p>IOException：操作输入流和输出流时可能出现的异常。</p>
<p>EOFException   文件已结束异常</p>
<p>FileNotFoundException   文件未找到异常</p>
<h1 id="常见的非受检异常"><a href="#常见的非受检异常" class="headerlink" title="常见的非受检异常"></a>常见的非受检异常</h1><p>运行时异常：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
<p>ArithmeticException</p>
<p>ArrayIndexOutOfBoundsException<br>1、 java.lang.ArrayIndexOutOfBoundsException<br> 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。<br> 2、java.lang.ArithmeticException<br> 算术条件异常。譬如：整数除零等。<br> 3、java.lang.NullPointerException<br> 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等<br> 4、java.lang.ClassNotFoundException<br> 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</p>
<p>5、java.lang.NegativeArraySizeException  数组长度为负异常</p>
<p>6、java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常</p>
<p>7、java.lang.SecurityException 安全性异常</p>
<p>8、java.lang.IllegalArgumentException 非法参数异常</p>
<p>综合实例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">testEx</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> ret = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ret = testEx1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;testEx, catch exception&quot;</span>);</span><br><span class="line">            ret = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;testEx, finally; return value=&quot;</span> + ret);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">testEx1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> ret = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ret = testEx2();</span><br><span class="line">            <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;testEx1, at the end of try&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;testEx1, catch exception&quot;</span>);</span><br><span class="line">            ret = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;testEx1, finally; return value=&quot;</span> + ret);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">testEx2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> ret = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">12</span>;</span><br><span class="line">            <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &gt;= -<span class="number">2</span>; i--) &#123;</span><br><span class="line">                c = b / i;</span><br><span class="line">                System.out.println(<span class="string">&quot;i=&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;testEx2, catch exception&quot;</span>);</span><br><span class="line">            ret = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;testEx2, finally; return value=&quot;</span> + ret);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestException testException1 = <span class="keyword">new</span> TestException();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testException1.testEx();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i&#x3D;2</span><br><span class="line">i&#x3D;1</span><br><span class="line">testEx2, catch exception</span><br><span class="line">testEx2, finally; return value&#x3D;false</span><br><span class="line">testEx1, finally; return value&#x3D;false</span><br><span class="line">testEx, finally; return value&#x3D;false</span><br></pre></td></tr></table></figure>
<hr>
<p>[参考文献]:</p>
<ol>
<li>Think in Java</li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/hguisu/article/details/6155636" title="深入理解java异常处理机制">深入理解java异常处理机制</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/io/java-XML-JSON/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/io/java-XML-JSON/" class="post-title-link" itemprop="url">Java IO之XML与JSON解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-04-08 11:28:00" itemprop="dateCreated datePublished" datetime="2016-04-08T11:28:00+08:00">2016-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-19 15:02:11" itemprop="dateModified" datetime="2021-04-19T15:02:11+08:00">2021-04-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="/Java/advanced-engineer-outline/">&lt;&lt; Java高级软件工程师知识结构</a></p>
<ol>
<li>掌握InputStream、OutputStream、Reader、Writer的继承体系。</li>
<li>掌握字节流(FileInputStream、DataInputStream、BufferedInputStream、FileOutputSteam、DataOutputStream、BufferedOutputStream)和 字符流(BufferedReader、InputStreamReader、FileReader、BufferedWriter、OutputStreamWriter、PrintWriter、FileWriter)，并熟练运用。</li>
<li>掌握NIO实现原理及使用方法。</li>
</ol>
<p>Java IO包括:</p>
<ul>
<li><a href="/Java/io/IO-Model/">IO Model</a></li>
<li><a href="/Java/io/BIO/">Java BIO</a></li>
<li><a href="/Java/io/NIO/">Java NIO</a></li>
<li><a href="/Java/io/AIO/">Java AIO</a></li>
<li><a href="/Java/io/java-zip/">Java压缩</a></li>
<li><a href="/Java/io/object-serialization/">Java序列化</a></li>
<li><a href="/Java/io/java-XML-JSON/">Java XML与JSON</a></li>
</ul>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JSON: JavaScript对象表示法(JavaScript Object Notation)<br>是存储和交换文本信息的语法， 类似于XML，它采用键值对的形式来组织，易于阅读和编写，同时也已于机器解析和生成。JSON是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来执行。</p>
<h2 id="JSON与XML比较"><a href="#JSON与XML比较" class="headerlink" title="JSON与XML比较"></a>JSON与XML比较</h2><ol>
<li>json长度更小</li>
<li>json读写速度更快</li>
<li>可以通过JavaScript内建的方法直接解析，转换成JavaScript对象，非常方便 。</li>
</ol>
<h2 id="JSON格式"><a href="#JSON格式" class="headerlink" title="JSON格式"></a>JSON格式</h2><p><img src="/images/java/io/jsonFormat.png"></p>
<h2 id="JavaScript中的解析"><a href="#JavaScript中的解析" class="headerlink" title="JavaScript中的解析"></a>JavaScript中的解析</h2><p>要两种方式：<code>eval</code>和<code>JSON.parse</code></p>
<p>在代码中使用eval时和危险的！ 特别是用它第三方的JSON数据（可能包含恶意代码）时， 尽可能使用 <code>JSON.parse()</code>方法解析字符串本身， 该方法还可以捕捉JSON中的语法错误。</p>
<p>例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsondata = <span class="string">&#x27;&#123;&quot;staff&quot;:[&#123;&quot;name&quot;:&quot;洪七&quot;,&quot;age&quot;:70&#125;,&#123;&quot;name&quot;:&quot;郭靖&quot;,&quot;age&quot;:35&#125;,&#123;&quot;name&quot;:&quot;黄蓉&quot;,&quot;age&quot;:30&#125;]&#125;&#x27;</span>；</span><br><span class="line"><span class="keyword">var</span> jsonobj= <span class="built_in">eval</span>(<span class="string">&#x27;(&#x27;</span>+jsondata+<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">alert(jsonobj.staff[<span class="number">0</span>].name);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsondata = <span class="string">&#x27;&#123;&quot;staff&quot;:[&#123;&quot;name&quot;:&quot;洪七&quot;,&quot;age&quot;:70&#125;,&#123;&quot;name&quot;:&quot;郭靖&quot;,&quot;age&quot;:35&#125;,&#123;&quot;name&quot;:&quot;黄蓉&quot;,&quot;age&quot;:30&#125;]&#125;&#x27;</span>；</span><br><span class="line"><span class="keyword">var</span> jsonobj=<span class="built_in">JSON</span>.parse(jsondata);</span><br><span class="line">alert(jsonobj.staff[<span class="number">0</span>].name);</span><br></pre></td></tr></table></figure>
<hr>
<p>[参考文献]:</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/database/concept/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/database/concept/" class="post-title-link" itemprop="url">数据库设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-04-07 00:00:00" itemprop="dateCreated datePublished" datetime="2016-04-07T00:00:00+08:00">2016-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-19 15:02:11" itemprop="dateModified" datetime="2021-04-19T15:02:11+08:00">2021-04-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DataBase/" itemprop="url" rel="index"><span itemprop="name">DataBase</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>SQL(Structured Query Language, 结构化查询语言)可以分为DDL(data definition language,数据定义语言) TPL(事务处理语言)  DML(data manipulation language, 数据操作语言)和DCL(data control language, 数据控制语言)。</p>
<p>其主要的语句有:</p>
<ol>
<li>DDL(data definition language,数据定义语言) 创建、删除和更改数据库对象<ol>
<li>创建 删除 修改数据库<ol>
<li> creat database</li>
<li> drop database</li>
<li> alter database</li>
</ol>
</li>
<li>创建 删除 修改数据表<ol>
<li> create table</li>
<li> alter table</li>
<li> drop table</li>
</ol>
</li>
<li>创建 删除索引<ol>
<li> create index</li>
<li> drop index</li>
</ol>
</li>
</ol>
</li>
<li>DML(data manipulation language, 数据操作语言) 查询和更新指令都成了SQL的DML部分<ol>
<li>select 从表或试图中检索数据</li>
<li>update 更改表中的数据</li>
<li>delete 从表中删除数据行</li>
<li>insert into  添加数据行到表</li>
</ol>
</li>
<li>DCL(data control language, 数据控制语言)<ol>
<li>用于规定数据库用户的各种权限<ol>
<li>grant 将权限或角色授予用户或其他角色</li>
<li>revoke 从用户或数据库角色回收权限</li>
</ol>
</li>
<li>数据库事务控制<ol>
<li>commit 把当前事务所有的更改写入磁盘</li>
<li>rollback 作废上次提交依赖的所有的更改</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><p>数据库设计可以分为需求分析、逻辑分析、物理设计和维护优化四个阶段。</p>
<p>数据库的基本名词：</p>
<ul>
<li>关系：一个关系对应通常所说的一张表</li>
<li>元组：表中的一行即为一个元组</li>
<li>属性：表中的一列即为一个属性；每一个属性都有一个名称，称为属性名。</li>
<li>候选码：表中的某个属性组，它可以唯一确定一个元组。</li>
<li>主码：一个关系有多个候选码，确定其中一个为主码</li>
<li>域：属性的取值范围</li>
<li>分量：元组中的一个属性值。</li>
</ul>
<h2 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h2><p>ER图中各符号的含义：</p>
<p><img src="/images/j2ee/database/ER-Components.png"></p>
<p>在这里以订单、用户、商品、供应商以及购物车的关系构建ER图</p>
<p><img src="/images/j2ee/database/ER-sample01.png"></p>
<p>矩形框表示实体, 即图中的订单、用户、商品、供应商以及购物车。<br>椭圆表示视图的属性， 如用户的用户ID、用户名、密码、昵称和身份证。椭圆中的文本表示属性的名称，文本带下划线表示为主键。<br>线段将属性与实体集相互连接，表示属性是实体的。将实体间相互连接，表示实体间的对应关系。<br>线段的两端标示1或M，表示是一对一、一对多或者多对多的关系。</p>
<h2 id="数据操作异常与数据冗余"><a href="#数据操作异常与数据冗余" class="headerlink" title="数据操作异常与数据冗余"></a>数据操作异常与数据冗余</h2><p>数据操作异常是判断数据库设计是否合理的依据。</p>
<ul>
<li>插入异常： 如果某实体随着另一个实体的存在而存在， 即缺少某个实体时无法表示这个实体，那么这个表就存在插入异常。</li>
<li>更新异常： 如果更改表所对应的某个实体实例的单独属性时，需要将多行更新，那么就说这个表存在更新异常。</li>
<li>删除异常： 如果删除表的某一行来反应某实体实例。失效时导致另一个不同实体实例信息丢失，那么这个表存在删除异常。</li>
</ul>
<p>数据冗余：<br>是指相同的数据在多个地方存在， 或者说表中的某个列可以有其他列计算得到，这样就说表中存在着数据冗余。</p>
<h2 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h2><h3 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a>第一范式(1NF)</h3><p>字段具有原子性,不可再分。所有关系型数据库系统都满足第一范式。<br>数据库表中的字段都是单一属性的，不可再分。例如，姓名字段，其中的姓和名必须作为一个整体，无法区分哪部分是姓，哪部分是名，如果要区分出姓和名，必须设计成两个独立的字段。</p>
<p>这个单一属性是由基本的数据类型所构成的， 如整数，浮点数，字符串等；<br>换句话说： <strong>第一范式要求数据库中的表都是二维表</strong></p>
<p>如下表中</p>
<p><img src="/images/j2ee/database/1NF-sample01.png"></p>
<p>第二个表格中， 用户信息列又包含<code>姓名</code> <code>电话</code>两个列。 不符合第一范式的要求</p>
<h3 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式(2NF)"></a>第二范式(2NF)</h3><p>满足第二范式（2NF）必须先满足第一范式（1NF）。<br>要求数据库表中的每个实例或行必须可以被惟一地区分。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键。<br>第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。</p>
<p><img src="/images/j2ee/database/2NF-sample01.png"></p>
<p>由于供应商和商品之间是多对多的关系<br>所以只有使用<code>商品名称</code>和<code>供应商名称</code>才可以唯一表示出一件商品。<br>也就是商品名称和供应商名称是一组组合关键字。<br>上表的依赖关系为:</p>
<ul>
<li>(商品名称)-&gt;(价格、描述、重量、商品有效期)</li>
<li>(供应商名称)-&gt;(供应商电话)</li>
</ul>
<p>存在的问题：</p>
<ol>
<li>插入异常</li>
<li>删除异常</li>
<li>更新异常</li>
<li>数据冗余</li>
</ol>
<h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p>必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。<br>所以第三范式具有如下特征：<br>    1. 每一列只有一个值<br>    2. 每一行都能区分。<br>    3. 每一个表都不包含其他表已经包含的非主关键字信息。</p>
<p>例如，帖子表中只能出现发帖人的id，而不能出现发帖人的id，还同时出现发帖人姓名，否则，只要出现同一发帖人id的所有记录，它们中的姓名部分都必须严格保持一致，这就是数据冗余。</p>
<p>如果数据表中不存在非关键字段对任一候选字段的传递函数依赖则符合第三范式。</p>
<h3 id="BC范式-Boyce-Codd范式"><a href="#BC范式-Boyce-Codd范式" class="headerlink" title="BC范式(Boyce.Codd范式)"></a>BC范式(Boyce.Codd范式)</h3><p>在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合BC范式。<br>也就是说如果是符合关键字，则符合关键字之间也不能存在函数依赖关系。</p>
<p><img src="/images/j2ee/database/BCNF-sample01.png"></p>
<p>上表中存在的下列关系不符合BCNF:</p>
<ul>
<li>(供应商)-&gt;(供应商联系人)</li>
<li>(供应商联系人)-&gt;(供应商)</li>
<li>并且存在数据存在异常及数据冗余</li>
</ul>
<h2 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h2><p>锁的类型有三种：</p>
<ul>
<li>共享（S)锁：多个事务可封锁一个共享页；任何事务都不能修改该页； 通常是该页被读取完毕，S锁立即被释放。 </li>
<li>排它（X)锁：仅允许一个事务封锁此页；其他任何事务必须等到X锁被释放才能对该页进行访问；X锁一直到事务结束才能被释放。 </li>
<li>更新（U)锁：用来预定要对此页施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的页将要被更新时，则升级为X锁；U锁一直到事务结束时才能被释放。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/zhouqianhua/archive/2011/04/15/2017049.html">SQLServer中的数据库锁</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/14/2770445.html">MySQL中的数据库锁</a></p>
<p><a target="_blank" rel="noopener" href="http://tec.5lulu.com/detail/104d2n2wtryip85cd.html">数据库锁原理</a></p>
<h2 id="TODOs"><a href="#TODOs" class="headerlink" title="TODOs"></a>TODOs</h2><ol>
<li>事务 各个层次的操作</li>
<li>键 唯一键 主键 外键</li>
<li>MySQL集群</li>
<li>事务隔离级别</li>
</ol>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/io/NIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/io/NIO/" class="post-title-link" itemprop="url">Java NIO(占坑)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-04-04 11:28:00" itemprop="dateCreated datePublished" datetime="2016-04-04T11:28:00+08:00">2016-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-19 15:02:11" itemprop="dateModified" datetime="2021-04-19T15:02:11+08:00">2021-04-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="/Java/advanced-engineer-outline/">&lt;&lt; Java高级软件工程师知识结构</a></p>
<ol>
<li>掌握InputStream、OutputStream、Reader、Writer的继承体系. </li>
<li>掌握字节流(FileInputStream、DataInputStream、BufferedInputStream、FileOutputSteam、DataOutputStream、BufferedOutputStream)和 字符流(BufferedReader、InputStreamReader、FileReader、BufferedWriter、OutputStreamWriter、PrintWriter、FileWriter), 并熟练运用. </li>
<li>掌握NIO实现原理及使用方法. </li>
</ol>
<p>Java IO包括:</p>
<ul>
<li><a href="/Java/io/IO-Model/">IO Model</a></li>
<li><a href="/Java/io/BIO/">Java BIO</a></li>
<li><a href="/Java/io/NIO/">Java NIO</a></li>
<li><a href="/Java/io/AIO/">Java AIO</a></li>
<li><a href="/Java/io/java-zip/">Java压缩</a></li>
<li><a href="/Java/io/object-serialization/">Java序列化</a></li>
<li><a href="/Java/io/java-XML-JSON/">Java XML与JSON</a></li>
</ul>
<pre><code>感谢`蔡毅`同学对NIO与AIO的深入研究</code></pre>
<p>文后的参考文献 <a target="_blank" rel="noopener" href="http://blog.csdn.net/kunluntaishan/article/details/53536386"> <strong>Java NIO浅析</strong> </a> 需要重点关注</p>
<p><a target="_blank" rel="noopener" href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">Doug Lea《scalable IO in Java》</a><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/fxjwind/p/3363329.html">中文解读</a></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>新的输入/输出(NIO)库是在JDK 1.4中引入的. NIO弥补了原来的I/O的不足, 它在标准java中提供了高速的、面向块的I/O.<br>   NIO与 <a href="/Java/io/BIO/">BIO</a> 最重要的区别是数据打包和传输的方式的不同, 原来的 I/O 以流 的方式处理数据, 而 NIO 以块 的方式处理数据.  <br>   面向流的I/O系统一次一个字节地处理数据. 一个输入流产生一个字节的数据, 一个输出流消费一个字节的数据. 为流式数据创建过滤器非常容易. 链接几个过滤器, 以便每个过滤器只负责单个复杂处理机制的一部分, 这样也是相对简单的. 不利的一面是, 面向流的I/O通常相当慢.  <br>   NIO与 <a href="/Java/io/BIO/">BIO</a> 有同样的作用和目的, 但是它使用块I/O的处理方式. 每一个操作都在一步中产生或者消费一个数据块. 按块处理数据比按(流式的)字节处理数据要快得多. 但是面向块的I/O缺少一些面向流的I/O所具有的优雅性和简单性. </p>
<p> </p>
<p>从一个例子开始 <br>     下面我们从一个简单的使用IO和NIO读取一个文件中的内容为例, 来进入NIO的学习之旅.<br>     使用IO来读取指定文件中的前1024字节并打印出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 使用IO读取指定文件的前1024个字节的内容.  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> file 指定文件名称.  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> java.io.IOException IO异常.  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ioRead</span><span class="params">(String file)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line"> FileInputStream in = <span class="keyword">new</span> FileInputStream(file);  </span><br><span class="line"> <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];  </span><br><span class="line"> in.read(b);  </span><br><span class="line"> System.out.println(<span class="keyword">new</span> String(b));  </span><br><span class="line">&#125;  </span><br><span class="line">​</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 使用NIO读取指定文件的前1024个字节的内容.  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> file 指定文件名称.  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span> java.io.IOException IO异常.  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nioRead</span><span class="params">(String file)</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line"> FileInputStream in = <span class="keyword">new</span> FileInputStream(file);  </span><br><span class="line"> FileChannel channel = in.getChannel();  </span><br><span class="line"> ​</span><br><span class="line"> ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);  </span><br><span class="line"> channel.read(buffer);  </span><br><span class="line"> <span class="keyword">byte</span>[] b = buffer.array();  </span><br><span class="line"> System.out.println(<span class="keyword">new</span> String(b));  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>从上面的例子中可以看出, NIO以 <code>通道Channel</code> 和 <code>缓冲区Buffer</code> 为基础来实现面向块的IO数据处理. 下面将讨论并学习NIO 库的核心概念以及从高级的特性到底层编程细节的几乎所有方面. </p>
<h1 id="核心概念：通道和缓冲区"><a href="#核心概念：通道和缓冲区" class="headerlink" title="核心概念：通道和缓冲区"></a>核心概念：通道和缓冲区</h1><p>通道和缓冲区是NIO中的核心对象, 几乎在每一个I/O操作中都要使用它们</p>
<ul>
<li>通道Channel 是对原I/O包中的流的模拟. 到任何目的地(或来自任何地方)的所有数据都必须通过一个Channel对象. </li>
<li>缓冲区Buffer 实质上是一个容器对象. 发送给一个通道的所有对象都必须首先放到缓冲区中；同样地, 从通道中读取的任何数据都要读到缓冲区中</li>
</ul>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>Buffer是一个容器对象, 它包含一些要写入或者刚读出的数据. 在NIO中加入Buffer对象, 体现了新库与原I/O的一个重要区别. 在面向流的I/O中, 您将数据直接写入或者将数据直接读到Stream对象中；<br>在NIO库中, 所有数据都是用缓冲区处理的. 在读取数据时, 它是直接读到缓冲区中的. 在写入数据时, 它是写入到缓冲区中的. 任何时候访问NIO中的数据, 您都是将它放到缓冲区中.  <br>缓冲区实质上是一个数组. 通常它是一个字节数组, 但是也可以使用其他种类的数组. 但是一个缓冲区不仅仅是一个数组. 缓冲区提供了对数据的结构化访问, 而且还可以跟踪系统的读/写进程.  </p>
<p>最常用的缓冲区类型是 <code>ByteBuffer</code> .  一个ByteBuffer可以在其底层字节数组上进行get/set操作(即字节的获取和设置).  <br>ByteBuffer不是NIO中唯一的缓冲区类型. 事实上, 对于每一种基本Java类型都有一种缓冲区类型：</p>
<ul>
<li><code>ByteBuffer</code></li>
<li><code>CharBuffer</code></li>
<li><code>ShortBuffer</code></li>
<li><code>IntBuffer</code></li>
<li><code>LongBuffer</code></li>
<li><code>FloatBuffer</code></li>
<li><code>DoubleBuffer</code></li>
</ul>
<p>每一个Buffer类都是Buffer接口的一个实例.  除了ByteBuffer,  每一个Buffer类都有完全一样的操作, 只是它们所处理的数据类型不一样. 因为大多数标准I/O操作都使用 ByteBuffer , 所以它具有所有共享的缓冲区操作以及一些特有的操作. </p>
<p>下面的例子使用类型化的缓冲区<code>FloatBuffer</code>的一个应用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个容量为10的新的 float 缓冲区  </span></span><br><span class="line">FloatBuffer buffer = FloatBuffer.allocate(<span class="number">10</span>);  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i++) &#123;  </span><br><span class="line">  <span class="keyword">float</span> f = (<span class="keyword">float</span>) Math.sin((((<span class="keyword">float</span>) i) / <span class="number">10</span>) * (<span class="number">2</span> * Math.PI));  </span><br><span class="line">  buffer.put(f);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 反转此缓冲区  </span></span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="comment">// 告知在当前位置和限制之间是否有元素  </span></span><br><span class="line"><span class="keyword">while</span> (buffer.hasRemaining()) &#123;  </span><br><span class="line">  <span class="keyword">float</span> f = buffer.get();  </span><br><span class="line">  System.out.println(f);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h2><p><code>Channel</code>是对原I/O包中的流的模拟, 可以通过它读取和写入数据. 通道就像流, 所有数据都通过<code>Buffer</code>对象来处理. 您永远不会将字节直接写入通道中, 相反, 是将数据写入包含一个或者多个字节的缓冲区. 同样, 您不会直接从通道中读取字节, 而是将数据从通道 读入缓冲区, 再从缓冲区获取这个字节</p>
<p>**通道与流的不同之处在于通道是双向的. ** 而流只是在一个方向上移动(一个流必须是InputStream或者OutputStream的子类),  而通道可以用于读、写或者同时用于读写. 因为它们是双向的, 所以通道可以比流更好地反映底层操作系统的真实情况. 特别是在UNIX模型中, 底层操作系统通道是双向的. </p>
<h1 id="从理论到实践：NIO中的读和写"><a href="#从理论到实践：NIO中的读和写" class="headerlink" title="从理论到实践：NIO中的读和写"></a>从理论到实践：NIO中的读和写</h1><p>读和写是I/O的基本过程. 从一个通道中读取很简单：只需创建一个缓冲区, 然后让通道将数据读到这个缓冲区中. 写入也相当简单：创建一个缓冲区, 用数据填充它, 然后让通道用这些数据来执行写入操作.  </p>
<h2 id="从文件中读取"><a href="#从文件中读取" class="headerlink" title="从文件中读取"></a>从文件中读取</h2><p>首先从FileInputStream获取一个FileChannel对象, 然后使用这个通道来读取数据.  </p>
<p>在NIO系统中, 任何时候执行一个读操作, 您都是从通道中读取, 但是您不是直接从通道读取. 因为所有数据最终都驻留在缓冲区中, 所以您是从通道读到缓冲区中</p>
<p>   因此读取文件涉及三个步骤：</p>
<p>  (1) 从 FileInputStream 获取 Channel<br>  (2) 创建 Buffer<br>  (3) 将数据从 Channel 读到 Buffer 中</p>
<p>现在, 让我们看一下这个过程. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一步是获取通道. 从 FileInputStream 获取通道：</span></span><br><span class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream( <span class="string">&quot;readandshow.txt&quot;</span> );  </span><br><span class="line">FileChannel fc = fin.getChannel();  </span><br><span class="line"><span class="comment">// 下一步是创建缓冲区：</span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );  </span><br><span class="line"><span class="comment">// 最后, 需要将数据从通道读到缓冲区中：</span></span><br><span class="line">fc.read( buffer );  </span><br></pre></td></tr></table></figure>
<p>不需要告诉通道要读多少数据到缓冲区中. 每一个缓冲区都有复杂的内部统计机制, 它会跟踪已经读了多少数据以及还有多少空间可以容纳更多的数据. </p>
<h2 id="写入文件："><a href="#写入文件：" class="headerlink" title="写入文件："></a>写入文件：</h2><p>在 NIO 中写入文件类似于从文件中读取. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先从 FileOutputStream 获取一个通道：</span></span><br><span class="line">FileOutputStream fout = <span class="keyword">new</span> FileOutputStream( <span class="string">&quot;writesomebytes.txt&quot;</span> );  </span><br><span class="line">FileChannel fc = fout.getChannel();  </span><br><span class="line"><span class="comment">// 下一步是创建一个缓冲区并在其中放入一些数据, 这里, 用message来表示一个持有数据的数组. </span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; message.length; ++i) &#123;  </span><br><span class="line">  buffer.put( message[i] );  </span><br><span class="line">&#125;  </span><br><span class="line">buffer.flip();  </span><br><span class="line"> <span class="comment">// 最后一步是从缓冲区写入通道中：</span></span><br><span class="line">fc.write( buffer );  </span><br></pre></td></tr></table></figure>
<h2 id="读写结合"><a href="#读写结合" class="headerlink" title="读写结合"></a>读写结合</h2><p>将一个文件的所有内容拷贝到另一个文件中. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 将一个文件的所有内容拷贝到另一个文件中. ​</span></span><br><span class="line"><span class="comment">* 执行三个基本操作： </span></span><br><span class="line"><span class="comment">* 首先创建一个 Buffer, 然后从源文件中将数据读到这个缓冲区中, </span></span><br><span class="line"><span class="comment">* 然后将缓冲区写入目标文件.  </span></span><br><span class="line"><span class="comment">* 程序不断重复 — 读、写、读、写 — 直到源文件结束.  </span></span><br><span class="line"><span class="comment">*  ​</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line">String infile = <span class="string">&quot;C:\\copy.sql&quot;</span>;  </span><br><span class="line">String outfile = <span class="string">&quot;C:\\copy.txt&quot;</span>;  </span><br><span class="line">​</span><br><span class="line"><span class="comment">// 获取源文件和目标文件的输入输出流  </span></span><br><span class="line">FileInputStream fin = <span class="keyword">new</span> FileInputStream(infile);  </span><br><span class="line">FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(outfile);  </span><br><span class="line">​</span><br><span class="line"><span class="comment">// 获取输入输出通道  </span></span><br><span class="line">FileChannel fcin = fin.getChannel();  </span><br><span class="line">FileChannel fcout = fout.getChannel();  </span><br><span class="line">​</span><br><span class="line"><span class="comment">// 创建缓冲区  </span></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);  </span><br><span class="line">​</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">  <span class="comment">// clear方法重设缓冲区, 使它可以接受读入的数据  </span></span><br><span class="line">  buffer.clear();  </span><br><span class="line">  ​</span><br><span class="line">  <span class="comment">// 从输入通道中将数据读到缓冲区  </span></span><br><span class="line">  <span class="keyword">int</span> r = fcin.read(buffer);  </span><br><span class="line">  ​</span><br><span class="line">  <span class="comment">// read方法返回读取的字节数, 可能为零, </span></span><br><span class="line">  <span class="comment">// 如果该通道已到达流的末尾, 则返回-1  </span></span><br><span class="line">  <span class="keyword">if</span> (r == -<span class="number">1</span>) &#123;  </span><br><span class="line">    <span class="keyword">break</span>;  </span><br><span class="line">  &#125;  </span><br><span class="line">  ​</span><br><span class="line">  <span class="comment">// flip方法让缓冲区可以将新读入的数据写入另一个通道  </span></span><br><span class="line">  buffer.flip();  </span><br><span class="line">  ​</span><br><span class="line">  <span class="comment">// 从输出通道中将数据写入缓冲区  </span></span><br><span class="line">  fcout.write(buffer);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h1 id="缓冲区内部实现"><a href="#缓冲区内部实现" class="headerlink" title="缓冲区内部实现"></a>缓冲区内部实现</h1><p>每一个缓冲区都有复杂的内部统计机制, 它会跟踪已经读了多少数据以及还有多少空间可以容纳更多的数据, 以便我们对缓冲区的操作. </p>
<p>本节介绍两个重要的缓冲区组件：状态变量和访问方法. 虽然NIO的内部统计机制初看起来可能很复杂, 但是您很快就会看到大部分的实际工作都已经替您完成了. 您只需像平时使用字节数组和索引变量一样进行操作即可. </p>
<h2 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h2><p>状态变量是”内部统计机制”的关键.  每一个读/写操作都会改变缓冲区的状态. 通过记录和跟踪这些变化, 缓冲区就能够管理内部地自己的资源. </p>
<p>每一种Java基本类型的缓冲区都是抽象类Buffer的子类, 从Buffer的源代码中可以发现, 它定义了三个私有属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> limit;  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;  </span><br></pre></td></tr></table></figure>
<p>实际上, 这三个属性值可以指定缓冲区在任意时刻的状态和它所包含的数据.<br>我们知道, 每一个基本类型的缓冲区底层实际上就是一个该类型的数组. 如在ByteBuffer中, 有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">byte</span>[] hb;  </span><br></pre></td></tr></table></figure>
<p>在从通道读取时, 所读取的数据将放被到底层的数组中；同理, 向通道中写入时, 将从底层数组中将数据写入通道. 下面我们来具体介绍这三个变量的作用：</p>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>position变量跟踪了向缓冲区中写入了多少数据或者从缓冲区中读取了多少数据.<br>更确切的说, 当您从通道中读取数据到缓冲区中时, 它指示了下一个数据将放到数组的哪一个元素中. 比如, 如果您从通道中读三个字节到缓冲区中, 那么缓冲区的position将会设置为3, 指向数组中第4个元素. 反之, 当您从缓冲区中获取数据进行写通道时, 它指示了下一个数据来自数组的哪一个元素. 比如, 当您从缓冲区写了5个字节到通道中, 那么缓冲区的 position 将被设置为5, 指向数组的第六个元素. </p>
<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>limit变量表明还有多少数据需要取出(在从缓冲区写入通道时), 或者还有多少空间可以放入数据(在从通道读入缓冲区时).<br>position总是小于或者等于limit. </p>
<h3 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h3><p>capacity变量表明可以储存在缓冲区中的最大数据容量. 实际上, 它指定了底层数组的大小—或者至少是指定了准许我们使用的底层数组的容量.  <br>limit总是小于或者等于capacity. </p>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>下面我们就以数据从一个输入通道拷贝到一个输出通道为例, 来详细分析每一个变量, 并说明它们是如何协同工作的：</p>
<p>初始变量： </p>
<p>我们首先观察一个新创建的缓冲区, 以ByteBuffer为例, 假设缓冲区的大小为8个字节, ByteBuffer初始状态如下：</p>
<p><img src="/images/java/io/NIO/01.gif" alt="NIO缓冲区内部实现机制"></p>
<p>回想一下 , limit决不能大于capacity, 此例中这两个值都被设置为8. 我们通过将它们指向数组的尾部之后(第8个槽位)来说明这点. </p>
<p><img src="/images/java/io/NIO/02.gif" alt="NIO缓冲区内部实现机制"></p>
<p>我们再将position设置为0. 表示如果我们读一些数据到缓冲区中, 那么下一个读取的数据就进入 slot 0. 如果我们从缓冲区写一些数据, 从缓冲区读取的下一个字节就来自slot 0. position设置如下所示：</p>
<p><img src="/images/java/io/NIO/03.gif" alt="NIO缓冲区内部实现机制"></p>
<p>由于缓冲区的最大数据容量capacity不会改变, 所以我们在下面的讨论中可以忽略它. </p>
<p>第一次读取： <br>   现在我们可以开始在新创建的缓冲区上进行读/写操作了. 首先从输入通道中读一些数据到缓冲区中. 第一次读取得到三个字节. 它们被放到数组中从position开始的位置, 这时position被设置为0. 读完之后, position就增加到了3, 如下所示, limit没有改变. </p>
<p><img src="/images/java/io/NIO/04.gif" alt="NIO缓冲区内部实现机制"></p>
<p>第二次读取： <br>   在第二次读取时, 我们从输入通道读取另外两个字节到缓冲区中. 这两个字节储存在由position所指定的位置上,  position因而增加2, limit没有改变. </p>
<p><img src="/images/java/io/NIO/05.gif" alt="NIO缓冲区内部实现机制"></p>
<p>flip： <br>   现在我们要将数据写到输出通道中. 在这之前, 我们必须调用flip()方法.  其源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	limit = position;  </span><br><span class="line">	position = <span class="number">0</span>;  </span><br><span class="line">	mark = -<span class="number">1</span>;  </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p>   这个方法做两件非常重要的事：<br>   i  将limit设置为当前position.<br>   ii 将position设置为0. </p>
<p>   上一个图显示了在flip之前缓冲区的情况. 下面是在flip之后的缓冲区：</p>
<p><img src="/images/java/io/NIO/06.gif" alt="NIO缓冲区内部实现机制"></p>
<p>   我们现在可以将数据从缓冲区写入通道了. position被设置为0, 这意味着我们得到的下一个字节是第一个字节. limit已被设置为原来的position, 这意味着它包括以前读到的所有字节, 并且一个字节也不多.<br>第一次写入： <br>   在第一次写入时, 我们从缓冲区中取四个字节并将它们 写入输出通道. 这使得position增加到4, 而limit不变, 如下所示：</p>
<p><img src="/images/java/io/NIO/07.gif" alt="NIO缓冲区内部实现机制"></p>
<p>第二次写入： <br>   我们只剩下一个字节可写了. limit在我们调用flip()时被设置为5, 并且position不能超过limit.  所以最后一次写入操作从缓冲区取出一个字节并将它写入输出通道. 这使得position增加到5, 并保持limit不变, 如下所示：</p>
<p><img src="/images/java/io/NIO/08.gif" alt="NIO缓冲区内部实现机制"></p>
<p>clear： <br>   最后一步是调用缓冲区的clear()方法. 这个方法重设缓冲区以便接收更多的字节. 其源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">	position = <span class="number">0</span>;  </span><br><span class="line">	limit = capacity;  </span><br><span class="line">	mark = -<span class="number">1</span>;  </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p>clear做两种非常重要的事情：</p>
<p>i 将limit设置为与capacity相同.  <br>ii 设置position为0.  </p>
<p>下图显示了在调用clear()后缓冲区的状态,  此时缓冲区现在可以接收新的数据了. </p>
<p><img src="/images/java/io/NIO/09.gif" alt="NIO缓冲区内部实现机制"></p>
<p> </p>
<h2 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h2><p>程序需要直接处理数据. 例如, 您可能需要将用户数据保存到磁盘. 在这种情况下, 您必须将这些数据直接放入缓冲区, 然后用通道将缓冲区写入磁盘.  或者, 您可能想要从磁盘读取用户数据. 在这种情况下, 您要将数据从通道读到缓冲区中, 然后检查缓冲区中的数据.  <br>   实际上, 每一个基本类型的缓冲区都为我们提供了直接访问缓冲区中数据的方法, 我们以ByteBuffer为例, 分析如何使用其提供的get()和put()方法直接访问缓冲区中的数据. </p>
<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>   ByteBuffer类中有四个get()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="function">ByteBuffer <span class="title">get</span><span class="params">( <span class="keyword">byte</span> dst[] )</span></span>;  </span><br><span class="line"><span class="function">ByteBuffer <span class="title">get</span><span class="params">( <span class="keyword">byte</span> dst[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length )</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">byte</span> <span class="title">get</span><span class="params">( <span class="keyword">int</span> index )</span></span>;</span><br></pre></td></tr></table></figure>
<p>   第一个方法获取单个字节. 第二和第三个方法将一组字节读到一个数组中. 第四个方法从缓冲区中的特定位置获取字节. 那些返回ByteBuffer的方法只是返回调用它们的缓冲区的this值.  <br>   前三个get()方法是相对的, 而最后一个方法是绝对的. “相对”意味着get()操作服从limit和position值, 更明确地说, 字节是从当前position读取的, 而position在get之后会增加. 另一方面, 一个“绝对”方法会忽略limit和position值, 也不会影响它们. 事实上, 它完全绕过了缓冲区的统计方法.  </p>
<p>上面列出的方法对应于ByteBuffer类. 其他类有等价的get()方法, 这些方法除了不是处理字节外, 其它方面是是完全一样的, 它们处理的是与该缓冲区类相适应的类型. </p>
<h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><p>   ByteBuffer类中有五个put()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ByteBuffer <span class="title">put</span><span class="params">( <span class="keyword">byte</span> b )</span></span>;  </span><br><span class="line"><span class="function">ByteBuffer <span class="title">put</span><span class="params">( <span class="keyword">byte</span> src[] )</span></span>;  </span><br><span class="line"><span class="function">ByteBuffer <span class="title">put</span><span class="params">( <span class="keyword">byte</span> src[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length )</span></span>;  </span><br><span class="line"><span class="function">ByteBuffer <span class="title">put</span><span class="params">( ByteBuffer src )</span></span>;  </span><br><span class="line"><span class="function">ByteBuffer <span class="title">put</span><span class="params">( <span class="keyword">int</span> index, <span class="keyword">byte</span> b )</span></span>;</span><br></pre></td></tr></table></figure>
<p>   第一个方法 写入（put）单个字节. 第二和第三个方法写入来自一个数组的一组字节. 第四个方法将数据从一个给定的源ByteBuffer写入这个ByteBuffer. 第五个方法将字节写入缓冲区中特定的 位置 . 那些返回ByteBuffer的方法只是返回调用它们的缓冲区的this值.  <br>   与get()方法一样, 我们将把put()方法划分为“相对”或者“绝对”的. 前四个方法是相对的, 而第五个方法是绝对的.  <br>   上面显示的方法对应于ByteBuffer类. 其他类有等价的put()方法, 这些方法除了不是处理字节之外, 其它方面是完全一样的. 它们处理的是与该缓冲区类相适应的类型.  </p>
<h3 id="类型化的-get-和-put-方法"><a href="#类型化的-get-和-put-方法" class="headerlink" title="类型化的 get() 和 put() 方法"></a>类型化的 get() 和 put() 方法</h3><p>   除了前些小节中描述的get()和put()方法,  ByteBuffer还有用于读写不同类型的值的其他方法, 如下所示</p>
<p> -  <code>getByte()</code><br> -  <code>getChar()</code><br> -  <code>getShort()</code><br> -  <code>getInt()</code><br> -  <code>getLong()</code><br> -  <code>getFloat()</code><br> -  <code>getDouble()</code><br> -  <code>putByte()</code><br> -  <code>putChar()</code><br> -  <code>putShort()</code><br> -  <code>putInt()</code><br> -  <code>putLong()</code><br> -  <code>putFloat()</code><br> -  <code>putDouble()</code></p>
<p>   事实上, 这其中的每个方法都有两种类型：一种是相对的, 另一种是绝对的. 它们对于读取格式化的二进制数据（如图像文件的头部）很有用. </p>
<p> </p>
<h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>   下面的内部循环概括了使用缓冲区将数据从输入通道拷贝到输出通道的过程. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line"> buffer.clear();  </span><br><span class="line"> <span class="keyword">int</span> r = fcin.read( buffer );  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (r==-<span class="number">1</span>) &#123;  </span><br><span class="line"> 	<span class="keyword">break</span>;  </span><br><span class="line"> &#125;  </span><br><span class="line"> buffer.flip();  </span><br><span class="line"> fcout.write( buffer );  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>   read()和write()调用得到了极大的简化, 因为许多工作细节都由缓冲区完成了. clear()和flip()方法用于让缓冲区在读和写之间切换. </p>
<h1 id="连网和异步IO"><a href="#连网和异步IO" class="headerlink" title="连网和异步IO"></a>连网和异步IO</h1><p>连网是学习异步I/O的很好基础, 而异步I/O对于在Java语言中执行任何输入/输出过程的人来说, 无疑都是必须具备的知识. NIO中的连网与NIO中的其他任何操作没有什么不同, 它依赖通道和缓冲区, 而您通常使用InputStream和OutputStream来获得通道. </p>
<h2 id="异步-I-O"><a href="#异步-I-O" class="headerlink" title="异步 I/O"></a>异步 I/O</h2><p>   异步I/O是一种“没有阻塞地读写数据”的方法. 通常, 在代码进行read()调用时, 代码会阻塞直至有可供读取的数据. 同样,  write()调用将会阻塞直至数据能够写入.  但异步I/O调用不会阻塞. 相反, 您可以注册对特定I/O事件的兴趣：如可读的数据的到达、新的套接字连接等等, 而在发生这样的事件时, 系统将会告诉您.  <br>   异步I/O的一个优势在于, 它允许您同时根据大量的输入和输出执行I/O. 同步程序常常要求助于轮询, 或者创建许许多多的线程以处理大量的连接. 使用异步I/O, 您可以监听任何数量的通道上的事件, 不用轮询, 也不用额外的线程.<br>   我们来看一个基于非阻塞I/O的服务器端的处理流程, 它接受网络连接并向它们echo它们可能发送的数据. 在这里假设它能同时监听多个端口, 并处理来自所有这些端口的连接. 下面是其主方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">execute</span> <span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;  </span><br><span class="line">  <span class="comment">// 创建一个新的选择器  </span></span><br><span class="line">  Selector selector = Selector.open();  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开在每个端口上的监听, 并向给定的选择器注册此通道接受客户端连接的I/O事件.   </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ports.length; i++) &#123;  </span><br><span class="line">    <span class="comment">// 打开服务器套接字通道  </span></span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();  </span><br><span class="line">    <span class="comment">// 设置此通道为非阻塞模式  </span></span><br><span class="line">    ssc.configureBlocking(<span class="keyword">false</span>);  </span><br><span class="line">    <span class="comment">// 绑定到特定地址  </span></span><br><span class="line">    ServerSocket ss = ssc.socket();  </span><br><span class="line">    InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(ports[i]);  </span><br><span class="line">    ss.bind(address);  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向给定的选择器注册此通道的接受连接事件  </span></span><br><span class="line">    ssc.register(selector, SelectionKey.OP_ACCEPT);  </span><br><span class="line">    System.out.println(<span class="string">&quot;Going to listen on &quot;</span> + ports[i]);  </span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">    <span class="comment">// 这个方法会阻塞, 直到至少有一个已注册的事件发生.   </span></span><br><span class="line">    <span class="comment">// 当一个或者更多的事件发生时, 此方法将返回所发生的事件的数量.   </span></span><br><span class="line">    <span class="keyword">int</span> num = selector.select();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代所有的选择键, 以处理特定的I/O事件.   </span></span><br><span class="line">    Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();  </span><br><span class="line">    Iterator&lt;SelectionKey&gt; iter = selectionKeys.iterator();  </span><br><span class="line"></span><br><span class="line">    SocketChannel sc;  </span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;  </span><br><span class="line">      SelectionKey key = iter.next();  </span><br><span class="line">      <span class="keyword">if</span> ((key.readyOps() </span><br><span class="line">      &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) &#123;  </span><br><span class="line">        <span class="comment">// 接受服务器套接字撒很能够传入的新的连接, 并处理接受连接事件.   </span></span><br><span class="line">        ServerSocketChannel ssc = (ServerSocketChannel) key.channel();  </span><br><span class="line">        sc = ssc.accept();  </span><br><span class="line">        <span class="comment">// 将新连接的套接字通道设置为非阻塞模式  </span></span><br><span class="line">        sc.configureBlocking(<span class="keyword">false</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接受连接后, 在此通道上从新注册读取事件, 以便接收数据.   </span></span><br><span class="line">        sc.register(selector, SelectionKey.OP_READ);  </span><br><span class="line">        <span class="comment">// 删除处理过的选择键  </span></span><br><span class="line">        iter.remove();  </span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Got connection from &quot;</span> + sc);  </span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((key.readyOps() </span><br><span class="line">      &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ) &#123;  </span><br><span class="line">          <span class="comment">// 处理读取事件, 读取套接字通道中发来的数据.   </span></span><br><span class="line">          sc = (SocketChannel) key.channel();  </span><br><span class="line"></span><br><span class="line">          <span class="comment">// 读取数据  </span></span><br><span class="line">          <span class="keyword">int</span> bytesEchoed = <span class="number">0</span>;  </span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">            echoBuffer.clear();  </span><br><span class="line">            <span class="keyword">int</span> r = sc.read(echoBuffer);  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r == -<span class="number">1</span>) &#123;  </span><br><span class="line">              <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">            echoBuffer.flip();  </span><br><span class="line">            sc.write(echoBuffer);  </span><br><span class="line"></span><br><span class="line">            bytesEchoed += r;  </span><br><span class="line">          &#125;  </span><br><span class="line">          System.out.println(<span class="string">&quot;Echoed &quot;</span> + bytesEchoed + <span class="string">&quot; from &quot;</span> + sc);  </span><br><span class="line">          <span class="comment">// 删除处理过的选择键  </span></span><br><span class="line">          iter.remove();  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3)    Selectors</p>
<p>Selector是异步<code>I/O</code>中的核心对象. Selector就是注册对各种<code>I/O</code>事件的兴趣的地方, 而且当那些事件发生时, 就是这个对象告诉您所发生的事件. 所以, 我们需要做的第一件事就是创建一个Selector：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();  </span><br></pre></td></tr></table></figure>
<p>然后, 我们将对不同的通道对象调用<code>register()</code>方法, 以便注册我们对这些对象中发生的I/O事件的兴趣. <code>register()</code>的第一个参数就是这个Selector对象.  </p>
<p>4)    打开一个<code>ServerSocketChannel</code></p>
<p>在服务端为了接收连接, 我们需要一个<code>ServerSocketChannel</code>.  事实上, 我们要监听的每一个端口都需要有一个<code>ServerSocketChannel</code>. 对于每一个端口, 我们打开一个<code>ServerSocketChannel</code>,  如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();  </span><br><span class="line">ssc.configureBlocking( <span class="keyword">false</span> );  </span><br><span class="line">ServerSocket ss = ssc.socket();  </span><br><span class="line">InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress( ports[i] );  </span><br><span class="line">ss.bind( address );  </span><br></pre></td></tr></table></figure>
<p>第一行创建一个新的<code>ServerSocketChannel</code>, 最后三行将它绑定到给定的端口. 第二行将<code>ServerSocketChannel</code>设置为非阻塞的. 我们必须对每一个要使用的套接字通道调用这个方法, 否则异步<code>I/O</code>就不能工作.</p>
<p>5)    选择键</p>
<p>下一步是将新打开的<code>ServerSocketChannels</code>注册到<code>Selector</code>上. 为此我们使用<code>ServerSocketChannel.register()</code>方法, 如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = ssc.register( selector, SelectionKey.OP_ACCEPT );  </span><br></pre></td></tr></table></figure>
<p><code>register()</code>方法的第一个参数总是这个<code>Selector</code>. 第二个参数是<code>OP_ACCEPT</code>, 这里它指定我们想要监听<code>accept</code>事件, 也就是在新的连接建立时所发生的事件. 这是适用于<code>ServerSocketChannel</code>的唯一事件类型.  </p>
<p>请注意对<code>register()</code>的调用的返回值. <code>SelectionKey</code>代表这个通道在此<code>Selector</code>上的这个注册. 当某个<code>Selector</code>通知您某个传入事件时, 它是通过提供对应于该事件的<code>SelectionKey</code>来进行的. <code>SelectionKey</code>还可以用于取消通道的注册.<br>  <br>6)    内部循环</p>
<p>现在已经注册了我们对一些 <code>I/O</code> 事件的兴趣, 下面将进入主循环. 使用 <code>Selectors</code> 的几乎每个程序都像下面这样使用内部循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = selector.select();  </span><br><span class="line"></span><br><span class="line">Set selectedKeys = selector.selectedKeys();  </span><br><span class="line">Iterator it = selectedKeys.iterator();  </span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;  </span><br><span class="line">SelectionKey key = (SelectionKey)it.next();  </span><br><span class="line"><span class="comment">// ... 处理I/O事件...  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<ul>
<li>调用<code>Selector</code>的<code>select()</code>方法. 这个方法会阻塞, 直到至少有一个已注册的事件发生. 当一个或者更多的事件发生时, <code>select()</code>方法将返回所发生的事件的数量.  </li>
<li>调用<code>Selector</code>的<code>selectedKeys()</code>方法, 它返回发生了事件的<code>SelectionKey</code>对象的一个集合.  </li>
<li>通过迭代<code>SelectionKeys</code>并依次处理每个<code>SelectionKey</code>来处理事件. 对于每一个<code>SelectionKey</code>, 您必须确定发生的是什么<code>I/O</code>事件, 以及这个事件影响哪些<code>I/O</code>对象.</li>
</ul>
<p>7)    监听新连接</p>
<p>程序执行到这里, 我们仅注册了<code>ServerSocketChannel</code>,  并且仅注册它们“接收”事件. 为确认这一点, 我们对<code>SelectionKey</code>调用<code>readyOps()</code>方法, 并检查发生了什么类型的事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((key.readyOps() &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) &#123;  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>可以肯定地说, <code>readOps()</code>方法告诉我们该事件是新的连接. </p>
<p>8)    接受新的连接</p>
<p>因为我们知道这个服务器套接字上有一个传入连接在等待, 所以可以安全地接受它；也就是说, 不用担心<code>accept()</code>操作会阻塞：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssc = (ServerSocketChannel)key.channel();  </span><br><span class="line">SocketChannel sc = ssc.accept();  </span><br></pre></td></tr></table></figure>
<p>下一步是将新连接的SocketChannel配置为非阻塞的. 而且由于接受这个连接的目的是为了读取来自套接字的数据, 所以我们还必须将SocketChannel注册到Selector上, 如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sc.configureBlocking( <span class="keyword">false</span> );  </span><br><span class="line">SelectionKey newKey = sc.register( selector, SelectionKey.OP_READ );  </span><br></pre></td></tr></table></figure>
<p>注意我们使用register()的OP_READ参数, 将SocketChannel注册用于“读取”而不是“接受”新连接.</p>
<p>9)    删除处理过的SelectionKey</p>
<p>在处理SelectionKey之后, 我们几乎可以返回主循环了. 但是我们必须首先将处理过的SelectionKey从选定的键集合中删除. 如果我们没有删除处理过的键, 那么它仍然会在主集合中以一个激活的键出现, 这会导致我们尝试再次处理它. 我们调用迭代器的remove()方法来删除处理过的SelectionKey：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it.remove();  </span><br></pre></td></tr></table></figure>
<p>现在我们可以返回主循环并接受从一个套接字中传入的数据(或者一个传入的I/O事件)了.  </p>
<p>10) 传入的I/O</p>
<p>当来自一个套接字的数据到达时, 它会触发一个I/O事件. 这会导致在主循环中调用Selector.select(), 并返回一个或者多个I/O事件. 这一次,  SelectionKey将被标记为OP_READ事件, 如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((key.readyOps() &amp; SelectionKey.OP_READ)  </span><br><span class="line">== SelectionKey.OP_READ) &#123;  </span><br><span class="line"><span class="comment">// Read the data  </span></span><br><span class="line">SocketChannel sc = (SocketChannel)key.channel();  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>与以前一样, 我们取得发生I/O事件的通道并处理它. 在本例中, 由于这是一个echo server, 我们只希望从套接字中读取数据并马上将它发送回去. 关于这个过程的细节, 请参见附件中的源代码 (MultiPortEcho.java).  </p>
<p>11)    回到主循环</p>
<p>每次返回主循环, 我们都要调用select的Selector()方法, 并取得一组SelectionKey. 每个键代表一个I/O事件. 我们处理事件, 从选定的键集中删除SelectionKey, 然后返回主循环的顶部.</p>
<p>说明： 这个程序有点过于简单, 因为它的目的只是展示异步I/O所涉及的技术. 在现实的应用程序中, 您需要通过将通道从Selector中删除来处理关闭的通道. 而且您可能要使用多个线程. 这个程序可以仅使用一个线程, 因为它只是一个演示, 但是在现实场景中, 创建一个线程池来负责I/O事件处理中的耗时部分会更有意义. </p>
<h1 id="缓冲区更多内容"><a href="#缓冲区更多内容" class="headerlink" title="缓冲区更多内容"></a>缓冲区更多内容</h1><p>比如缓冲区分配、包装和分片. 我们还会讨论NIO带给Java平台的一些新功能. 我们将学如何创建不同类型的缓冲区以达到不同的目的, 如可保护数据不被修改的“只读缓冲区”, 和直接映射到底层操作系统缓冲区的“直接缓冲区”, 以及如何在 NIO 中创建内存映射文件. </p>
<p>   1) 缓冲区分配和包装</p>
<p>在能够读和写之前, 必须有一个缓冲区. 要创建缓冲区, 您必须“分配”它. 我们使用静态方法allocate()来分配缓冲区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">1024</span> );  </span><br></pre></td></tr></table></figure>
<p>   allocate()方法分配一个具有指定大小的底层数组, 并将它包装到一个缓冲区对象中, 在本例中是一个ByteBuffer.<br>   您还可以将一个现有的数组转换为缓冲区, 如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> array[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];  </span><br><span class="line">ByteBuffer buffer = ByteBuffer.wrap( array );  </span><br></pre></td></tr></table></figure>
<p>   本例使用了wrap()方法将一个数组包装为缓冲区. 必须非常小心地进行这类操作. 一旦完成包装, 底层数据就可以通过缓冲区或者直接访问.<br> <br>2) 缓冲区分片 </p>
<p>   slice()方法根据现有的缓冲区创建一个子缓冲区. 也就是说, 它创建一个新的缓冲区, 新缓冲区与原来的缓冲区的一部分共享数据.<br>  <br>   使用例子可以最好地说明这点. 让我们首先创建一个长度为10的ByteBuffer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate( <span class="number">10</span> );  </span><br></pre></td></tr></table></figure>
<p>   然后使用数据来填充这个缓冲区, 在第n个槽中放入数字n：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;buffer.capacity(); ++i) &#123;  </span><br><span class="line"> buffer.put( (<span class="keyword">byte</span>)i );  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>   现在我们对这个缓冲区“分片”, 以创建一个包含槽3到槽6的子缓冲区. 在某种意义上, 子缓冲区就像原来的缓冲区中的一个窗口 . </p>
<p>   窗口的起始和结束位置通过设置position和limit值来指定, 然后调用Buffer的slice()方法进行分片：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.position( <span class="number">3</span> );  </span><br><span class="line">buffer.limit( <span class="number">7</span> );  </span><br><span class="line">ByteBuffer slice = buffer.slice();  </span><br></pre></td></tr></table></figure>
<p>   该“片段”是缓冲区的子缓冲区. 不过, “片段”和“缓冲区”共享同一个底层数据数组, 我们在下一节将会看到这一点. </p>
<ol start="3">
<li>缓冲区片份和数据共享 </li>
</ol>
<p>   我们已经创建了原缓冲区的子缓冲区, 并且已经知道缓冲区和子缓冲区共享同一个底层数据数组. 让我们看看这意味着什么.  </p>
<p>   我们遍历子缓冲区, 将每一个元素乘以11来改变它. 例如, 5会变成55. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;slice.capacity(); ++i) &#123;  </span><br><span class="line"> <span class="keyword">byte</span> b = slice.get( i );  </span><br><span class="line"> b *= <span class="number">11</span>;  </span><br><span class="line"> slice.put( i, b );  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>   最后, 再看一下原缓冲区中的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buffer.position( <span class="number">0</span> );  </span><br><span class="line">buffer.limit( buffer.capacity() );  </span><br><span class="line"><span class="keyword">while</span> ( buffer.remaining() &gt; <span class="number">0</span> ) &#123;  </span><br><span class="line"> System.out.println( buffer.get() );  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>   结果表明只有在子缓冲区窗口中的元素被改变了： </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">33</span><br><span class="line">44</span><br><span class="line">55</span><br><span class="line">66</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<p>   缓冲区片对于促进抽象非常有帮助. 可以编写自己的函数处理整个缓冲区, 而且如果想要将这个过程应用于子缓冲区上, 您只需取主缓冲区的一个片, 并将它传递给您的函数. 这比编写自己的函数来取额外的参数以指定要对缓冲区的哪一部分进行操作更容易.  </p>
<ol start="4">
<li>只读缓冲区</li>
</ol>
<p>只读缓冲区的含义已经很直白了：您可以读取它们, 但是不能向它们写入. 可以通过调用缓冲区的<code>asReadOnlyBuffer()</code>方法, 来将任何常规缓冲区转换为只读缓冲区, 这个方法返回一个与原缓冲区完全相同的缓冲区(并与其共享数据), 只不过它是只读的.  </p>
<p>   只读缓冲区对于保护数据很有用. 在将缓冲区传递给某个对象的方法时, 您无法知道这个方法是否会修改缓冲区中的数据. 创建一个只读的缓冲区可以保证该缓冲区不会被修改. 不能将只读的缓冲区转换为可写的缓冲区.  </p>
<ol start="5">
<li>直接和间接缓冲区 </li>
</ol>
<p>   另一种有用的ByteBuffer是直接缓冲区. “直接缓冲区”是为加快I/O速度, 而以一种特殊的方式分配其内存的缓冲区. 实际上, 直接缓冲区的准确定义是与实现相关的. </p>
<blockquote>
<p>Sun的文档是这样描述直接缓冲区的： 给定一个直接字节缓冲区, Java虚拟机将尽最大努力直接对它执行本机I/O操作. 也就是说, 它会在每一次调用底层操作系统的本机I/O操作之前(或之后), 尝试避免将缓冲区的内容拷贝到一个中间缓冲区中(或者从一个中间缓冲区中拷贝数据).  </p>
</blockquote>
<p>附件中, 您可以在例子程序FastCopyFile.java中看到直接缓冲区的实际应用, 这个程序是CopyFile.java的另一个版本, 它使用了直接缓冲区以提高速度. 还可以用内存映射文件创建直接缓冲区.  </p>
<ol start="6">
<li>内存映射文件I/O</li>
</ol>
<p>   内存映射文件I/O是一种读和写文件数据的方法, 它可以比常规的基于流或者基于通道的I/O快得多.  </p>
<p>内存映射文件I/O是通过使文件中的数据神奇般地出现为内存数组的内容来完成的. 这其初听起来似乎不过就是将整个文件读到内存中, 但是事实上并不是这样. 一般来说, 只有文件中实际读取或者写入的部分才会送入（或者映射）到内存中.  </p>
<p><strong>内存映射并不真的神奇或者多么不寻常. 现代操作系统一般根据需要将文件的部分映射为内存的部分, 从而实现文件系统. Java内存映射机制不过是在底层操作系统中可以采用这种机制时, 提供了对该机制的访问</strong></p>
<p>尽管创建内存映射文件相当简单, 但是向它写入可能是危险的. 仅只是改变数组的单个元素这样的简单操作, 就可能会直接修改磁盘上的文件. 修改数据与将 数据保存到磁盘是没有分开的. </p>
<ol start="7">
<li>将文件映射到内存</li>
</ol>
<p>了解内存映射的最好方法是使用例子. 在下面的例子中, 我们要将一个FileChannel (它的全部或者部分)映射到内存中. 为此我们将使用<code>FileChannel.map()</code>方法. 下面代码行将文件的前1024个字节映射到内存中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MappedByteBuffer mbb = fc.map( FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">1024</span> );  </span><br></pre></td></tr></table></figure>
<p>map()方法返回一个<code>MappedByteBuffer</code>, 它是ByteBuffer的子类. 因此, 您可以像使用其他任何ByteBuffer 一样使用新映射的缓冲区, 操作系统会在需要时负责执行行映射.</p>
<ol>
<li>分散和聚集 </li>
</ol>
<ol>
<li>概述：</li>
</ol>
<p>分散/聚集I/O是使用多个而不是单个缓冲区来保存数据的读写方法.  <br>一个分散的读取就像一个常规通道读取, 只不过它是将数据读到一个缓冲区数组中而不是读到单个缓冲区中. 同样地, 一个聚集写入是向缓冲区数组而不是向单个缓冲区写入数据. 分散/聚集I/O对于将数据流划分为单独的部分很有用, 这有助于实现复杂的数据格式. </p>
<ol start="2">
<li>分散/聚集 I/O：</li>
</ol>
<p>通道可以有选择地实现两个新的接口：ScatteringByteChannel和GatheringByteChannel. 一个 ScatteringByteChannel是一个具有两个附加读方法的通道：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">read</span><span class="params">( ByteBuffer[] dsts )</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">read</span><span class="params">( ByteBuffer[] dsts, <span class="keyword">int</span> offset, <span class="keyword">int</span> length )</span></span>;</span><br></pre></td></tr></table></figure>
<p>这些long read()方法很像标准的read方法, 只不过它们不是取单个缓冲区而是取一个缓冲区数组.  </p>
<p>在“分散读取”中, 通道依次填充每个缓冲区. 填满一个缓冲区后, 它就开始填充下一个. 在某种意义上, 缓冲区数组就像一个大缓冲区.  </p>
<ol start="3">
<li>分散/聚集的应用： </li>
</ol>
<p>分散/聚集I/O对于将数据划分为几个部分很有用. 例如, 您可能在编写一个使用消息对象的网络应用程序, 每一个消息被划分为固定长度的头部和固定长度的正文. 您可以创建一个刚好可以容纳头部的缓冲区和另一个刚好可以容难正文的缓冲区. 当您将它们放入一个数组中并使用分散读取来向它们读入消息时, 头部和正文将整齐地划分到这 两个缓冲区中.  </p>
<p>我们从缓冲区所得到的方便性对于缓冲区数组同样有效. 因为每一个缓冲区都跟踪自己还可以接受多少数据, 所以分散读取会自动找到有空间接受数据的第一个缓冲区. 在这个缓冲区填满后, 它就会移动到下一个缓冲区.  </p>
<ol start="4">
<li>聚集写入： </li>
</ol>
<p>聚集写入类似于分散读取, 只不过是用来写入. 它也有接受缓冲区数组的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">write</span><span class="params">( ByteBuffer[] srcs )</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">write</span><span class="params">( ByteBuffer[] srcs, <span class="keyword">int</span> offset, <span class="keyword">int</span> length )</span></span>;</span><br></pre></td></tr></table></figure>
<p>聚集写对于把一组单独的缓冲区中组成单个数据流很有用. 为了与上面的消息例子保持一致, 您可以使用聚集写入来自动将网络消息的各个部分组装为单个数据流, 以便跨越网络传输消息.  <br>从附件的例子程序 UseScatterGather.java 中可以看到分散读取和聚集写入的实际应用. </p>
<h1 id="文件锁定"><a href="#文件锁定" class="headerlink" title="文件锁定"></a>文件锁定</h1><ol>
<li>概述： </li>
</ol>
<p>文件锁定初看起来可能让人迷惑. 它似乎指的是防止程序或者用户访问特定文件. 事实上, <strong>文件锁就像常规的Java对象锁, 它们是“劝告式”的（advisory）锁</strong>. <strong>它们不阻止任何形式的数据访问, 相反, 它们通过锁的共享和获取来允许系统的不同部分相互协调</strong>. 您可以锁定整个文件或者文件的一部分. 如果您获取一个排它锁, 那么其他人就不能获得同一个文件或者文件的一部分上的锁. 如果您获得一个共享锁, 那么其他人可以获得同一个文件或者文件一部分上的共享锁, 但是不能获得排它锁. 文件锁定并不总是出于保护数据的目的. 例如, 您可能临时锁定一个文件以保证特定 的写操作成为原子的, 而不会有其他程序的干扰.  大多数操作系统提供了文件系统锁, 但是它们并不都是采用同样的方式. 有些实现提供了共享锁, 而另一些仅提供了排它锁. 事实上, 有些实现使得文件的锁定部分不可访问, 尽管大多数实现不是这样的.  在这里, 我们将学习如何在 NIO 中执行简单的文件锁过程, 还将探讨一些保证被锁定的文件尽可能可移植的方法.  </p>
<ol start="2">
<li>锁定文件： </li>
</ol>
<p>要获取文件的一部分上的锁, 您要调用一个打开的FileChannel上的lock()方法. 注意, 如果要获取一个排它锁, 您必须以写方式打开文件. </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile( <span class="string">&quot;usefilelocks.txt&quot;</span>, <span class="string">&quot;rw&quot;</span> );  </span><br><span class="line">FileChannel fc = raf.getChannel();  </span><br><span class="line">FileLock lock = fc.lock( start, end, <span class="keyword">false</span> );  </span><br></pre></td></tr></table></figure>
<p>   在拥有锁之后, 您可以执行需要的任何敏感操作, 然后再释放锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.release();  </span><br></pre></td></tr></table></figure>
<p>   在释放锁后, 尝试获得锁的其他任何程序都有机会获得它.  <br>   本附件的例子程序UseFileLocks.java必须与它自己并行运行. 这个程序获取一个文件上的锁, 持有三秒钟, 然后释放它. 如果同时运行这个程序的多个实例, 您会看到每个实例依次获得锁.  </p>
<ol start="3">
<li>文件锁定和可移植性：</li>
</ol>
<p>文件锁定可能是一个复杂的操作, 特别是考虑到 不同的操作系统是以不同的方式实现锁这一事实. 下面的指导原则将帮助您尽可能保持代码的可移植性： </p>
<p>i 只使用排它锁.  </p>
<p>ii 将所有的锁视为劝告式的（advisory）.  </p>
<h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><ol>
<li>概述： </li>
</ol>
<p>根据Sun的文档, 一个Charset是“十六位Unicode字符序列与字节序列之间的一个命名的映射”. 实际上, 一个Charset允许您以尽可能最具可移植性的方式读写字符序列.  </p>
<p>Java语言被定义为基于Unicode. 然而在实际上, 许多人编写代码时都假设一个字符在磁盘上或者在网络流中用一个字节表示. 这种假设在许多情况下成立, 但是并不是在所有情况下都成立, 而且随着计算机变得对Unicode越来越友好, 这个假设就日益变得不能成立了.  </p>
<p>在这里, 我们将看一下如何使用Charsets以适合现代文本格式的方式处理文本数据. 这里将使用的示例程序相当简单, 不过, 它触及了使用Charset的所有关键方面：为给定的字符编码创建Charset, 以及使用该Charset解码和编码文本数据.  </p>
<ol start="2">
<li>编码/解码： </li>
</ol>
<p>要读和写文本, 我们要分别使用CharsetDecoder和CharsetEncoder. 将它们称为“编码器”和“解码器” 是有道理的. 一个字符不再表示一个特定的位模式, 而是表示字符系统中的一个实体. 因此, 由某个实际的位模式表示的字符必须以某种特定的编码来表示.  </p>
<p>CharsetDecoder用于将逐位表示的一串字符转换为具体的char值. 同样, 一个CharsetEncoder用于将字符转换回位.  </p>
<ol start="3">
<li>处理文本的正确方式： </li>
</ol>
<p>现在我们将分析这个例子程序UseCharsets.java. 这个程序非常简单：它从一个文件中读取一些文本, 并将该文本写入另一个文件. 但是它把该数据当作文本数据, 并使用CharBuffer来将该数句读入一个CharsetDecoder中. 同样, 它使用CharsetEncoder来写回该数据.  </p>
<p>我们将假设字符以ISO-8859-1(Latin1)字符集（这是ASCII的标准扩展）的形式储存在磁盘上. 尽管我们必须为使用Unicode做好准备, 但是也必须认识到不同的文件是以不同的格式储存的, 而ASCII无疑是非常普遍的一种格式. 事实上, 每种Java实现都要求对以下字符编码提供完全的支持： </p>
<p>   US-ASCII <br>   ISO-8859-1 <br>   UTF-8 <br>   UTF-16BE <br>   UTF-16LE <br>   UTF-16 </p>
<ol start="4">
<li>示例程序： </li>
</ol>
<p>   在打开相应的文件、将输入数据读入名为inputData的ByteBuffer之后, 我们的程序必须创建ISO-8859-1字符集的一个实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Charset latin1 = Charset.forName( <span class="string">&quot;ISO-8859-1&quot;</span> );  </span><br></pre></td></tr></table></figure>
<p>   然后, 创建一个解码器（用于读取）和一个编码器 （用于写入）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CharsetDecoder decoder = latin1.newDecoder();  </span><br><span class="line">CharsetEncoder encoder = latin1.newEncoder();</span><br></pre></td></tr></table></figure>
<p>   为了将字节数据解码为一组字符, 我们把ByteBuffer传递给CharsetDecoder,  结果得到一个CharBuffer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharBuffer cb = decoder.decode( inputData );  </span><br></pre></td></tr></table></figure>
<p>   如果想要处理字符, 我们可以在程序的此处进行. 但是我们只想无改变地将它写回, 所以没有什么要做的.  </p>
<p>   要写回数据, 我们必须使用CharsetEncoder将它转换回字节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer outputData = encoder.encode( cb );  </span><br></pre></td></tr></table></figure>
<p>   在转换完成之后, 我们就可以将数据写到文件中了. </p>
<h2 id="Java-NIO-bug"><a href="#Java-NIO-bug" class="headerlink" title="Java NIO bug"></a>Java NIO bug</h2><p>JDK 原生 NIO 程序的问题</p>
<p>JDK 原生也有一套网络应用程序 API，但是存在一系列问题，主要如下：</p>
<p>NIO 的类库和 API 繁杂，使用麻烦。你需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等。</p>
<p>需要具备其他的额外技能做铺垫。例如熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的 NIO 程序。</p>
<p>可靠性能力补齐，开发工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等。</p>
<p>NIO 编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大。</p>
<p>JDK NIO 的 Bug。例如臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。</p>
<p>官方声称在 JDK 1.6 版本的 update 18 修复了该问题，但是直到 JDK 1.7 版本该问题仍旧存在，只不过该 Bug 发生概率降低了一些而已，它并没有被根本解决。</p>
<hr>
<p>[参考文献]</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html">NIO 入门</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/kunluntaishan/article/details/53536386"> <strong>Java NIO浅析</strong> </a></li>
<li><a target="_blank" rel="noopener" href="http://zhangshixi.iteye.com/blog/679959">NIO学习系列：核心概念及基本读写</a></li>
<li><a target="_blank" rel="noopener" href="http://zhangshixi.iteye.com/blog/683767">NIO学习系列：连网和异步IO</a></li>
<li><a target="_blank" rel="noopener" href="http://zhangshixi.iteye.com/blog/684544">NIO学习系列：缓冲区更多特性及分散/聚集IO</a></li>
<li><a target="_blank" rel="noopener" href="http://zhangshixi.iteye.com/blog/685022">NIO学习系列：文件锁定和字符集</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/database/MySQL/struct_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/database/MySQL/struct_1/" class="post-title-link" itemprop="url">MySQL架构1 主从复制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-04-03 11:30:00" itemprop="dateCreated datePublished" datetime="2016-04-03T11:30:00+08:00">2016-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-19 15:02:11" itemprop="dateModified" datetime="2021-04-19T15:02:11+08:00">2021-04-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DataStruct/" itemprop="url" rel="index"><span itemprop="name">DataStruct</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>主从复制的几种方式</strong></p>
<p><strong>同步复制</strong></p>
<p>所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,…,slave-n完成后才能返回。</p>
<p>这样，显然不可取，也不是MYSQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间。</p>
<p><strong>异步复制</strong></p>
<p>如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心。MYSQL的默认设置。</p>
<p><strong>半同步复制</strong></p>
<p>master只保证slaves中的一个操作成功，就返回，其他slave不管。这个功能，是由google为MYSQL引入的。</p>
<p><img src="/images/database/MySQL/master_slave_01.png"></p>
<p>当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave,那是发N次，还是只发一次？</p>
<p>如果只发一次，发给了slave-1，那slave-2,slave-3,…它们怎么办？</p>
<p>显然，应该发N次。实际上，在MYSQL   master内部，维护N个线程，每一个线程负责将二进制日志文件发往对应的slave。master既要负责写操作，还的维护N个线程，负担会很重。可以这样，slave-1是master的从，slave-1又是slave-2,slave-3,…的主，同时slave-1不再负责select。slave-1将master的复制线程的负担，转移到自己的身上。这就是所谓的多级复制的概念。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/20/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/22/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">aaronzhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">237</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">127</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aaronzhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
