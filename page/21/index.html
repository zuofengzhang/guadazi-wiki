<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Guadazi">
<meta property="og:url" content="http://example.com/page/21/index.html">
<meta property="og:site_name" content="Guadazi">
<meta property="og:locale">
<meta property="article:author" content="aaronzhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/21/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Guadazi</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Guadazi</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/collection/collection-map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/collection/collection-map/" class="post-title-link" itemprop="url">Java Collection与Map</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-05-12 08:44:00" itemprop="dateCreated datePublished" datetime="2016-05-12T08:44:00+08:00">2016-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-24 12:58:51" itemprop="dateModified" datetime="2021-04-24T12:58:51+08:00">2021-04-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="/Java/advanced-engineer-outline/">&lt;&lt; Java高级软件工程师知识结构</a></p>
<blockquote>
<ol>
<li>掌握Collection和Map的继承体系。</li>
<li>掌握ArrayList、LinkedList、Vector、Stack、PriorityQueue、HashSet、LinkedHashSet、TreeSet、HashMap、</li>
<li>LinkedHashMap、TreeMap、WeakHashMap、EnumMap、HashTable的特点和实现原理。<br>4.掌握CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentHashMap的实现原理和适用场景。</li>
</ol>
</blockquote>
<h1 id="Java-Collection与Map的继承关系"><a href="#Java-Collection与Map的继承关系" class="headerlink" title="Java Collection与Map的继承关系"></a>Java Collection与Map的继承关系</h1><p>在程序设计中, 集合可以存储和传递一组数据. 集合虽然比不上数组的查询速度, 但是有更加方便的功能,<br>如可变长度、键值对、去重复等.<br>其家族成员有:</p>
<p><img src="/images/java/Collection_Map/java-collections-integrated-relation.png"></p>
<p><code>Collection</code>是一个接口, 该接口允许添加和查找一个或多个元素、<code>生成迭代器</code>等功能.</p>
<p><code>List</code> <code>Set</code>和<code>Queue</code>分别是继承了<code>Collocation</code>的子接口.<br><code>List</code>用于存放可重复可为<code>null</code>的元素的有序集合. 并且可以对元素进行精确地控制, 可根据整数索引访问元素.<br><code>Set</code>用于存放不可重复可为<code>null</code>的元素的集合,<br><code>Map</code>并没有继承<code>Collection</code>, 是由一系列键值对组成的集合. 在<code>Map</code>中一个<code>key</code>对应一个<code>value</code>, key不能相同.</p>
<h1 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h1><p>实现了List接口的集合主要有 <code>ArrayList</code> <code>LinkedList</code> <code>Vector</code> <code>Stack</code></p>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p><strong>特性</strong></p>
<ol>
<li><strong>可重复</strong>, <strong>可为null</strong>: 添加元素是将元素存放到数组中</li>
<li><strong>有序</strong></li>
<li>擅长随机访问： 快速检索 增删慢</li>
<li><strong>非线程同步</strong><br>通过<code>Collections.synchronizedList(new ArrayList());</code>转换为线程安全的List</li>
</ol>
<p><strong>实现原理</strong><br>动态数组, 底层也是通过<code>单个Java数组</code>实现的, <code>ArrayList</code>根据元素个数动态调整内部数组的长度以达到实现动态数组的效果.<br>内部数组的初始长度为10, 当添加的元素的个数超出了内部数组的长度时, 调用JNI函数对内部数组实现扩容（为原长度的<code>150%</code>）和复制.<br>本质上, <code>ArrayList</code>是采用了<strong>线性表</strong>的结构, 因此, <code>ArrayList</code>具有快速检索的优点也具有增删慢的缺点.</p>
<p><strong>复杂度</strong><br>添加n个元素需要O(n)时间</p>
<blockquote>
<p><strong>优化建议 :</strong><br>如果确定了插入元素的多少, 最好可以指定初始容量值,<br>避免过多的进行扩容和复制而浪费时间.</p>
</blockquote>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p><strong>特性</strong></p>
<ol>
<li><strong>不能随机访问</strong></li>
<li><strong>非线程同步</strong><br> 通过<code>Collections.synchronizedList(new LinkedList());</code>转换为线程安全的List</li>
<li>善于<strong>插入和删除</strong> 不善于随机访问</li>
</ol>
<p><strong>实现原理</strong><br>双向链表, 可以通过<code>get</code> <code>remove</code> <code>insert</code>方法操作首部和尾部的元素.</p>
<p><strong>复杂度</strong></p>
<p><strong>与ArrayList对比</strong><br>由于<code>ArrayList</code>是线性表的形式存储的, 需要连续的存储空间. 而<code>LinkedList</code>不需要连续,<br>因此在存储数据量较大的情况下, 优先选择<code>LinkedList</code>.</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p><strong>特性</strong></p>
<ol>
<li><strong>线程同步</strong></li>
<li>与ArrayList一样 <strong>???</strong></li>
</ol>
<p><strong>实现原理</strong><br>线程安全的动态数组, 内部也是采用单个数组</p>
<p><strong>复杂度</strong></p>
<h2 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack 栈"></a>Stack 栈</h2><p><strong>特性</strong></p>
<ol>
<li><strong>后进先出的栈</strong></li>
<li>提供了除了ArrayList和Vector以外的栈操作方法:<ul>
<li>push 压入栈</li>
<li>pop  出栈</li>
<li>peek 得到栈顶</li>
<li>empty 测试栈是否为空</li>
<li>search 检测一个元素在栈中的位置</li>
</ul>
</li>
</ol>
<p><strong>实现原理</strong><br>用<code>Vector</code>构建,而非继承自<code>Vector</code></p>
<p><strong>复杂度</strong></p>
<p>【样例】: 使用栈实现计算器</p>
<h1 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h1><p><strong>特性</strong></p>
<ol>
<li><strong>不可重复</strong></li>
<li><strong>最多只允许一个null</strong></li>
</ol>
<h2 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h2><p><strong>特性</strong></p>
<ol>
<li>枚举专用Set</li>
<li>不是同步的<br>多线程情况下, 最好在创建时完成这一操作, 以防止意外的非同步访问<br><code>Set&lt;MyEnum&gt; s = Collections.synchronizedSet(EnumSet.noneOf(MyEnum.class));</code></li>
<li>枚举 set 中所有键都必须来自单个枚举类型, 该枚举类型在创建 set 时显式或隐式地指定.</li>
</ol>
<p><strong>实现原理</strong></p>
<p>//TODO</p>
<p><strong>复杂度</strong></p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><p><strong>特性</strong></p>
<ol>
<li><strong>速度最快的集合</strong></li>
<li>不能重复，最多一个为null</li>
</ol>
<p><strong>实现原理</strong><br>内部存在一个HashMap, 借助于HashCode来实现, 所以不保证元素的顺序</p>
<p><strong>复杂度</strong></p>
<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p><strong>特性</strong></p>
<ol>
<li>有序</li>
</ol>
<p><strong>实现原理</strong><br>内部是<code>LinkedHashMap</code>实现的<br>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它 <strong>同时使用链表维护元素的次序</strong> 。<br>当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。<br>LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</p>
<p><strong>复杂度</strong></p>
<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><p><strong>特性</strong></p>
<ol>
<li>总是处于排序状态的Set(顺序取决于元素的自然顺序或者创建Set时指定的Comparator)</li>
<li>非线程同步<br> 多线程情况下,最好在创建时进行, 以防止对 set 的意外非同步访问：<br> <code>SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...));</code></li>
</ol>
<p><strong>实现原理</strong><br>内部由TreeMap(使用<a target="_blank" rel="noopener" href="http://www.cnblogs.com/liqizhou/archive/2012/09/27/java%E4%B8%ADtreemap%E5%92%8Ctreeset%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91.html">红黑树</a>)来实现</p>
<p><strong>复杂度</strong></p>
<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p><strong>特性</strong></p>
<ol>
<li>键值对</li>
<li>Key不能重复</li>
</ol>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p><strong>特性</strong></p>
<ol>
<li><strong>线程不安全</strong></li>
<li>初始容量设定</li>
</ol>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><a target="_blank" rel="noopener" href="http://www.importnew.com/7099.html">参考链接: HashMap的工作原理</a></p>
<p>以哈希表的数据结构实现. 内部存在一个哈希表数组, 每个数组元素又有一组长度不确定的链表.</p>
<p><img src="/images/java/Collection_Map/java-collections-hashtable.png"></p>
<p><code>HashMap</code>是基于hashing的原理，我们使用<code>put(key, value)</code>存储对象到HashMap中，使用<code>get(key)</code>从HashMap中获取对象。当我们给<code>put()</code>方法传递键和值时，我们先对键调用<code>hashCode()</code>方法，返回的hashCode用于找到bucket位置来储存<strong>Entry对象</strong>。”这里关键点在于指出，HashMap是在bucket中储存<strong>键对象和值对象</strong>，作为Map.Entry。</p>
<p><code>HashMap</code>在bucket中存储<code>Map.Entry</code>对象，每个Map.Entry保存有key和value。</p>
<h3 id="get的工作原理"><a href="#get的工作原理" class="headerlink" title="get的工作原理"></a>get的工作原理</h3><p>当使用get(key)方法，<br>首先调用hashing方法，利用<code>key.hashcode</code>计算key所在的bucket，找到相应的bucket后。<br>然后遍历bucket中的Map.Entry，首先比对<code>key.hashcode</code>值，其次比对(key值或<code>key.equals</code>方法比对两个对象)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (e.hash == hash &amp;&amp;  ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line"><span class="keyword">return</span> e;</span><br></pre></td></tr></table></figure>
<p>在这里，使用了 <code>&amp;&amp;</code> 的短路特性: 只要第一个条件不满足，不再比较后面的条件；只有前面的条件满足了，才比较后面的条件。<br>等价于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(e.hash==hash)&#123;</span><br><span class="line">  <span class="keyword">if</span>((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))&#123;</span><br><span class="line"><span class="keyword">return</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="key的hashcode相同的情况"><a href="#key的hashcode相同的情况" class="headerlink" title="key的hashcode相同的情况"></a>key的<code>hashcode</code>相同的情况</h3><p>因为<code>hashcode</code>相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。当<code>hashcode</code>相同时，还会调用key.equals比对两个key对象是否相同。</p>
<h3 id="负载因子-0-75"><a href="#负载因子-0-75" class="headerlink" title="负载因子 0.75"></a>负载因子 0.75</h3><p>“如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？”<br>默认的负载因子大小为 0.75，也就是说，当一个map填满了 75% 的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。<br>这个过程叫作 <strong>rehashing</strong>，因为它调用hash方法找到新的bucket位置。</p>
<h3 id="rehashing-过程"><a href="#rehashing-过程" class="headerlink" title="rehashing 过程"></a>rehashing 过程</h3><p>重新调整HashMap大小存在的问题:<br>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候， HashMap 并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。</p>
<h3 id="key类型的选择与提速"><a href="#key类型的选择与提速" class="headerlink" title="key类型的选择与提速"></a>key类型的选择与提速</h3><ul>
<li><p>hashing的概念</p>
</li>
<li><p>HashMap 中解决碰撞的方法</p>
</li>
<li><p>equals()和hashCode()的应用，以及它们在HashMap中的重要性</p>
</li>
<li><p><strong>不可变对象的好处</strong></p>
<p>使用不可变的、声明作final的对象，并且采用合适的<code>equals()</code>和<code>hashCode()</code>方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用 String，Interger 这样的wrapper类作为键是非常好的选择。而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。</p>
<p>不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。<strong>不可变性还有其他的优点如线程安全</strong>。如果你可以仅仅通过将某个field声明成final就能<strong>保证hashCode是不变的</strong>，那么请这么做吧。</p>
<p>因为获取对象的时候要用到<code>equals()</code>和<code>hashCode()</code>方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的<code>hashcode</code>的话，那么碰撞的几率就会小些，这样就能提高<code>HashMap</code>的性能。</p>
</li>
</ul>
<p><strong>复杂度</strong></p>
<h2 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h2><p><strong>特性</strong></p>
<ol>
<li>非线程同步</li>
<li>有序： 可以按照访问顺序或者插入顺序排序</li>
</ol>
<p><strong>实现原理</strong><br>底层使用哈希表与<strong>双向链表</strong>来保存所有元素。其基本操作与父类 HashMap 相似</p>
<p>LinkedHashMap 定义了排序模式 accessOrder，该属性为 boolean 型变量，对于访问顺序，为 true；<br>对于插入顺序，则为 false。一般情况下，不必指定排序模式，其迭代顺序即为默认为插入顺序。</p>
<p>//TODO 排序模式</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p><strong>特性</strong></p>
<ol>
<li><strong>可排序</strong></li>
<li>不是同步的<br><code>SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));</code></li>
</ol>
<p><strong>实现原理</strong><br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/liqizhou/archive/2012/09/27/java%E4%B8%ADtreemap%E5%92%8Ctreeset%E5%AE%9E%E7%8E%B0%E7%BA%A2%E9%BB%91%E6%A0%91.html">红黑树</a>的数据结构, 实现了SortedMap接口</p>
<p><strong>复杂度</strong></p>
<p><strong>应用</strong><br>TreeMap 常用于在接口参数拼接中，以自动对key排序</p>
<h2 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h2><p><strong>特性</strong></p>
<ol>
<li>当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值</li>
</ol>
<p><strong>实现原理</strong><br>使用<a target="_blank" rel="noopener" href="http://www.cnblogs.com/-OYK/archive/2011/10/24/2222874.html" title="Java中的四种引用类型">弱引用</a>作为内部数据的存储方案。 WeakHashMap可以作为简单缓存表的解决方案，<br>当系统内存不够的时候，垃圾收集器会自动的清除没有在其他任何地方被引用的键值对。</p>
<h2 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h2><p><strong>特性</strong></p>
<ol>
<li>Key必须是Enum</li>
<li>EnumMap的key不允许为null，value可以为null，按照key在enum中的顺序进行保存，非线程安全。</li>
</ol>
<p><strong>实现原理</strong></p>
<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p><strong>特性</strong></p>
<ol>
<li><strong>线程安全</strong></li>
<li>性能比HashMap差</li>
</ol>
<p><strong>实现原理</strong><br>哈希表<br>使用 synchronized 锁住所有的读写操作</p>
<p><strong>复杂度</strong></p>
<h1 id="Queue接口"><a href="#Queue接口" class="headerlink" title="Queue接口"></a>Queue接口</h1><blockquote>
<p>// FIXME 实现原理</p>
</blockquote>
<p>队列, 它主要分为两大类:</p>
<ul>
<li>一类是阻塞式队列, 队列满了以后再插入元素则会抛出异常, 主要包括<ul>
<li><code>ArrayBlockQueue</code></li>
<li><code>PriorityBlockingQueue</code></li>
<li><code>LinkedBlockingQueue</code></li>
</ul>
</li>
<li>另一类是双端队列, 支持在头、尾两端插入和移除元素, 主要包括：<ul>
<li><code>ArrayDeque</code></li>
<li><code>LinkedBlockingDeque</code></li>
<li><code>LinkedList</code></li>
</ul>
</li>
</ul>
<p>常见的队列有:</p>
<ol>
<li>ArrayDeque, （数组双端队列）</li>
<li>PriorityQueue, （优先级队列）</li>
<li>ConcurrentLinkedQueue, （基于链表的并发队列）</li>
<li>DelayQueue, （延期阻塞队列）（阻塞队列实现了BlockingQueue接口）</li>
<li>ArrayBlockingQueue, （基于数组的并发阻塞队列）</li>
<li>LinkedBlockingQueue, （基于链表的FIFO阻塞队列）</li>
<li>LinkedBlockingDeque, （基于链表的FIFO双端阻塞队列）</li>
<li>PriorityBlockingQueue, （带优先级的无界阻塞队列）</li>
<li>SynchronousQueue （并发同步阻塞队列）</li>
</ol>
<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><p>无界优先级队列<br><strong>特性</strong></p>
<ol>
<li>有序:<ul>
<li>顺序取决于元素的自然顺序或者创建队列时指定的Comparator</li>
<li>依靠自然顺序的优先级队列还不允许插入不可比较的对象（这样做可能导致 ClassCastException）。</li>
</ul>
</li>
<li>不允许元素为null</li>
<li>优先级队列是无界的<br>有一个内部容量，控制着用于存储队列元素的数组大小。它通常至少等于队列的大小。<br>随着不断向优先级队列添加元素，其容量会自动增加。无需指定容量增加策略的细节。</li>
<li>非线程安全</li>
</ol>
<h2 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h2><p>无界优先级阻塞队列<br><strong>特性</strong></p>
<ol>
<li>有序: 与PriorityQueue相同</li>
<li>不允许元素为null</li>
<li>无界: 资源耗尽时执行add会失败（导致 OutOfMemoryError）</li>
<li>线程安全</li>
</ol>
<h1 id="几种特殊的"><a href="#几种特殊的" class="headerlink" title="几种特殊的"></a>几种特殊的</h1><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a><code>CopyOnWriteArrayList</code></h2><p><code>ArrayList</code>的一个线程安全的变体, 所有可变操作（<code>add</code>、<code>set</code> 等等）都是通过对底层数组进行一次新的复制作为新的内部数组来实现的.</p>
<ul>
<li>这一般需要很大的开销, 但是当遍历操作的数量大大超过可变操作的数量时, 这种方法可能比其他替代方法更有效.</li>
<li>在不能或不想进行同步遍历, 但又需要从并发线程中排除冲突时, 它也很有用.</li>
</ul>
<p><code>“快照”风格</code>的迭代器方法在创建迭代器时使用了对数组状态的引用. 此数组在迭代器的生存期内不会更改, 因此不可能发生冲突, 并且迭代器保证不会抛出<code>ConcurrentModificationException</code>. 创建迭代器以后, 迭代器就不会反映列表的添加、移除或者更改. 在迭代器上进行的元素更改操作（remove、set 和 add）不受支持. 这些方法将抛出 <code>UnsupportedOperationException</code>.</p>
<p>允许使用所有元素, 包括 null.</p>
<p>内存一致性效果：</p>
<p>当存在其他并发 collection 时, 将对象放入 <code>CopyOnWriteArrayList</code> 之前的线程中的操作 <code>happen-before</code><br>随后通过另一线程从 <code>CopyOnWriteArrayList</code> 中访问或移除该元素的操作.</p>
<p>这个类和ArrayList最大的区别就是add(E) 的时候。容器会自动copy一份出来然后再尾部add(E)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">Object[] elements = getArray();</span><br><span class="line"><span class="keyword">int</span> len = elements.length;</span><br><span class="line">Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">newElements[len] = e;</span><br><span class="line">setArray(newElements);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a><code>CopyOnWriteArraySet</code></h2><p>对其所有操作使用内部 <code>CopyOnWriteArrayList</code> 的 Set. 因此, 它共享以下相同的基本属性：</p>
<p>它最适合于具有以下特征的应用程序：</p>
<ul>
<li>set 大小通常保持很小, 只读操作远多于可变操作, 需要在遍历期间防止线程间的冲突.</li>
<li>它是线程安全的.</li>
<li>因为通常需要复制整个基础数组, 所以可变操作（add、set 和 remove 等等）的开销很大.</li>
<li>迭代器不支持可变 remove 操作.</li>
<li>使用迭代器进行遍历的速度很快, 并且不会与其他线程发生冲突. 在构造迭代器时, 迭代器依赖于不变的数组快照.</li>
</ul>
<p><strong>示例用法</strong></p>
<p>以下代码使用一个写时复制（copy-on-write）的 set, 以维护在状态更新时执行某项操作的一组 Handler 对象.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>; ... &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArraySet&lt;Handler&gt; handlers = <span class="keyword">new</span> CopyOnWriteArraySet&lt;Handler&gt;();</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHandler</span><span class="params">(Handler h)</span> </span>&#123;</span><br><span class="line">handlers.add(h);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">long</span> internalState;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">changeState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">internalState = ...;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">changeState();</span><br><span class="line"><span class="keyword">for</span> (Handler handler : handlers)</span><br><span class="line">    handler.handle();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><blockquote>
<p>   //FIXME 重写介绍</p>
</blockquote>
<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><ol>
<li>结构</li>
</ol>
<p><img src="/images/java/Collection_Map/concurrentHashMap-construction.png" alt="c"></p>
<ol>
<li>详情请参考: <a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/index.html">探索 ConcurrentHashMap 高并发性的实现机制</a>的<a href="/Java/collection/ConcurrentHashMap/">本地版</a></li>
</ol>
<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><h2 id="Collections类中的静态方法"><a href="#Collections类中的静态方法" class="headerlink" title="Collections类中的静态方法"></a>Collections类中的静态方法</h2><p>在 Collections类中有多个静态方法，它们可以获取通过同步方法封装非同步集合而得到的集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Collection <span class="title">synchronizedCollention</span><span class="params">(Collection c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">synchronizedList</span><span class="params">(list l)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title">synchronizedMap</span><span class="params">(Map m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set <span class="title">synchronizedSet</span><span class="params">(Set s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SortedMap <span class="title">synchronizedSortedMap</span><span class="params">(SortedMap sm)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SortedSet <span class="title">synchronizedSortedSet</span><span class="params">(SortedSet ss)</span></span></span><br></pre></td></tr></table></figure>
<p>这些方法基本上返回具有同步集合方法版本的新类。比如，为了创建多线程安全且由ArrayList支持的List，可以使用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = Collection.synchronizedList(<span class="keyword">new</span> ArrayList());</span><br></pre></td></tr></table></figure>
<p>注意，ArrayList实例马上封装起来，不存在对未同步化ArrayList的直接引用（即直接封装匿名实例）。这是一种最安全的途径。如果另一个线程要直接引用ArrayList实例，它可以执行非同步修改。</p>
<p>//FIXME 实现原理</p>
<h2 id="CopyOnWrite机制"><a href="#CopyOnWrite机制" class="headerlink" title="CopyOnWrite机制"></a>CopyOnWrite机制</h2><h2 id="synchronized机制"><a href="#synchronized机制" class="headerlink" title="synchronized机制"></a>synchronized机制</h2><h2 id="ReteenLock机制"><a href="#ReteenLock机制" class="headerlink" title="ReteenLock机制"></a>ReteenLock机制</h2><h2 id="ConcurrentHashMap是个特例"><a href="#ConcurrentHashMap是个特例" class="headerlink" title="ConcurrentHashMap是个特例"></a>ConcurrentHashMap是个特例</h2><h1 id="异同点"><a href="#异同点" class="headerlink" title="异同点"></a>异同点</h1><h2 id="Vector-和-ArrayList"><a href="#Vector-和-ArrayList" class="headerlink" title="Vector 和 ArrayList"></a>Vector 和 ArrayList</h2><ol>
<li>Vector是线程同步的, 所以它也是线程安全的, 而ArrayList是线程异步的, 是不安全的. 如果不考虑到线程的安全因素, 一般用ArrayList效率比较高.</li>
<li>如果集合中的元素的数目大于目前集合数组的长度时, Vector增长率为目前数组长度的100%, 而ArrayList增长率为目前数组长度的50%. 如果在集合中使用数据量比较大的数据, 用Vector有一定的优势.</li>
<li>如果查找一个指定位置的数据, Vector和ArrayList使用的时间是相同的, 都是<code>O(1)</code>,这个时候使用Vector和ArrayList都可以; 而如果移动一个指定位置的数据花费的时间为<code>O(n-i)</code>  n为总长度, 这个时候就应该考虑到使用LinkedList, 因为它移动一个指定位置的数据所花费的时间为<code>O(1)</code>, 而查询一个指定位置的数据时花费的时间为<code>O(i)</code>.</li>
</ol>
<h2 id="Arraylist和LinkedList"><a href="#Arraylist和LinkedList" class="headerlink" title="Arraylist和LinkedList"></a>Arraylist和LinkedList</h2><ol>
<li>ArrayList是实现了基于动态数组的数据结构, LinkedList基于链表的数据结构.</li>
<li>对于随机访问<code>get</code>和<code>set</code>, <code>ArrayList</code>优于<code>LinkedList</code>, 因为<code>LinkedList</code>要移动指针.</li>
<li>对于新增和删除操作<code>add</code>和<code>remove</code>, <code>LinkedList</code>比较占优势, 因为<code>ArrayList</code>要移动数据.<br>这一点要看实际情况的. 若只对单条数据插入或删除, <code>ArrayList</code>的速度反而优于<code>LinkedList</code>. 但若是批量随机的插入删除数据, <code>LinkedList</code>的速度大大优于<code>ArrayList</code>. 因为<code>ArrayList</code>每插入一条数据, 要移动插入点及之后的所有数据.</li>
</ol>
<h2 id="HashMap-与-TreeMap"><a href="#HashMap-与-TreeMap" class="headerlink" title="HashMap 与 TreeMap"></a>HashMap 与 TreeMap</h2><ol>
<li>HashMap通过hashcode对其内容进行快速查找, 而TreeMap中所有的元素都保持着某种固定的顺序,<br> 如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）.</li>
<li>在Map 中插入、删除和定位元素, HashMap 是最好的选择. 但如果您要按自然顺序或自定义顺序遍历键, 那么TreeMap会更好.<br>使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现.  这个TreeMap没有调优选项, 因为该树总处于平衡状态.</li>
</ol>
<h2 id="HashMap与HashTable的区别"><a href="#HashMap与HashTable的区别" class="headerlink" title="HashMap与HashTable的区别"></a>HashMap与HashTable的区别</h2><ol>
<li>继承不同<br><code>public class Hashtable extends Dictionary implements Map</code><br><code>public class HashMap  extends AbstractMap implements Map</code></li>
<li>Hashtable 中的方法是同步的, 而HashMap中的方法在缺省情况下是非同步的. 在多线程并发的环境下, 可以直接使用Hashtable, 但是要使用HashMap的话就要自己增加同步处理了.</li>
<li>Hashtable中, key和value都不允许出现null值, 在HashMap中, null可以作为键, 这样的键只有一个; 可以有一个或多个键所对应的值为null. 当get()方法返回null值时, 即可以表示 HashMap中没有该键,也可以表示该键所对应的值为null. 因此, 在HashMap中不能由get()方法来判断HashMap中是否存在某个键, 而应该用containsKey()方法来判断.</li>
<li>两个遍历方式的内部实现上不同.<br>Hashtable、HashMap都使用了 Iterator. 而由于历史原因, Hashtable还使用了Enumeration的方式 .</li>
<li>哈希值的使用不同, HashTable直接使用对象的hashCode. 而HashMap重新计算hash值.</li>
<li>Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式. HashTable中hash数组默认大小是11, 增加的方式是 old*2+1. HashMap中hash数组的默认大小是16, 而且一定是2的指数</li>
</ol>
<h2 id="对集合的选择"><a href="#对集合的选择" class="headerlink" title="对集合的选择"></a>对集合的选择</h2><h3 id="对List的选择"><a href="#对List的选择" class="headerlink" title="对List的选择"></a>对List的选择</h3><ol>
<li>对于随机查询与迭代遍历操作, 数组比所有的容器都要快. 所以在随机访问中一般使用ArrayList</li>
<li>LinkedList使用双向链表对元素的增加和删除提供了非常好的支持, 而ArrayList执行增加和删除元素需要进行元素位移.</li>
<li>对于Vector而已, 我们一般都是避免使用.</li>
<li>将ArrayList当做首选, 毕竟对于集合元素而已我们都是进行遍历, 只有当程序的性能因为List的频繁插入和删除而降低时, 再考虑LinkedList.</li>
</ol>
<h3 id="对Set的选择"><a href="#对Set的选择" class="headerlink" title="对Set的选择"></a>对Set的选择</h3><ol>
<li><code>HashSet</code>由于使用<code>HashCode</code>实现, 所以在某种程度上来说它的性能永远比<code>TreeSet</code>要好, 尤其是进行增加和查找操作.</li>
<li>虽然<code>TreeSet</code>没有<code>HashSet</code>性能好, 但是由于它可以维持元素的排序, 所以它还是存在用武之地的.</li>
</ol>
<h3 id="对Map的选择"><a href="#对Map的选择" class="headerlink" title="对Map的选择"></a>对Map的选择</h3><ol>
<li>HashMap与HashSet同样, 支持快速查询. 虽然HashTable的速度也不慢, 但是在HashMap面前还是稍微慢了些, 所以HashMap在查询方面可以取代HashTable.</li>
<li>由于TreeMap需要维持内部元素的顺序, 所以它通常要比HashMap和HashTable慢.</li>
</ol>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组复制System-arrayCopy"><a href="#数组复制System-arrayCopy" class="headerlink" title="数组复制System.arrayCopy"></a>数组复制<code>System.arrayCopy</code></h3><p>该方法是个JNI函数, 是在JVM中实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*从src的srcPos位置复制数据到dest的destPos位置, 长度为length</span></span><br><span class="line"><span class="comment">*src - 源数组.</span></span><br><span class="line"><span class="comment">*srcPos - 源数组中的起始位置.</span></span><br><span class="line"><span class="comment">*dest - 目标数组.</span></span><br><span class="line"><span class="comment">*destPos - 目标数据中的起始位置.</span></span><br><span class="line"><span class="comment">*length - 要复制的数组元素的数量.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="Arrays-copyOf"><a href="#Arrays-copyOf" class="headerlink" title="Arrays.copyOf"></a>Arrays.copyOf</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 由U类型复制为T类型？</span></span><br><span class="line"><span class="comment">* original - 要复制的数组</span></span><br><span class="line"><span class="comment">* newLength - 要返回的副本的长度</span></span><br><span class="line"><span class="comment">* newType - 要返回的副本的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">  T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">? (T[]) <span class="keyword">new</span> Object[newLength]</span><br><span class="line">: (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">  System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line"> Math.min(original.length, newLength));</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Arrays-asList-将数组转换为ArrayList"><a href="#Arrays-asList-将数组转换为ArrayList" class="headerlink" title="Arrays.asList: 将数组转换为ArrayList"></a>Arrays.asList: 将数组转换为ArrayList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;T&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Arrays.asList返回的<code>ArrayList</code>并不是<code>java.util.ArrayList</code>, 只是<code>Arrays</code>的内部类. 该类只提供了一些基本的操作,</p>
<ol>
<li>size：元素数量</li>
<li>toArray：转换为数组, 实现了数组的浅拷贝.</li>
<li>get：获得指定元素.</li>
<li>contains：是否包含某元素.<br>asList返回的是一个长度不可变的列表. 数组是多长, 转换成的列表是多长, 我们是无法通过add、remove来增加或者减少其长度的<br>我们经常需要使用到Arrays这个工具的asList()方法将其转换成列表. 方便是方便, 但是有时候会出现莫名其妙的问题. 如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span>[] datas = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">  List list = Arrays.asList(datas);</span><br><span class="line">  System.out.println(list.size());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<p>结果是1, 为什么会是1而不是5呢？先注意这个参数: T…a, 这个参数是一个泛型的变长参数, 我们知道 <strong>基本数据类型是不可能泛型化的</strong> ,也就是说8个基本数据类型是不可作为泛型参数的, 但是为什么编译器没有报错呢？这是因为数组会当做一个对象来处理, 它是可以泛型的, 所以我们的程序是把一个int型的数组作为了T的类型,所以在转换之后List中就只会存在一个类型为int数组的元素了.<br>所以我们这样的程序<code>System.out.println(datas.equals(list.get(0)));</code>输出结果肯定是<code>true</code>.<br>当然如果将int改为Integer, 则长度就会变成5了.</p>
<h3 id="Arrays-fill"><a href="#Arrays-fill" class="headerlink" title="Arrays.fill"></a>Arrays.fill</h3><p>使用值填充数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">Arrays.fill(a,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 使用0填充数组a</span></span><br></pre></td></tr></table></figure>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="Map的遍历"><a href="#Map的遍历" class="headerlink" title="Map的遍历"></a>Map的遍历</h3><p>Map的遍历,都是需要转换为Collection</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = ...;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>由Map生成<code>Collection</code>, 获取所有的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; values = map.values();</span><br><span class="line">Iterator&lt;String&gt; iterator = values.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">	System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>由Map.keySet, 遍历key值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">Iterator&lt;String&gt; keyIterator = keySet.iterator();</span><br></pre></td></tr></table></figure></li>
<li><p>获取Map.Entry类型的Set</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; entryIterator = entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span> (entryIterator.hasNext()) &#123;</span><br><span class="line">	Map.Entry&lt;String, String&gt; entry = entryIterator.next();</span><br><span class="line">	String key = entry.getKey();</span><br><span class="line">	String value = entry.getValue();</span><br><span class="line">	System.out.println(key + <span class="string">&quot;\t&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Collection的遍历方法"><a href="#Collection的遍历方法" class="headerlink" title="Collection的遍历方法"></a>Collection的遍历方法</h3></li>
<li><p>Iterator 迭代子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; values2 = map.values();</span><br><span class="line">Iterator&lt;String&gt; iterator2 = values2.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">	System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>foreach</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String valueItem : values2) &#123;</span><br><span class="line">	System.out.println(valueItem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>List特有的遍历方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">assert</span> list != <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">	System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当然也可以写成</span></span><br><span class="line"><span class="keyword">for</span> (String aList : list) &#123;</span><br><span class="line">	System.out.println(aList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>List遍历方式有三种:</p>
<ul>
<li>下标遍历</li>
<li>Iterator遍历</li>
<li>Foreach遍历（最快）</li>
</ul>
</li>
</ol>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><blockquote>
<p>FIXME 排序：集合自带排序 对集合排序</p>
</blockquote>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="Java中有多少种数据结构-分别是什么？"><a href="#Java中有多少种数据结构-分别是什么？" class="headerlink" title="Java中有多少种数据结构, 分别是什么？"></a>Java中有多少种数据结构, 分别是什么？</h2><pre><code>- List：是列表, 有下标值, 存储元素可以重复, 遍历元素是有序的.
- Set：是散列集, 无下标值, 存储元素不可重复, 遍历元素时无序的.
- Map：是以键值对存储, 一个key一个value, key不可以重复, value可以重复.
- 数组：指定类型, 固定长度, 元素存储地址是连续的.
- 树：元素以树形结构存储, 只有一个根节点.
- 栈：元素是先进后出, 后进先出.
- 向量：动态数组, 可以存储任何类型元素, 动态长度, 元素存储地址是连续的.
- 队列：元素存储是排列有序的, 一定保证先进的先出, 后进的后出.</code></pre>
<hr>
<p>修改记录:</p>
<ol>
<li>HashMap的详细实现原理 重写ConcurrentHashMap介绍     2016-08-20</li>
</ol>
<hr>
<p>参考文献:</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://cmsblogs.com/?p=106">java提高篇（二十）集合大家族</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/softwave/article/details/4166598">Java集合类详解</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/index.html">探索 ConcurrentHashMap 高并发性的实现机制</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/collection/ConcurrentHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/collection/ConcurrentHashMap/" class="post-title-link" itemprop="url">探索 ConcurrentHashMap 高并发性的实现机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-05-12 08:44:00" itemprop="dateCreated datePublished" datetime="2016-05-12T08:44:00+08:00">2016-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-24 12:58:51" itemprop="dateModified" datetime="2021-04-24T12:58:51+08:00">2021-04-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/index.html">转载自 探索 ConcurrentHashMap 高并发性的实现机制</a></p>
<p>ConcurrentHashMap 是 Java concurrent 包的重要成员。本文将结合 Java 内存模型，来分析 ConcurrentHashMap 的 JDK 源代码。通过本文，读者将了解到 ConcurrentHashMap 高并发性的具体实现机制。这对于我们在实际应用中更加高效的使用它是很有帮助的。</p>
<p>[TOC]</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ConcurrentHashMap 是 util.concurrent 包的重要成员。本文将结合 Java 内存模型，分析 JDK 源代码，探索 ConcurrentHashMap 高并发的具体实现机制。</p>
<p>由于 ConcurrentHashMap 的源代码实现依赖于 Java 内存模型，所以阅读本文需要读者了解 <a href="/java">Java 内存模型</a>。同时，ConcurrentHashMap 的源代码会涉及到<a href="/hashing">散列算法</a>和链表数据结构，所以，读者需要对散列算法和基于链表的数据结构有所了解。</p>
<h2 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h2><p>由于 ConcurrentHashMap 是建立在 Java 内存模型基础上的，为了更好的理解 ConcurrentHashMap，让我们首先来了解一下 Java 的内存模型。</p>
<p>Java 语言的内存模型由一些规则组成，这些规则确定线程对内存的访问如何排序以及何时可以确保它们对线程是可见的。下面我们将分别介绍 Java 内存模型的重排序，内存可见性和 happens-before 关系。</p>
<h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>内存模型描述了程序的可能行为。具体的编译器实现可以产生任意它喜欢的代码 – <strong>只要所有执行这些代码产生的结果，能够和内存模型预测的结果保持一致</strong>。这为编译器实现者提供了很大的自由，包括操作的重排序。</p>
<p>编译器生成指令的次序，可以不同于源代码所暗示的“显然”版本。重排序后的指令，对于优化执行以及成熟的全局寄存器分配算法的使用，都是大有脾益的，它使得程序在计算性能上有了很大的提升。</p>
<p>重排序类型包括：</p>
<ul>
<li>编译器生成指令的次序，可以不同于源代码所暗示的“显然”版本。</li>
<li>处理器可以乱序或者并行的执行指令。</li>
<li>缓存会改变写入提交到主内存的变量的次序。</li>
</ul>
<h3 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h3><p>由于现代可共享内存的多处理器架构可能导致一个线程无法马上（甚至永远）看到另一个线程操作产生的结果。所以 Java 内存模型规定了 JVM 的一种最小保证：什么时候写入一个变量对其他线程可见。</p>
<p>在现代可共享内存的多处理器体系结构中每个处理器都有自己的缓存，并周期性的与主内存协调一致。假设线程 A 写入一个变量值 V，随后另一个线程 B 读取变量 V 的值，在下列情况下，线程 B 读取的值可能不是线程 A 写入的最新值：</p>
<ul>
<li>执行线程 A 的处理器把变量 V 缓存到寄存器中。</li>
<li>执行线程 A 的处理器把变量 V 缓存到自己的缓存中，但还没有同步刷新到主内存中去。</li>
<li>执行线程 B 的处理器的缓存中有变量 V 的旧值。</li>
</ul>
<h3 id="Happens-before-关系"><a href="#Happens-before-关系" class="headerlink" title="Happens-before 关系"></a>Happens-before 关系</h3><p>happens-before 关系保证：如果线程 A 与线程 B 满足 happens-before 关系，则线程 A 执行动作的结果对于线程 B 是可见的。如果两个操作未按 happens-before 排序，JVM 将可以对他们任意重排序。</p>
<p>下面介绍几个与理解 ConcurrentHashMap 有关的 happens-before 关系法则：</p>
<ol>
<li>程序次序法则：如果在程序中，所有动作 A 出现在动作 B 之前，则线程中的每动作 A 都 happens-before 于该线程中的每一个动作 B。</li>
<li>监视器锁法则：对一个监视器的解锁 happens-before 于每个后续对同一监视器的加锁。</li>
<li>Volatile 变量法则：对 Volatile 域的写入操作 happens-before 于每个后续对同一 Volatile 的读操作。</li>
<li>传递性：如果 A happens-before 于 B，且 B happens-before C，则 A happens-before C</li>
</ol>
<h2 id="ConcurrentHashMap-的结构分析"><a href="#ConcurrentHashMap-的结构分析" class="headerlink" title="ConcurrentHashMap 的结构分析"></a>ConcurrentHashMap 的结构分析</h2><p>为了更好的理解 <code>ConcurrentHashMap</code> 高并发的具体实现，让我们先探索它的结构模型。</p>
<p><code>ConcurrentHashMap</code> 类中包含两个静态内部类 <code>HashEntry</code> 和 <code>Segment</code> 。 <code>HashEntry</code> 用来封装映射表的键 / 值对；<code>Segment</code> 用来充当锁的角色，每个 <code>Segment</code> 对象守护整个散列映射表的若干个桶。每个桶是由若干个 <code>HashEntry</code> 对象链接起来的链表。一个 <code>ConcurrentHashMap</code> 实例中包含由若干个 <code>Segment</code> 对象组成的数组。</p>
<h3 id="HashEntry-类"><a href="#HashEntry-类" class="headerlink" title="HashEntry 类"></a>HashEntry 类</h3><p>HashEntry 用来封装散列映射表中的键值对。在 HashEntry 类中，key，hash 和 next 域都被声明为 final 型，value 域被声明为 volatile 型。</p>
<p>清单 1.HashEntry 类的定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123; </span><br><span class="line">    <span class="keyword">final</span> K key;                       <span class="comment">// 声明 key 为 final 型</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;                   <span class="comment">// 声明 hash 值为 final 型 </span></span><br><span class="line">    <span class="keyword">volatile</span> V value;                 <span class="comment">// 声明 value 为 volatile 型</span></span><br><span class="line">    <span class="keyword">final</span> HashEntry&lt;K,V&gt; next;      <span class="comment">// 声明 next 为 final 型 </span></span><br><span class="line"></span><br><span class="line">    HashEntry(K key, <span class="keyword">int</span> hash, HashEntry&lt;K,V&gt; next, V value) &#123; </span><br><span class="line">        <span class="keyword">this</span>.key = key; </span><br><span class="line">        <span class="keyword">this</span>.hash = hash; </span><br><span class="line">        <span class="keyword">this</span>.next = next; </span><br><span class="line">        <span class="keyword">this</span>.value = value; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ConcurrentHashMap 中，在散列时如果产生“碰撞”，将采用“分离链接法”来处理“碰撞”：把“碰撞”的 HashEntry 对象链接成一个链表。由于 HashEntry 的 next 域为 final 型，所以新节点只能在链表的表头处插入。下图是在一个空桶中依次插入 A，B，C 三个 HashEntry 对象后的结构图：</p>
<p><img src="/images/java/Collection_Map/concurrentHashMap_01.jpg"></p>
<p>图 1. 插入三个节点后桶的结构示意图：</p>
<p>注意：由于只能在表头插入，所以链表中节点的顺序和插入的顺序相反。</p>
<p>避免热点域</p>
<p>在 <code>ConcurrentHashMap</code>中，每一个 Segment 对象都有一个 count 对象来表示本 Segment 中包含的 <code>HashEntry</code> 对象的个数。这样当需要更新计数器时，不用锁定整个 <code>ConcurrentHashMap</code>。</p>
<h3 id="Segment-类"><a href="#Segment-类" class="headerlink" title="Segment 类"></a>Segment 类</h3><p>Segment 类继承于 <code>ReentrantLock</code> 类，从而使得 Segment 对象能充当锁的角色。每个 Segment 对象用来守护其（成员对象 table 中）包含的若干个桶。</p>
<p>table 是一个由 HashEntry 对象组成的数组。table 数组的每一个数组成员就是散列映射表的一个桶。</p>
<p>count 变量是一个计数器，它表示每个 Segment 对象管理的 table 数组（若干个 HashEntry 组成的链表）包含的 HashEntry 对象的个数。每一个 Segment 对象都有一个 count 对象来表示本 Segment 中包含的 HashEntry 对象的总数。注意，之所以在每个 Segment 对象中包含一个计数器，而不是在 ConcurrentHashMap 中使用全局的计数器，是为了避免出现“热点域”而影响 ConcurrentHashMap 的并发性。</p>
<p>清单 2.Segment 类的定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 在本 segment 范围内，包含的 HashEntry 元素的个数</span></span><br><span class="line"><span class="comment">     * 该变量被声明为 volatile 型</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * table 被更新的次数</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 当 table 中包含的 HashEntry 元素的个数超过本变量值时，触发 table 的再散列</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> threshold; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * table 是由 HashEntry 对象组成的数组</span></span><br><span class="line"><span class="comment">     * 如果散列时发生碰撞，碰撞的 HashEntry 对象就以链表的形式链接成一个链表</span></span><br><span class="line"><span class="comment">     * table 数组的数组成员代表散列映射表的一个桶</span></span><br><span class="line"><span class="comment">     * 每个 table 守护整个 ConcurrentHashMap 包含桶总数的一部分</span></span><br><span class="line"><span class="comment">     * 如果并发级别为 16，table 则守护 ConcurrentHashMap 包含的桶总数的 1/16 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 装载因子</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor; </span><br><span class="line"></span><br><span class="line">    Segment(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> lf) &#123; </span><br><span class="line">        loadFactor = lf; </span><br><span class="line">        setTable(HashEntry.&lt;K,V&gt;newArray(initialCapacity)); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 设置 table 引用到这个新生成的 HashEntry 数组</span></span><br><span class="line"><span class="comment">     * 只能在持有锁或构造函数中调用本方法</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTable</span><span class="params">(HashEntry&lt;K,V&gt;[] newTable)</span> </span>&#123; </span><br><span class="line">        <span class="comment">// 计算临界阀值为新数组的长度与装载因子的乘积</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)(newTable.length * loadFactor); </span><br><span class="line">        table = newTable; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 根据 key 的散列值，找到 table 中对应的那个桶（table 数组的某个数组成员）</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="function">HashEntry&lt;K,V&gt; <span class="title">getFirst</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123; </span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class="line">        <span class="comment">// 把散列值与 table 数组长度减 1 的值相“与”，</span></span><br><span class="line">        <span class="comment">// 得到散列值对应的 table 数组的下标</span></span><br><span class="line">        <span class="comment">// 然后返回 table 数组中此下标对应的 HashEntry 元素</span></span><br><span class="line">        <span class="keyword">return</span> tab[hash &amp; (tab.length - <span class="number">1</span>)]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图是依次插入 ABC 三个 HashEntry 节点后，Segment 的结构示意图。</p>
<p><img src="/images/java/Collection_Map/concurrentHashMap_02.jpg"></p>
<p>图 2. 插入三个节点后 Segment 的结构示意图：</p>
<h3 id="ConcurrentHashMap-类"><a href="#ConcurrentHashMap-类" class="headerlink" title="ConcurrentHashMap 类"></a>ConcurrentHashMap 类</h3><p>ConcurrentHashMap 在默认并发级别会创建包含 16 个 Segment 对象的数组。每个 Segment 的成员对象 table 包含若干个散列表的桶。每个桶是由 HashEntry 链接起来的一个链表。如果键能均匀散列，每个 Segment 大约守护整个散列表中桶总数的 1/16。</p>
<p>清单 3.ConcurrentHashMap 类的定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span></span><br><span class="line"><span class="class">       <span class="keyword">implements</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 散列映射表的默认初始容量为 16，即初始默认为 16 个桶</span></span><br><span class="line"><span class="comment">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> 	 <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY= <span class="number">16</span>; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 散列映射表的默认装载因子为 0.75，该值是 table 中包含的 HashEntry 元素的个数与</span></span><br><span class="line"><span class="comment">* table 数组长度的比值</span></span><br><span class="line"><span class="comment">    * 当 table 中包含的 HashEntry 元素的个数超过了 table 数组的长度与装载因子的乘积时，</span></span><br><span class="line"><span class="comment">* 将触发 再散列</span></span><br><span class="line"><span class="comment">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR= <span class="number">0.75f</span>; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 散列表的默认并发级别为 16。该值表示当前更新线程的估计数</span></span><br><span class="line"><span class="comment">    * 在构造函数中没有指定这个参数时，使用本参数</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL= <span class="number">16</span>; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * segments 的掩码值</span></span><br><span class="line"><span class="comment">    * key 的散列码的高位用来选择具体的 segment </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> segmentMask; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 偏移量</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> segmentShift; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 由 Segment 对象组成的数组</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 创建一个带有指定初始容量、加载因子和并发级别的新的空映射。</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, </span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123; </span><br><span class="line">       <span class="keyword">if</span>(!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || </span><br><span class="line">concurrencyLevel &lt;= <span class="number">0</span>) </span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(); </span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(concurrencyLevel &gt; MAX_SEGMENTS) </span><br><span class="line">           concurrencyLevel = MAX_SEGMENTS; </span><br><span class="line"></span><br><span class="line">       <span class="comment">// 寻找最佳匹配参数（不小于给定参数的最接近的 2 次幂） </span></span><br><span class="line">       <span class="keyword">int</span> sshift = <span class="number">0</span>; </span><br><span class="line">       <span class="keyword">int</span> ssize = <span class="number">1</span>; </span><br><span class="line">       <span class="keyword">while</span>(ssize &lt; concurrencyLevel) &#123; </span><br><span class="line">           ++sshift; </span><br><span class="line">           ssize &lt;&lt;= <span class="number">1</span>; </span><br><span class="line">       &#125; </span><br><span class="line">       segmentShift = <span class="number">32</span> - sshift;       <span class="comment">// 偏移量值</span></span><br><span class="line">       segmentMask = ssize - <span class="number">1</span>;           <span class="comment">// 掩码值 </span></span><br><span class="line">       <span class="keyword">this</span>.segments = Segment.newArray(ssize);   <span class="comment">// 创建数组</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY) </span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY; </span><br><span class="line">       <span class="keyword">int</span> c = initialCapacity / ssize; </span><br><span class="line">       <span class="keyword">if</span>(c * ssize &lt; initialCapacity) </span><br><span class="line">           ++c; </span><br><span class="line">       <span class="keyword">int</span> cap = <span class="number">1</span>; </span><br><span class="line">       <span class="keyword">while</span>(cap &lt; c) </span><br><span class="line">           cap &lt;&lt;= <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">       <span class="comment">// 依次遍历每个数组元素</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.segments.length; ++i) </span><br><span class="line">           <span class="comment">// 初始化每个数组元素引用的 Segment 对象</span></span><br><span class="line"><span class="keyword">this</span>.segments[i] = <span class="keyword">new</span> Segment&lt;K,V&gt;(cap, loadFactor); </span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * 创建一个带有默认初始容量 (16)、默认加载因子 (0.75) 和 默认并发级别 (16) </span></span><br><span class="line"><span class="comment"> * 的空散列映射表。</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">()</span> </span>&#123; </span><br><span class="line">       <span class="comment">// 使用三个默认参数，调用上面重载的构造函数来创建空散列映射表</span></span><br><span class="line"><span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>}</p>
<p>下面是 ConcurrentHashMap 的结构示意图。</p>
<p><img src="/images/java/Collection_Map/concurrentHashMap_03.jpg"></p>
<p>图 3.ConcurrentHashMap 的结构示意图：</p>
<h2 id="用分离锁实现多个线程间的并发写操作"><a href="#用分离锁实现多个线程间的并发写操作" class="headerlink" title="用分离锁实现多个线程间的并发写操作"></a>用分离锁实现多个线程间的并发写操作</h2><p>在 ConcurrentHashMap 中，线程对映射表做读操作时，<em>一般情况下</em>不需要加锁就可以完成，对容器做结构性修改的操作才需要加锁。下面以 put 操作为例说明对 ConcurrentHashMap 做结构性修改的过程。</p>
<p>首先，根据 key 计算出对应的 hash 值：</p>
<p>清单 4.Put 方法的实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)          <span class="comment">//ConcurrentHashMap 中不允许用 null 作为映射值</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); </span><br><span class="line">    <span class="keyword">int</span> hash = hash(key.hashCode());        <span class="comment">// 计算键对应的散列码</span></span><br><span class="line">    <span class="comment">// 根据散列码找到对应的 Segment </span></span><br><span class="line">    <span class="keyword">return</span> segmentFor(hash).put(key, hash, value, <span class="keyword">false</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，根据 hash 值找到对应的<code>Segment</code> 对象：</p>
<p>清单 5.根据 hash 值找到对应的 Segment</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 使用 key 的散列码来得到 segments 数组中对应的 Segment </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">final</span> Segment&lt;K,V&gt; <span class="title">segmentFor</span><span class="params">(<span class="keyword">int</span> hash)</span> </span>&#123; </span><br><span class="line"><span class="comment">// 将散列值右移 segmentShift 个位，并在高位填充 0 </span></span><br><span class="line"><span class="comment">// 然后把得到的值与 segmentMask 相“与”</span></span><br><span class="line"><span class="comment">// 从而得到 hash 值对应的 segments 数组的下标值</span></span><br><span class="line"><span class="comment">// 最后根据下标值返回散列码对应的 Segment 对象</span></span><br><span class="line">    <span class="keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在这个 Segment 中执行具体的 put 操作：</p>
<p>清单 6.在 Segment 中执行具体的 put 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123; </span><br><span class="line">    lock();  <span class="comment">// 加锁，这里是锁定某个 Segment 对象而非整个 ConcurrentHashMap </span></span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">int</span> c = count; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c++ &gt; threshold)     <span class="comment">// 如果超过再散列的阈值</span></span><br><span class="line">            rehash();              <span class="comment">// 执行再散列，table 数组的长度将扩充一倍</span></span><br><span class="line"></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class="line">        <span class="comment">// 把散列码值与 table 数组的长度减 1 的值相“与”</span></span><br><span class="line">        <span class="comment">// 得到该散列码对应的 table 数组的下标值</span></span><br><span class="line">        <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>); </span><br><span class="line">        <span class="comment">// 找到散列码对应的具体的那个桶</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = tab[index]; </span><br><span class="line"></span><br><span class="line">        HashEntry&lt;K,V&gt; e = first; </span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key))) </span><br><span class="line">            e = e.next; </span><br><span class="line"></span><br><span class="line">        V oldValue; </span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;            <span class="comment">// 如果键 / 值对以经存在</span></span><br><span class="line">            oldValue = e.value; </span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent) </span><br><span class="line">                e.value = value;    <span class="comment">// 设置 value 值</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;                        <span class="comment">// 键 / 值对不存在 </span></span><br><span class="line">            oldValue = <span class="keyword">null</span>; </span><br><span class="line">            ++modCount;         <span class="comment">// 要添加新节点到链表中，所以 modCont 要加 1  </span></span><br><span class="line">            <span class="comment">// 创建新节点，并添加到链表的头部 </span></span><br><span class="line">            tab[index] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(key, hash, first, value); </span><br><span class="line">            count = c;               <span class="comment">// 写 count 变量</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> oldValue; </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        unlock();                     <span class="comment">// 解锁</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<br>这里的加锁操作是针对（键的 hash 值对应的）某个具体的 Segment，锁定的是该 <code>Segment</code> 而不是整个 <code>ConcurrentHashMap</code>。因为插入键 / 值对操作只是在这个 Segment 包含的某个桶中完成，不需要锁定整个<code>ConcurrentHashMap</code>。此时，其他写线程对另外 15 个<code>Segment</code> 的加锁并不会因为当前线程对这个 Segment 的加锁而阻塞。同时，所有读线程几乎不会因本线程的加锁而阻塞（除非读线程刚好读到这个 Segment 中某个 <code>HashEntry</code> 的 <code>value</code> 域的值为 null，此时需要加锁后重新读取该值）。</p>
<p>相比较于 <code>HashTable</code> 和由同步包装器包装的 <code>HashMap</code>每次只能有一个线程执行读或写操作，<code>ConcurrentHashMap</code> 在并发访问性能上有了质的提高。<em>在理想状态下</em>，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设置为 16），及任意数量线程的读操作。</p>
<h2 id="用-HashEntery-对象的不变性来降低读操作对加锁的需求"><a href="#用-HashEntery-对象的不变性来降低读操作对加锁的需求" class="headerlink" title="用 HashEntery 对象的不变性来降低读操作对加锁的需求"></a>用 HashEntery 对象的不变性来降低读操作对加锁的需求</h2><p>在代码清单“HashEntry 类的定义”中我们可以看到，HashEntry 中的 key，hash，next 都声明为 final 型。这意味着，不能把节点添加到链接的中间和尾部，也不能在链接的中间和尾部删除节点。这个特性可以保证：在访问某个节点时，这个节点之后的链接不会被改变。这个特性可以大大降低处理链表时的复杂性。</p>
<p>同时，HashEntry 类的 value 域被声明为 Volatile 型，Java 的内存模型可以保证：某个写线程对 value 域的写入马上可以被后续的某个读线程“看”到。在 ConcurrentHashMap 中，不允许用 null 作为键和值，<strong>当读线程读到某个 HashEntry 的 value 域的值为 null 时，便知道产生了冲突——发生了重排序现象，需要加锁后重新读入这个 value 值。</strong>这些特性互相配合，使得读线程即使在不加锁状态下，也能正确访问 ConcurrentHashMap。</p>
<p>下面我们分别来分析线程写入的两种情形：对散列表做非结构性修改的操作和对散列表做结构性修改的操作。</p>
<p>非结构性修改操作只是更改某个 HashEntry 的 value 域的值。由于对 Volatile 变量的写入操作将与随后对这个变量的读操作进行同步。当一个写线程修改了某个 HashEntry 的 value 域后，另一个读线程读这个值域，Java 内存模型能够保证读线程读取的一定是更新后的值。所以，写线程对链表的非结构性修改能够被后续不加锁的读线程“看到”。</p>
<p>对 ConcurrentHashMap 做结构性修改，实质上是对某个桶指向的链表做结构性修改。如果能够确保：在读线程遍历一个链表期间，写线程对这个链表所做的结构性修改不影响读线程继续正常遍历这个链表。那么读 / 写线程之间就可以安全并发访问这个 ConcurrentHashMap。</p>
<p>结构性修改操作包括 put，remove，clear。下面我们分别分析这三个操作。</p>
<p>clear 操作只是把 ConcurrentHashMap 中所有的桶“置空”，每个桶之前引用的链表依然存在，只是桶不再引用到这些链表（所有链表的结构并没有被修改）。正在遍历某个链表的读线程依然可以正常执行对该链表的遍历。</p>
<p>从上面的代码清单“在 Segment 中执行具体的 put 操作”中，我们可以看出：put 操作如果需要插入一个新节点到链表中时 , 会在链表头部插入这个新节点。此时，链表中的原有节点的链接并没有被修改。也就是说：插入新健 / 值对到链表中的操作不会影响读线程正常遍历这个链表。</p>
<p>下面来分析 remove 操作，先让我们来看看 remove 操作的源代码实现。</p>
<p>清单 7.remove 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key, <span class="keyword">int</span> hash, Object value)</span> </span>&#123; </span><br><span class="line">lock();         <span class="comment">// 加锁</span></span><br><span class="line"><span class="keyword">try</span>&#123; </span><br><span class="line">    <span class="keyword">int</span> c = count - <span class="number">1</span>; </span><br><span class="line">    HashEntry&lt;K,V&gt;[] tab = table; </span><br><span class="line">    <span class="comment">// 根据散列码找到 table 的下标值</span></span><br><span class="line">    <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>); </span><br><span class="line">    <span class="comment">// 找到散列码对应的那个桶</span></span><br><span class="line">    HashEntry&lt;K,V&gt; first = tab[index]; </span><br><span class="line">    HashEntry&lt;K,V&gt; e = first; </span><br><span class="line">    <span class="keyword">while</span>(e != <span class="keyword">null</span>&amp;&amp; (e.hash != hash || !key.equals(e.key))) </span><br><span class="line">        e = e.next; </span><br><span class="line"></span><br><span class="line">    V oldValue = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">if</span>(e != <span class="keyword">null</span>) &#123; </span><br><span class="line">        V v = e.value; </span><br><span class="line">        <span class="keyword">if</span>(value == <span class="keyword">null</span>|| value.equals(v)) &#123; <span class="comment">// 找到要删除的节点</span></span><br><span class="line">            oldValue = v; </span><br><span class="line">            ++modCount; </span><br><span class="line">            <span class="comment">// 所有处于待删除节点之后的节点原样保留在链表中</span></span><br><span class="line">            <span class="comment">// 所有处于待删除节点之前的节点被克隆到新链表中</span></span><br><span class="line">            HashEntry&lt;K,V&gt; newFirst = e.next;<span class="comment">// 待删节点的后继结点</span></span><br><span class="line">            <span class="keyword">for</span>(HashEntry&lt;K,V&gt; p = first; p != e; p = p.next) </span><br><span class="line">                newFirst = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(p.key, p.hash, </span><br><span class="line">                                              newFirst, p.value); </span><br><span class="line">            <span class="comment">// 把桶链接到新的头结点</span></span><br><span class="line">            <span class="comment">// 新的头结点是原链表中，删除节点之前的那个节点</span></span><br><span class="line">            tab[index] = newFirst; </span><br><span class="line">            count = c;      <span class="comment">// 写 count 变量</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> oldValue; </span><br><span class="line">&#125; <span class="keyword">finally</span>&#123; </span><br><span class="line">    unlock();               <span class="comment">// 解锁</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 get 操作一样，首先根据散列码找到具体的链表；然后遍历这个链表找到要删除的节点；最后把待删除节点之后的所有节点原样保留在新链表中，把待删除节点之前的每个节点克隆到新链表中。下面通过图例来说明 remove 操作。假设写线程执行 remove 操作，要删除链表的 C 节点，另一个读线程同时正在遍历这个链表。</p>
<p><img src="/images/java/Collection_Map/concurrentHashMap_04.jpg"></p>
<p>图 4. 执行删除之前的原链表：</p>
<p><img src="/images/java/Collection_Map/concurrentHashMap_05.jpg"></p>
<p>图 5. 执行删除之后的新链表</p>
<p>从上图可以看出，删除节点 C 之后的所有节点原样保留到新链表中；删除节点 C 之前的每个节点被克隆到新链表中，<em>注意：它们在新链表中的链接顺序被反转了</em>。</p>
<p>在执行 remove 操作时，原始链表并没有被修改，也就是说：读线程不会受同时执行 remove 操作的并发写线程的干扰。</p>
<p>综合上面的分析我们可以看出，写线程对某个链表的结构性修改不会影响其他的并发读线程对这个链表的遍历访问。</p>
<h2 id="用-Volatile-变量协调读写线程间的内存可见性"><a href="#用-Volatile-变量协调读写线程间的内存可见性" class="headerlink" title="用 Volatile 变量协调读写线程间的内存可见性"></a>用 Volatile 变量协调读写线程间的内存可见性</h2><p>由于内存可见性问题，未正确同步的情况下，写线程写入的值可能并不为后续的读线程可见。</p>
<p>下面以写线程 M 和读线程 N 来说明 ConcurrentHashMap 如何协调读 / 写线程间的内存可见性问题。</p>
<p>图 6. 协调读 - 写线程间的内存可见性的示意图：</p>
<p><img src="/images/java/Collection_Map/concurrentHashMap_06.jpg"></p>
<p>假设线程 M 在写入了 volatile 型变量 count 后，线程 N 读取了这个 volatile 型变量 count。</p>
<p>根据 happens-before 关系法则中的程序次序法则，A appens-before 于 B，C happens-before D。</p>
<p>根据 Volatile 变量法则，B happens-before C。</p>
<p>根据传递性，连接上面三个 happens-before 关系得到：A appens-before 于 B； B appens-before C；C happens-before D。也就是说：写线程 M 对链表做的结构性修改，在读线程 N 读取了同一个 volatile 变量后，对线程 N 也是可见的了。</p>
<p>虽然线程 N 是在未加锁的情况下访问链表。Java 的内存模型可以保证：只要之前对链表做结构性修改操作的写线程 M 在退出写方法前写 volatile 型变量 count，读线程 N 在读取这个 volatile 型变量 count 后，就一定能“看到”这些修改。</p>
<p>ConcurrentHashMap 中，每个 Segment 都有一个变量 count。它用来统计 Segment 中的 HashEntry 的个数。这个变量被声明为 volatile。</p>
<p>清单 8.Count 变量的声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>
<p> 所有不加锁读方法，在进入读方法时，首先都会去读这个 count 变量。比如下面的 get 方法：</p>
<p>清单 9.get 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key, <span class="keyword">int</span> hash)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(count != <span class="number">0</span>) &#123;       <span class="comment">// 首先读 count 变量</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = getFirst(hash); </span><br><span class="line">        <span class="keyword">while</span>(e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span>(e.hash == hash &amp;&amp; key.equals(e.key)) &#123; </span><br><span class="line">                V v = e.value; </span><br><span class="line">                <span class="keyword">if</span>(v != <span class="keyword">null</span>)            </span><br><span class="line">                    <span class="keyword">return</span> v; </span><br><span class="line">                <span class="comment">// 如果读到 value 域为 null，说明发生了重排序，加锁后重新读取</span></span><br><span class="line">                <span class="keyword">return</span> readValueUnderLock(e); </span><br><span class="line">            &#125; </span><br><span class="line">            e = e.next; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ConcurrentHashMap 中，所有执行写操作的方法（put, remove, clear），在对链表做结构性修改之后，在退出写方法前都会去写这个 count 变量。所有未加锁的读操作（get, contains, containsKey）在读方法中，都会首先去读取这个 count 变量。</p>
<p>根据 Java 内存模型，对 同一个 volatile 变量的写 / 读操作可以确保：写线程写入的值，能够被之后未加锁的读线程“看到”。</p>
<p>这个特性和前面介绍的 HashEntry 对象的不变性相结合，使得在 ConcurrentHashMap 中，读线程在读取散列表时，基本不需要加锁就能成功获得需要的值。这两个特性相配合，不仅减少了请求同一个锁的频率（读操作一般不需要加锁就能够成功获得值），也减少了持有同一个锁的时间（只有读到 value 域的值为 null 时 , 读线程才需要加锁后重读）。</p>
<h2 id="ConcurrentHashMap-实现高并发的总结"><a href="#ConcurrentHashMap-实现高并发的总结" class="headerlink" title="ConcurrentHashMap 实现高并发的总结"></a>ConcurrentHashMap 实现高并发的总结</h2><h3 id="基于通常情形而优化"><a href="#基于通常情形而优化" class="headerlink" title="基于通常情形而优化"></a>基于通常情形而优化</h3><p>在实际的应用中，散列表一般的应用场景是：除了少数插入操作和删除操作外，绝大多数都是读取操作，而且读操作在大多数时候都是成功的。正是基于这个前提，ConcurrentHashMap 针对读操作做了大量的优化。通过 HashEntry 对象的不变性和用 volatile 型变量协调线程间的内存可见性，使得 大多数时候，读操作不需要加锁就可以正确获得值。这个特性使得 ConcurrentHashMap 的并发性能在分离锁的基础上又有了近一步的提高。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 <code>HashTable 和</code>用同步包装器包装的 HashMap（Collections.synchronizedMap(new HashMap())），ConcurrentHashMap 拥有更高的并发性。在 HashTable 和由同步包装器包装的 HashMap 中，使用一个全局的锁来同步不同线程间的并发访问。同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器。这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成<code>串行化</code>的了。</p>
<p>在使用锁来协调多线程间并发访问的模式下，减小对锁的竞争可以有效提高并发性。有两种方式可以减小对锁的竞争：</p>
<ol>
<li>减小请求 同一个锁的 频率。</li>
<li>减少持有锁的 时间。</li>
</ol>
<p>ConcurrentHashMap 的高并发性主要来自于三个方面：</p>
<ol>
<li>用分离锁实现多个线程间的更深层次的共享访问。</li>
<li>用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。</li>
<li>通过对同一个 Volatile 变量的写/读访问，协调不同线程间读/写操作的内存可见性。</li>
</ol>
<p>使用分离锁，减小了请求 <em>同一个锁</em> 的频率。</p>
<p>通过 HashEntery 对象的不变性及对同一个 Volatile 变量的读/写来协调内存可见性，使得 读操作大多数时候不需要加锁就能成功获取到需要的值。由于散列映射表在实际应用中大多数操作都是成功的 读操作，所以 2 和 3 既可以减少请求同一个锁的频率，也可以有效减少持有锁的时间。</p>
<p>通过减小请求同一个锁的频率和尽量减少持有锁的时间 ，使得 ConcurrentHashMap 的并发性相对于 HashTable 和<code>用同步包装器包装的 HashMap</code>有了质的提高。</p>
<h2 id="Java-8中的优化"><a href="#Java-8中的优化" class="headerlink" title="Java 8中的优化"></a>Java 8中的优化</h2><p>参考文献</p>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/collection/HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/collection/HashMap/" class="post-title-link" itemprop="url">Java HashMap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-05-12 08:44:00" itemprop="dateCreated datePublished" datetime="2016-05-12T08:44:00+08:00">2016-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-24 12:58:51" itemprop="dateModified" datetime="2021-04-24T12:58:51+08:00">2021-04-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p><img src="_v_images/20200709141031567_1720882596.png"></p>
<p>jdk8和jdk7不一样，jdk7中没有红黑树,数组中只挂载链表。而jdk8中在桶容量大于等于64且链表节点数大于等于8的时候转换为红黑树。当红黑树节点数量小于6时又会转换为链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化容量，必须要2的n次幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子默认值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要从链表转换为红黑树时,链表节点的最小长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为红黑树时数组的最小容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// resize操作时,红黑树节点个数小于6则转换为链表。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HashMap阈值，用于判断是否需要扩容(threshold = 容量*loadFactor)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<h2 id="HashMap解决hash冲突的方法"><a href="#HashMap解决hash冲突的方法" class="headerlink" title="HashMap解决hash冲突的方法"></a>HashMap解决hash冲突的方法</h2><h2 id="Java7的死循环问题"><a href="#Java7的死循环问题" class="headerlink" title="Java7的死循环问题"></a>Java7的死循环问题</h2><h2 id="Java8-中的HashMap扩容"><a href="#Java8-中的HashMap扩容" class="headerlink" title="Java8 中的HashMap扩容"></a>Java8 中的HashMap扩容</h2><p>而newTab[j + oldCap] = hiHead;这一步，是一个非常巧妙的地方，也是本文分析的重点。</p>
<p>解释<br>经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，经过rehash之后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。对应的就是下方的resize的注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Initializes or doubles table size.  If null, allocates in</span><br><span class="line"> * accord with initial capacity target held in field threshold.</span><br><span class="line"> * Otherwise, because we are using power-of-two expansion, the</span><br><span class="line"> * elements from each bin must either stay at same index, or move</span><br><span class="line"> * with a power of two offset in the new table.</span><br><span class="line"> * &#x2F;</span><br></pre></td></tr></table></figure>

<p>看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希值(也就是根据key1算出来的hashcode值)与高位与运算的结果。</p>
<p><img src="_v_images/20200709130208070_533098526.png"></p>
<p><img src="_v_images/20200709130233960_485151198.png"></p>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。<br>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。</p>
<p>再解释：为什么刚好原位置+原数组长度就会等于新的数组中的位置呢？<br>要搞明白这个问题首先要清楚</p>
<p>HashMap的数组长度恒定为2的n次方，也就是说只会为2 4 8 16 。。。。。这种数。源码中有限制，也就是说即使你创建HashMap的时候是写的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; hashMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">13</span>);</span><br></pre></td></tr></table></figure>
<p>最后数组长度也会变成16，而不是你的13. 会取与你传入的数最近的一个2的n次方的数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>那么明确这一点有什么用呢？我们知道2,4,8,16,32所对应的二进制分别为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2：  0000 0000 0000 0000 0000 0000 0000 0010</span><br><span class="line">4：  0000 0000 0000 0000 0000 0000 0000 0100</span><br><span class="line">8：  0000 0000 0000 0000 0000 0000 0000 1000</span><br><span class="line">16： 0000 0000 0000 0000 0000 0000 0001 0000</span><br><span class="line">32:  0000 0000 0000 0000 0000 0000 0010 0000</span><br></pre></td></tr></table></figure>
<p>而我们知道，0在做位与运算时与任何一个数运算结果都恒为0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 &amp; 1 &#x3D; 0</span><br><span class="line">0 &amp; 0 &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>故看源码中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) </span><br></pre></td></tr></table></figure>
<p>这一步是否为0只需要看元素的二进制数对应数组长度的二进制数1那个位置是否为0.<br>假设某个元素的hashcode为52：<br><img src="_v_images/20200709130402587_2088260774.png"></p>
<p>而假设某个元素的hashcode为100：<br><img src="_v_images/20200709130419110_1073585697.png"><br>而通过源码可以看出0就还是在原来的位置。不为0就需要变动位置了，新的位置为元素在原数组的位置+原数组的长度，那么为什么是这样呢？我们接着看<br>看之前我们先使用jdk1.7中的方式重新进行hash运算<br>HashMap在运算元素位置的时候使用为 数组长度-1。也就是15.31这种数15 31 对应的二进制为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15：0000 0000 0000 0000 0000 0000 0000 1111</span><br><span class="line">31: 0000 0000 0000 0000 0000 0000 0001 1111</span><br></pre></td></tr></table></figure>
<p>这里需要注意的是hashmap中，计算元素位置采用的是length-1，而leng是用来判断元素是否需要更换位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0)  &#x2F;&#x2F;仅仅是判断元素是否需要换位置</span><br></pre></td></tr></table></figure>
<p>这一步才是计算位置，使用的是length-1.</p>
<p>16扩容后变成32.那么1.7中计算元素的位置方式为 31&amp;52, 31&amp;100.我们把他与扩容前的15&amp;52。15&amp;100做对比看看<br><img src="_v_images/20200709130508438_597207385.png"><br>可以看到，由于每次扩容会把原数组的长度*2，那么再二进制上的表现就是多出来一个1，比如元数组16-1二进制为1111，那么扩容后的32-1的二进制就变成了1 1111<br>而扩容前和扩容后的位置是否一样完全取决于多出来的那一位与key值的hash做按位与运算之后的值值是为0还是1。为0则新位置与原位置相同，不需要换位置，不为零则需要换位置。</p>
<p>而为什么新的位置是原位置+原数组长度，是因为每次换的位置只是前面多了一个1而已。那么新位置的变化的高位进1位。而每一次高位进1都是在加上原数组长度的过程。<br><img src="_v_images/20200709130528192_2073437264.png"><br>正好1+2=3 3+4=7 7+8=15 。也就验证了新的位置为原位置+原数组长度。</p>
<p><img src="_v_images/20200709130901169_1202973639.png"></p>
<p>[参考文献]<br>————————————————</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq32933432/java/article/details/86668385">jdk8之HashMap resize方法详解（深入讲解为什么1.8中扩容后的元素新位置为原位置+原数组长度）</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3797c6f83d4f">JAVA8对HashMap扩容机制的优化</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/jvm/jvm2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/jvm/jvm2/" class="post-title-link" itemprop="url">GC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-05-04 12:26:00" itemprop="dateCreated datePublished" datetime="2016-05-04T12:26:00+08:00">2016-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-24 12:58:51" itemprop="dateModified" datetime="2021-04-24T12:58:51+08:00">2021-04-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>heap分代的目的是，应对不同生命周期的对象，大部分对象是朝生夕死的，也用一些常量是长期占用内存的，如数据值的枚举<br>动态调整：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/jvm/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/jvm/JVM/" class="post-title-link" itemprop="url">深入理解JVM(Java虚拟机)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-05-04 12:26:00" itemprop="dateCreated datePublished" datetime="2016-05-04T12:26:00+08:00">2016-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-24 12:58:51" itemprop="dateModified" datetime="2021-04-24T12:58:51+08:00">2021-04-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <pre><code>JVM内存区域划分
    1. 掌握程序计数器、堆、虚拟机栈、本地方法栈、方法区（JAVA8已移除）、元空间（JAVA8新增）的作用及基本原理.
    2. 掌握堆的划分:  新生代（Eden、Survivor1、Survivor2）和老年代的作用及工作原理.
    3. 掌握JVM内存参数设置及调优.
类加载
    1. 掌握类的加载阶段:  加载、链接（验证、准备、解析）、初始化、使用、卸载.
    2. 掌握类加载器分类及其应用:  启动类加载器、扩展类加载器、应用程序类加载器、自定义加载器.</code></pre>
<h1 id="运行时内存结构"><a href="#运行时内存结构" class="headerlink" title="运行时内存结构"></a>运行时内存结构</h1><h1 id="Class文件格式"><a href="#Class文件格式" class="headerlink" title="Class文件格式"></a>Class文件格式</h1><h1 id="Java字节码和执行引擎"><a href="#Java字节码和执行引擎" class="headerlink" title="Java字节码和执行引擎"></a>Java字节码和执行引擎</h1><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h1 id="监控调优"><a href="#监控调优" class="headerlink" title="监控调优"></a>监控调优</h1><h1 id="GC算法和垃圾回收"><a href="#GC算法和垃圾回收" class="headerlink" title="GC算法和垃圾回收"></a>GC算法和垃圾回收</h1><h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><h1 id="线程和锁"><a href="#线程和锁" class="headerlink" title="线程和锁"></a>线程和锁</h1><h1 id="JVM内存区域划分"><a href="#JVM内存区域划分" class="headerlink" title="JVM内存区域划分"></a>JVM内存区域划分</h1><p><img src="/images/java/JVM/jvm-struct.jpg" alt="java虚拟机运行时数据区"><br><img src="/images/java/JVM/jvm-struct-thread.jpg" alt="java虚拟机运行时数据区与线程的关系"></p>
<p>JVM内存区域可以划分为:</p>
<ul>
<li>程序计数器</li>
<li>堆</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>方法区(Java8已移除)</li>
<li>元空间(Java8新增)</li>
</ul>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><ol>
<li><p>程序计数器可以看做是当前线程所执行的字节码的行号指示器. 在JVM的概念模型里, 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令.</p>
</li>
<li><p>由于JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的, 为了在线程切换后能恢复到正确的执行位置, 每条线程都需要有一个独立的程序计数器, 独立存储, 互不影响. 所以, 程序计数器是<strong>线程私有</strong>的内存区域.</p>
</li>
<li><p>如果线程执行的是一个Java方法, 计数器记录的是正在执行的虚拟机字节码指令的地址；如果线程执行的是一个Native方法, 计数器的值为空.</p>
</li>
<li><p>程序计数器是Java虚拟机规范中<strong>唯一</strong>一个<strong>没有</strong>规定任何<strong>OutOfMemoryError</strong>情况的区域.</p>
</li>
</ol>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><ol>
<li><p>Java虚拟机栈描述的是Java方法执行的内存模型:  </p>
<p>每个方法执行的同时会创建一个栈帧, 栈帧用于存储<strong>局部变量表</strong>、操作数栈、动态链接、方法出口等信息. 每个方法从调用直至执行完成的过程, 就对应着一个栈帧在虚拟机栈中入栈到出栈的过程.</p>
<p><img src="/images/java/JVM/jvm-stack-frame.png" alt="栈帧"></p>
</li>
</ol>
<ol>
<li><p>Java虚拟机栈是<strong>线程私有</strong>的, 它的生命周期与线程相同.</p>
</li>
<li><p>程序员主要关注的stack栈内存, 就是虚拟机栈中局部变量表部分.<br>局部变量表存放了编译时期可知的各种<strong>基本数据类型</strong>和<strong>对象引用</strong>.<br>局部变量表所需的内存空间在编译时期完成分配, 当进入一个方法时, 这个方法需要在栈帧中分配多大的局部变量空间是完全确定的, 在方法运行期间不会改变局部变量表的大小.</p>
</li>
<li><p>Java虚拟机规范对这个区域规定了两种异常情况:  </p>
</li>
</ol>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度, 将抛出<code>StackOverflowError</code> 异常；</li>
<li>如果虚拟机栈可以动态扩展, 如果扩展时无法申请到足够的内存, 就会抛出<code>OutOfMemoryError</code>异常；<br>  （当前大部分JVM都可以动态扩展, 只不过JVM规范也允许固定长度的虚拟机栈）</li>
</ul>
<blockquote>
<p>栈深度:   每次方法调用, 都会创建一个栈帧, 一个方法调用另一个方法, 栈帧就会深度增加一层</p>
</blockquote>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><ol>
<li><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的, 它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务（也就是字节码）, 而本地方法栈为虚拟机使用到的Native方法服务.</p>
</li>
<li><p>Java虚拟机规范对本地方法栈使用的语言、使用方法与数据结构并没有强制规定, 因此可以由虚拟机自由实现. 例如:  HotSpot虚拟机直接将本地方法栈和虚拟机栈合二为一.</p>
</li>
<li><p>同虚拟机栈相同, Java虚拟机规范对这个区域也规定了两种异常情况<code>StackOverflowError</code> 和 <code>OutOfMemoryError</code>异常.</p>
</li>
</ol>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ol>
<li>Java堆是被<strong>所有的线程共享</strong>的一块内存区域, 在虚拟机启动时创建.<br>Java堆的唯一目的就是存放对象实例, 几乎所有的对象实例都在这里分配内存.</li>
<li>Java堆是垃圾回收器管理的主要区域, 因此也被称为”GC堆”.</li>
</ol>
<p>从内存回收的角度看, 由于现在收集器基本都采用分代收集算法, 所以Java堆可以细分为:  新生代、老生代；</p>
<p>从内存分配的角度看, 线程共享的Java堆可能划分出多个线程私有的分配缓冲区（TLAB）；</p>
<p>不论如何划分, 都与存放的内容无关, 无论哪个区域, 存储的仍然是对象实例.</p>
<ol>
<li><p>Java虚拟机规范规定, Java堆可以处于物理上不连续的内存空间中, 只要逻辑上是连续的即可, 就像我们的磁盘空间一样. 在实现上, 既可以是固定大小的, 也可以是可扩展的, 不过当前主流JVM都是按照可扩展来实现的.</p>
</li>
<li><p>Java虚拟机规范规定, 如果在堆上没有内存完成实例分配, 并且堆上也无法再扩展时, 将会抛出<code>OutOfMemoryError</code>异常.</p>
</li>
<li><p>内存泄露和内存溢出<br> Java堆内存的<code>OOM</code>异常是非常常见的异常情况, 重点是根据内存中的对象是否是必要的, 来弄清楚到底是出现了<code>内存泄露(Memory Leak)</code>还是<code>内存溢出(Memory Overflow)</code>.</p>
</li>
</ol>
<ul>
<li> 内存泄露:  指程序中一些对象不会被GC所回收, 它始终占用内存, 即被分配的对象引用链可达但已无用. （可用内存减少）</li>
<li> 内存溢出:  程序运行过程中无法申请到足够的内存而导致的一种错误. 内存溢出通常发生于OLD段或Perm段垃圾回收后, 仍然无内存空间容纳新的Java对象的情况.</li>
<li> 内存泄露是内存溢出的一种诱因, 不是唯一因素.</li>
</ul>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ol>
<li><p>方法区也是被<code>所有的线程共享</code>的一块内存区域. 它用于存储已被虚拟机加载的<code>类信息</code>、<code>常量</code>、<code>静态变量</code>、<code>即时编译器编译后的代码</code>等数据.</p>
</li>
<li><p>Java虚拟机规范对方法区的限制非常宽松, 除了和Java堆一样 不需要连续的内存和可以选择固定大小或者可扩展之外, 还可以选择不实现垃圾回收.<br> 这区域的内存回收目标主要是针对常量池的回收和类型的卸载, 一般而言, 这个区域的内存回收比较难以令人满意, 尤其是类型的回收, 条件相当苛刻, 但是这部分区域的内存回收确实是必要的.</p>
</li>
<li><p>Java虚拟机规范规定, 当方法区无法满足内存分配的需求时, 将抛出<code>OutOfMemoryError</code>异常.</p>
</li>
<li><p><strong>运行时常量池</strong></p>
<p><code>运行时常量池</code>是方法区的一部分. Class文件中除了有类的版本、字段、方法、接口等描述信息外, 还有一项信息是常量池, 用于存放编译期生成的各种字面量和符号引用, 这部分内容将在类加载后进入方法区的运行时常量池中存放.</p>
<p><code>运行时常量池</code>相对于Class文件常量池的另外一个重要特征是具备动态性, Java语言并不要求常量一定只有编译期才能产生, 也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池, 运行期间也可能将新的常量放入池中, 这种特性被开发人员利用比较多的就是String类的intern()方法.</p>
</li>
<li><p>String.intern()</p>
<p><code>String.intern()</code>是一个<code>Native</code>方法, 它的作用是:  如果字符串常量池中已经包含了一个等于此String对象的字符串, 则返回代表池中这个字符串的String对象；否则, 将此String对象包含的字符串添加到常量池中, 并且返回此字符串的引用.</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;计算机&quot;</span>).append(<span class="string">&quot;软件&quot;</span>).toString();</span><br><span class="line"> System.out.println(str1.intern() == str1);</span><br><span class="line"></span><br><span class="line"> String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;ja&quot;</span>).append(<span class="string">&quot;va&quot;</span>).toString();</span><br><span class="line"> System.out.println(str2.intern() == str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这段代码在JDK1.6中运行, 会得到两个false, 而在JDK1.7中运行, 会得到一个true和一个false. 原因是:  </p>
<ol>
<li>在JDK1.6中<code>intern()</code>方法会把首次遇到的字符串实例复制到永久代中, 返回的也是永久代中这个字符串实例的引用, 而由<code>StringBuilder</code>创建的字符串实例在Java堆上, 所以必然不是一个引用.</li>
<li>在JDK1.7中<code>intern()</code>方法不会复制实例, 只是在常量池中记录首次出现的实例引用, 因此<code>intern()</code>返回的引用和由<code>StringBuilder</code>创建的字符串实例是同一个.</li>
<li>str2返回false是因为Java这个字符串在执行<code>StringBuilder(&quot;ja&quot;).append(&quot;va&quot;).toString()</code>之前已经出现过, 字符串常量池中已经有它的引用了, 不符合首次出现的原则, 而”计算机软件”这个字符串是首次出现的.</li>
</ol>
<h1 id="堆的划分"><a href="#堆的划分" class="headerlink" title="堆的划分"></a>堆的划分</h1><p><img src="/images/java/JVM/jvm-heap-generations.jpg" alt="堆的分代划分"><br>堆的分代划分</p>
<ol>
<li><p>Young（年轻代）</p>
<p>年轻代分三个区. 一个<code>Eden</code>区, 两个 <code>Survivor</code>区. 大部分对象在<code>Eden</code>区中生成. 当Eden区满时, 还存活的对象将被复制到Survivor区（两个中的一个）, 当这个 Survivor区满时, 此区的存活对象将被复制到另外一个Survivor区, 当这个Survivor区也满了的时候, 从第一个Survivor区复制过来的并且此时还存活的对象, 将被复制“<code>年老区(Tenured)</code>”. 需要注意, Survivor的两个区是对称的, 没先后关系, 所以同一个区中可能同时存在从Eden复制过来的对象和从前一个Survivor复制过来的对象, 而复制到年老区的只有从第一个Survivor区过来的对象. 而且, Survivor区总有一个是空的.</p>
</li>
<li><p>Tenured（年老代）</p>
<p>年老代存放从年轻代存活的对象. 一般来说年老代存放的都是生命期较长的对象.</p>
</li>
<li><p>Perm（持久代）</p>
<p>用于存放静态文件, 如Java类、方法等. 持久代对垃圾回收没有显著影响, 但是有些应用可能动态生成或者调用一些Class, 例如Hibernate等,  在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类. 持久代大小通过-XX:MaxPermSize=进行设置.</p>
</li>
</ol>
<h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>GC有两种类型:  Scavenge GC和Full GC.</p>
<ol>
<li><p><code> Scavenge GC</code></p>
<p>一般情况下, 当新对象生成, 并且在Eden申请空间失败时, 就好触发Scavenge GC, 堆Eden区域进行GC, 清除非存活对象, 并且把尚且存活的对象移动到Survivor区. 然后整理Survivor的两个区.</p>
</li>
<li><p><code> Full GC</code></p>
<p>对整个堆进行整理, 包括Young、Tenured和Perm. Full GC比Scavenge GC要慢, 因此应该尽可能减少Full GC. 有如下原因可能导致Full GC:  </p>
</li>
</ol>
<ul>
<li>   Tenured被写满</li>
<li> Perm域被写满<ul>
<li>   System.gc()被显示调用</li>
<li>   上一次GC之后Heap的各域分配策略动态变化</li>
</ul>
</li>
</ul>
<h2 id="基本回收算法"><a href="#基本回收算法" class="headerlink" title="基本回收算法"></a>基本回收算法</h2><ul>
<li>引用计数（Reference Counting）<br>比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只用收集计数为0的对象。此算法最致命的是无法处理循环引用的问题。</li>
<li>标记-清除（Mark-Sweep）<br>此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</li>
<li>复制（Copying）<br>此 算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。次算法每次只处理 正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不过出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍 内存空间。</li>
<li>标记-整理（Mark-Compact）<br>此算法结 合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活 对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</li>
<li>增量收集（Incremental Collecting）<br>实施垃圾回收算法，即：在应用进行的同时进行垃圾回收。不知道什么原因JDK5.0中的收集器没有使用这种算法的。</li>
<li>分代（Generational Collecting）<br>基于对对象生命周期分析后得出的垃圾回收算法。把对象分为年青代、年老代、持久代，对不同生命周期的对象使用不同的算法（上述方式中的一个）进行回收。现在的垃圾回收器（从J2SE1.2开始）都是使用此算法的。</li>
</ul>
<h1 id="JVM内存参数设置与调优"><a href="#JVM内存参数设置与调优" class="headerlink" title="JVM内存参数设置与调优"></a>JVM内存参数设置与调优</h1><p>常见配置举例</p>
<p>堆大小设置</p>
<p>  JVM 中最大堆大小有三方面限制:  相关操作系统的数据模型（32-bt还是64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制. 32位系统 下, 一般限制在1.5G~2G；64为操作系统对内存无限制. 我在Windows Server 2003 系统, 3.5G物理内存, JDK5.0下测试, 最大可设置为1478m.</p>
<p>典型设置:  </p>
<ul>
<li><code>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k</code><ul>
<li> -Xmx3550m:  设置JVM最大可用内存为3550M.</li>
<li> -Xms3550m:  设置JVM初始内存为3550m. 此值可以设置与-Xmx相同, 以避免每次垃圾回收完成后JVM重新分配内存.</li>
<li> -Xmn2g:  设置年轻代大小为2G. 整个堆大小=年轻代大小 + 年老代大小 + 持久代大小. 持久代一般固定大小为64m, 所以增大年轻代后, 将会减小年老代大小. 此值对系统性能影响较大, Sun官方推荐配置为整个堆的3/8.</li>
<li> -Xss128k:   设置每个线程的堆栈大小. JDK5.0以后每个线程堆栈大小为1M, 以前每个线程堆栈大小为256K. 更具应用的线程所需内存大小进行调整. 在相同物理内 存下, 减小这个值能生成更多的线程. 但是操作系统对一个进程内的线程数还是有限制的, 不能无限生成, 经验值在3000~5000左右.</li>
</ul>
</li>
<li><code>java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0</code><ul>
<li> -XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）. 设置为4, 则年轻代与年老代所占比值为1:  4, 年轻代占整个堆栈的1/5</li>
<li> -XX:SurvivorRatio=4:  设置年轻代中Eden区与Survivor区的大小比值. 设置为4, 则两个Survivor区与一个Eden区的比值为2:4, 一个Survivor区占整个年轻代的1/6</li>
<li> -XX:MaxPermSize=16m:设置持久代大小为16m.</li>
<li> -XX:MaxTenuringThreshold=0:  设置垃圾最大年龄. 如果设置为0的话, 则年轻代对象不经过Survivor区, 直接进入年老代. 对于年老代比较多的应用, 可以提高效率. 如果将此值设置为一个较大值, 则年轻代对象会在Survivor区进行多次复制, 这样可以增加对象再年轻代的存活时间, 增加在年轻代即被回收的概论.</li>
</ul>
</li>
</ul>
<h2 id="调优总结"><a href="#调优总结" class="headerlink" title="调优总结"></a>调优总结</h2><ol>
<li><p>年轻代大小选择</p>
<p>  响应时间优先的应用:  尽可能设大, 直到接近系统的最低响应时间限制（根据实际情况选择）. 在此种情况下, 年轻代收集发生的频率也是最小的. 同时, 减少到达年老代的对象.</p>
<p>  吞吐量优先的应用:  尽可能设大, 可能到达Gbit的程度. 因为对响应时间没有要求, 垃圾收集可以并行进行, 一般适合8CPU以上的应用.</p>
</li>
<li><p>年老代大小选择</p>
<pre><code>响应时间优先的应用:  

年老代使用并发收集器, 所以其大小需要小心设置, 一般要考虑并发会话率和会话持续时间等一些参数. 如果堆设置小了, 可以会造成内存碎片、高回收频率以及应用暂停而使用传统的标记清除方式；如果堆大了, 则需要较长的收集时间. 最优化的方案, 一般需要参考以下数据获得:  </code></pre>
<ul>
<li>   并发垃圾收集信息</li>
<li>   持久代并发收集次数</li>
<li>   传统GC信息</li>
<li>   花在年轻代和年老代回收上的时间比例 减少年轻代和年老代花费的时间, 一般会提高应用的效率</li>
</ul>
<p>吞吐量优先的应用:  一般吞吐量优先的应用都有一个很大的年轻代和一个较小的年老代. 原因是, 这样可以尽可能回收掉大部分短期对象, 减少中期的对象, 而年老代尽存放长期存活对象.</p>
</li>
<li><p>较小堆引起的碎片问题</p>
<p>因为年老代的并发收集器使用标记、清除算法, 所以不会对堆进行压缩. 当收集器回收时, 他会把相邻的空间进行合并, 这样可以分配给较大的对象. 但是, 当堆空间 较小时, 运行一段时间以后, 就会出现“碎片”, 如果并发收集器找不到足够的空间, 那么并发收集器将会停止, 然后使用传统的标记、清除方式进行回收. 如果出 现“碎片”, 可能需要进行如下配置:  </p>
<ul>
<li>-XX:+UseCMSCompactAtFullCollection:  使用并发收集器时, 开启对年老代的压缩.</li>
<li>-XX:CMSFullGCsBeforeCompaction=0:  上面配置开启的情况下, 这里设置多少次Full GC后, 对年老代进行压缩</li>
</ul>
</li>
</ol>
<h2 id="常见配置参数汇总"><a href="#常见配置参数汇总" class="headerlink" title="常见配置参数汇总"></a>常见配置参数汇总</h2><ol>
<li>堆设置<ul>
<li>-Xms:初始堆大小</li>
<li>-Xmx:最大堆大小</li>
<li>-XX:NewSize=n:设置年轻代大小</li>
<li>-XX:NewRatio=n:设置年轻代和年老代的比值. 如:为3, 表示年轻代与年老代比值为1:  3, 年轻代占整个年轻代年老代和的1/4</li>
<li>-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值. 注意Survivor区有两个. 如:  3, 表示Eden:  Survivor=3:  2, 一个Survivor区占整个年轻代的1/5</li>
<li>-XX:MaxPermSize=n:设置持久代大小</li>
</ul>
</li>
<li>收集器设置<ul>
<li>-XX:+UseSerialGC:设置串行收集器</li>
<li>-XX:+UseParallelGC:设置并行收集器</li>
<li>-XX:+UseParalledlOldGC:设置并行年老代收集器</li>
<li>-XX:+UseConcMarkSweepGC:设置并发收集器</li>
</ul>
</li>
<li>垃圾回收统计信息<ul>
<li>-XX:+PrintGC</li>
<li>-XX:+Printetails</li>
<li>-XX:+PrintGCTimeStamps</li>
<li>-Xloggc:filename</li>
</ul>
</li>
<li>并行收集器设置<ul>
<li>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数. 并行收集线程数.</li>
<li>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间</li>
<li>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比. 公式为1/(1+n)</li>
</ul>
</li>
<li>并发收集器设置<ul>
<li>-XX:+CMSIncrementalMode:设置为增量模式. 适用于单CPU情况.</li>
<li>-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时, 使用的CPU数. 并行收集线程数.</li>
</ul>
</li>
</ol>
<h1 id="类加载-1"><a href="#类加载-1" class="headerlink" title="类加载"></a>类加载</h1><h2 id="类的加载阶段"><a href="#类的加载阶段" class="headerlink" title="类的加载阶段"></a>类的加载阶段</h2><p>类加载分为装载、链接、初始化三步.</p>
<ol>
<li><p>装载</p>
<p>通过类的全限定名和ClassLoader加载类, 主要是将指定的.Class文件加载至JVM. 当类被加载以后, 在JVM内部就以“类的全限定名+ClassLoader实例ID”来标明类.</p>
<p>在内存中, ClassLoader实例和类的实例都位于堆中, 它们的类信息都位于方法区.</p>
<p>装载过程采用了一种被称为“双亲委派模型（Parent Delegation Model）”的方式, 当一个ClassLoader要加载类时, 它会先请求它的双亲ClassLoader（其实这里只有两个ClassLoader, 所以称为父ClassLoader可能更容易理解）加载类, 而它的双亲ClassLoader会继续把加载请求提交再上一级的ClassLoader, 直到启动类加载器. 只有其双亲ClassLoader无法加载指定的类时, 它才会自己加载类.</p>
<p>双亲委派模型是JVM的第一道安全防线, 它保证了类的安全加载, 这里同时依赖了类加载器隔离的原理:  不同类加载器加载的类之间是无法直接交互的, 即使是同一个类, 被不同的ClassLoader加载, 它们也无法感知到彼此的存在. 这样即使有恶意的类冒充自己在核心包（例如java.lang）下, 由于它无法被启动类加载器加载, 也造成不了危害.</p>
<p>由此也可见, 如果用户自定义了类加载器, 那就必须自己保障类加载过程中的安全.</p>
</li>
<li><p>链接</p>
<p>链接的任务是把二进制的类型信息合并到JVM运行时状态中去.<br>链接分为以下三步:  </p>
</li>
</ol>
<ul>
<li>验证:  校验.Class文件的正确性, 确保该文件是符合规范定义的, 并且适合当前JVM使用.</li>
<li>准备:  为类分配内存, 同时初始化类中的静态变量赋值为默认值.</li>
<li>解析（可选）:  主要是把类的常量池中的符号引用解析为直接引用, 这一步可以在用到相应的引用时再解析.</li>
</ul>
<ol>
<li>初始化</li>
</ol>
<p>初始化类中的静态变量, 并执行类中的static代码、构造函数.</p>
<p>JVM规范严格定义了何时需要对类进行初始化:  </p>
<ul>
<li>通过new关键字、反射、clone、反序列化机制实例化对象时.</li>
<li>调用类的静态方法时.</li>
<li>使用类的静态字段或对其赋值时.</li>
<li>通过反射调用类的方法时.</li>
<li>初始化该类的子类时（初始化子类前其父类必须已经被初始化）.</li>
<li>JVM启动时被标记为启动类的类（简单理解为具有main方法的类）.</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p><img src="/images/java/JVM/ClassLoader-01.png"></p>
<p>ClassLoader的分类:  </p>
<p>1）BootstrapClassLoader（启动类加载器）<br>　　负责加载$JAVA_HOME中jre/lib/rt.jar里所有的Class，加载System.getProperty(“sun.boot.Class.path”)所指定的路径或jar。<br>2）ExtensionClassLoader（标准扩展类加载器）<br>　　负责加载java平台中扩展功能的一些jar包，包括<code>$JAVA_HOME</code>中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包。<br>   在System.getProperty(“java.ext.dirs”)所指定的路径或jar。<br>3）AppClassLoader（系统类加载器）<br>　　负责记载Classpath中指定的jar包及目录中Class<br>4）CustomClassLoader（自定义加载器）<br>　　属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现。</p>
<h3 id="类加载器的顺序-双亲委派"><a href="#类加载器的顺序-双亲委派" class="headerlink" title="类加载器的顺序: 双亲委派"></a>类加载器的顺序: 双亲委派</h3><p>当一个ClassLoader要加载类时，它会先请求它的双亲ClassLoader（其实这里只有两个ClassLoader，所以称为父ClassLoader可能更容易理解）加载类，而它的双亲ClassLoader会继续把加载请求提交再上一级的ClassLoader，直到启动类加载器。只有其双亲ClassLoader无法加载指定的类时，它才会自己加载类。</p>
<p>双亲委派模型是JVM的第一道安全防线，它保证了类的安全加载，这里同时依赖了类加载器隔离的原理：不同类加载器加载的类之间是无法直接交互的，即使是同一个类，被不同的ClassLoader加载，它们也无法感知到彼此的存在。这样即使有恶意的类冒充自己在核心包（例如java.lang）下，由于它无法被启动类加载器加载，也造成不了危害。</p>
<p>由此也可见，如果用户自定义了类加载器，那就必须自己保障类加载过程中的安全。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/7ebbe102c1ae">深入理解JVM 1</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/anders_zhuo/article/details/47776569">JVM调优总结 </a></li>
<li><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/26594">浅析Java虚拟机结构与机制 </a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/ochangwen/article/details/51407574"> 深入理解JVM03–垃圾收集算法</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/regular-expression/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/regular-expression/" class="post-title-link" itemprop="url">正则表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-04-21 11:28:00" itemprop="dateCreated datePublished" datetime="2016-04-21T11:28:00+08:00">2016-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-24 12:58:51" itemprop="dateModified" datetime="2021-04-24T12:58:51+08:00">2021-04-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><ol>
<li><code>\w</code> 匹配一个字符，可以是数字、下划线、字母或者汉字</li>
<li><code>\b</code> 匹配的是位置，它的前一个字符和后一个字符不全是(一个是, 一个不是或不存在) <code>\w</code></li>
</ol>
<ul>
<li><code>\bhi\b</code> 匹配hi单词， 对于history和him都不匹配</li>
<li><code>\bhi\b.*\blucy\b</code> hi单词后面若干字符之后是lucy</li>
</ul>
<ol>
<li><code>.</code> 匹配除了换行符之外的任一字符<br><code>\bhi.lucy\b</code>在hi和lucy中存在一个除了换行符之外的任一字符</li>
<li><code>*</code> 匹配的是数量 0~若干个<br><code>\bhi\b.*\blucy\b</code> hi单词后面若干个除换行符以外的字符之后是lucy</li>
<li><code>\s</code> 匹配任意的空白符</li>
<li><code>\d</code> 匹配数字<br><code>0\d&#123;2&#125;-\d&#123;8&#125;</code> 匹配以0开头，紧接着是2位数字，接着是-，最后是8位数字<br><code>\d+</code> 匹配多于一个数字</li>
<li><code>[0123456789]</code>或者<code>[0-9]</code> 匹配数字与<code>\d</code>的意义完全相同</li>
<li><code>^</code> 匹配字符串的开始</li>
<li><code>$</code> 匹配字符串的结束<br><code>^\b&#123;5,12&#125;$</code> 匹配5到12位的数字</li>
</ol>
<h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h2><p>使用斜杠<code>\</code>对特殊字符转义，转换为普通字符</p>
<h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td><code>+</code></td>
<td>重复一次或者更多次</td>
</tr>
<tr>
<td><code>?</code></td>
<td>重复零次或一次</td>
</tr>
<tr>
<td><code>&#123;n&#125;</code></td>
<td>重复n次</td>
</tr>
<tr>
<td><code>&#123;n,&#125;</code></td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td><code>&#123;n,m&#125;</code></td>
<td>重复n到m次</td>
</tr>
</tbody></table>
<p><code>windows\d+</code> windows后面紧跟着多于一个数字<br><code>^\w+</code> 以多于一个字符开头</p>
<h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><ol>
<li><p><code>[aeiou]</code> aeiou中的一个字符</p>
</li>
<li><p><code>[0-9]</code> 从0到9</p>
</li>
<li><p><code>[0-9A-Za-z]</code> 完全等同于 <code>\w</code>(如果不考虑中文字符)</p>
</li>
<li><p><code>[) -]</code> 从右括号、空格和减号中选择一个</p>
<p> <code>\(?0\d&#123;2&#125;[) -]?\d&#123;8&#125;</code> 首先是一个转义字符<code>\(</code>， 它可能出现0次或1次(?)， 然后是一个0， 后面跟着2个数字<code>\d&#123;2&#125;</code>，然后是)或-或空格中的一个，它出现1此或不出现(?), 最后是8个数字(\d{8}).</p>
</li>
</ol>
<h2 id="分枝条件"><a href="#分枝条件" class="headerlink" title="分枝条件"></a>分枝条件</h2><p>分枝条件: 满足若干条件中的一个就能匹配. 要注意优先级和各条件顺序问题.</p>
<p>** 例1 匹配电话号码<br>要匹配两种电话号码形式:  (0755)12345678 或者 0755-12345678 以及 0751-1234567</p>
<p><code>\(\d&#123;3,4&#125;\)\d&#123;7,8&#125;|\d&#123;3,4&#125;-\d&#123;7,8&#125;</code></p>
<p>** 例2: 注意分枝条件各条件的顺序<br>美国的邮编是有两种形式的: 5位数字 或者用连字号间隔的9位数字, 如12345和12345-1234两种形式.</p>
<p>应该使用<code>\d&#123;5&#125;-\d&#123;4&#125;|\d&#123;5&#125;</code>, 而不能使用<code>\d&#123;5&#125;|\d&#123;5&#125;-\d&#123;4&#125;</code><br>也就是说, 如果<code>\d&#123;5&#125;</code>提前匹配了<code>12345</code>之后会返回而丢弃掉后面的四位.</p>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>分组可以实现子表达式重复出现.</p>
<p><code>(\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1,3&#125;</code> 匹配以点号分割的四组数字, 每组数字是1到3位,如 <code>999.999.999.999</code> 或<code>1.1.0.0</code></p>
<p>** IP地址的匹配 **<br>IP地址分为4段, 每段的数字范围为: 0~255<br>正则表达式只能匹配字符串的格式, 不支持数值比较, 因此需要用尽可能精简的方式准确列出所有的可能性</p>
<p><code>((2[0-4]\d|25[0-5]|[0-1]?\d\d?)\.)&#123;3&#125;(2[0-4]\d|25[0-5]|[0-1]?\d\d?)</code></p>
<p>解释:</p>
<ol>
<li><code>2[0-4]\d</code> 首位是2,第二位可以为0到4,第三位是任意数字</li>
<li><code>25[0-5]</code> 前两位是25,第三位必须是0到5, 因为最大是255</li>
<li><code>[0-1]?\d\d?</code> 首位是0或1, 也可以首位不存在, 第二位为任何数字, 第三位是任意数字, 也可以不存在, 不存在这种情况下, 就只有前两位.<br> 为什么不是<code>[0-1]?\d?\d</code>?</li>
</ol>
<h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><p>对字符类进行反义, 只需要将上面<a href="">字符类</a>一节的所有的字符转为大写</p>
<table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>\W</code></td>
<td>匹配任意不是字母，数字，下划线，汉字的字符</td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配任意不是空白符的字符</td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配任意非数字的字符</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>匹配不是单词开头或结束的位置</td>
</tr>
<tr>
<td><code>[^x]</code></td>
<td>匹配除了x以外的任意字符</td>
</tr>
<tr>
<td><code>[^aeiou]</code></td>
<td>匹配除了aeiou这几个字母以外的任意字符</td>
</tr>
</tbody></table>
<h2 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h2><p>用于引用上文中匹配到的字符- 给上文中出现的表达式添加组号, 在下文中引用这个组号</p>
<table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>(exp)</code></td>
<td>匹配exp,并捕获文本到自动命名的组里</td>
</tr>
<tr>
<td><code>(?&lt;name&gt;exp)</code></td>
<td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td>
</tr>
<tr>
<td><code>(?:exp)</code></td>
<td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td>
</tr>
</tbody></table>
<p>分组命名规则为:</p>
<ul>
<li>  分组0对应整个正则表达式</li>
<li>  实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号</li>
<li>  你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．</li>
</ul>
<p>例1 <strong>自动命名</strong><br><code>\b(\w+)\b\s+\1\b</code> 首先匹配一个单词(<code>\w+</code>)并放到分组1中, 在下文中通过<code>\1</code>引用上文中分组1匹配到的字符.<br>该表达式用于匹配重复单词. 如 <code>hello hello</code></p>
<p>例2 <strong>手动命名</strong><br><code>\b(?&lt;name&gt;\w+)\b\s+\k&lt;name&gt;\b</code> 首先匹配一个单词(<code>\w+</code>) 并将这个单词放入name组中, 在下文中引用name分组, 看后面是否再出现<br>注意反向引用时的格式: <code>\k&lt;name&gt;</code></p>
<p>例3 <strong>不捕获</strong><br>    <code>\b(?:\w+)\b\s+</code> 不捕获</p>
<h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>零宽断言和负向零宽断言用于指示位置, 零宽断言分为两种, 分别指示匹配表达式的前面和后面.</p>
<h3 id="零宽度正预测先行断言"><a href="#零宽度正预测先行断言" class="headerlink" title="零宽度正预测先行断言"></a>零宽度正预测先行断言</h3><p>用于指示匹配表达式的字符串的上一个字符位置</p>
<p><code>\b\w+(?=ing\b)</code> 匹配以ing结尾的单词的前面部分(除了ing以外的部分).<br>如果查找 <code> I&#39;m singing while you&#39;re dancing.</code>时, 它会匹配sing和danc.</p>
<h3 id="零宽度正回顾后发断言"><a href="#零宽度正回顾后发断言" class="headerlink" title="零宽度正回顾后发断言"></a>零宽度正回顾后发断言</h3><p>用于指示匹配表达式的字符串的下一个字符位置</p>
<p><code>(?&lt;=\bre)\w+\b</code> 匹配以re开头的单词的后半部分</p>
<p><code>((?&lt;=\d)\d&#123;3&#125;+\b)</code>匹配一个数字后面是若干的三个数字的后面部分.<br>对1234567890进行查找时结果是234567890</p>
<h2 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h2><p>负向零宽断言, 与上一节中的正向零宽断言相对, 用于匹配不是某个字符或不在某些字符类里的方法</p>
<p>确保某个字符没有出现, 但并不想去匹配它, 就可以使用<code>负向零宽断言</code></p>
<h3 id="零宽度负预测先行断言-exp"><a href="#零宽度负预测先行断言-exp" class="headerlink" title="零宽度负预测先行断言(?!exp)"></a>零宽度负预测先行断言(?!exp)</h3><p>断言此位置的后面不能匹配表达式exp。<br>例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；<br>\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。</p>
<h3 id="零宽度负回顾后发断言"><a href="#零宽度负回顾后发断言" class="headerlink" title="零宽度负回顾后发断言"></a>零宽度负回顾后发断言</h3><p>同理，可以用(<code>?&lt;!exp</code>),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：<br><code>(?&lt;![a-z])\d&#123;7&#125;</code> 匹配前面不是小写字母的七位数字。</p>
<p>请详细分析表达式<code>(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)</code>，这个表达式最能表现零宽断言的真正用途。</p>
<p>一个更复杂的例子：<br><code>(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)</code>匹配不包含属性的简单HTML标签内里的内容。<br><code>(?&lt;=&lt;(\w+)&gt;)</code>指定了这样的前缀：被尖括号括起来的单词(比如可能是<b>)，<br>然后是.<code>*(任意的字符串)</code>,最后是一个后缀(?=&lt;/\1&gt;)。注意后缀里的/，<br>它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，<br>前面的(\w+)匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。<br>整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>通过语法<code>(?#comment)</code>来包含注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(?&lt;&#x3D;    # 断言要匹配的文本的前缀</span><br><span class="line"> &lt;(\w+)&gt; # 查找尖括号括起来的字母或数字(即HTML&#x2F;XML标签)</span><br><span class="line">)       # 前缀结束</span><br><span class="line">.*      # 匹配任意文本</span><br><span class="line">(?&#x3D;     # 断言要匹配的文本的后缀</span><br><span class="line"> &lt;\&#x2F;\1&gt;  # 查找尖括号括起来的内容：前面是一个&quot;&#x2F;&quot;，后面是先前捕获的标签</span><br><span class="line">)       # 后缀结束</span><br></pre></td></tr></table></figure>

<h2 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h2><table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>*?</code></td>
<td>重复任意次，但尽可能少重复</td>
</tr>
<tr>
<td><code>+?</code></td>
<td>重复1次或更多次，但尽可能少重复</td>
</tr>
<tr>
<td><code>??</code></td>
<td>重复0次或1次，但尽可能少重复</td>
</tr>
<tr>
<td><code>&#123;n,m&#125;?</code></td>
<td>重复n到m次，但尽可能少重复</td>
</tr>
<tr>
<td><code>&#123;n,&#125;?</code></td>
<td>重复n次以上，但尽可能少重复</td>
</tr>
</tbody></table>
<h2 id="处理选项"><a href="#处理选项" class="headerlink" title="处理选项"></a>处理选项</h2><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>IgnoreCase</code>(忽略大小写)</td>
<td>匹配时不区分大小写。</td>
</tr>
<tr>
<td><code>Multiline</code>(多行模式)</td>
<td>更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\n之前的位置以及字符串结束前的位置.)</td>
</tr>
<tr>
<td><code>Singleline</code>(单行模式)</td>
<td>更改.的含义，使它与每一个字符匹配（包括换行符\n）。</td>
</tr>
<tr>
<td><code>IgnorePatternWhitespace</code>(忽略空白)</td>
<td>忽略表达式中的非转义空白并启用由#标记的注释。</td>
</tr>
<tr>
<td><code>ExplicitCapture</code>(显式捕获)</td>
<td>仅捕获已被显式命名的组。</td>
</tr>
</tbody></table>
<h2 id="平衡组-递归匹配"><a href="#平衡组-递归匹配" class="headerlink" title="平衡组/递归匹配"></a>平衡组/递归匹配</h2><p>用于在嵌套的层次结构中, 判断是否嵌套.</p>
<ul>
<li>   <code>(?&#39;group&#39;)</code> 把捕获的内容命名为group,并压入堆栈(Stack)</li>
<li>   <code>(?&#39;-group&#39;)</code> 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败</li>
<li>   <code>(?(group)yes|no)</code> 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分</li>
<li>   <code>(?!)</code> 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;                         #最外层的左括号</span><br><span class="line">[^&lt;&gt;]*                #最外层的左括号后面的不是括号的内容</span><br><span class="line">(</span><br><span class="line"> (</span><br><span class="line">  (?&#39;Open&#39;&lt;)    #碰到了左括号，在黑板上写一个&quot;Open&quot;</span><br><span class="line">  [^&lt;&gt;]*       #匹配左括号后面的不是括号的内容</span><br><span class="line"> )+</span><br><span class="line"> (</span><br><span class="line">  (?&#39;-Open&#39;&gt;)   #碰到了右括号，擦掉一个&quot;Open&quot;</span><br><span class="line">  [^&lt;&gt;]*        #匹配右括号后面不是括号的内容</span><br><span class="line"> )+</span><br><span class="line">)*</span><br><span class="line">(?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的&quot;Open&quot;；如果还有，则匹配失败</span><br><span class="line"></span><br><span class="line">&gt;                         #最外层的右括号</span><br></pre></td></tr></table></figure>
<p>我们需要做的是每碰到了左括号，就在压入一个”Open”,每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。</p>
<h2 id="其他语法"><a href="#其他语法" class="headerlink" title="其他语法"></a>其他语法</h2><table>
<thead>
<tr>
<th>代码/语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>报警字符(打印它的效果是电脑嘀一声)</td>
</tr>
<tr>
<td>\b</td>
<td>通常是单词分界位置，但如果在字符类里使用代表退格</td>
</tr>
<tr>
<td>\t</td>
<td>制表符，Tab</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\v</td>
<td>竖向制表符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\e</td>
<td>Escape</td>
</tr>
<tr>
<td>\0nn</td>
<td>ASCII代码中八进制代码为nn的字符</td>
</tr>
<tr>
<td>\xnn</td>
<td>ASCII代码中十六进制代码为nn的字符</td>
</tr>
<tr>
<td>\unnnn</td>
<td>Unicode代码中十六进制代码为nnnn的字符</td>
</tr>
<tr>
<td>\cN</td>
<td>ASCII控制字符。比如\cC代表Ctrl+C</td>
</tr>
<tr>
<td>\A</td>
<td>字符串开头(类似^，但不受处理多行选项的影响)</td>
</tr>
<tr>
<td>\Z</td>
<td>字符串结尾或行尾(不受处理多行选项的影响)</td>
</tr>
<tr>
<td>\z</td>
<td>字符串结尾(类似$，但不受处理多行选项的影响)</td>
</tr>
<tr>
<td>\G</td>
<td>当前搜索的开头</td>
</tr>
<tr>
<td>\p{name}</td>
<td>Unicode中命名为name的字符类，例如\p{IsGreek}</td>
</tr>
<tr>
<td>(?&gt;exp)</td>
<td>贪婪子表达式</td>
</tr>
<tr>
<td>(?<x>-<y>exp)</td>
<td>平衡组</td>
</tr>
<tr>
<td>(?im-nsx:exp)</td>
<td>在子表达式exp中改变处理选项</td>
</tr>
<tr>
<td>(?im-nsx)</td>
<td>为表达式后面的部分改变处理选项</td>
</tr>
<tr>
<td>(?(exp)yes</td>
<td>no)</td>
</tr>
<tr>
<td>(?(exp)yes)</td>
<td>同上，只是使用空表达式作为no</td>
</tr>
<tr>
<td>(?(name)yes</td>
<td>no)</td>
</tr>
<tr>
<td>(?(name)yes)</td>
<td>同上，只是使用空表达式作为no</td>
</tr>
</tbody></table>
<h1 id="常用的正则表达式"><a href="#常用的正则表达式" class="headerlink" title="常用的正则表达式"></a>常用的正则表达式</h1><h2 id="电子邮箱Email"><a href="#电子邮箱Email" class="headerlink" title="电子邮箱Email"></a>电子邮箱Email</h2><p><code>\w+([-+.]\w+)*@\w+([-.]\w)*\.\w+([-.]\w+)*</code><br>Email地址是以@分割, <code>@</code>前面的部分为用户名, 后面为域名.<br>用户名部分可以包含字母/数字/下划线/-/+/., 但是只能字母/数字/下划线开头.<br>不能出现+-.连续<br>而域名部分可以包含字母/数字/下划线/-以及. 也是只能字母/数字/下划线开头.</p>
<p>用户名部分<code>\w+([-+.]\w+)*</code> , 必须是至少一个<code>\w</code>开头,</p>
<h2 id="手机号码"><a href="#手机号码" class="headerlink" title="手机号码"></a>手机号码</h2><p><code>[1-9][3,4,5,7,8]/d&#123;9&#125;</code></p>
<h2 id="汉字"><a href="#汉字" class="headerlink" title="汉字"></a>汉字</h2><p><code>[\u4e00-\u9fa5]</code></p>
<h2 id="QQ号码"><a href="#QQ号码" class="headerlink" title="QQ号码"></a>QQ号码</h2><p><code>[1-9]\d&#123;4,&#125;</code></p>
<h2 id="邮编"><a href="#邮编" class="headerlink" title="邮编"></a>邮编</h2><p><code>[1-9]\d&#123;5&#125;</code></p>
<h2 id="不含abc的单词"><a href="#不含abc的单词" class="headerlink" title="不含abc的单词"></a>不含abc的单词</h2><p><code>\b((?!abc)\w)+\b</code></p>
<h2 id="时间-小时-分钟-24小时制"><a href="#时间-小时-分钟-24小时制" class="headerlink" title="时间(小时:分钟, 24小时制)"></a>时间(小时:分钟, 24小时制)</h2><p>((1|0?)[0-9]|2[0-3]):([0-5][0-9])</p>
<h2 id="姓名"><a href="#姓名" class="headerlink" title="姓名"></a>姓名</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String regex=<span class="string">&quot;^([(?&lt;cc&gt;a-zA-Z\\u4e00-\\u9fa5)]+)|([a-zA-Z\\u4e00-\\u9fa5]+[a-zA-Z\\u4e00-\\u9fa5. _·]*)$&quot;</span>;</span><br><span class="line">String [] tem=&#123;</span><br><span class="line">  <span class="string">&quot;张大千&quot;</span>,</span><br><span class="line">    <span class="string">&quot;张.大千&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zhangdaqian&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zhang.daqian&quot;</span>,</span><br><span class="line">    <span class="string">&quot;张大千Quene&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zhang daqian&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zhang_daqian&quot;</span>,</span><br><span class="line">    <span class="string">&quot; 张大千&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.张大千&quot;</span>,</span><br><span class="line">    <span class="string">&quot;_张大千&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (String s : tem) &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> matches = Pattern.matches(regex, s);</span><br><span class="line">  System.out.println(s+<span class="string">&quot;:\t&quot;</span>+(matches?<span class="string">&quot;√&quot;</span>:<span class="string">&quot;×&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">张大千:	√</span><br><span class="line">张.大千:	√</span><br><span class="line">zhangdaqian:	√</span><br><span class="line">zhang.daqian:	√</span><br><span class="line">张大千Quene:	√</span><br><span class="line">zhang daqian:	√</span><br><span class="line">zhang_daqian:	√</span><br><span class="line"> 张大千:	×</span><br><span class="line">.张大千:	×</span><br><span class="line">_张大千:	×</span><br></pre></td></tr></table></figure>


<h1 id="Java中运用"><a href="#Java中运用" class="headerlink" title="Java中运用"></a>Java中运用</h1><p>java.util.regex 包主要由三个类所组成：Pattern、Matcher 和 PatternSyntaxException。</p>
<ul>
<li>Pattern 对象表示一个已编译的正则表达式。Pattern 类没有提供公共的构造方法。要构建一个模式，首先必须调用公共的静态 <code>compile</code> 方法，它将返回一个 Pattern 对象。这个方法接受正则表达式作为第一个参数。</li>
<li>Matcher 是一个靠着输入的字符串来解析这个模式和完成匹配操作的对象。与 Pattern 相似，Matcher 也没有定义公共的构造方法，需要通过调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</li>
<li>PatternSyntaxException 对象是一个未检查异常，指示了正则表达式中的一个语法错误。</li>
</ul>
<h2 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String message=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">// 大小写不敏感</span></span><br><span class="line">Pattern pattern = Pattern.compile(message, Pattern.CASE_INSENSITIVE );</span><br><span class="line"><span class="comment">// 大小写不敏感且使用Unix的行结束符</span></span><br><span class="line">pattern = Pattern.compile(<span class="string">&quot;[az]$&quot;</span>, Pattern.MULTILINE | Pattern.UNIX_LINES);</span><br><span class="line"><span class="comment">// 使用int变量， 启用Unicode折叠感知和大小写不敏感</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> flags = Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE;</span><br><span class="line">Pattern pattern = Pattern.compile(<span class="string">&quot;aa&quot;</span>, flags);</span><br></pre></td></tr></table></figure>
<p>** matches(String, CharSequence) 方法 **</p>
<p>Pattern 类定义了一个方便的 matches 方法，用于快速地检查模式是否表示给定的输入字符串。与使用所有的公共静态方法一样，应该通过它的类名来调用 matches 方法，诸如 Pattern.matches(“\d”,”1”);。这个例子中，方法返回 true，这是由于数字“1”匹配了正则表达式\d。</p>
<p>** split(String) 方法 **</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String REGEX = <span class="string">&quot;:&quot;</span>;</span><br><span class="line">String INPUT = <span class="string">&quot;one:two:three:four:five&quot;</span>;</span><br><span class="line">Pattern p = Pattern.compile(REGEX);</span><br><span class="line">String[] items = p.split(INPUT);</span><br><span class="line"><span class="keyword">for</span>(String s : items) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">REGEX=<span class="string">&quot;//d&quot;</span>;</span><br><span class="line">INPUT=<span class="string">&quot;one9two4three7four1five&quot;</span>;</span><br><span class="line">Pattern p = Pattern.compile(REGEX);</span><br><span class="line">String[] items = p.split(INPUT);</span><br><span class="line"><span class="keyword">for</span>(String s : items) &#123;</span><br><span class="line">  System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果 one two three four five</span></span><br></pre></td></tr></table></figure>
<p>** public static String quote(String s)** ：返回指定字符串字面模式的字符串。此方法会产生一个字符串，能被用于构建一个与字符串 s 匹配的 Pattern，好像它是一个字面上的模式。输入序列中的元字符和转义序列将没有特殊的意义了。<br>**　　public String toString() ** ：返回这个模式的字符串表现形式。这是一个编译过的模式中的正则表达式。</p>
<p>** java.lang.String中等价的方法 **</p>
<p><code>java.lang.String</code> 通过模拟 <code>java.util.regex.Pattern</code> 行为的几个方法，也可以支持正则表达式。方便起见，下面主要摘录了出现在 API 关键的方法。</p>
<ul>
<li><code>public boolean matches(String regex)</code>：告知字符串是否匹配给定的正则表达式。调用 <code>str.matches(regex)</code>方法所产生的结果与作为表达式的 <code>Pattern.matches(regex, str)</code>的结果是完全一致。</li>
<li><code>public String[] split(String regex, int limit)</code>：依照匹配给定的正则表达式来拆分字符串。调用 <code>str.split(regex, n)</code>方法所产生的结果与作为表达式的 <code>Pattern.compile(regex).split(str, n)</code> 的结果完全一致。</li>
<li><code>public String[] split(String regex)</code>：依照匹配给定的正则表达式来拆分字符串。这个方法与调用两个参数的 split 方法是相同的，第一个参数使用给定的表达式，第二个参数限制为 0。在结果数组中不包括尾部的空字符串。</li>
<li>还有一个替换方法，把一个 <code>CharSequence</code> 替换成另外一个：<br><code>public String replace(CharSequence target,CharSequence replacement)</code>：将字符串中每一个匹配替换匹配字面目标序列的子字符串，替换成指定的字面替换序列。这个替换从字符串的开始处理直至结束，例如，把字符串“aaa”中的“aa”替换成“b”，结果是“ba”，而不是“ab”。</li>
</ul>
<h2 id="Matcher"><a href="#Matcher" class="headerlink" title="Matcher"></a>Matcher</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">索引方法</span><br><span class="line"></span><br><span class="line">　　索引方法（index methods）提供了一些正好在输入字符串中发现匹配的索引值：</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">start</span><span class="params">()</span>：返回之前匹配的开始索引。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> group)</span>：返回之前匹配操作中通过给定组所捕获序列的开始索引。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> <span class="keyword">int</span> <span class="title">end</span><span class="params">()</span>: 返回最后匹配字符后的偏移量。</span></span><br><span class="line"><span class="function">   <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">end</span><span class="params">(<span class="keyword">int</span> group)</span>: 返回之前匹配操作中通过给定组所捕获序列的最后字符之后的偏移量。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">研究方法</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　研究方法（study methods）回顾输入的字符串，并且返回一个用于指示是否找到模式的布尔值。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lookingAt</span><span class="params">()</span>: 尝试从区域开头处开始，输入序列与该模式匹配。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">()</span>: 尝试地寻找输入序列中，匹配模式的下一个子序列。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> start)</span>: 重置匹配器，然后从指定的索引处开始，尝试地寻找输入序列中，匹配模式的下一个子序列。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">()</span>: 尝试将整个区域与模式进行匹配</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">替换方法</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">　　替换方法（replacement methods）用于在输入的字符串中替换文本有用处的方法。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> Matcher <span class="title">appendReplacement</span><span class="params">(StringBuffer sb, String replacement)</span>：实现非结尾处的增加和替换操作。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> StringBuffer <span class="title">appendTail</span><span class="params">(StringBuffer sb)</span>：实现结尾处的增加和替换操作。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String replacement)</span>：使用给定的替换字符串来替换输入序列中匹配模式的每一个子序列。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> String <span class="title">replaceFirst</span><span class="params">(String replacement)</span>：使用给定的替换字符串来替换输入序列中匹配模式的第一个子序列。</span></span><br><span class="line"><span class="function">　　<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">quoteReplacement</span><span class="params">(String s)</span>：返回指定字符串的字面值来替换字符串。这个方法会生成一个字符串，用作 Matcher 的 appendReplacement 方法中的字面值替换 s。所产生的字符串将与作为字面值序列的 s 中的字符序列匹配。斜线（\）和美元符号（$）将不再有特殊意义了。</span></span><br></pre></td></tr></table></figure>
<p>** 使用 start 和 end 方法 **</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String REGEX = <span class="string">&quot;\\bdog\\b&quot;</span>;</span><br><span class="line">String INPUT = <span class="string">&quot;dog dog dog doggie dogg&quot;</span>;</span><br><span class="line">Pattern p = Pattern.compile(REGEX);</span><br><span class="line">Matcher m = p.matcher(INPUT);        <span class="comment">// 获得匹配器对象</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line"> count++;</span><br><span class="line"> System.out.println(<span class="string">&quot;Match number &quot;</span> + count);</span><br><span class="line"> System.out.println(<span class="string">&quot;start(): &quot;</span> + m.start());</span><br><span class="line"> System.out.println(<span class="string">&quot;end(): &quot;</span> + m.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>** 使用 matches 和 lookingAt 方法 **</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String REGEX = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">String INPUT = <span class="string">&quot;fooooooooooooooooo&quot;</span>;</span><br><span class="line">Pattern pattern;</span><br><span class="line">Matcher matcher;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">pattern = Pattern.compile(REGEX);</span><br><span class="line">matcher = pattern.matcher(INPUT);</span><br><span class="line">System.out.println(<span class="string">&quot;Current REGEX is: &quot;</span> + REGEX);</span><br><span class="line">System.out.println(<span class="string">&quot;Current INPUT is: &quot;</span> + INPUT);</span><br><span class="line">System.out.println(<span class="string">&quot;lookingAt(): &quot;</span> + matcher.lookingAt());</span><br><span class="line">System.out.println(<span class="string">&quot;matches(): &quot;</span> + matcher.matches());</span><br></pre></td></tr></table></figure>
<p>** 使用 replaceFirst(String) 和 replaceAll(String) 方法 **</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String REGEX = <span class="string">&quot;dog&quot;</span>;</span><br><span class="line">String INPUT = <span class="string">&quot;The dog says meow. All dogs say meow.&quot;</span>;</span><br><span class="line">String REPLACE = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line"></span><br><span class="line">Pattern p = Pattern.compile(REGEX);</span><br><span class="line">Matcher m = p.matcher(INPUT);       <span class="comment">// 获得匹配器对象</span></span><br><span class="line">INPUT = m.replaceAll(REPLACE);</span><br><span class="line">System.out.println(INPUT);</span><br></pre></td></tr></table></figure>
<p>** 使用 appendReplacement(StringBuffer, String) 和<br>　     appendTail(StringBuffer) 方法 **</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String REGEX = <span class="string">&quot;a*b&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> String INPUT = <span class="string">&quot;aabfooaabfooabfoob&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> String REPLACE = <span class="string">&quot;-&quot;</span>;</span><br><span class="line">Pattern p = Pattern.compile(REGEX);</span><br><span class="line">Matcher m = p.matcher(INPUT);       <span class="comment">// 获得匹配器对象</span></span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">    m.appendReplacement(sb, REPLACE);</span><br><span class="line">&#125;</span><br><span class="line">m.appendTail(sb);</span><br><span class="line">System.out.println(sb.toString());</span><br></pre></td></tr></table></figure>

<p>** 在 java.lang.String 中等价的 Matcher 方法 **</p>
<p>为了使用方便，String 类看上去还不错地模仿了 Matcher 的两个方法：</p>
<p><code>public String replaceFirst(String regex, String replacement)</code>：使用给定的替换字符串替换该字符串中匹配了给定正则表达式的第一个子字符串。调用 str.replaceFirst(regex, repl)方法与使用 Pattern.compile(regex).matcher(str).replaceFirst(repl)产生的结果是完全相同的。</p>
<p><code>public String replaceAll(String regex, String replacement)</code>：使用给定的替换字符串替换该字符串中匹配了给定正则表达式的每一个子字符串。调用 str.replaceAll(regex, repl)方法与使用 Pattern.compile(regex).matcher(str).replaceAll(repl)产生的结果是完全相同的。</p>
<h2 id="PatternSyntaxException"><a href="#PatternSyntaxException" class="headerlink" title="PatternSyntaxException"></a>PatternSyntaxException</h2><p>PatternSyntaxException 是未检查异常，指示正则表达式模式中的语法错误。PatternSyntaxException 类提供了下面的一些方法，用于确定在什么地方发生了错误：</p>
<ul>
<li>public String getDescription()：获得错误描述。</li>
<li>public int getIndex()：获得错误索引。</li>
<li>public String getPattern()：获得字符串形式的错误正则表达式。</li>
<li>public String getMessage()：获得一个多行的字符串，包括语法错误和错误的索引、错误的正则表达式模式，以及模式内可视化的索引指示。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Pattern pattern = <span class="keyword">null</span>;</span><br><span class="line">Matcher matcher = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Console console = System.console();</span><br><span class="line"><span class="keyword">if</span> (console == <span class="keyword">null</span>) &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;No console.&quot;</span>);</span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pattern = Pattern.compile(console.readLine(<span class="string">&quot;%nEnter your regex: &quot;</span>));</span><br><span class="line">        matcher = pattern.matcher(console.readLine(<span class="string">&quot;Enter input string to search: &quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PatternSyntaxException pse)&#123;</span><br><span class="line">        console.format(<span class="string">&quot;There is a problem with the regular expression!%n&quot;</span>);</span><br><span class="line">        console.format(<span class="string">&quot;The pattern in question is: %s%n&quot;</span>, pse.getPattern());</span><br><span class="line">        console.format(<span class="string">&quot;The description is: %s%n&quot;</span>, pse.getDescription());</span><br><span class="line">        console.format(<span class="string">&quot;The message is: %s%n&quot;</span>, pse.getMessage());</span><br><span class="line">        console.format(<span class="string">&quot;The index is: %s%n&quot;</span>, pse.getIndex());</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">        console.format(<span class="string">&quot;I found the text \&quot;%s\&quot; starting at &quot;</span> +</span><br><span class="line">                <span class="string">&quot;index %d and ending at index %d.%n&quot;</span>,</span><br><span class="line">                matcher.group(), matcher.start(), matcher.end()</span><br><span class="line">                );</span><br><span class="line">        found = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!found)&#123;</span><br><span class="line">        console.format(<span class="string">&quot;No match found.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Enter your regex: ?i)</span><br><span class="line">There is a problem with the regular expression!</span><br><span class="line">The pattern in question is: ?i)</span><br><span class="line">The description is: Dangling meta character &#39;?&#39;</span><br><span class="line">The message is: Dangling meta character &#39;?&#39; near index 0</span><br><span class="line">?i)</span><br><span class="line">^</span><br><span class="line">The index is: 0</span><br></pre></td></tr></table></figure>
<h2 id="问题与练习"><a href="#问题与练习" class="headerlink" title="问题与练习"></a>问题与练习</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">〖问题〗</span><br><span class="line"></span><br><span class="line">1. 在 java.util.regex 包中有哪三个公共的类？描述一下它们的作用。</span><br><span class="line">2. 考虑一下字符串“foo”，它的开始索引是多少？结束索引是多少？解释一下这些编号的意思。</span><br><span class="line">3. 普通字符和元字符有什么不同？各给出它们的一个例子。</span><br><span class="line">4. 如何把元字符表现成像普通字符那样？</span><br><span class="line">5. 附有方括号的字符集称为什么？它有什么作用？</span><br><span class="line">6. 这里是三个预定义的字符类：\d、\s和\w。描述一下它们各表示什么？并使用方括号的形式将它们重写。</span><br><span class="line">7. 对于\d、\s和\w，写出两个简单的表达式，匹配它们相反的字符集。</span><br><span class="line">8. 思考正则表达式(dog)&#123;3&#125;，识别一下其中的两个子表达式。这个表达式会匹配什么字符串？</span><br><span class="line"></span><br><span class="line">〖练习〗</span><br><span class="line"></span><br><span class="line">1. 使用反向引用写一个表达式，用于匹配一个人的名字，假设这个人的 first 名字与 last 名字是相同的。</span><br><span class="line"></span><br><span class="line">【问题答案】</span><br><span class="line"></span><br><span class="line">1. 问：在 java.util.regex 包中有哪三个公共的类？描述一下它们的作用。</span><br><span class="line">答：</span><br><span class="line"></span><br><span class="line">编译后的 Pattern 实例表示正则表达式。</span><br><span class="line">Matcher 实例是解析模式和靠着输入的字符串完成匹配操作的引擎。</span><br><span class="line">PatternSyntaxException 定义一个未检查异常，指示正则表达式中的语法错误。</span><br><span class="line"></span><br><span class="line">2. 问：考虑一下字符串“foo”，它的开始索引是多少？结束索引是多少？解释一下这些编号的意思。</span><br><span class="line"></span><br><span class="line">答：字符串中的每一个字符位于其自身的单元格中。索引位置在两个单元格之间。字符串“foo”开始于索引 0，结束于索引 3，即便是这些字符仅占用了 0、1 和 2 号单元格。</span><br><span class="line"></span><br><span class="line">3. 问：普通字符和元字符有什么不同？各给出它们的一个例子。</span><br><span class="line"></span><br><span class="line">答：正则表达式中的普通字符匹配其本身。元字符是一个特殊的字符，会影响被匹配模式的方式。字母A是一个普通字符。标点符号.是一个元字符，其匹配任意的单字符。</span><br><span class="line"></span><br><span class="line">4. 问：如何把元字符表现成像普通字符那样？答：有两种方法：</span><br><span class="line"></span><br><span class="line">在元字符前加上反斜线（\）；</span><br><span class="line">把元字符置于\Q（开始）\E（结束）的引用表达式中。</span><br><span class="line"></span><br><span class="line">5. 问：附有方括号的字符集称为什么？它有什么作用？</span><br><span class="line"></span><br><span class="line">答：是一个字符类。通过方括号间的表达式，匹配指定字符类中的任意一个字符。</span><br><span class="line"></span><br><span class="line">6. 问：这里是三个预定义的字符类：\d、\s和\w。描述一下它们各表示什么？并使用方括号的形式将它们重写。</span><br><span class="line"></span><br><span class="line">答：\d 匹配任意数字[0-9]</span><br><span class="line">　　\s 匹配任意空白字符[ \t\n-x0B\f\r ]</span><br><span class="line">　　\w 匹配任意单词字符[a-zA-Z_0-9]</span><br><span class="line"></span><br><span class="line">7. 问：对于\d、\s和\w，写出两个简单的表达式，匹配它们相反的字符集。</span><br><span class="line"></span><br><span class="line">答：\d \D [^\d]</span><br><span class="line">　　\s \S [^\s]</span><br><span class="line">　　\w \W [^\w]</span><br><span class="line"></span><br><span class="line">8. 问：思考正则表达式(dog)&#123;3&#125;，识别一下其中的两个子表达式。这个表达式会匹配什么字符串？</span><br><span class="line"></span><br><span class="line">答：表达式由捕获组(dog)和接着的贪婪量词&#123;3&#125;所组成。它匹配字符串“dogdogdog”。</span><br><span class="line"></span><br><span class="line">【练习答案】</span><br><span class="line"></span><br><span class="line">1. 练习：使用反向引用写一个表达式，用于匹配一个人的名字，假设这个人的 first 名字与 last 名字是相同的。</span><br><span class="line"></span><br><span class="line">解答：([A-Z][a-zA-Z]*)\s\1</span><br></pre></td></tr></table></figure>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>替换字符串中的字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String regularExpressionString=...;</span><br><span class="line">Matcher m = Pattern.compile(regularExpressionString, Pattern.CASE_INSENSITIVE).matcher(source); </span><br><span class="line">String result=m.replaceAll(newstring); </span><br><span class="line">System.out.println(<span class="string">&quot;使用正则表达式不区分大小写的替换结果&quot;</span>+result);</span><br><span class="line"></span><br><span class="line">Matcher m1 = Pattern.compile(regularExpressionString, Pattern.CANON_EQ).matcher(source); </span><br><span class="line">String result1=m1.replaceAll(newstring); </span><br><span class="line">System.out.println(<span class="string">&quot;使用正则表达式区分大小写的替换结果&quot;</span>+result1); </span><br></pre></td></tr></table></figure>
<hr>
<p>参考文献:</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://www.jb51.net/tools/zhengze.html">正则表达式30分钟入门教程</a></li>
<li><a href="www.zuidaima.com/share/1835085544524800.htm">java正则表达式语法详解及其使用代码实例</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/TimeApiInJava8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/TimeApiInJava8/" class="post-title-link" itemprop="url">Java8 Time API</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-04-12 11:28:00" itemprop="dateCreated datePublished" datetime="2016-04-12T11:28:00+08:00">2016-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-24 12:58:51" itemprop="dateModified" datetime="2021-04-24T12:58:51+08:00">2021-04-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.TemporalAdjusters;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeApiInJava8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dateToLocalDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">final</span> Instant instant = date.toInstant();</span><br><span class="line">        System.out.println(instant);</span><br><span class="line">        <span class="keyword">final</span> ZoneId defaultZoneId = ZoneId.systemDefault();</span><br><span class="line">        ZonedDateTime atZone = instant.atZone(defaultZoneId);</span><br><span class="line">        <span class="keyword">final</span> LocalDate localDate = atZone.toLocalDate();</span><br><span class="line">        System.out.println(localDate);</span><br><span class="line">        LocalDateTime localDateTime = atZone.toLocalDateTime();</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dateToLocalDateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        Instant instant = date.toInstant();</span><br><span class="line">        ZoneId systemDefault = ZoneId.systemDefault();</span><br><span class="line">        LocalDateTime.ofInstant(instant, systemDefault);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalDateTime <span class="title">longToLocalDateTime</span><span class="params">(Long time)</span> </span>&#123;</span><br><span class="line">        ZoneId systemDefault = ZoneId.systemDefault();</span><br><span class="line">        Instant instant = Instant.ofEpochMilli(time);</span><br><span class="line">        LocalDateTime localDateTime = instant.atZone(systemDefault).toLocalDateTime();</span><br><span class="line">        <span class="keyword">return</span> localDateTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localDateNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LocalDate now = LocalDate.now();</span><br><span class="line">        System.out.println(<span class="string">&quot;localDateNow: &quot;</span> + now);</span><br><span class="line">        System.out.println(<span class="string">&quot;year: &quot;</span> + now.getYear());</span><br><span class="line">        System.out.println(<span class="string">&quot;month: &quot;</span> + now.getMonthValue());</span><br><span class="line">        System.out.println(<span class="string">&quot;day: &quot;</span> + now.getDayOfMonth());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localDateDiff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LocalDate nowLocalDate = LocalDate.of(<span class="number">2019</span>, <span class="number">12</span>, <span class="number">15</span>);</span><br><span class="line">        LocalDate birthLocalDate = LocalDate.of(<span class="number">1986</span>, <span class="number">2</span>, <span class="number">14</span>);</span><br><span class="line">        <span class="keyword">long</span> l = nowLocalDate.toEpochDay() - birthLocalDate.toEpochDay();</span><br><span class="line">        System.out.println(<span class="string">&quot;date diff: &quot;</span> + l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">firstLastDay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LocalDate now = LocalDate.now();</span><br><span class="line">        LocalDate firstDayOfMonth = now.with(TemporalAdjusters.firstDayOfMonth());</span><br><span class="line">        LocalDate lastDayOfMonth = now.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">        LocalDate firstDayOfNextYear = now.with(TemporalAdjusters.firstDayOfNextYear());</span><br><span class="line">        LocalDate lastDayOfYear = now.with(TemporalAdjusters.lastDayOfYear());</span><br><span class="line">        LocalDate firstDayOfYear = now.with(TemporalAdjusters.firstDayOfYear());</span><br><span class="line">        System.out.println(<span class="string">&quot;firstDayOfMonth: &quot;</span> + firstDayOfMonth);</span><br><span class="line">        System.out.println(<span class="string">&quot;lastDayOfMonth: &quot;</span> + lastDayOfMonth);</span><br><span class="line">        System.out.println(<span class="string">&quot;firstDayOfNextYear: &quot;</span> + firstDayOfNextYear);</span><br><span class="line">        System.out.println(<span class="string">&quot;lastDayOfYear: &quot;</span> + lastDayOfYear);</span><br><span class="line">        System.out.println(<span class="string">&quot;firstDayOfYear: &quot;</span> + firstDayOfYear);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDayOfMonth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LocalDate localDate = LocalDate.of(<span class="number">2019</span>, <span class="number">2</span>, <span class="number">14</span>);</span><br><span class="line">        LocalDate lastDay = localDate.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">        <span class="keyword">int</span> dayOfMonth = lastDay.getDayOfMonth();</span><br><span class="line">        System.out.println(<span class="string">&quot;day of month: &quot;</span> + dayOfMonth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localDateCompareTo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LocalDate date1 = LocalDate.of(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">20</span>);</span><br><span class="line">        LocalDate date2 = LocalDate.of(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">21</span>);</span><br><span class="line">        System.out.println(date1 + <span class="string">&quot;.compareTo(&quot;</span> + date2 + <span class="string">&quot;): &quot;</span> + date1.compareTo(date2));</span><br><span class="line">        System.out.println(date1 + <span class="string">&quot;.compareTo(&quot;</span> + date1 + <span class="string">&quot;): &quot;</span> + date1.compareTo(date1));</span><br><span class="line">        System.out.println(date2 + <span class="string">&quot;.compareTo(&quot;</span> + date1 + <span class="string">&quot;): &quot;</span> + date2.compareTo(date1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextMonth</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        LocalDate localDate = LocalDate.of(<span class="number">2018</span>, <span class="number">2</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下一周的该星期</span></span><br><span class="line">        LocalDate nextWeeks1 = localDate.minusWeeks(-<span class="number">1</span>);</span><br><span class="line">        System.out.println(nextWeeks1);</span><br><span class="line">        <span class="comment">// 2018-02-19</span></span><br><span class="line">        LocalDate nextWeeks2 = localDate.plusWeeks(<span class="number">1</span>);</span><br><span class="line">        System.out.println(nextWeeks2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取下个月的这天</span></span><br><span class="line">        LocalDate nextMonth1 = localDate.minusMonths(-<span class="number">1</span>);</span><br><span class="line">        System.out.println(nextMonth1);</span><br><span class="line">        <span class="comment">// 2018-03-12</span></span><br><span class="line">        LocalDate nextMonth2 = localDate.plusMonths(<span class="number">1</span>);</span><br><span class="line">        System.out.println(nextMonth2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下个月的1号</span></span><br><span class="line">        LocalDate localDate3 = LocalDate.of(localDate.getYear(), localDate.getMonthValue() + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(localDate3);</span><br><span class="line">        <span class="comment">// 2018-03-01</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localDatePeriod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LocalDate date1 = LocalDate.of(<span class="number">2018</span>, <span class="number">10</span>, <span class="number">9</span>);</span><br><span class="line">        LocalDate date2 = LocalDate.of(<span class="number">2019</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line">        Period period = Period.between(date1, date2);</span><br><span class="line">        <span class="keyword">int</span> years = period.getYears();</span><br><span class="line">        <span class="keyword">int</span> months = period.getMonths();</span><br><span class="line">        <span class="keyword">int</span> days = period.getDays();</span><br><span class="line">        System.out.println(<span class="string">&quot;years:&quot;</span> + years + <span class="string">&quot;, months:&quot;</span> + months + <span class="string">&quot;, days:&quot;</span> + days);</span><br><span class="line">        <span class="comment">// years:0, months:5, days:23</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ofEpochSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Instant now = Instant.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line">        <span class="comment">// 2019-03-13T06:41:32.865Z</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去除毫秒</span></span><br><span class="line">        <span class="keyword">long</span> l = now.toEpochMilli() / <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 通过秒构建Instant对象</span></span><br><span class="line">        Instant instant = Instant.ofEpochSecond(l);</span><br><span class="line">        System.out.println(instant);</span><br><span class="line">        <span class="comment">// 2019-03-13T06:41:32Z</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stringToLocalDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String string = <span class="string">&quot;2018-12-07&quot;</span>;</span><br><span class="line">        LocalDate parse = LocalDate.parse(string);</span><br><span class="line">        System.out.println(parse.toString());</span><br><span class="line">        <span class="comment">// 结果是2018-12-07</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">localDateTimeToZonedDateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String string = <span class="string">&quot;2018-12-07T09:33:38&quot;</span>;</span><br><span class="line">        LocalDateTime parse = LocalDateTime.parse(string);</span><br><span class="line">        ZonedDateTime z1 = ZonedDateTime.of(parse, ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>));</span><br><span class="line">        System.out.println(z1.toString());</span><br><span class="line">        <span class="comment">// 2018-12-07T09:33:38+08:00[Asia/Shanghai]</span></span><br><span class="line"></span><br><span class="line">        ZonedDateTime z2 = ZonedDateTime.of(parse, ZoneId.of(<span class="string">&quot;Z&quot;</span>));</span><br><span class="line">        System.out.println(z2.toString());</span><br><span class="line">        <span class="comment">// 2018-12-07T09:33:38Z</span></span><br><span class="line"></span><br><span class="line">        ZonedDateTime z3 = ZonedDateTime.of(parse, ZoneId.of(<span class="string">&quot;UTC&quot;</span>));</span><br><span class="line">        System.out.println(z3.toString());</span><br><span class="line">        <span class="comment">// 2018-12-07T09:33:38Z[UTC]</span></span><br><span class="line"></span><br><span class="line">        ZonedDateTime z4 = ZonedDateTime.of(parse, ZoneId.of(<span class="string">&quot;UTC+08:00&quot;</span>));</span><br><span class="line">        System.out.println(z4.toString());</span><br><span class="line">        <span class="comment">// 2018-12-07T09:33:38+08:00[UTC+08:00]</span></span><br><span class="line"></span><br><span class="line">        ZonedDateTime z5 = ZonedDateTime.of(parse, ZoneId.of(<span class="string">&quot;+08:00&quot;</span>));</span><br><span class="line">        System.out.println(z5.toString());</span><br><span class="line">        <span class="comment">// 2018-12-07T09:33:38+08:00</span></span><br><span class="line"></span><br><span class="line">        ZonedDateTime z6 = ZonedDateTime.of(parse, ZoneId.of(<span class="string">&quot;+00:00&quot;</span>));</span><br><span class="line">        System.out.println(z6.toString());</span><br><span class="line">        <span class="comment">// 2018-12-07T09:33:38Z</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">        TimeApiInJava8 timeApi = <span class="keyword">new</span> TimeApiInJava8();</span><br><span class="line">        timeApi.dateToLocalDate();</span><br><span class="line">        timeApi.dateToLocalDateTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;long to localDateTime: &quot;</span> + timeApi.longToLocalDateTime(System.currentTimeMillis()));</span><br><span class="line">        timeApi.localDateNow();</span><br><span class="line">        timeApi.localDateDiff();</span><br><span class="line">        timeApi.firstLastDay();</span><br><span class="line">        timeApi.getDayOfMonth();</span><br><span class="line">        timeApi.localDateCompareTo();</span><br><span class="line">        timeApi.nextMonth();</span><br><span class="line">        timeApi.localDatePeriod();</span><br><span class="line">        timeApi.ofEpochSecond();</span><br><span class="line">        timeApi.stringToLocalDate();</span><br><span class="line">        timeApi.localDateTimeToZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/Throwable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/Throwable/" class="post-title-link" itemprop="url">Java异常</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-04-12 11:28:00" itemprop="dateCreated datePublished" datetime="2016-04-12T11:28:00+08:00">2016-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-24 12:58:51" itemprop="dateModified" datetime="2021-04-24T12:58:51+08:00">2021-04-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>请参考<a target="_blank" rel="noopener" href="http://blog.csdn.net/hguisu/article/details/6155636" title="深入理解java异常处理机制">深入理解java异常处理机制</a></p>
<p>异常是指当程序中某些地方出错时创建的一种特殊的运行时错误对象。Java创建异常对象后，就发送给Java程序，即抛出异常(throwing an exception)。程序捕捉到这个异常后，可以编写相应的异常处理代码进行处理。使用异常处理可以使得程序更加健壮，有助于调试和后期维护。</p>
<h1 id="Throwable的继承体系"><a href="#Throwable的继承体系" class="headerlink" title="Throwable的继承体系"></a>Throwable的继承体系</h1><p>Throwable类派生了两个类：Exception类和Error类，其中Error类系统保留，而Exception类供应用程序使用，它下面又派生出几个具体的异常类，都对应着一项具体的运行错误</p>
<p><img src="/images/java/Throwable/inherit.png"></p>
<h1 id="异常的工作原理"><a href="#异常的工作原理" class="headerlink" title="异常的工作原理"></a>异常的工作原理</h1><p>抛出异常：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。</p>
<p>捕获异常：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</p>
<h1 id="常见的受检异常"><a href="#常见的受检异常" class="headerlink" title="常见的受检异常"></a>常见的受检异常</h1><p> 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p>
<p>IOException：操作输入流和输出流时可能出现的异常。</p>
<p>EOFException   文件已结束异常</p>
<p>FileNotFoundException   文件未找到异常</p>
<h1 id="常见的非受检异常"><a href="#常见的非受检异常" class="headerlink" title="常见的非受检异常"></a>常见的非受检异常</h1><p>运行时异常：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。</p>
<p>ArithmeticException</p>
<p>ArrayIndexOutOfBoundsException<br>1、 java.lang.ArrayIndexOutOfBoundsException<br> 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。<br> 2、java.lang.ArithmeticException<br> 算术条件异常。譬如：整数除零等。<br> 3、java.lang.NullPointerException<br> 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等<br> 4、java.lang.ClassNotFoundException<br> 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</p>
<p>5、java.lang.NegativeArraySizeException  数组长度为负异常</p>
<p>6、java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常</p>
<p>7、java.lang.SecurityException 安全性异常</p>
<p>8、java.lang.IllegalArgumentException 非法参数异常</p>
<p>综合实例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">testEx</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> ret = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ret = testEx1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;testEx, catch exception&quot;</span>);</span><br><span class="line">            ret = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;testEx, finally; return value=&quot;</span> + ret);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">testEx1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> ret = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ret = testEx2();</span><br><span class="line">            <span class="keyword">if</span> (!ret) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;testEx1, at the end of try&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;testEx1, catch exception&quot;</span>);</span><br><span class="line">            ret = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;testEx1, finally; return value=&quot;</span> + ret);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">testEx2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> ret = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> b = <span class="number">12</span>;</span><br><span class="line">            <span class="keyword">int</span> c;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &gt;= -<span class="number">2</span>; i--) &#123;</span><br><span class="line">                c = b / i;</span><br><span class="line">                System.out.println(<span class="string">&quot;i=&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;testEx2, catch exception&quot;</span>);</span><br><span class="line">            ret = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;testEx2, finally; return value=&quot;</span> + ret);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestException testException1 = <span class="keyword">new</span> TestException();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            testException1.testEx();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i&#x3D;2</span><br><span class="line">i&#x3D;1</span><br><span class="line">testEx2, catch exception</span><br><span class="line">testEx2, finally; return value&#x3D;false</span><br><span class="line">testEx1, finally; return value&#x3D;false</span><br><span class="line">testEx, finally; return value&#x3D;false</span><br></pre></td></tr></table></figure>
<hr>
<p>[参考文献]:</p>
<ol>
<li>Think in Java</li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/hguisu/article/details/6155636" title="深入理解java异常处理机制">深入理解java异常处理机制</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/Java/io/java-XML-JSON/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Java/io/java-XML-JSON/" class="post-title-link" itemprop="url">Java IO之XML与JSON解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-04-08 11:28:00" itemprop="dateCreated datePublished" datetime="2016-04-08T11:28:00+08:00">2016-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-24 12:58:51" itemprop="dateModified" datetime="2021-04-24T12:58:51+08:00">2021-04-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="/Java/advanced-engineer-outline/">&lt;&lt; Java高级软件工程师知识结构</a></p>
<ol>
<li>掌握InputStream、OutputStream、Reader、Writer的继承体系。</li>
<li>掌握字节流(FileInputStream、DataInputStream、BufferedInputStream、FileOutputSteam、DataOutputStream、BufferedOutputStream)和 字符流(BufferedReader、InputStreamReader、FileReader、BufferedWriter、OutputStreamWriter、PrintWriter、FileWriter)，并熟练运用。</li>
<li>掌握NIO实现原理及使用方法。</li>
</ol>
<p>Java IO包括:</p>
<ul>
<li><a href="/Java/io/IO-Model/">IO Model</a></li>
<li><a href="/Java/io/BIO/">Java BIO</a></li>
<li><a href="/Java/io/NIO/">Java NIO</a></li>
<li><a href="/Java/io/AIO/">Java AIO</a></li>
<li><a href="/Java/io/java-zip/">Java压缩</a></li>
<li><a href="/Java/io/object-serialization/">Java序列化</a></li>
<li><a href="/Java/io/java-XML-JSON/">Java XML与JSON</a></li>
</ul>
<h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>JSON: JavaScript对象表示法(JavaScript Object Notation)<br>是存储和交换文本信息的语法， 类似于XML，它采用键值对的形式来组织，易于阅读和编写，同时也已于机器解析和生成。JSON是独立于语言的，也就是说不管什么语言，都可以解析json，只需要按照json的规则来执行。</p>
<h2 id="JSON与XML比较"><a href="#JSON与XML比较" class="headerlink" title="JSON与XML比较"></a>JSON与XML比较</h2><ol>
<li>json长度更小</li>
<li>json读写速度更快</li>
<li>可以通过JavaScript内建的方法直接解析，转换成JavaScript对象，非常方便 。</li>
</ol>
<h2 id="JSON格式"><a href="#JSON格式" class="headerlink" title="JSON格式"></a>JSON格式</h2><p><img src="/images/java/io/jsonFormat.png"></p>
<h2 id="JavaScript中的解析"><a href="#JavaScript中的解析" class="headerlink" title="JavaScript中的解析"></a>JavaScript中的解析</h2><p>要两种方式：<code>eval</code>和<code>JSON.parse</code></p>
<p>在代码中使用eval时和危险的！ 特别是用它第三方的JSON数据（可能包含恶意代码）时， 尽可能使用 <code>JSON.parse()</code>方法解析字符串本身， 该方法还可以捕捉JSON中的语法错误。</p>
<p>例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsondata = <span class="string">&#x27;&#123;&quot;staff&quot;:[&#123;&quot;name&quot;:&quot;洪七&quot;,&quot;age&quot;:70&#125;,&#123;&quot;name&quot;:&quot;郭靖&quot;,&quot;age&quot;:35&#125;,&#123;&quot;name&quot;:&quot;黄蓉&quot;,&quot;age&quot;:30&#125;]&#125;&#x27;</span>；</span><br><span class="line"><span class="keyword">var</span> jsonobj= <span class="built_in">eval</span>(<span class="string">&#x27;(&#x27;</span>+jsondata+<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">alert(jsonobj.staff[<span class="number">0</span>].name);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsondata = <span class="string">&#x27;&#123;&quot;staff&quot;:[&#123;&quot;name&quot;:&quot;洪七&quot;,&quot;age&quot;:70&#125;,&#123;&quot;name&quot;:&quot;郭靖&quot;,&quot;age&quot;:35&#125;,&#123;&quot;name&quot;:&quot;黄蓉&quot;,&quot;age&quot;:30&#125;]&#125;&#x27;</span>；</span><br><span class="line"><span class="keyword">var</span> jsonobj=<span class="built_in">JSON</span>.parse(jsondata);</span><br><span class="line">alert(jsonobj.staff[<span class="number">0</span>].name);</span><br></pre></td></tr></table></figure>
<hr>
<p>[参考文献]:</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://example.com/database/concept/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="aaronzhang">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Guadazi">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/database/concept/" class="post-title-link" itemprop="url">数据库设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-04-07 00:00:00" itemprop="dateCreated datePublished" datetime="2016-04-07T00:00:00+08:00">2016-04-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-04-24 12:58:51" itemprop="dateModified" datetime="2021-04-24T12:58:51+08:00">2021-04-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DataBase/" itemprop="url" rel="index"><span itemprop="name">DataBase</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>SQL(Structured Query Language, 结构化查询语言)可以分为DDL(data definition language,数据定义语言) TPL(事务处理语言)  DML(data manipulation language, 数据操作语言)和DCL(data control language, 数据控制语言)。</p>
<p>其主要的语句有:</p>
<ol>
<li>DDL(data definition language,数据定义语言) 创建、删除和更改数据库对象<ol>
<li>创建 删除 修改数据库<ol>
<li> creat database</li>
<li> drop database</li>
<li> alter database</li>
</ol>
</li>
<li>创建 删除 修改数据表<ol>
<li> create table</li>
<li> alter table</li>
<li> drop table</li>
</ol>
</li>
<li>创建 删除索引<ol>
<li> create index</li>
<li> drop index</li>
</ol>
</li>
</ol>
</li>
<li>DML(data manipulation language, 数据操作语言) 查询和更新指令都成了SQL的DML部分<ol>
<li>select 从表或试图中检索数据</li>
<li>update 更改表中的数据</li>
<li>delete 从表中删除数据行</li>
<li>insert into  添加数据行到表</li>
</ol>
</li>
<li>DCL(data control language, 数据控制语言)<ol>
<li>用于规定数据库用户的各种权限<ol>
<li>grant 将权限或角色授予用户或其他角色</li>
<li>revoke 从用户或数据库角色回收权限</li>
</ol>
</li>
<li>数据库事务控制<ol>
<li>commit 把当前事务所有的更改写入磁盘</li>
<li>rollback 作废上次提交依赖的所有的更改</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h1><p>数据库设计可以分为需求分析、逻辑分析、物理设计和维护优化四个阶段。</p>
<p>数据库的基本名词：</p>
<ul>
<li>关系：一个关系对应通常所说的一张表</li>
<li>元组：表中的一行即为一个元组</li>
<li>属性：表中的一列即为一个属性；每一个属性都有一个名称，称为属性名。</li>
<li>候选码：表中的某个属性组，它可以唯一确定一个元组。</li>
<li>主码：一个关系有多个候选码，确定其中一个为主码</li>
<li>域：属性的取值范围</li>
<li>分量：元组中的一个属性值。</li>
</ul>
<h2 id="ER图"><a href="#ER图" class="headerlink" title="ER图"></a>ER图</h2><p>ER图中各符号的含义：</p>
<p><img src="/images/j2ee/database/ER-Components.png"></p>
<p>在这里以订单、用户、商品、供应商以及购物车的关系构建ER图</p>
<p><img src="/images/j2ee/database/ER-sample01.png"></p>
<p>矩形框表示实体, 即图中的订单、用户、商品、供应商以及购物车。<br>椭圆表示视图的属性， 如用户的用户ID、用户名、密码、昵称和身份证。椭圆中的文本表示属性的名称，文本带下划线表示为主键。<br>线段将属性与实体集相互连接，表示属性是实体的。将实体间相互连接，表示实体间的对应关系。<br>线段的两端标示1或M，表示是一对一、一对多或者多对多的关系。</p>
<h2 id="数据操作异常与数据冗余"><a href="#数据操作异常与数据冗余" class="headerlink" title="数据操作异常与数据冗余"></a>数据操作异常与数据冗余</h2><p>数据操作异常是判断数据库设计是否合理的依据。</p>
<ul>
<li>插入异常： 如果某实体随着另一个实体的存在而存在， 即缺少某个实体时无法表示这个实体，那么这个表就存在插入异常。</li>
<li>更新异常： 如果更改表所对应的某个实体实例的单独属性时，需要将多行更新，那么就说这个表存在更新异常。</li>
<li>删除异常： 如果删除表的某一行来反应某实体实例。失效时导致另一个不同实体实例信息丢失，那么这个表存在删除异常。</li>
</ul>
<p>数据冗余：<br>是指相同的数据在多个地方存在， 或者说表中的某个列可以有其他列计算得到，这样就说表中存在着数据冗余。</p>
<h2 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h2><h3 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式(1NF)"></a>第一范式(1NF)</h3><p>字段具有原子性,不可再分。所有关系型数据库系统都满足第一范式。<br>数据库表中的字段都是单一属性的，不可再分。例如，姓名字段，其中的姓和名必须作为一个整体，无法区分哪部分是姓，哪部分是名，如果要区分出姓和名，必须设计成两个独立的字段。</p>
<p>这个单一属性是由基本的数据类型所构成的， 如整数，浮点数，字符串等；<br>换句话说： <strong>第一范式要求数据库中的表都是二维表</strong></p>
<p>如下表中</p>
<p><img src="/images/j2ee/database/1NF-sample01.png"></p>
<p>第二个表格中， 用户信息列又包含<code>姓名</code> <code>电话</code>两个列。 不符合第一范式的要求</p>
<h3 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式(2NF)"></a>第二范式(2NF)</h3><p>满足第二范式（2NF）必须先满足第一范式（1NF）。<br>要求数据库表中的每个实例或行必须可以被惟一地区分。通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键。<br>第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。</p>
<p><img src="/images/j2ee/database/2NF-sample01.png"></p>
<p>由于供应商和商品之间是多对多的关系<br>所以只有使用<code>商品名称</code>和<code>供应商名称</code>才可以唯一表示出一件商品。<br>也就是商品名称和供应商名称是一组组合关键字。<br>上表的依赖关系为:</p>
<ul>
<li>(商品名称)-&gt;(价格、描述、重量、商品有效期)</li>
<li>(供应商名称)-&gt;(供应商电话)</li>
</ul>
<p>存在的问题：</p>
<ol>
<li>插入异常</li>
<li>删除异常</li>
<li>更新异常</li>
<li>数据冗余</li>
</ol>
<h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p>必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。<br>所以第三范式具有如下特征：<br>    1. 每一列只有一个值<br>    2. 每一行都能区分。<br>    3. 每一个表都不包含其他表已经包含的非主关键字信息。</p>
<p>例如，帖子表中只能出现发帖人的id，而不能出现发帖人的id，还同时出现发帖人姓名，否则，只要出现同一发帖人id的所有记录，它们中的姓名部分都必须严格保持一致，这就是数据冗余。</p>
<p>如果数据表中不存在非关键字段对任一候选字段的传递函数依赖则符合第三范式。</p>
<h3 id="BC范式-Boyce-Codd范式"><a href="#BC范式-Boyce-Codd范式" class="headerlink" title="BC范式(Boyce.Codd范式)"></a>BC范式(Boyce.Codd范式)</h3><p>在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合BC范式。<br>也就是说如果是符合关键字，则符合关键字之间也不能存在函数依赖关系。</p>
<p><img src="/images/j2ee/database/BCNF-sample01.png"></p>
<p>上表中存在的下列关系不符合BCNF:</p>
<ul>
<li>(供应商)-&gt;(供应商联系人)</li>
<li>(供应商联系人)-&gt;(供应商)</li>
<li>并且存在数据存在异常及数据冗余</li>
</ul>
<h2 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h2><p>锁的类型有三种：</p>
<ul>
<li>共享（S)锁：多个事务可封锁一个共享页；任何事务都不能修改该页； 通常是该页被读取完毕，S锁立即被释放。 </li>
<li>排它（X)锁：仅允许一个事务封锁此页；其他任何事务必须等到X锁被释放才能对该页进行访问；X锁一直到事务结束才能被释放。 </li>
<li>更新（U)锁：用来预定要对此页施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的页将要被更新时，则升级为X锁；U锁一直到事务结束时才能被释放。</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/zhouqianhua/archive/2011/04/15/2017049.html">SQLServer中的数据库锁</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/ggjucheng/archive/2012/11/14/2770445.html">MySQL中的数据库锁</a></p>
<p><a target="_blank" rel="noopener" href="http://tec.5lulu.com/detail/104d2n2wtryip85cd.html">数据库锁原理</a></p>
<h2 id="TODOs"><a href="#TODOs" class="headerlink" title="TODOs"></a>TODOs</h2><ol>
<li>事务 各个层次的操作</li>
<li>键 唯一键 主键 外键</li>
<li>MySQL集群</li>
<li>事务隔离级别</li>
</ol>
<hr>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/20/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/22/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">aaronzhang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">239</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">128</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aaronzhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
